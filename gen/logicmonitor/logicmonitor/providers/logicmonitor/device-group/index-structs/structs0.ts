import * as cdktf from 'cdktf';
export interface DeviceGroupAwsTestResult {
}

export function deviceGroupAwsTestResultToTerraform(struct?: DeviceGroupAwsTestResult): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function deviceGroupAwsTestResultToHclTerraform(struct?: DeviceGroupAwsTestResult): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DeviceGroupAwsTestResultOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupAwsTestResult | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupAwsTestResult | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }

  // detail_link - computed: true, optional: false, required: false
  public get detailLink() {
    return this.getStringAttribute('detail_link');
  }

  // no_permission_services - computed: true, optional: false, required: false
  public get noPermissionServices() {
    return cdktf.Fn.tolist(this.getListAttribute('no_permission_services'));
  }

  // non_permission_errors - computed: true, optional: false, required: false
  public get nonPermissionErrors() {
    return cdktf.Fn.tolist(this.getListAttribute('non_permission_errors'));
  }
}

export class DeviceGroupAwsTestResultList extends cdktf.ComplexList {

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupAwsTestResultOutputReference {
    return new DeviceGroupAwsTestResultOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupAzureTestResult {
}

export function deviceGroupAzureTestResultToTerraform(struct?: DeviceGroupAzureTestResult): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function deviceGroupAzureTestResultToHclTerraform(struct?: DeviceGroupAzureTestResult): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DeviceGroupAzureTestResultOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupAzureTestResult | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupAzureTestResult | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }

  // detail_link - computed: true, optional: false, required: false
  private _detailLink = new cdktf.StringMap(this, "detail_link");
  public get detailLink() {
    return this._detailLink;
  }

  // no_permission_services - computed: true, optional: false, required: false
  private _noPermissionServices = new cdktf.StringMap(this, "no_permission_services");
  public get noPermissionServices() {
    return this._noPermissionServices;
  }
}

export class DeviceGroupAzureTestResultList extends cdktf.ComplexList {

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupAzureTestResultOutputReference {
    return new DeviceGroupAzureTestResultOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupCustomProperties {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#name DeviceGroup#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#value DeviceGroup#value}
  */
  readonly value?: string;
}

export function deviceGroupCustomPropertiesToTerraform(struct?: DeviceGroupCustomProperties | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function deviceGroupCustomPropertiesToHclTerraform(struct?: DeviceGroupCustomProperties | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupCustomPropertiesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupCustomProperties | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupCustomProperties | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DeviceGroupCustomPropertiesList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupCustomProperties[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupCustomPropertiesOutputReference {
    return new DeviceGroupCustomPropertiesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupGcpTestResult {
}

export function deviceGroupGcpTestResultToTerraform(struct?: DeviceGroupGcpTestResult): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function deviceGroupGcpTestResultToHclTerraform(struct?: DeviceGroupGcpTestResult): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DeviceGroupGcpTestResultOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupGcpTestResult | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupGcpTestResult | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }

  // detail_link - computed: true, optional: false, required: false
  public get detailLink() {
    return this.getStringAttribute('detail_link');
  }

  // no_permission_services - computed: true, optional: false, required: false
  public get noPermissionServices() {
    return cdktf.Fn.tolist(this.getListAttribute('no_permission_services'));
  }

  // non_permission_errors - computed: true, optional: false, required: false
  public get nonPermissionErrors() {
    return cdktf.Fn.tolist(this.getListAttribute('non_permission_errors'));
  }
}

export class DeviceGroupGcpTestResultList extends cdktf.ComplexList {

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupGcpTestResultOutputReference {
    return new DeviceGroupGcpTestResultOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupSaasTestResult {
}

export function deviceGroupSaasTestResultToTerraform(struct?: DeviceGroupSaasTestResult): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function deviceGroupSaasTestResultToHclTerraform(struct?: DeviceGroupSaasTestResult): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DeviceGroupSaasTestResultOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupSaasTestResult | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupSaasTestResult | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }

  // detail_link - computed: true, optional: false, required: false
  public get detailLink() {
    return this.getStringAttribute('detail_link');
  }

  // invalid_status_urls - computed: true, optional: false, required: false
  public get invalidStatusUrls() {
    return this.getStringAttribute('invalid_status_urls');
  }

  // no_permission_apis - computed: true, optional: false, required: false
  public get noPermissionApis() {
    return cdktf.Fn.tolist(this.getListAttribute('no_permission_apis'));
  }

  // no_permission_service - computed: true, optional: false, required: false
  public get noPermissionService() {
    return this.getStringAttribute('no_permission_service');
  }

  // non_permission_apis_errors - computed: true, optional: false, required: false
  public get nonPermissionApisErrors() {
    return cdktf.Fn.tolist(this.getListAttribute('non_permission_apis_errors'));
  }

  // result_code - computed: true, optional: false, required: false
  public get resultCode() {
    return this.getNumberAttribute('result_code');
  }
}

export class DeviceGroupSaasTestResultList extends cdktf.ComplexList {

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupSaasTestResultOutputReference {
    return new DeviceGroupSaasTestResultOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupSubGroups {
}

export function deviceGroupSubGroupsToTerraform(struct?: DeviceGroupSubGroups): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function deviceGroupSubGroupsToHclTerraform(struct?: DeviceGroupSubGroups): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DeviceGroupSubGroupsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupSubGroups | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupSubGroups | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }

  // applies_to - computed: true, optional: false, required: false
  public get appliesTo() {
    return this.getStringAttribute('applies_to');
  }

  // aws_regions_info - computed: true, optional: false, required: false
  public get awsRegionsInfo() {
    return this.getStringAttribute('aws_regions_info');
  }

  // azure_regions_info - computed: true, optional: false, required: false
  public get azureRegionsInfo() {
    return this.getStringAttribute('azure_regions_info');
  }

  // description - computed: true, optional: false, required: false
  public get description() {
    return this.getStringAttribute('description');
  }

  // full_path - computed: true, optional: false, required: false
  public get fullPath() {
    return this.getStringAttribute('full_path');
  }

  // gcp_regions_info - computed: true, optional: false, required: false
  public get gcpRegionsInfo() {
    return this.getStringAttribute('gcp_regions_info');
  }

  // group_type - computed: true, optional: false, required: false
  public get groupType() {
    return this.getStringAttribute('group_type');
  }

  // id - computed: true, optional: false, required: false
  public get id() {
    return this.getNumberAttribute('id');
  }

  // name - computed: true, optional: false, required: false
  public get name() {
    return this.getStringAttribute('name');
  }

  // num_of_direct_devices - computed: true, optional: false, required: false
  public get numOfDirectDevices() {
    return this.getNumberAttribute('num_of_direct_devices');
  }

  // num_of_direct_sub_groups - computed: true, optional: false, required: false
  public get numOfDirectSubGroups() {
    return this.getNumberAttribute('num_of_direct_sub_groups');
  }

  // num_of_hosts - computed: true, optional: false, required: false
  public get numOfHosts() {
    return this.getNumberAttribute('num_of_hosts');
  }

  // user_permission - computed: true, optional: false, required: false
  public get userPermission() {
    return this.getStringAttribute('user_permission');
  }
}

export class DeviceGroupSubGroupsList extends cdktf.ComplexList {

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupSubGroupsOutputReference {
    return new DeviceGroupSubGroupsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraDevices {
}

export function deviceGroupExtraDevicesToTerraform(struct?: DeviceGroupExtraDevices): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function deviceGroupExtraDevicesToHclTerraform(struct?: DeviceGroupExtraDevices): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DeviceGroupExtraDevicesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraDevices | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraDevices | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }

  // device_type - computed: true, optional: false, required: false
  public get deviceType() {
    return this.getNumberAttribute('device_type');
  }

  // required_props - computed: true, optional: false, required: false
  public get requiredProps() {
    return cdktf.Fn.tolist(this.getListAttribute('required_props'));
  }
}

export class DeviceGroupExtraDevicesList extends cdktf.ComplexList {

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraDevicesOutputReference {
    return new DeviceGroupExtraDevicesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraAccount {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#account_id DeviceGroup#account_id}
  */
  readonly accountId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#assumed_role_arn DeviceGroup#assumed_role_arn}
  */
  readonly assumedRoleArn?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#client_id DeviceGroup#client_id}
  */
  readonly clientId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#collector_description DeviceGroup#collector_description}
  */
  readonly collectorDescription?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#country DeviceGroup#country}
  */
  readonly country?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#external_id DeviceGroup#external_id}
  */
  readonly externalId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#schedule DeviceGroup#schedule}
  */
  readonly schedule?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#secret_key DeviceGroup#secret_key}
  */
  readonly secretKey?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#subscription_ids DeviceGroup#subscription_ids}
  */
  readonly subscriptionIds?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#tenant_id DeviceGroup#tenant_id}
  */
  readonly tenantId?: string;
}

export function deviceGroupExtraAccountToTerraform(struct?: DeviceGroupExtraAccount | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    account_id: cdktf.stringToTerraform(struct!.accountId),
    assumed_role_arn: cdktf.stringToTerraform(struct!.assumedRoleArn),
    client_id: cdktf.stringToTerraform(struct!.clientId),
    collector_description: cdktf.stringToTerraform(struct!.collectorDescription),
    country: cdktf.stringToTerraform(struct!.country),
    external_id: cdktf.stringToTerraform(struct!.externalId),
    schedule: cdktf.stringToTerraform(struct!.schedule),
    secret_key: cdktf.stringToTerraform(struct!.secretKey),
    subscription_ids: cdktf.stringToTerraform(struct!.subscriptionIds),
    tenant_id: cdktf.stringToTerraform(struct!.tenantId),
  }
}


export function deviceGroupExtraAccountToHclTerraform(struct?: DeviceGroupExtraAccount | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    account_id: {
      value: cdktf.stringToHclTerraform(struct!.accountId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    assumed_role_arn: {
      value: cdktf.stringToHclTerraform(struct!.assumedRoleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_id: {
      value: cdktf.stringToHclTerraform(struct!.clientId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    collector_description: {
      value: cdktf.stringToHclTerraform(struct!.collectorDescription),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    country: {
      value: cdktf.stringToHclTerraform(struct!.country),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    external_id: {
      value: cdktf.stringToHclTerraform(struct!.externalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    schedule: {
      value: cdktf.stringToHclTerraform(struct!.schedule),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_key: {
      value: cdktf.stringToHclTerraform(struct!.secretKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subscription_ids: {
      value: cdktf.stringToHclTerraform(struct!.subscriptionIds),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tenant_id: {
      value: cdktf.stringToHclTerraform(struct!.tenantId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraAccountOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraAccount | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accountId !== undefined) {
      hasAnyValues = true;
      internalValueResult.accountId = this._accountId;
    }
    if (this._assumedRoleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumedRoleArn = this._assumedRoleArn;
    }
    if (this._clientId !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientId = this._clientId;
    }
    if (this._collectorDescription !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectorDescription = this._collectorDescription;
    }
    if (this._country !== undefined) {
      hasAnyValues = true;
      internalValueResult.country = this._country;
    }
    if (this._externalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.externalId = this._externalId;
    }
    if (this._schedule !== undefined) {
      hasAnyValues = true;
      internalValueResult.schedule = this._schedule;
    }
    if (this._secretKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKey = this._secretKey;
    }
    if (this._subscriptionIds !== undefined) {
      hasAnyValues = true;
      internalValueResult.subscriptionIds = this._subscriptionIds;
    }
    if (this._tenantId !== undefined) {
      hasAnyValues = true;
      internalValueResult.tenantId = this._tenantId;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraAccount | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accountId = undefined;
      this._assumedRoleArn = undefined;
      this._clientId = undefined;
      this._collectorDescription = undefined;
      this._country = undefined;
      this._externalId = undefined;
      this._schedule = undefined;
      this._secretKey = undefined;
      this._subscriptionIds = undefined;
      this._tenantId = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accountId = value.accountId;
      this._assumedRoleArn = value.assumedRoleArn;
      this._clientId = value.clientId;
      this._collectorDescription = value.collectorDescription;
      this._country = value.country;
      this._externalId = value.externalId;
      this._schedule = value.schedule;
      this._secretKey = value.secretKey;
      this._subscriptionIds = value.subscriptionIds;
      this._tenantId = value.tenantId;
    }
  }

  // account_id - computed: false, optional: true, required: false
  private _accountId?: string; 
  public get accountId() {
    return this.getStringAttribute('account_id');
  }
  public set accountId(value: string) {
    this._accountId = value;
  }
  public resetAccountId() {
    this._accountId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accountIdInput() {
    return this._accountId;
  }

  // assumed_role_arn - computed: false, optional: true, required: false
  private _assumedRoleArn?: string; 
  public get assumedRoleArn() {
    return this.getStringAttribute('assumed_role_arn');
  }
  public set assumedRoleArn(value: string) {
    this._assumedRoleArn = value;
  }
  public resetAssumedRoleArn() {
    this._assumedRoleArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumedRoleArnInput() {
    return this._assumedRoleArn;
  }

  // billing_bucket_name - computed: true, optional: false, required: false
  public get billingBucketName() {
    return this.getStringAttribute('billing_bucket_name');
  }

  // billing_path_prefix - computed: true, optional: false, required: false
  public get billingPathPrefix() {
    return this.getStringAttribute('billing_path_prefix');
  }

  // client_id - computed: false, optional: true, required: false
  private _clientId?: string; 
  public get clientId() {
    return this.getStringAttribute('client_id');
  }
  public set clientId(value: string) {
    this._clientId = value;
  }
  public resetClientId() {
    this._clientId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientIdInput() {
    return this._clientId;
  }

  // collector_description - computed: false, optional: true, required: false
  private _collectorDescription?: string; 
  public get collectorDescription() {
    return this.getStringAttribute('collector_description');
  }
  public set collectorDescription(value: string) {
    this._collectorDescription = value;
  }
  public resetCollectorDescription() {
    this._collectorDescription = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorDescriptionInput() {
    return this._collectorDescription;
  }

  // collector_id - computed: true, optional: false, required: false
  public get collectorId() {
    return this.getNumberAttribute('collector_id');
  }

  // country - computed: false, optional: true, required: false
  private _country?: string; 
  public get country() {
    return this.getStringAttribute('country');
  }
  public set country(value: string) {
    this._country = value;
  }
  public resetCountry() {
    this._country = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get countryInput() {
    return this._country;
  }

  // external_id - computed: false, optional: true, required: false
  private _externalId?: string; 
  public get externalId() {
    return this.getStringAttribute('external_id');
  }
  public set externalId(value: string) {
    this._externalId = value;
  }
  public resetExternalId() {
    this._externalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get externalIdInput() {
    return this._externalId;
  }

  // schedule - computed: false, optional: true, required: false
  private _schedule?: string; 
  public get schedule() {
    return this.getStringAttribute('schedule');
  }
  public set schedule(value: string) {
    this._schedule = value;
  }
  public resetSchedule() {
    this._schedule = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scheduleInput() {
    return this._schedule;
  }

  // secret_key - computed: false, optional: true, required: false
  private _secretKey?: string; 
  public get secretKey() {
    return this.getStringAttribute('secret_key');
  }
  public set secretKey(value: string) {
    this._secretKey = value;
  }
  public resetSecretKey() {
    this._secretKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyInput() {
    return this._secretKey;
  }

  // subscription_ids - computed: false, optional: true, required: false
  private _subscriptionIds?: string; 
  public get subscriptionIds() {
    return this.getStringAttribute('subscription_ids');
  }
  public set subscriptionIds(value: string) {
    this._subscriptionIds = value;
  }
  public resetSubscriptionIds() {
    this._subscriptionIds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subscriptionIdsInput() {
    return this._subscriptionIds;
  }

  // tenant_id - computed: false, optional: true, required: false
  private _tenantId?: string; 
  public get tenantId() {
    return this.getStringAttribute('tenant_id');
  }
  public set tenantId(value: string) {
    this._tenantId = value;
  }
  public resetTenantId() {
    this._tenantId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tenantIdInput() {
    return this._tenantId;
  }

  // type - computed: true, optional: false, required: false
  public get type() {
    return this.getStringAttribute('type');
  }
}

export class DeviceGroupExtraAccountList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraAccount[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraAccountOutputReference {
    return new DeviceGroupExtraAccountOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraDefaultTags {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#name DeviceGroup#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#operation DeviceGroup#operation}
  */
  readonly operation?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#value DeviceGroup#value}
  */
  readonly value?: string;
}

export function deviceGroupExtraDefaultTagsToTerraform(struct?: DeviceGroupExtraDefaultTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    operation: cdktf.stringToTerraform(struct!.operation),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function deviceGroupExtraDefaultTagsToHclTerraform(struct?: DeviceGroupExtraDefaultTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operation: {
      value: cdktf.stringToHclTerraform(struct!.operation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraDefaultTagsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraDefaultTags | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._operation !== undefined) {
      hasAnyValues = true;
      internalValueResult.operation = this._operation;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraDefaultTags | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._operation = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._operation = value.operation;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // operation - computed: false, optional: true, required: false
  private _operation?: string; 
  public get operation() {
    return this.getStringAttribute('operation');
  }
  public set operation(value: string) {
    this._operation = value;
  }
  public resetOperation() {
    this._operation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operationInput() {
    return this._operation;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DeviceGroupExtraDefaultTagsList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraDefaultTags[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraDefaultTagsOutputReference {
    return new DeviceGroupExtraDefaultTagsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraDefaultNormalCollectorConfigCollectors {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#applies_to DeviceGroup#applies_to}
  */
  readonly appliesTo?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#auto_balanced_collector_group_id DeviceGroup#auto_balanced_collector_group_id}
  */
  readonly autoBalancedCollectorGroupId?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#collector_id DeviceGroup#collector_id}
  */
  readonly collectorId?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#priority DeviceGroup#priority}
  */
  readonly priority?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#use_public_ip DeviceGroup#use_public_ip}
  */
  readonly usePublicIp?: boolean | cdktf.IResolvable;
}

export function deviceGroupExtraDefaultNormalCollectorConfigCollectorsToTerraform(struct?: DeviceGroupExtraDefaultNormalCollectorConfigCollectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    applies_to: cdktf.stringToTerraform(struct!.appliesTo),
    auto_balanced_collector_group_id: cdktf.numberToTerraform(struct!.autoBalancedCollectorGroupId),
    collector_id: cdktf.numberToTerraform(struct!.collectorId),
    priority: cdktf.numberToTerraform(struct!.priority),
    use_public_ip: cdktf.booleanToTerraform(struct!.usePublicIp),
  }
}


export function deviceGroupExtraDefaultNormalCollectorConfigCollectorsToHclTerraform(struct?: DeviceGroupExtraDefaultNormalCollectorConfigCollectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    applies_to: {
      value: cdktf.stringToHclTerraform(struct!.appliesTo),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auto_balanced_collector_group_id: {
      value: cdktf.numberToHclTerraform(struct!.autoBalancedCollectorGroupId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    collector_id: {
      value: cdktf.numberToHclTerraform(struct!.collectorId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    priority: {
      value: cdktf.numberToHclTerraform(struct!.priority),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    use_public_ip: {
      value: cdktf.booleanToHclTerraform(struct!.usePublicIp),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraDefaultNormalCollectorConfigCollectorsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraDefaultNormalCollectorConfigCollectors | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._appliesTo !== undefined) {
      hasAnyValues = true;
      internalValueResult.appliesTo = this._appliesTo;
    }
    if (this._autoBalancedCollectorGroupId !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoBalancedCollectorGroupId = this._autoBalancedCollectorGroupId;
    }
    if (this._collectorId !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectorId = this._collectorId;
    }
    if (this._priority !== undefined) {
      hasAnyValues = true;
      internalValueResult.priority = this._priority;
    }
    if (this._usePublicIp !== undefined) {
      hasAnyValues = true;
      internalValueResult.usePublicIp = this._usePublicIp;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraDefaultNormalCollectorConfigCollectors | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._appliesTo = undefined;
      this._autoBalancedCollectorGroupId = undefined;
      this._collectorId = undefined;
      this._priority = undefined;
      this._usePublicIp = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._appliesTo = value.appliesTo;
      this._autoBalancedCollectorGroupId = value.autoBalancedCollectorGroupId;
      this._collectorId = value.collectorId;
      this._priority = value.priority;
      this._usePublicIp = value.usePublicIp;
    }
  }

  // applies_to - computed: false, optional: true, required: false
  private _appliesTo?: string; 
  public get appliesTo() {
    return this.getStringAttribute('applies_to');
  }
  public set appliesTo(value: string) {
    this._appliesTo = value;
  }
  public resetAppliesTo() {
    this._appliesTo = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appliesToInput() {
    return this._appliesTo;
  }

  // auto_balanced_collector_group_id - computed: false, optional: true, required: false
  private _autoBalancedCollectorGroupId?: number; 
  public get autoBalancedCollectorGroupId() {
    return this.getNumberAttribute('auto_balanced_collector_group_id');
  }
  public set autoBalancedCollectorGroupId(value: number) {
    this._autoBalancedCollectorGroupId = value;
  }
  public resetAutoBalancedCollectorGroupId() {
    this._autoBalancedCollectorGroupId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoBalancedCollectorGroupIdInput() {
    return this._autoBalancedCollectorGroupId;
  }

  // collector_id - computed: false, optional: true, required: false
  private _collectorId?: number; 
  public get collectorId() {
    return this.getNumberAttribute('collector_id');
  }
  public set collectorId(value: number) {
    this._collectorId = value;
  }
  public resetCollectorId() {
    this._collectorId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorIdInput() {
    return this._collectorId;
  }

  // priority - computed: false, optional: true, required: false
  private _priority?: number; 
  public get priority() {
    return this.getNumberAttribute('priority');
  }
  public set priority(value: number) {
    this._priority = value;
  }
  public resetPriority() {
    this._priority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get priorityInput() {
    return this._priority;
  }

  // use_public_ip - computed: false, optional: true, required: false
  private _usePublicIp?: boolean | cdktf.IResolvable; 
  public get usePublicIp() {
    return this.getBooleanAttribute('use_public_ip');
  }
  public set usePublicIp(value: boolean | cdktf.IResolvable) {
    this._usePublicIp = value;
  }
  public resetUsePublicIp() {
    this._usePublicIp = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usePublicIpInput() {
    return this._usePublicIp;
  }
}

export class DeviceGroupExtraDefaultNormalCollectorConfigCollectorsList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraDefaultNormalCollectorConfigCollectors[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraDefaultNormalCollectorConfigCollectorsOutputReference {
    return new DeviceGroupExtraDefaultNormalCollectorConfigCollectorsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraDefaultNormalCollectorConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#collectors DeviceGroup#collectors}
  */
  readonly collectors?: DeviceGroupExtraDefaultNormalCollectorConfigCollectors[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#enabled DeviceGroup#enabled}
  */
  readonly enabled: boolean | cdktf.IResolvable;
}

export function deviceGroupExtraDefaultNormalCollectorConfigToTerraform(struct?: DeviceGroupExtraDefaultNormalCollectorConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    collectors: cdktf.listMapper(deviceGroupExtraDefaultNormalCollectorConfigCollectorsToTerraform, false)(struct!.collectors),
    enabled: cdktf.booleanToTerraform(struct!.enabled),
  }
}


export function deviceGroupExtraDefaultNormalCollectorConfigToHclTerraform(struct?: DeviceGroupExtraDefaultNormalCollectorConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    collectors: {
      value: cdktf.listMapperHcl(deviceGroupExtraDefaultNormalCollectorConfigCollectorsToHclTerraform, false)(struct!.collectors),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraDefaultNormalCollectorConfigCollectorsList",
    },
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraDefaultNormalCollectorConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraDefaultNormalCollectorConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._collectors?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectors = this._collectors?.internalValue;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraDefaultNormalCollectorConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._collectors.internalValue = undefined;
      this._enabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._collectors.internalValue = value.collectors;
      this._enabled = value.enabled;
    }
  }

  // collectors - computed: false, optional: true, required: false
  private _collectors = new DeviceGroupExtraDefaultNormalCollectorConfigCollectorsList(this, "collectors", false);
  public get collectors() {
    return this._collectors;
  }
  public putCollectors(value: DeviceGroupExtraDefaultNormalCollectorConfigCollectors[] | cdktf.IResolvable) {
    this._collectors.internalValue = value;
  }
  public resetCollectors() {
    this._collectors.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorsInput() {
    return this._collectors.internalValue;
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }
}

export class DeviceGroupExtraDefaultNormalCollectorConfigList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraDefaultNormalCollectorConfig[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraDefaultNormalCollectorConfigOutputReference {
    return new DeviceGroupExtraDefaultNormalCollectorConfigOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraDefault {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#custom_n_s_p_schedule DeviceGroup#custom_n_s_p_schedule}
  */
  readonly customNSPSchedule?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#dead_operation DeviceGroup#dead_operation}
  */
  readonly deadOperation?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#device_display_name_template DeviceGroup#device_display_name_template}
  */
  readonly deviceDisplayNameTemplate?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#disable_stop_terminate_host_monitor DeviceGroup#disable_stop_terminate_host_monitor}
  */
  readonly disableStopTerminateHostMonitor?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#disable_terminated_host_alerting DeviceGroup#disable_terminated_host_alerting}
  */
  readonly disableTerminatedHostAlerting?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#monitoring_region_infos DeviceGroup#monitoring_region_infos}
  */
  readonly monitoringRegionInfos?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#monitoring_regions DeviceGroup#monitoring_regions}
  */
  readonly monitoringRegions?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#name_filter DeviceGroup#name_filter}
  */
  readonly nameFilter?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#select_all DeviceGroup#select_all}
  */
  readonly selectAll?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#tags DeviceGroup#tags}
  */
  readonly tags?: DeviceGroupExtraDefaultTags[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#use_default DeviceGroup#use_default}
  */
  readonly useDefault: boolean | cdktf.IResolvable;
  /**
  * normal_collector_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#normal_collector_config DeviceGroup#normal_collector_config}
  */
  readonly normalCollectorConfig?: DeviceGroupExtraDefaultNormalCollectorConfig[] | cdktf.IResolvable;
}

export function deviceGroupExtraDefaultToTerraform(struct?: DeviceGroupExtraDefault | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    custom_n_s_p_schedule: cdktf.stringToTerraform(struct!.customNSPSchedule),
    dead_operation: cdktf.stringToTerraform(struct!.deadOperation),
    device_display_name_template: cdktf.stringToTerraform(struct!.deviceDisplayNameTemplate),
    disable_stop_terminate_host_monitor: cdktf.booleanToTerraform(struct!.disableStopTerminateHostMonitor),
    disable_terminated_host_alerting: cdktf.booleanToTerraform(struct!.disableTerminatedHostAlerting),
    monitoring_region_infos: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.monitoringRegionInfos),
    monitoring_regions: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.monitoringRegions),
    name_filter: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.nameFilter),
    select_all: cdktf.booleanToTerraform(struct!.selectAll),
    tags: cdktf.listMapper(deviceGroupExtraDefaultTagsToTerraform, false)(struct!.tags),
    use_default: cdktf.booleanToTerraform(struct!.useDefault),
    normal_collector_config: cdktf.listMapper(deviceGroupExtraDefaultNormalCollectorConfigToTerraform, true)(struct!.normalCollectorConfig),
  }
}


export function deviceGroupExtraDefaultToHclTerraform(struct?: DeviceGroupExtraDefault | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    custom_n_s_p_schedule: {
      value: cdktf.stringToHclTerraform(struct!.customNSPSchedule),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dead_operation: {
      value: cdktf.stringToHclTerraform(struct!.deadOperation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    device_display_name_template: {
      value: cdktf.stringToHclTerraform(struct!.deviceDisplayNameTemplate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disable_stop_terminate_host_monitor: {
      value: cdktf.booleanToHclTerraform(struct!.disableStopTerminateHostMonitor),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    disable_terminated_host_alerting: {
      value: cdktf.booleanToHclTerraform(struct!.disableTerminatedHostAlerting),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    monitoring_region_infos: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.monitoringRegionInfos),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    monitoring_regions: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.monitoringRegions),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    name_filter: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.nameFilter),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    select_all: {
      value: cdktf.booleanToHclTerraform(struct!.selectAll),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tags: {
      value: cdktf.listMapperHcl(deviceGroupExtraDefaultTagsToHclTerraform, false)(struct!.tags),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraDefaultTagsList",
    },
    use_default: {
      value: cdktf.booleanToHclTerraform(struct!.useDefault),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    normal_collector_config: {
      value: cdktf.listMapperHcl(deviceGroupExtraDefaultNormalCollectorConfigToHclTerraform, true)(struct!.normalCollectorConfig),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraDefaultNormalCollectorConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraDefaultOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraDefault | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._customNSPSchedule !== undefined) {
      hasAnyValues = true;
      internalValueResult.customNSPSchedule = this._customNSPSchedule;
    }
    if (this._deadOperation !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadOperation = this._deadOperation;
    }
    if (this._deviceDisplayNameTemplate !== undefined) {
      hasAnyValues = true;
      internalValueResult.deviceDisplayNameTemplate = this._deviceDisplayNameTemplate;
    }
    if (this._disableStopTerminateHostMonitor !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableStopTerminateHostMonitor = this._disableStopTerminateHostMonitor;
    }
    if (this._disableTerminatedHostAlerting !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableTerminatedHostAlerting = this._disableTerminatedHostAlerting;
    }
    if (this._monitoringRegionInfos !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoringRegionInfos = this._monitoringRegionInfos;
    }
    if (this._monitoringRegions !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoringRegions = this._monitoringRegions;
    }
    if (this._nameFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.nameFilter = this._nameFilter;
    }
    if (this._selectAll !== undefined) {
      hasAnyValues = true;
      internalValueResult.selectAll = this._selectAll;
    }
    if (this._tags?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags?.internalValue;
    }
    if (this._useDefault !== undefined) {
      hasAnyValues = true;
      internalValueResult.useDefault = this._useDefault;
    }
    if (this._normalCollectorConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.normalCollectorConfig = this._normalCollectorConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraDefault | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._customNSPSchedule = undefined;
      this._deadOperation = undefined;
      this._deviceDisplayNameTemplate = undefined;
      this._disableStopTerminateHostMonitor = undefined;
      this._disableTerminatedHostAlerting = undefined;
      this._monitoringRegionInfos = undefined;
      this._monitoringRegions = undefined;
      this._nameFilter = undefined;
      this._selectAll = undefined;
      this._tags.internalValue = undefined;
      this._useDefault = undefined;
      this._normalCollectorConfig.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._customNSPSchedule = value.customNSPSchedule;
      this._deadOperation = value.deadOperation;
      this._deviceDisplayNameTemplate = value.deviceDisplayNameTemplate;
      this._disableStopTerminateHostMonitor = value.disableStopTerminateHostMonitor;
      this._disableTerminatedHostAlerting = value.disableTerminatedHostAlerting;
      this._monitoringRegionInfos = value.monitoringRegionInfos;
      this._monitoringRegions = value.monitoringRegions;
      this._nameFilter = value.nameFilter;
      this._selectAll = value.selectAll;
      this._tags.internalValue = value.tags;
      this._useDefault = value.useDefault;
      this._normalCollectorConfig.internalValue = value.normalCollectorConfig;
    }
  }

  // custom_n_s_p_schedule - computed: false, optional: true, required: false
  private _customNSPSchedule?: string; 
  public get customNSPSchedule() {
    return this.getStringAttribute('custom_n_s_p_schedule');
  }
  public set customNSPSchedule(value: string) {
    this._customNSPSchedule = value;
  }
  public resetCustomNSPSchedule() {
    this._customNSPSchedule = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customNSPScheduleInput() {
    return this._customNSPSchedule;
  }

  // dead_operation - computed: false, optional: true, required: false
  private _deadOperation?: string; 
  public get deadOperation() {
    return this.getStringAttribute('dead_operation');
  }
  public set deadOperation(value: string) {
    this._deadOperation = value;
  }
  public resetDeadOperation() {
    this._deadOperation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadOperationInput() {
    return this._deadOperation;
  }

  // device_display_name_template - computed: false, optional: true, required: false
  private _deviceDisplayNameTemplate?: string; 
  public get deviceDisplayNameTemplate() {
    return this.getStringAttribute('device_display_name_template');
  }
  public set deviceDisplayNameTemplate(value: string) {
    this._deviceDisplayNameTemplate = value;
  }
  public resetDeviceDisplayNameTemplate() {
    this._deviceDisplayNameTemplate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deviceDisplayNameTemplateInput() {
    return this._deviceDisplayNameTemplate;
  }

  // disable_stop_terminate_host_monitor - computed: false, optional: true, required: false
  private _disableStopTerminateHostMonitor?: boolean | cdktf.IResolvable; 
  public get disableStopTerminateHostMonitor() {
    return this.getBooleanAttribute('disable_stop_terminate_host_monitor');
  }
  public set disableStopTerminateHostMonitor(value: boolean | cdktf.IResolvable) {
    this._disableStopTerminateHostMonitor = value;
  }
  public resetDisableStopTerminateHostMonitor() {
    this._disableStopTerminateHostMonitor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableStopTerminateHostMonitorInput() {
    return this._disableStopTerminateHostMonitor;
  }

  // disable_terminated_host_alerting - computed: false, optional: true, required: false
  private _disableTerminatedHostAlerting?: boolean | cdktf.IResolvable; 
  public get disableTerminatedHostAlerting() {
    return this.getBooleanAttribute('disable_terminated_host_alerting');
  }
  public set disableTerminatedHostAlerting(value: boolean | cdktf.IResolvable) {
    this._disableTerminatedHostAlerting = value;
  }
  public resetDisableTerminatedHostAlerting() {
    this._disableTerminatedHostAlerting = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableTerminatedHostAlertingInput() {
    return this._disableTerminatedHostAlerting;
  }

  // monitoring_region_infos - computed: false, optional: true, required: false
  private _monitoringRegionInfos?: string[]; 
  public get monitoringRegionInfos() {
    return cdktf.Fn.tolist(this.getListAttribute('monitoring_region_infos'));
  }
  public set monitoringRegionInfos(value: string[]) {
    this._monitoringRegionInfos = value;
  }
  public resetMonitoringRegionInfos() {
    this._monitoringRegionInfos = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoringRegionInfosInput() {
    return this._monitoringRegionInfos;
  }

  // monitoring_regions - computed: false, optional: true, required: false
  private _monitoringRegions?: string[]; 
  public get monitoringRegions() {
    return cdktf.Fn.tolist(this.getListAttribute('monitoring_regions'));
  }
  public set monitoringRegions(value: string[]) {
    this._monitoringRegions = value;
  }
  public resetMonitoringRegions() {
    this._monitoringRegions = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoringRegionsInput() {
    return this._monitoringRegions;
  }

  // name_filter - computed: false, optional: true, required: false
  private _nameFilter?: string[]; 
  public get nameFilter() {
    return cdktf.Fn.tolist(this.getListAttribute('name_filter'));
  }
  public set nameFilter(value: string[]) {
    this._nameFilter = value;
  }
  public resetNameFilter() {
    this._nameFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameFilterInput() {
    return this._nameFilter;
  }

  // select_all - computed: false, optional: true, required: false
  private _selectAll?: boolean | cdktf.IResolvable; 
  public get selectAll() {
    return this.getBooleanAttribute('select_all');
  }
  public set selectAll(value: boolean | cdktf.IResolvable) {
    this._selectAll = value;
  }
  public resetSelectAll() {
    this._selectAll = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectAllInput() {
    return this._selectAll;
  }

  // tags - computed: false, optional: true, required: false
  private _tags = new DeviceGroupExtraDefaultTagsList(this, "tags", false);
  public get tags() {
    return this._tags;
  }
  public putTags(value: DeviceGroupExtraDefaultTags[] | cdktf.IResolvable) {
    this._tags.internalValue = value;
  }
  public resetTags() {
    this._tags.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags.internalValue;
  }

  // use_default - computed: false, optional: false, required: true
  private _useDefault?: boolean | cdktf.IResolvable; 
  public get useDefault() {
    return this.getBooleanAttribute('use_default');
  }
  public set useDefault(value: boolean | cdktf.IResolvable) {
    this._useDefault = value;
  }
  // Temporarily expose input value. Use with caution.
  public get useDefaultInput() {
    return this._useDefault;
  }

  // normal_collector_config - computed: false, optional: true, required: false
  private _normalCollectorConfig = new DeviceGroupExtraDefaultNormalCollectorConfigList(this, "normal_collector_config", false);
  public get normalCollectorConfig() {
    return this._normalCollectorConfig;
  }
  public putNormalCollectorConfig(value: DeviceGroupExtraDefaultNormalCollectorConfig[] | cdktf.IResolvable) {
    this._normalCollectorConfig.internalValue = value;
  }
  public resetNormalCollectorConfig() {
    this._normalCollectorConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get normalCollectorConfigInput() {
    return this._normalCollectorConfig.internalValue;
  }
}

export class DeviceGroupExtraDefaultList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraDefault[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraDefaultOutputReference {
    return new DeviceGroupExtraDefaultOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesAPPLICATIONELBTags {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#name DeviceGroup#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#operation DeviceGroup#operation}
  */
  readonly operation?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#value DeviceGroup#value}
  */
  readonly value?: string;
}

export function deviceGroupExtraServicesAPPLICATIONELBTagsToTerraform(struct?: DeviceGroupExtraServicesAPPLICATIONELBTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    operation: cdktf.stringToTerraform(struct!.operation),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function deviceGroupExtraServicesAPPLICATIONELBTagsToHclTerraform(struct?: DeviceGroupExtraServicesAPPLICATIONELBTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operation: {
      value: cdktf.stringToHclTerraform(struct!.operation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesAPPLICATIONELBTagsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesAPPLICATIONELBTags | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._operation !== undefined) {
      hasAnyValues = true;
      internalValueResult.operation = this._operation;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesAPPLICATIONELBTags | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._operation = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._operation = value.operation;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // operation - computed: false, optional: true, required: false
  private _operation?: string; 
  public get operation() {
    return this.getStringAttribute('operation');
  }
  public set operation(value: string) {
    this._operation = value;
  }
  public resetOperation() {
    this._operation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operationInput() {
    return this._operation;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DeviceGroupExtraServicesAPPLICATIONELBTagsList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesAPPLICATIONELBTags[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesAPPLICATIONELBTagsOutputReference {
    return new DeviceGroupExtraServicesAPPLICATIONELBTagsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesAPPLICATIONELBNormalCollectorConfigCollectors {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#applies_to DeviceGroup#applies_to}
  */
  readonly appliesTo?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#auto_balanced_collector_group_id DeviceGroup#auto_balanced_collector_group_id}
  */
  readonly autoBalancedCollectorGroupId?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#collector_id DeviceGroup#collector_id}
  */
  readonly collectorId?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#priority DeviceGroup#priority}
  */
  readonly priority?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#use_public_ip DeviceGroup#use_public_ip}
  */
  readonly usePublicIp?: boolean | cdktf.IResolvable;
}

export function deviceGroupExtraServicesAPPLICATIONELBNormalCollectorConfigCollectorsToTerraform(struct?: DeviceGroupExtraServicesAPPLICATIONELBNormalCollectorConfigCollectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    applies_to: cdktf.stringToTerraform(struct!.appliesTo),
    auto_balanced_collector_group_id: cdktf.numberToTerraform(struct!.autoBalancedCollectorGroupId),
    collector_id: cdktf.numberToTerraform(struct!.collectorId),
    priority: cdktf.numberToTerraform(struct!.priority),
    use_public_ip: cdktf.booleanToTerraform(struct!.usePublicIp),
  }
}


export function deviceGroupExtraServicesAPPLICATIONELBNormalCollectorConfigCollectorsToHclTerraform(struct?: DeviceGroupExtraServicesAPPLICATIONELBNormalCollectorConfigCollectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    applies_to: {
      value: cdktf.stringToHclTerraform(struct!.appliesTo),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auto_balanced_collector_group_id: {
      value: cdktf.numberToHclTerraform(struct!.autoBalancedCollectorGroupId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    collector_id: {
      value: cdktf.numberToHclTerraform(struct!.collectorId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    priority: {
      value: cdktf.numberToHclTerraform(struct!.priority),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    use_public_ip: {
      value: cdktf.booleanToHclTerraform(struct!.usePublicIp),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesAPPLICATIONELBNormalCollectorConfigCollectorsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesAPPLICATIONELBNormalCollectorConfigCollectors | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._appliesTo !== undefined) {
      hasAnyValues = true;
      internalValueResult.appliesTo = this._appliesTo;
    }
    if (this._autoBalancedCollectorGroupId !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoBalancedCollectorGroupId = this._autoBalancedCollectorGroupId;
    }
    if (this._collectorId !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectorId = this._collectorId;
    }
    if (this._priority !== undefined) {
      hasAnyValues = true;
      internalValueResult.priority = this._priority;
    }
    if (this._usePublicIp !== undefined) {
      hasAnyValues = true;
      internalValueResult.usePublicIp = this._usePublicIp;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesAPPLICATIONELBNormalCollectorConfigCollectors | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._appliesTo = undefined;
      this._autoBalancedCollectorGroupId = undefined;
      this._collectorId = undefined;
      this._priority = undefined;
      this._usePublicIp = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._appliesTo = value.appliesTo;
      this._autoBalancedCollectorGroupId = value.autoBalancedCollectorGroupId;
      this._collectorId = value.collectorId;
      this._priority = value.priority;
      this._usePublicIp = value.usePublicIp;
    }
  }

  // applies_to - computed: false, optional: true, required: false
  private _appliesTo?: string; 
  public get appliesTo() {
    return this.getStringAttribute('applies_to');
  }
  public set appliesTo(value: string) {
    this._appliesTo = value;
  }
  public resetAppliesTo() {
    this._appliesTo = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appliesToInput() {
    return this._appliesTo;
  }

  // auto_balanced_collector_group_id - computed: false, optional: true, required: false
  private _autoBalancedCollectorGroupId?: number; 
  public get autoBalancedCollectorGroupId() {
    return this.getNumberAttribute('auto_balanced_collector_group_id');
  }
  public set autoBalancedCollectorGroupId(value: number) {
    this._autoBalancedCollectorGroupId = value;
  }
  public resetAutoBalancedCollectorGroupId() {
    this._autoBalancedCollectorGroupId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoBalancedCollectorGroupIdInput() {
    return this._autoBalancedCollectorGroupId;
  }

  // collector_id - computed: false, optional: true, required: false
  private _collectorId?: number; 
  public get collectorId() {
    return this.getNumberAttribute('collector_id');
  }
  public set collectorId(value: number) {
    this._collectorId = value;
  }
  public resetCollectorId() {
    this._collectorId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorIdInput() {
    return this._collectorId;
  }

  // priority - computed: false, optional: true, required: false
  private _priority?: number; 
  public get priority() {
    return this.getNumberAttribute('priority');
  }
  public set priority(value: number) {
    this._priority = value;
  }
  public resetPriority() {
    this._priority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get priorityInput() {
    return this._priority;
  }

  // use_public_ip - computed: false, optional: true, required: false
  private _usePublicIp?: boolean | cdktf.IResolvable; 
  public get usePublicIp() {
    return this.getBooleanAttribute('use_public_ip');
  }
  public set usePublicIp(value: boolean | cdktf.IResolvable) {
    this._usePublicIp = value;
  }
  public resetUsePublicIp() {
    this._usePublicIp = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usePublicIpInput() {
    return this._usePublicIp;
  }
}

export class DeviceGroupExtraServicesAPPLICATIONELBNormalCollectorConfigCollectorsList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesAPPLICATIONELBNormalCollectorConfigCollectors[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesAPPLICATIONELBNormalCollectorConfigCollectorsOutputReference {
    return new DeviceGroupExtraServicesAPPLICATIONELBNormalCollectorConfigCollectorsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesAPPLICATIONELBNormalCollectorConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#collectors DeviceGroup#collectors}
  */
  readonly collectors?: DeviceGroupExtraServicesAPPLICATIONELBNormalCollectorConfigCollectors[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#enabled DeviceGroup#enabled}
  */
  readonly enabled: boolean | cdktf.IResolvable;
}

export function deviceGroupExtraServicesAPPLICATIONELBNormalCollectorConfigToTerraform(struct?: DeviceGroupExtraServicesAPPLICATIONELBNormalCollectorConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    collectors: cdktf.listMapper(deviceGroupExtraServicesAPPLICATIONELBNormalCollectorConfigCollectorsToTerraform, false)(struct!.collectors),
    enabled: cdktf.booleanToTerraform(struct!.enabled),
  }
}


export function deviceGroupExtraServicesAPPLICATIONELBNormalCollectorConfigToHclTerraform(struct?: DeviceGroupExtraServicesAPPLICATIONELBNormalCollectorConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    collectors: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesAPPLICATIONELBNormalCollectorConfigCollectorsToHclTerraform, false)(struct!.collectors),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesAPPLICATIONELBNormalCollectorConfigCollectorsList",
    },
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesAPPLICATIONELBNormalCollectorConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesAPPLICATIONELBNormalCollectorConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._collectors?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectors = this._collectors?.internalValue;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesAPPLICATIONELBNormalCollectorConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._collectors.internalValue = undefined;
      this._enabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._collectors.internalValue = value.collectors;
      this._enabled = value.enabled;
    }
  }

  // collectors - computed: false, optional: true, required: false
  private _collectors = new DeviceGroupExtraServicesAPPLICATIONELBNormalCollectorConfigCollectorsList(this, "collectors", false);
  public get collectors() {
    return this._collectors;
  }
  public putCollectors(value: DeviceGroupExtraServicesAPPLICATIONELBNormalCollectorConfigCollectors[] | cdktf.IResolvable) {
    this._collectors.internalValue = value;
  }
  public resetCollectors() {
    this._collectors.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorsInput() {
    return this._collectors.internalValue;
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }
}

export class DeviceGroupExtraServicesAPPLICATIONELBNormalCollectorConfigList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesAPPLICATIONELBNormalCollectorConfig[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesAPPLICATIONELBNormalCollectorConfigOutputReference {
    return new DeviceGroupExtraServicesAPPLICATIONELBNormalCollectorConfigOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesAPPLICATIONELB {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#custom_n_s_p_schedule DeviceGroup#custom_n_s_p_schedule}
  */
  readonly customNSPSchedule?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#dead_operation DeviceGroup#dead_operation}
  */
  readonly deadOperation?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#device_display_name_template DeviceGroup#device_display_name_template}
  */
  readonly deviceDisplayNameTemplate?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#disable_stop_terminate_host_monitor DeviceGroup#disable_stop_terminate_host_monitor}
  */
  readonly disableStopTerminateHostMonitor?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#disable_terminated_host_alerting DeviceGroup#disable_terminated_host_alerting}
  */
  readonly disableTerminatedHostAlerting?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#monitoring_region_infos DeviceGroup#monitoring_region_infos}
  */
  readonly monitoringRegionInfos?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#monitoring_regions DeviceGroup#monitoring_regions}
  */
  readonly monitoringRegions?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#name_filter DeviceGroup#name_filter}
  */
  readonly nameFilter?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#select_all DeviceGroup#select_all}
  */
  readonly selectAll?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#tags DeviceGroup#tags}
  */
  readonly tags?: DeviceGroupExtraServicesAPPLICATIONELBTags[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#use_default DeviceGroup#use_default}
  */
  readonly useDefault: boolean | cdktf.IResolvable;
  /**
  * normal_collector_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#normal_collector_config DeviceGroup#normal_collector_config}
  */
  readonly normalCollectorConfig?: DeviceGroupExtraServicesAPPLICATIONELBNormalCollectorConfig[] | cdktf.IResolvable;
}

export function deviceGroupExtraServicesAPPLICATIONELBToTerraform(struct?: DeviceGroupExtraServicesAPPLICATIONELB | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    custom_n_s_p_schedule: cdktf.stringToTerraform(struct!.customNSPSchedule),
    dead_operation: cdktf.stringToTerraform(struct!.deadOperation),
    device_display_name_template: cdktf.stringToTerraform(struct!.deviceDisplayNameTemplate),
    disable_stop_terminate_host_monitor: cdktf.booleanToTerraform(struct!.disableStopTerminateHostMonitor),
    disable_terminated_host_alerting: cdktf.booleanToTerraform(struct!.disableTerminatedHostAlerting),
    monitoring_region_infos: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.monitoringRegionInfos),
    monitoring_regions: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.monitoringRegions),
    name_filter: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.nameFilter),
    select_all: cdktf.booleanToTerraform(struct!.selectAll),
    tags: cdktf.listMapper(deviceGroupExtraServicesAPPLICATIONELBTagsToTerraform, false)(struct!.tags),
    use_default: cdktf.booleanToTerraform(struct!.useDefault),
    normal_collector_config: cdktf.listMapper(deviceGroupExtraServicesAPPLICATIONELBNormalCollectorConfigToTerraform, true)(struct!.normalCollectorConfig),
  }
}


export function deviceGroupExtraServicesAPPLICATIONELBToHclTerraform(struct?: DeviceGroupExtraServicesAPPLICATIONELB | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    custom_n_s_p_schedule: {
      value: cdktf.stringToHclTerraform(struct!.customNSPSchedule),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dead_operation: {
      value: cdktf.stringToHclTerraform(struct!.deadOperation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    device_display_name_template: {
      value: cdktf.stringToHclTerraform(struct!.deviceDisplayNameTemplate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disable_stop_terminate_host_monitor: {
      value: cdktf.booleanToHclTerraform(struct!.disableStopTerminateHostMonitor),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    disable_terminated_host_alerting: {
      value: cdktf.booleanToHclTerraform(struct!.disableTerminatedHostAlerting),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    monitoring_region_infos: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.monitoringRegionInfos),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    monitoring_regions: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.monitoringRegions),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    name_filter: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.nameFilter),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    select_all: {
      value: cdktf.booleanToHclTerraform(struct!.selectAll),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tags: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesAPPLICATIONELBTagsToHclTerraform, false)(struct!.tags),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesAPPLICATIONELBTagsList",
    },
    use_default: {
      value: cdktf.booleanToHclTerraform(struct!.useDefault),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    normal_collector_config: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesAPPLICATIONELBNormalCollectorConfigToHclTerraform, true)(struct!.normalCollectorConfig),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesAPPLICATIONELBNormalCollectorConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesAPPLICATIONELBOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesAPPLICATIONELB | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._customNSPSchedule !== undefined) {
      hasAnyValues = true;
      internalValueResult.customNSPSchedule = this._customNSPSchedule;
    }
    if (this._deadOperation !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadOperation = this._deadOperation;
    }
    if (this._deviceDisplayNameTemplate !== undefined) {
      hasAnyValues = true;
      internalValueResult.deviceDisplayNameTemplate = this._deviceDisplayNameTemplate;
    }
    if (this._disableStopTerminateHostMonitor !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableStopTerminateHostMonitor = this._disableStopTerminateHostMonitor;
    }
    if (this._disableTerminatedHostAlerting !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableTerminatedHostAlerting = this._disableTerminatedHostAlerting;
    }
    if (this._monitoringRegionInfos !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoringRegionInfos = this._monitoringRegionInfos;
    }
    if (this._monitoringRegions !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoringRegions = this._monitoringRegions;
    }
    if (this._nameFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.nameFilter = this._nameFilter;
    }
    if (this._selectAll !== undefined) {
      hasAnyValues = true;
      internalValueResult.selectAll = this._selectAll;
    }
    if (this._tags?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags?.internalValue;
    }
    if (this._useDefault !== undefined) {
      hasAnyValues = true;
      internalValueResult.useDefault = this._useDefault;
    }
    if (this._normalCollectorConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.normalCollectorConfig = this._normalCollectorConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesAPPLICATIONELB | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._customNSPSchedule = undefined;
      this._deadOperation = undefined;
      this._deviceDisplayNameTemplate = undefined;
      this._disableStopTerminateHostMonitor = undefined;
      this._disableTerminatedHostAlerting = undefined;
      this._monitoringRegionInfos = undefined;
      this._monitoringRegions = undefined;
      this._nameFilter = undefined;
      this._selectAll = undefined;
      this._tags.internalValue = undefined;
      this._useDefault = undefined;
      this._normalCollectorConfig.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._customNSPSchedule = value.customNSPSchedule;
      this._deadOperation = value.deadOperation;
      this._deviceDisplayNameTemplate = value.deviceDisplayNameTemplate;
      this._disableStopTerminateHostMonitor = value.disableStopTerminateHostMonitor;
      this._disableTerminatedHostAlerting = value.disableTerminatedHostAlerting;
      this._monitoringRegionInfos = value.monitoringRegionInfos;
      this._monitoringRegions = value.monitoringRegions;
      this._nameFilter = value.nameFilter;
      this._selectAll = value.selectAll;
      this._tags.internalValue = value.tags;
      this._useDefault = value.useDefault;
      this._normalCollectorConfig.internalValue = value.normalCollectorConfig;
    }
  }

  // custom_n_s_p_schedule - computed: false, optional: true, required: false
  private _customNSPSchedule?: string; 
  public get customNSPSchedule() {
    return this.getStringAttribute('custom_n_s_p_schedule');
  }
  public set customNSPSchedule(value: string) {
    this._customNSPSchedule = value;
  }
  public resetCustomNSPSchedule() {
    this._customNSPSchedule = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customNSPScheduleInput() {
    return this._customNSPSchedule;
  }

  // dead_operation - computed: false, optional: true, required: false
  private _deadOperation?: string; 
  public get deadOperation() {
    return this.getStringAttribute('dead_operation');
  }
  public set deadOperation(value: string) {
    this._deadOperation = value;
  }
  public resetDeadOperation() {
    this._deadOperation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadOperationInput() {
    return this._deadOperation;
  }

  // device_display_name_template - computed: false, optional: true, required: false
  private _deviceDisplayNameTemplate?: string; 
  public get deviceDisplayNameTemplate() {
    return this.getStringAttribute('device_display_name_template');
  }
  public set deviceDisplayNameTemplate(value: string) {
    this._deviceDisplayNameTemplate = value;
  }
  public resetDeviceDisplayNameTemplate() {
    this._deviceDisplayNameTemplate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deviceDisplayNameTemplateInput() {
    return this._deviceDisplayNameTemplate;
  }

  // disable_stop_terminate_host_monitor - computed: false, optional: true, required: false
  private _disableStopTerminateHostMonitor?: boolean | cdktf.IResolvable; 
  public get disableStopTerminateHostMonitor() {
    return this.getBooleanAttribute('disable_stop_terminate_host_monitor');
  }
  public set disableStopTerminateHostMonitor(value: boolean | cdktf.IResolvable) {
    this._disableStopTerminateHostMonitor = value;
  }
  public resetDisableStopTerminateHostMonitor() {
    this._disableStopTerminateHostMonitor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableStopTerminateHostMonitorInput() {
    return this._disableStopTerminateHostMonitor;
  }

  // disable_terminated_host_alerting - computed: false, optional: true, required: false
  private _disableTerminatedHostAlerting?: boolean | cdktf.IResolvable; 
  public get disableTerminatedHostAlerting() {
    return this.getBooleanAttribute('disable_terminated_host_alerting');
  }
  public set disableTerminatedHostAlerting(value: boolean | cdktf.IResolvable) {
    this._disableTerminatedHostAlerting = value;
  }
  public resetDisableTerminatedHostAlerting() {
    this._disableTerminatedHostAlerting = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableTerminatedHostAlertingInput() {
    return this._disableTerminatedHostAlerting;
  }

  // monitoring_region_infos - computed: false, optional: true, required: false
  private _monitoringRegionInfos?: string[]; 
  public get monitoringRegionInfos() {
    return cdktf.Fn.tolist(this.getListAttribute('monitoring_region_infos'));
  }
  public set monitoringRegionInfos(value: string[]) {
    this._monitoringRegionInfos = value;
  }
  public resetMonitoringRegionInfos() {
    this._monitoringRegionInfos = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoringRegionInfosInput() {
    return this._monitoringRegionInfos;
  }

  // monitoring_regions - computed: false, optional: true, required: false
  private _monitoringRegions?: string[]; 
  public get monitoringRegions() {
    return cdktf.Fn.tolist(this.getListAttribute('monitoring_regions'));
  }
  public set monitoringRegions(value: string[]) {
    this._monitoringRegions = value;
  }
  public resetMonitoringRegions() {
    this._monitoringRegions = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoringRegionsInput() {
    return this._monitoringRegions;
  }

  // name_filter - computed: false, optional: true, required: false
  private _nameFilter?: string[]; 
  public get nameFilter() {
    return cdktf.Fn.tolist(this.getListAttribute('name_filter'));
  }
  public set nameFilter(value: string[]) {
    this._nameFilter = value;
  }
  public resetNameFilter() {
    this._nameFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameFilterInput() {
    return this._nameFilter;
  }

  // select_all - computed: false, optional: true, required: false
  private _selectAll?: boolean | cdktf.IResolvable; 
  public get selectAll() {
    return this.getBooleanAttribute('select_all');
  }
  public set selectAll(value: boolean | cdktf.IResolvable) {
    this._selectAll = value;
  }
  public resetSelectAll() {
    this._selectAll = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectAllInput() {
    return this._selectAll;
  }

  // tags - computed: false, optional: true, required: false
  private _tags = new DeviceGroupExtraServicesAPPLICATIONELBTagsList(this, "tags", false);
  public get tags() {
    return this._tags;
  }
  public putTags(value: DeviceGroupExtraServicesAPPLICATIONELBTags[] | cdktf.IResolvable) {
    this._tags.internalValue = value;
  }
  public resetTags() {
    this._tags.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags.internalValue;
  }

  // use_default - computed: false, optional: false, required: true
  private _useDefault?: boolean | cdktf.IResolvable; 
  public get useDefault() {
    return this.getBooleanAttribute('use_default');
  }
  public set useDefault(value: boolean | cdktf.IResolvable) {
    this._useDefault = value;
  }
  // Temporarily expose input value. Use with caution.
  public get useDefaultInput() {
    return this._useDefault;
  }

  // normal_collector_config - computed: false, optional: true, required: false
  private _normalCollectorConfig = new DeviceGroupExtraServicesAPPLICATIONELBNormalCollectorConfigList(this, "normal_collector_config", false);
  public get normalCollectorConfig() {
    return this._normalCollectorConfig;
  }
  public putNormalCollectorConfig(value: DeviceGroupExtraServicesAPPLICATIONELBNormalCollectorConfig[] | cdktf.IResolvable) {
    this._normalCollectorConfig.internalValue = value;
  }
  public resetNormalCollectorConfig() {
    this._normalCollectorConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get normalCollectorConfigInput() {
    return this._normalCollectorConfig.internalValue;
  }
}

export class DeviceGroupExtraServicesAPPLICATIONELBList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesAPPLICATIONELB[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesAPPLICATIONELBOutputReference {
    return new DeviceGroupExtraServicesAPPLICATIONELBOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesAPPLICATIONGATEWAYTags {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#name DeviceGroup#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#operation DeviceGroup#operation}
  */
  readonly operation?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#value DeviceGroup#value}
  */
  readonly value?: string;
}

export function deviceGroupExtraServicesAPPLICATIONGATEWAYTagsToTerraform(struct?: DeviceGroupExtraServicesAPPLICATIONGATEWAYTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    operation: cdktf.stringToTerraform(struct!.operation),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function deviceGroupExtraServicesAPPLICATIONGATEWAYTagsToHclTerraform(struct?: DeviceGroupExtraServicesAPPLICATIONGATEWAYTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operation: {
      value: cdktf.stringToHclTerraform(struct!.operation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesAPPLICATIONGATEWAYTagsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesAPPLICATIONGATEWAYTags | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._operation !== undefined) {
      hasAnyValues = true;
      internalValueResult.operation = this._operation;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesAPPLICATIONGATEWAYTags | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._operation = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._operation = value.operation;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // operation - computed: false, optional: true, required: false
  private _operation?: string; 
  public get operation() {
    return this.getStringAttribute('operation');
  }
  public set operation(value: string) {
    this._operation = value;
  }
  public resetOperation() {
    this._operation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operationInput() {
    return this._operation;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DeviceGroupExtraServicesAPPLICATIONGATEWAYTagsList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesAPPLICATIONGATEWAYTags[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesAPPLICATIONGATEWAYTagsOutputReference {
    return new DeviceGroupExtraServicesAPPLICATIONGATEWAYTagsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesAPPLICATIONGATEWAYNormalCollectorConfigCollectors {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#applies_to DeviceGroup#applies_to}
  */
  readonly appliesTo?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#auto_balanced_collector_group_id DeviceGroup#auto_balanced_collector_group_id}
  */
  readonly autoBalancedCollectorGroupId?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#collector_id DeviceGroup#collector_id}
  */
  readonly collectorId?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#priority DeviceGroup#priority}
  */
  readonly priority?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#use_public_ip DeviceGroup#use_public_ip}
  */
  readonly usePublicIp?: boolean | cdktf.IResolvable;
}

export function deviceGroupExtraServicesAPPLICATIONGATEWAYNormalCollectorConfigCollectorsToTerraform(struct?: DeviceGroupExtraServicesAPPLICATIONGATEWAYNormalCollectorConfigCollectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    applies_to: cdktf.stringToTerraform(struct!.appliesTo),
    auto_balanced_collector_group_id: cdktf.numberToTerraform(struct!.autoBalancedCollectorGroupId),
    collector_id: cdktf.numberToTerraform(struct!.collectorId),
    priority: cdktf.numberToTerraform(struct!.priority),
    use_public_ip: cdktf.booleanToTerraform(struct!.usePublicIp),
  }
}


export function deviceGroupExtraServicesAPPLICATIONGATEWAYNormalCollectorConfigCollectorsToHclTerraform(struct?: DeviceGroupExtraServicesAPPLICATIONGATEWAYNormalCollectorConfigCollectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    applies_to: {
      value: cdktf.stringToHclTerraform(struct!.appliesTo),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auto_balanced_collector_group_id: {
      value: cdktf.numberToHclTerraform(struct!.autoBalancedCollectorGroupId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    collector_id: {
      value: cdktf.numberToHclTerraform(struct!.collectorId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    priority: {
      value: cdktf.numberToHclTerraform(struct!.priority),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    use_public_ip: {
      value: cdktf.booleanToHclTerraform(struct!.usePublicIp),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesAPPLICATIONGATEWAYNormalCollectorConfigCollectorsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesAPPLICATIONGATEWAYNormalCollectorConfigCollectors | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._appliesTo !== undefined) {
      hasAnyValues = true;
      internalValueResult.appliesTo = this._appliesTo;
    }
    if (this._autoBalancedCollectorGroupId !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoBalancedCollectorGroupId = this._autoBalancedCollectorGroupId;
    }
    if (this._collectorId !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectorId = this._collectorId;
    }
    if (this._priority !== undefined) {
      hasAnyValues = true;
      internalValueResult.priority = this._priority;
    }
    if (this._usePublicIp !== undefined) {
      hasAnyValues = true;
      internalValueResult.usePublicIp = this._usePublicIp;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesAPPLICATIONGATEWAYNormalCollectorConfigCollectors | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._appliesTo = undefined;
      this._autoBalancedCollectorGroupId = undefined;
      this._collectorId = undefined;
      this._priority = undefined;
      this._usePublicIp = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._appliesTo = value.appliesTo;
      this._autoBalancedCollectorGroupId = value.autoBalancedCollectorGroupId;
      this._collectorId = value.collectorId;
      this._priority = value.priority;
      this._usePublicIp = value.usePublicIp;
    }
  }

  // applies_to - computed: false, optional: true, required: false
  private _appliesTo?: string; 
  public get appliesTo() {
    return this.getStringAttribute('applies_to');
  }
  public set appliesTo(value: string) {
    this._appliesTo = value;
  }
  public resetAppliesTo() {
    this._appliesTo = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appliesToInput() {
    return this._appliesTo;
  }

  // auto_balanced_collector_group_id - computed: false, optional: true, required: false
  private _autoBalancedCollectorGroupId?: number; 
  public get autoBalancedCollectorGroupId() {
    return this.getNumberAttribute('auto_balanced_collector_group_id');
  }
  public set autoBalancedCollectorGroupId(value: number) {
    this._autoBalancedCollectorGroupId = value;
  }
  public resetAutoBalancedCollectorGroupId() {
    this._autoBalancedCollectorGroupId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoBalancedCollectorGroupIdInput() {
    return this._autoBalancedCollectorGroupId;
  }

  // collector_id - computed: false, optional: true, required: false
  private _collectorId?: number; 
  public get collectorId() {
    return this.getNumberAttribute('collector_id');
  }
  public set collectorId(value: number) {
    this._collectorId = value;
  }
  public resetCollectorId() {
    this._collectorId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorIdInput() {
    return this._collectorId;
  }

  // priority - computed: false, optional: true, required: false
  private _priority?: number; 
  public get priority() {
    return this.getNumberAttribute('priority');
  }
  public set priority(value: number) {
    this._priority = value;
  }
  public resetPriority() {
    this._priority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get priorityInput() {
    return this._priority;
  }

  // use_public_ip - computed: false, optional: true, required: false
  private _usePublicIp?: boolean | cdktf.IResolvable; 
  public get usePublicIp() {
    return this.getBooleanAttribute('use_public_ip');
  }
  public set usePublicIp(value: boolean | cdktf.IResolvable) {
    this._usePublicIp = value;
  }
  public resetUsePublicIp() {
    this._usePublicIp = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usePublicIpInput() {
    return this._usePublicIp;
  }
}

export class DeviceGroupExtraServicesAPPLICATIONGATEWAYNormalCollectorConfigCollectorsList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesAPPLICATIONGATEWAYNormalCollectorConfigCollectors[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesAPPLICATIONGATEWAYNormalCollectorConfigCollectorsOutputReference {
    return new DeviceGroupExtraServicesAPPLICATIONGATEWAYNormalCollectorConfigCollectorsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesAPPLICATIONGATEWAYNormalCollectorConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#collectors DeviceGroup#collectors}
  */
  readonly collectors?: DeviceGroupExtraServicesAPPLICATIONGATEWAYNormalCollectorConfigCollectors[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#enabled DeviceGroup#enabled}
  */
  readonly enabled: boolean | cdktf.IResolvable;
}

export function deviceGroupExtraServicesAPPLICATIONGATEWAYNormalCollectorConfigToTerraform(struct?: DeviceGroupExtraServicesAPPLICATIONGATEWAYNormalCollectorConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    collectors: cdktf.listMapper(deviceGroupExtraServicesAPPLICATIONGATEWAYNormalCollectorConfigCollectorsToTerraform, false)(struct!.collectors),
    enabled: cdktf.booleanToTerraform(struct!.enabled),
  }
}


export function deviceGroupExtraServicesAPPLICATIONGATEWAYNormalCollectorConfigToHclTerraform(struct?: DeviceGroupExtraServicesAPPLICATIONGATEWAYNormalCollectorConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    collectors: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesAPPLICATIONGATEWAYNormalCollectorConfigCollectorsToHclTerraform, false)(struct!.collectors),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesAPPLICATIONGATEWAYNormalCollectorConfigCollectorsList",
    },
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesAPPLICATIONGATEWAYNormalCollectorConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesAPPLICATIONGATEWAYNormalCollectorConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._collectors?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectors = this._collectors?.internalValue;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesAPPLICATIONGATEWAYNormalCollectorConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._collectors.internalValue = undefined;
      this._enabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._collectors.internalValue = value.collectors;
      this._enabled = value.enabled;
    }
  }

  // collectors - computed: false, optional: true, required: false
  private _collectors = new DeviceGroupExtraServicesAPPLICATIONGATEWAYNormalCollectorConfigCollectorsList(this, "collectors", false);
  public get collectors() {
    return this._collectors;
  }
  public putCollectors(value: DeviceGroupExtraServicesAPPLICATIONGATEWAYNormalCollectorConfigCollectors[] | cdktf.IResolvable) {
    this._collectors.internalValue = value;
  }
  public resetCollectors() {
    this._collectors.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorsInput() {
    return this._collectors.internalValue;
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }
}

export class DeviceGroupExtraServicesAPPLICATIONGATEWAYNormalCollectorConfigList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesAPPLICATIONGATEWAYNormalCollectorConfig[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesAPPLICATIONGATEWAYNormalCollectorConfigOutputReference {
    return new DeviceGroupExtraServicesAPPLICATIONGATEWAYNormalCollectorConfigOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesAPPLICATIONGATEWAY {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#custom_n_s_p_schedule DeviceGroup#custom_n_s_p_schedule}
  */
  readonly customNSPSchedule?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#dead_operation DeviceGroup#dead_operation}
  */
  readonly deadOperation?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#device_display_name_template DeviceGroup#device_display_name_template}
  */
  readonly deviceDisplayNameTemplate?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#disable_stop_terminate_host_monitor DeviceGroup#disable_stop_terminate_host_monitor}
  */
  readonly disableStopTerminateHostMonitor?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#disable_terminated_host_alerting DeviceGroup#disable_terminated_host_alerting}
  */
  readonly disableTerminatedHostAlerting?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#monitoring_region_infos DeviceGroup#monitoring_region_infos}
  */
  readonly monitoringRegionInfos?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#monitoring_regions DeviceGroup#monitoring_regions}
  */
  readonly monitoringRegions?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#name_filter DeviceGroup#name_filter}
  */
  readonly nameFilter?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#select_all DeviceGroup#select_all}
  */
  readonly selectAll?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#tags DeviceGroup#tags}
  */
  readonly tags?: DeviceGroupExtraServicesAPPLICATIONGATEWAYTags[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#use_default DeviceGroup#use_default}
  */
  readonly useDefault: boolean | cdktf.IResolvable;
  /**
  * normal_collector_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#normal_collector_config DeviceGroup#normal_collector_config}
  */
  readonly normalCollectorConfig?: DeviceGroupExtraServicesAPPLICATIONGATEWAYNormalCollectorConfig[] | cdktf.IResolvable;
}

export function deviceGroupExtraServicesAPPLICATIONGATEWAYToTerraform(struct?: DeviceGroupExtraServicesAPPLICATIONGATEWAY | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    custom_n_s_p_schedule: cdktf.stringToTerraform(struct!.customNSPSchedule),
    dead_operation: cdktf.stringToTerraform(struct!.deadOperation),
    device_display_name_template: cdktf.stringToTerraform(struct!.deviceDisplayNameTemplate),
    disable_stop_terminate_host_monitor: cdktf.booleanToTerraform(struct!.disableStopTerminateHostMonitor),
    disable_terminated_host_alerting: cdktf.booleanToTerraform(struct!.disableTerminatedHostAlerting),
    monitoring_region_infos: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.monitoringRegionInfos),
    monitoring_regions: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.monitoringRegions),
    name_filter: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.nameFilter),
    select_all: cdktf.booleanToTerraform(struct!.selectAll),
    tags: cdktf.listMapper(deviceGroupExtraServicesAPPLICATIONGATEWAYTagsToTerraform, false)(struct!.tags),
    use_default: cdktf.booleanToTerraform(struct!.useDefault),
    normal_collector_config: cdktf.listMapper(deviceGroupExtraServicesAPPLICATIONGATEWAYNormalCollectorConfigToTerraform, true)(struct!.normalCollectorConfig),
  }
}


export function deviceGroupExtraServicesAPPLICATIONGATEWAYToHclTerraform(struct?: DeviceGroupExtraServicesAPPLICATIONGATEWAY | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    custom_n_s_p_schedule: {
      value: cdktf.stringToHclTerraform(struct!.customNSPSchedule),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dead_operation: {
      value: cdktf.stringToHclTerraform(struct!.deadOperation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    device_display_name_template: {
      value: cdktf.stringToHclTerraform(struct!.deviceDisplayNameTemplate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disable_stop_terminate_host_monitor: {
      value: cdktf.booleanToHclTerraform(struct!.disableStopTerminateHostMonitor),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    disable_terminated_host_alerting: {
      value: cdktf.booleanToHclTerraform(struct!.disableTerminatedHostAlerting),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    monitoring_region_infos: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.monitoringRegionInfos),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    monitoring_regions: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.monitoringRegions),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    name_filter: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.nameFilter),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    select_all: {
      value: cdktf.booleanToHclTerraform(struct!.selectAll),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tags: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesAPPLICATIONGATEWAYTagsToHclTerraform, false)(struct!.tags),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesAPPLICATIONGATEWAYTagsList",
    },
    use_default: {
      value: cdktf.booleanToHclTerraform(struct!.useDefault),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    normal_collector_config: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesAPPLICATIONGATEWAYNormalCollectorConfigToHclTerraform, true)(struct!.normalCollectorConfig),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesAPPLICATIONGATEWAYNormalCollectorConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesAPPLICATIONGATEWAYOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesAPPLICATIONGATEWAY | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._customNSPSchedule !== undefined) {
      hasAnyValues = true;
      internalValueResult.customNSPSchedule = this._customNSPSchedule;
    }
    if (this._deadOperation !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadOperation = this._deadOperation;
    }
    if (this._deviceDisplayNameTemplate !== undefined) {
      hasAnyValues = true;
      internalValueResult.deviceDisplayNameTemplate = this._deviceDisplayNameTemplate;
    }
    if (this._disableStopTerminateHostMonitor !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableStopTerminateHostMonitor = this._disableStopTerminateHostMonitor;
    }
    if (this._disableTerminatedHostAlerting !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableTerminatedHostAlerting = this._disableTerminatedHostAlerting;
    }
    if (this._monitoringRegionInfos !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoringRegionInfos = this._monitoringRegionInfos;
    }
    if (this._monitoringRegions !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoringRegions = this._monitoringRegions;
    }
    if (this._nameFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.nameFilter = this._nameFilter;
    }
    if (this._selectAll !== undefined) {
      hasAnyValues = true;
      internalValueResult.selectAll = this._selectAll;
    }
    if (this._tags?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags?.internalValue;
    }
    if (this._useDefault !== undefined) {
      hasAnyValues = true;
      internalValueResult.useDefault = this._useDefault;
    }
    if (this._normalCollectorConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.normalCollectorConfig = this._normalCollectorConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesAPPLICATIONGATEWAY | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._customNSPSchedule = undefined;
      this._deadOperation = undefined;
      this._deviceDisplayNameTemplate = undefined;
      this._disableStopTerminateHostMonitor = undefined;
      this._disableTerminatedHostAlerting = undefined;
      this._monitoringRegionInfos = undefined;
      this._monitoringRegions = undefined;
      this._nameFilter = undefined;
      this._selectAll = undefined;
      this._tags.internalValue = undefined;
      this._useDefault = undefined;
      this._normalCollectorConfig.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._customNSPSchedule = value.customNSPSchedule;
      this._deadOperation = value.deadOperation;
      this._deviceDisplayNameTemplate = value.deviceDisplayNameTemplate;
      this._disableStopTerminateHostMonitor = value.disableStopTerminateHostMonitor;
      this._disableTerminatedHostAlerting = value.disableTerminatedHostAlerting;
      this._monitoringRegionInfos = value.monitoringRegionInfos;
      this._monitoringRegions = value.monitoringRegions;
      this._nameFilter = value.nameFilter;
      this._selectAll = value.selectAll;
      this._tags.internalValue = value.tags;
      this._useDefault = value.useDefault;
      this._normalCollectorConfig.internalValue = value.normalCollectorConfig;
    }
  }

  // custom_n_s_p_schedule - computed: false, optional: true, required: false
  private _customNSPSchedule?: string; 
  public get customNSPSchedule() {
    return this.getStringAttribute('custom_n_s_p_schedule');
  }
  public set customNSPSchedule(value: string) {
    this._customNSPSchedule = value;
  }
  public resetCustomNSPSchedule() {
    this._customNSPSchedule = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customNSPScheduleInput() {
    return this._customNSPSchedule;
  }

  // dead_operation - computed: false, optional: true, required: false
  private _deadOperation?: string; 
  public get deadOperation() {
    return this.getStringAttribute('dead_operation');
  }
  public set deadOperation(value: string) {
    this._deadOperation = value;
  }
  public resetDeadOperation() {
    this._deadOperation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadOperationInput() {
    return this._deadOperation;
  }

  // device_display_name_template - computed: false, optional: true, required: false
  private _deviceDisplayNameTemplate?: string; 
  public get deviceDisplayNameTemplate() {
    return this.getStringAttribute('device_display_name_template');
  }
  public set deviceDisplayNameTemplate(value: string) {
    this._deviceDisplayNameTemplate = value;
  }
  public resetDeviceDisplayNameTemplate() {
    this._deviceDisplayNameTemplate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deviceDisplayNameTemplateInput() {
    return this._deviceDisplayNameTemplate;
  }

  // disable_stop_terminate_host_monitor - computed: false, optional: true, required: false
  private _disableStopTerminateHostMonitor?: boolean | cdktf.IResolvable; 
  public get disableStopTerminateHostMonitor() {
    return this.getBooleanAttribute('disable_stop_terminate_host_monitor');
  }
  public set disableStopTerminateHostMonitor(value: boolean | cdktf.IResolvable) {
    this._disableStopTerminateHostMonitor = value;
  }
  public resetDisableStopTerminateHostMonitor() {
    this._disableStopTerminateHostMonitor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableStopTerminateHostMonitorInput() {
    return this._disableStopTerminateHostMonitor;
  }

  // disable_terminated_host_alerting - computed: false, optional: true, required: false
  private _disableTerminatedHostAlerting?: boolean | cdktf.IResolvable; 
  public get disableTerminatedHostAlerting() {
    return this.getBooleanAttribute('disable_terminated_host_alerting');
  }
  public set disableTerminatedHostAlerting(value: boolean | cdktf.IResolvable) {
    this._disableTerminatedHostAlerting = value;
  }
  public resetDisableTerminatedHostAlerting() {
    this._disableTerminatedHostAlerting = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableTerminatedHostAlertingInput() {
    return this._disableTerminatedHostAlerting;
  }

  // monitoring_region_infos - computed: false, optional: true, required: false
  private _monitoringRegionInfos?: string[]; 
  public get monitoringRegionInfos() {
    return cdktf.Fn.tolist(this.getListAttribute('monitoring_region_infos'));
  }
  public set monitoringRegionInfos(value: string[]) {
    this._monitoringRegionInfos = value;
  }
  public resetMonitoringRegionInfos() {
    this._monitoringRegionInfos = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoringRegionInfosInput() {
    return this._monitoringRegionInfos;
  }

  // monitoring_regions - computed: false, optional: true, required: false
  private _monitoringRegions?: string[]; 
  public get monitoringRegions() {
    return cdktf.Fn.tolist(this.getListAttribute('monitoring_regions'));
  }
  public set monitoringRegions(value: string[]) {
    this._monitoringRegions = value;
  }
  public resetMonitoringRegions() {
    this._monitoringRegions = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoringRegionsInput() {
    return this._monitoringRegions;
  }

  // name_filter - computed: false, optional: true, required: false
  private _nameFilter?: string[]; 
  public get nameFilter() {
    return cdktf.Fn.tolist(this.getListAttribute('name_filter'));
  }
  public set nameFilter(value: string[]) {
    this._nameFilter = value;
  }
  public resetNameFilter() {
    this._nameFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameFilterInput() {
    return this._nameFilter;
  }

  // select_all - computed: false, optional: true, required: false
  private _selectAll?: boolean | cdktf.IResolvable; 
  public get selectAll() {
    return this.getBooleanAttribute('select_all');
  }
  public set selectAll(value: boolean | cdktf.IResolvable) {
    this._selectAll = value;
  }
  public resetSelectAll() {
    this._selectAll = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectAllInput() {
    return this._selectAll;
  }

  // tags - computed: false, optional: true, required: false
  private _tags = new DeviceGroupExtraServicesAPPLICATIONGATEWAYTagsList(this, "tags", false);
  public get tags() {
    return this._tags;
  }
  public putTags(value: DeviceGroupExtraServicesAPPLICATIONGATEWAYTags[] | cdktf.IResolvable) {
    this._tags.internalValue = value;
  }
  public resetTags() {
    this._tags.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags.internalValue;
  }

  // use_default - computed: false, optional: false, required: true
  private _useDefault?: boolean | cdktf.IResolvable; 
  public get useDefault() {
    return this.getBooleanAttribute('use_default');
  }
  public set useDefault(value: boolean | cdktf.IResolvable) {
    this._useDefault = value;
  }
  // Temporarily expose input value. Use with caution.
  public get useDefaultInput() {
    return this._useDefault;
  }

  // normal_collector_config - computed: false, optional: true, required: false
  private _normalCollectorConfig = new DeviceGroupExtraServicesAPPLICATIONGATEWAYNormalCollectorConfigList(this, "normal_collector_config", false);
  public get normalCollectorConfig() {
    return this._normalCollectorConfig;
  }
  public putNormalCollectorConfig(value: DeviceGroupExtraServicesAPPLICATIONGATEWAYNormalCollectorConfig[] | cdktf.IResolvable) {
    this._normalCollectorConfig.internalValue = value;
  }
  public resetNormalCollectorConfig() {
    this._normalCollectorConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get normalCollectorConfigInput() {
    return this._normalCollectorConfig.internalValue;
  }
}

export class DeviceGroupExtraServicesAPPLICATIONGATEWAYList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesAPPLICATIONGATEWAY[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesAPPLICATIONGATEWAYOutputReference {
    return new DeviceGroupExtraServicesAPPLICATIONGATEWAYOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesAPPLICATIONINSIGHTSTags {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#name DeviceGroup#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#operation DeviceGroup#operation}
  */
  readonly operation?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#value DeviceGroup#value}
  */
  readonly value?: string;
}

export function deviceGroupExtraServicesAPPLICATIONINSIGHTSTagsToTerraform(struct?: DeviceGroupExtraServicesAPPLICATIONINSIGHTSTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    operation: cdktf.stringToTerraform(struct!.operation),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function deviceGroupExtraServicesAPPLICATIONINSIGHTSTagsToHclTerraform(struct?: DeviceGroupExtraServicesAPPLICATIONINSIGHTSTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operation: {
      value: cdktf.stringToHclTerraform(struct!.operation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesAPPLICATIONINSIGHTSTagsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesAPPLICATIONINSIGHTSTags | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._operation !== undefined) {
      hasAnyValues = true;
      internalValueResult.operation = this._operation;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesAPPLICATIONINSIGHTSTags | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._operation = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._operation = value.operation;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // operation - computed: false, optional: true, required: false
  private _operation?: string; 
  public get operation() {
    return this.getStringAttribute('operation');
  }
  public set operation(value: string) {
    this._operation = value;
  }
  public resetOperation() {
    this._operation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operationInput() {
    return this._operation;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DeviceGroupExtraServicesAPPLICATIONINSIGHTSTagsList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesAPPLICATIONINSIGHTSTags[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesAPPLICATIONINSIGHTSTagsOutputReference {
    return new DeviceGroupExtraServicesAPPLICATIONINSIGHTSTagsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesAPPLICATIONINSIGHTSNormalCollectorConfigCollectors {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#applies_to DeviceGroup#applies_to}
  */
  readonly appliesTo?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#auto_balanced_collector_group_id DeviceGroup#auto_balanced_collector_group_id}
  */
  readonly autoBalancedCollectorGroupId?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#collector_id DeviceGroup#collector_id}
  */
  readonly collectorId?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#priority DeviceGroup#priority}
  */
  readonly priority?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#use_public_ip DeviceGroup#use_public_ip}
  */
  readonly usePublicIp?: boolean | cdktf.IResolvable;
}

export function deviceGroupExtraServicesAPPLICATIONINSIGHTSNormalCollectorConfigCollectorsToTerraform(struct?: DeviceGroupExtraServicesAPPLICATIONINSIGHTSNormalCollectorConfigCollectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    applies_to: cdktf.stringToTerraform(struct!.appliesTo),
    auto_balanced_collector_group_id: cdktf.numberToTerraform(struct!.autoBalancedCollectorGroupId),
    collector_id: cdktf.numberToTerraform(struct!.collectorId),
    priority: cdktf.numberToTerraform(struct!.priority),
    use_public_ip: cdktf.booleanToTerraform(struct!.usePublicIp),
  }
}


export function deviceGroupExtraServicesAPPLICATIONINSIGHTSNormalCollectorConfigCollectorsToHclTerraform(struct?: DeviceGroupExtraServicesAPPLICATIONINSIGHTSNormalCollectorConfigCollectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    applies_to: {
      value: cdktf.stringToHclTerraform(struct!.appliesTo),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auto_balanced_collector_group_id: {
      value: cdktf.numberToHclTerraform(struct!.autoBalancedCollectorGroupId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    collector_id: {
      value: cdktf.numberToHclTerraform(struct!.collectorId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    priority: {
      value: cdktf.numberToHclTerraform(struct!.priority),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    use_public_ip: {
      value: cdktf.booleanToHclTerraform(struct!.usePublicIp),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesAPPLICATIONINSIGHTSNormalCollectorConfigCollectorsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesAPPLICATIONINSIGHTSNormalCollectorConfigCollectors | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._appliesTo !== undefined) {
      hasAnyValues = true;
      internalValueResult.appliesTo = this._appliesTo;
    }
    if (this._autoBalancedCollectorGroupId !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoBalancedCollectorGroupId = this._autoBalancedCollectorGroupId;
    }
    if (this._collectorId !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectorId = this._collectorId;
    }
    if (this._priority !== undefined) {
      hasAnyValues = true;
      internalValueResult.priority = this._priority;
    }
    if (this._usePublicIp !== undefined) {
      hasAnyValues = true;
      internalValueResult.usePublicIp = this._usePublicIp;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesAPPLICATIONINSIGHTSNormalCollectorConfigCollectors | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._appliesTo = undefined;
      this._autoBalancedCollectorGroupId = undefined;
      this._collectorId = undefined;
      this._priority = undefined;
      this._usePublicIp = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._appliesTo = value.appliesTo;
      this._autoBalancedCollectorGroupId = value.autoBalancedCollectorGroupId;
      this._collectorId = value.collectorId;
      this._priority = value.priority;
      this._usePublicIp = value.usePublicIp;
    }
  }

  // applies_to - computed: false, optional: true, required: false
  private _appliesTo?: string; 
  public get appliesTo() {
    return this.getStringAttribute('applies_to');
  }
  public set appliesTo(value: string) {
    this._appliesTo = value;
  }
  public resetAppliesTo() {
    this._appliesTo = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appliesToInput() {
    return this._appliesTo;
  }

  // auto_balanced_collector_group_id - computed: false, optional: true, required: false
  private _autoBalancedCollectorGroupId?: number; 
  public get autoBalancedCollectorGroupId() {
    return this.getNumberAttribute('auto_balanced_collector_group_id');
  }
  public set autoBalancedCollectorGroupId(value: number) {
    this._autoBalancedCollectorGroupId = value;
  }
  public resetAutoBalancedCollectorGroupId() {
    this._autoBalancedCollectorGroupId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoBalancedCollectorGroupIdInput() {
    return this._autoBalancedCollectorGroupId;
  }

  // collector_id - computed: false, optional: true, required: false
  private _collectorId?: number; 
  public get collectorId() {
    return this.getNumberAttribute('collector_id');
  }
  public set collectorId(value: number) {
    this._collectorId = value;
  }
  public resetCollectorId() {
    this._collectorId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorIdInput() {
    return this._collectorId;
  }

  // priority - computed: false, optional: true, required: false
  private _priority?: number; 
  public get priority() {
    return this.getNumberAttribute('priority');
  }
  public set priority(value: number) {
    this._priority = value;
  }
  public resetPriority() {
    this._priority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get priorityInput() {
    return this._priority;
  }

  // use_public_ip - computed: false, optional: true, required: false
  private _usePublicIp?: boolean | cdktf.IResolvable; 
  public get usePublicIp() {
    return this.getBooleanAttribute('use_public_ip');
  }
  public set usePublicIp(value: boolean | cdktf.IResolvable) {
    this._usePublicIp = value;
  }
  public resetUsePublicIp() {
    this._usePublicIp = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usePublicIpInput() {
    return this._usePublicIp;
  }
}

export class DeviceGroupExtraServicesAPPLICATIONINSIGHTSNormalCollectorConfigCollectorsList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesAPPLICATIONINSIGHTSNormalCollectorConfigCollectors[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesAPPLICATIONINSIGHTSNormalCollectorConfigCollectorsOutputReference {
    return new DeviceGroupExtraServicesAPPLICATIONINSIGHTSNormalCollectorConfigCollectorsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesAPPLICATIONINSIGHTSNormalCollectorConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#collectors DeviceGroup#collectors}
  */
  readonly collectors?: DeviceGroupExtraServicesAPPLICATIONINSIGHTSNormalCollectorConfigCollectors[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#enabled DeviceGroup#enabled}
  */
  readonly enabled: boolean | cdktf.IResolvable;
}

export function deviceGroupExtraServicesAPPLICATIONINSIGHTSNormalCollectorConfigToTerraform(struct?: DeviceGroupExtraServicesAPPLICATIONINSIGHTSNormalCollectorConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    collectors: cdktf.listMapper(deviceGroupExtraServicesAPPLICATIONINSIGHTSNormalCollectorConfigCollectorsToTerraform, false)(struct!.collectors),
    enabled: cdktf.booleanToTerraform(struct!.enabled),
  }
}


export function deviceGroupExtraServicesAPPLICATIONINSIGHTSNormalCollectorConfigToHclTerraform(struct?: DeviceGroupExtraServicesAPPLICATIONINSIGHTSNormalCollectorConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    collectors: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesAPPLICATIONINSIGHTSNormalCollectorConfigCollectorsToHclTerraform, false)(struct!.collectors),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesAPPLICATIONINSIGHTSNormalCollectorConfigCollectorsList",
    },
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesAPPLICATIONINSIGHTSNormalCollectorConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesAPPLICATIONINSIGHTSNormalCollectorConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._collectors?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectors = this._collectors?.internalValue;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesAPPLICATIONINSIGHTSNormalCollectorConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._collectors.internalValue = undefined;
      this._enabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._collectors.internalValue = value.collectors;
      this._enabled = value.enabled;
    }
  }

  // collectors - computed: false, optional: true, required: false
  private _collectors = new DeviceGroupExtraServicesAPPLICATIONINSIGHTSNormalCollectorConfigCollectorsList(this, "collectors", false);
  public get collectors() {
    return this._collectors;
  }
  public putCollectors(value: DeviceGroupExtraServicesAPPLICATIONINSIGHTSNormalCollectorConfigCollectors[] | cdktf.IResolvable) {
    this._collectors.internalValue = value;
  }
  public resetCollectors() {
    this._collectors.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorsInput() {
    return this._collectors.internalValue;
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }
}

export class DeviceGroupExtraServicesAPPLICATIONINSIGHTSNormalCollectorConfigList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesAPPLICATIONINSIGHTSNormalCollectorConfig[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesAPPLICATIONINSIGHTSNormalCollectorConfigOutputReference {
    return new DeviceGroupExtraServicesAPPLICATIONINSIGHTSNormalCollectorConfigOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesAPPLICATIONINSIGHTS {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#custom_n_s_p_schedule DeviceGroup#custom_n_s_p_schedule}
  */
  readonly customNSPSchedule?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#dead_operation DeviceGroup#dead_operation}
  */
  readonly deadOperation?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#device_display_name_template DeviceGroup#device_display_name_template}
  */
  readonly deviceDisplayNameTemplate?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#disable_stop_terminate_host_monitor DeviceGroup#disable_stop_terminate_host_monitor}
  */
  readonly disableStopTerminateHostMonitor?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#disable_terminated_host_alerting DeviceGroup#disable_terminated_host_alerting}
  */
  readonly disableTerminatedHostAlerting?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#monitoring_region_infos DeviceGroup#monitoring_region_infos}
  */
  readonly monitoringRegionInfos?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#monitoring_regions DeviceGroup#monitoring_regions}
  */
  readonly monitoringRegions?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#name_filter DeviceGroup#name_filter}
  */
  readonly nameFilter?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#select_all DeviceGroup#select_all}
  */
  readonly selectAll?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#tags DeviceGroup#tags}
  */
  readonly tags?: DeviceGroupExtraServicesAPPLICATIONINSIGHTSTags[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#use_default DeviceGroup#use_default}
  */
  readonly useDefault: boolean | cdktf.IResolvable;
  /**
  * normal_collector_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#normal_collector_config DeviceGroup#normal_collector_config}
  */
  readonly normalCollectorConfig?: DeviceGroupExtraServicesAPPLICATIONINSIGHTSNormalCollectorConfig[] | cdktf.IResolvable;
}

export function deviceGroupExtraServicesAPPLICATIONINSIGHTSToTerraform(struct?: DeviceGroupExtraServicesAPPLICATIONINSIGHTS | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    custom_n_s_p_schedule: cdktf.stringToTerraform(struct!.customNSPSchedule),
    dead_operation: cdktf.stringToTerraform(struct!.deadOperation),
    device_display_name_template: cdktf.stringToTerraform(struct!.deviceDisplayNameTemplate),
    disable_stop_terminate_host_monitor: cdktf.booleanToTerraform(struct!.disableStopTerminateHostMonitor),
    disable_terminated_host_alerting: cdktf.booleanToTerraform(struct!.disableTerminatedHostAlerting),
    monitoring_region_infos: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.monitoringRegionInfos),
    monitoring_regions: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.monitoringRegions),
    name_filter: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.nameFilter),
    select_all: cdktf.booleanToTerraform(struct!.selectAll),
    tags: cdktf.listMapper(deviceGroupExtraServicesAPPLICATIONINSIGHTSTagsToTerraform, false)(struct!.tags),
    use_default: cdktf.booleanToTerraform(struct!.useDefault),
    normal_collector_config: cdktf.listMapper(deviceGroupExtraServicesAPPLICATIONINSIGHTSNormalCollectorConfigToTerraform, true)(struct!.normalCollectorConfig),
  }
}


export function deviceGroupExtraServicesAPPLICATIONINSIGHTSToHclTerraform(struct?: DeviceGroupExtraServicesAPPLICATIONINSIGHTS | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    custom_n_s_p_schedule: {
      value: cdktf.stringToHclTerraform(struct!.customNSPSchedule),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dead_operation: {
      value: cdktf.stringToHclTerraform(struct!.deadOperation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    device_display_name_template: {
      value: cdktf.stringToHclTerraform(struct!.deviceDisplayNameTemplate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disable_stop_terminate_host_monitor: {
      value: cdktf.booleanToHclTerraform(struct!.disableStopTerminateHostMonitor),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    disable_terminated_host_alerting: {
      value: cdktf.booleanToHclTerraform(struct!.disableTerminatedHostAlerting),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    monitoring_region_infos: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.monitoringRegionInfos),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    monitoring_regions: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.monitoringRegions),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    name_filter: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.nameFilter),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    select_all: {
      value: cdktf.booleanToHclTerraform(struct!.selectAll),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tags: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesAPPLICATIONINSIGHTSTagsToHclTerraform, false)(struct!.tags),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesAPPLICATIONINSIGHTSTagsList",
    },
    use_default: {
      value: cdktf.booleanToHclTerraform(struct!.useDefault),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    normal_collector_config: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesAPPLICATIONINSIGHTSNormalCollectorConfigToHclTerraform, true)(struct!.normalCollectorConfig),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesAPPLICATIONINSIGHTSNormalCollectorConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesAPPLICATIONINSIGHTSOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesAPPLICATIONINSIGHTS | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._customNSPSchedule !== undefined) {
      hasAnyValues = true;
      internalValueResult.customNSPSchedule = this._customNSPSchedule;
    }
    if (this._deadOperation !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadOperation = this._deadOperation;
    }
    if (this._deviceDisplayNameTemplate !== undefined) {
      hasAnyValues = true;
      internalValueResult.deviceDisplayNameTemplate = this._deviceDisplayNameTemplate;
    }
    if (this._disableStopTerminateHostMonitor !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableStopTerminateHostMonitor = this._disableStopTerminateHostMonitor;
    }
    if (this._disableTerminatedHostAlerting !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableTerminatedHostAlerting = this._disableTerminatedHostAlerting;
    }
    if (this._monitoringRegionInfos !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoringRegionInfos = this._monitoringRegionInfos;
    }
    if (this._monitoringRegions !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoringRegions = this._monitoringRegions;
    }
    if (this._nameFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.nameFilter = this._nameFilter;
    }
    if (this._selectAll !== undefined) {
      hasAnyValues = true;
      internalValueResult.selectAll = this._selectAll;
    }
    if (this._tags?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags?.internalValue;
    }
    if (this._useDefault !== undefined) {
      hasAnyValues = true;
      internalValueResult.useDefault = this._useDefault;
    }
    if (this._normalCollectorConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.normalCollectorConfig = this._normalCollectorConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesAPPLICATIONINSIGHTS | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._customNSPSchedule = undefined;
      this._deadOperation = undefined;
      this._deviceDisplayNameTemplate = undefined;
      this._disableStopTerminateHostMonitor = undefined;
      this._disableTerminatedHostAlerting = undefined;
      this._monitoringRegionInfos = undefined;
      this._monitoringRegions = undefined;
      this._nameFilter = undefined;
      this._selectAll = undefined;
      this._tags.internalValue = undefined;
      this._useDefault = undefined;
      this._normalCollectorConfig.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._customNSPSchedule = value.customNSPSchedule;
      this._deadOperation = value.deadOperation;
      this._deviceDisplayNameTemplate = value.deviceDisplayNameTemplate;
      this._disableStopTerminateHostMonitor = value.disableStopTerminateHostMonitor;
      this._disableTerminatedHostAlerting = value.disableTerminatedHostAlerting;
      this._monitoringRegionInfos = value.monitoringRegionInfos;
      this._monitoringRegions = value.monitoringRegions;
      this._nameFilter = value.nameFilter;
      this._selectAll = value.selectAll;
      this._tags.internalValue = value.tags;
      this._useDefault = value.useDefault;
      this._normalCollectorConfig.internalValue = value.normalCollectorConfig;
    }
  }

  // custom_n_s_p_schedule - computed: false, optional: true, required: false
  private _customNSPSchedule?: string; 
  public get customNSPSchedule() {
    return this.getStringAttribute('custom_n_s_p_schedule');
  }
  public set customNSPSchedule(value: string) {
    this._customNSPSchedule = value;
  }
  public resetCustomNSPSchedule() {
    this._customNSPSchedule = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customNSPScheduleInput() {
    return this._customNSPSchedule;
  }

  // dead_operation - computed: false, optional: true, required: false
  private _deadOperation?: string; 
  public get deadOperation() {
    return this.getStringAttribute('dead_operation');
  }
  public set deadOperation(value: string) {
    this._deadOperation = value;
  }
  public resetDeadOperation() {
    this._deadOperation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadOperationInput() {
    return this._deadOperation;
  }

  // device_display_name_template - computed: false, optional: true, required: false
  private _deviceDisplayNameTemplate?: string; 
  public get deviceDisplayNameTemplate() {
    return this.getStringAttribute('device_display_name_template');
  }
  public set deviceDisplayNameTemplate(value: string) {
    this._deviceDisplayNameTemplate = value;
  }
  public resetDeviceDisplayNameTemplate() {
    this._deviceDisplayNameTemplate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deviceDisplayNameTemplateInput() {
    return this._deviceDisplayNameTemplate;
  }

  // disable_stop_terminate_host_monitor - computed: false, optional: true, required: false
  private _disableStopTerminateHostMonitor?: boolean | cdktf.IResolvable; 
  public get disableStopTerminateHostMonitor() {
    return this.getBooleanAttribute('disable_stop_terminate_host_monitor');
  }
  public set disableStopTerminateHostMonitor(value: boolean | cdktf.IResolvable) {
    this._disableStopTerminateHostMonitor = value;
  }
  public resetDisableStopTerminateHostMonitor() {
    this._disableStopTerminateHostMonitor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableStopTerminateHostMonitorInput() {
    return this._disableStopTerminateHostMonitor;
  }

  // disable_terminated_host_alerting - computed: false, optional: true, required: false
  private _disableTerminatedHostAlerting?: boolean | cdktf.IResolvable; 
  public get disableTerminatedHostAlerting() {
    return this.getBooleanAttribute('disable_terminated_host_alerting');
  }
  public set disableTerminatedHostAlerting(value: boolean | cdktf.IResolvable) {
    this._disableTerminatedHostAlerting = value;
  }
  public resetDisableTerminatedHostAlerting() {
    this._disableTerminatedHostAlerting = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableTerminatedHostAlertingInput() {
    return this._disableTerminatedHostAlerting;
  }

  // monitoring_region_infos - computed: false, optional: true, required: false
  private _monitoringRegionInfos?: string[]; 
  public get monitoringRegionInfos() {
    return cdktf.Fn.tolist(this.getListAttribute('monitoring_region_infos'));
  }
  public set monitoringRegionInfos(value: string[]) {
    this._monitoringRegionInfos = value;
  }
  public resetMonitoringRegionInfos() {
    this._monitoringRegionInfos = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoringRegionInfosInput() {
    return this._monitoringRegionInfos;
  }

  // monitoring_regions - computed: false, optional: true, required: false
  private _monitoringRegions?: string[]; 
  public get monitoringRegions() {
    return cdktf.Fn.tolist(this.getListAttribute('monitoring_regions'));
  }
  public set monitoringRegions(value: string[]) {
    this._monitoringRegions = value;
  }
  public resetMonitoringRegions() {
    this._monitoringRegions = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoringRegionsInput() {
    return this._monitoringRegions;
  }

  // name_filter - computed: false, optional: true, required: false
  private _nameFilter?: string[]; 
  public get nameFilter() {
    return cdktf.Fn.tolist(this.getListAttribute('name_filter'));
  }
  public set nameFilter(value: string[]) {
    this._nameFilter = value;
  }
  public resetNameFilter() {
    this._nameFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameFilterInput() {
    return this._nameFilter;
  }

  // select_all - computed: false, optional: true, required: false
  private _selectAll?: boolean | cdktf.IResolvable; 
  public get selectAll() {
    return this.getBooleanAttribute('select_all');
  }
  public set selectAll(value: boolean | cdktf.IResolvable) {
    this._selectAll = value;
  }
  public resetSelectAll() {
    this._selectAll = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectAllInput() {
    return this._selectAll;
  }

  // tags - computed: false, optional: true, required: false
  private _tags = new DeviceGroupExtraServicesAPPLICATIONINSIGHTSTagsList(this, "tags", false);
  public get tags() {
    return this._tags;
  }
  public putTags(value: DeviceGroupExtraServicesAPPLICATIONINSIGHTSTags[] | cdktf.IResolvable) {
    this._tags.internalValue = value;
  }
  public resetTags() {
    this._tags.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags.internalValue;
  }

  // use_default - computed: false, optional: false, required: true
  private _useDefault?: boolean | cdktf.IResolvable; 
  public get useDefault() {
    return this.getBooleanAttribute('use_default');
  }
  public set useDefault(value: boolean | cdktf.IResolvable) {
    this._useDefault = value;
  }
  // Temporarily expose input value. Use with caution.
  public get useDefaultInput() {
    return this._useDefault;
  }

  // normal_collector_config - computed: false, optional: true, required: false
  private _normalCollectorConfig = new DeviceGroupExtraServicesAPPLICATIONINSIGHTSNormalCollectorConfigList(this, "normal_collector_config", false);
  public get normalCollectorConfig() {
    return this._normalCollectorConfig;
  }
  public putNormalCollectorConfig(value: DeviceGroupExtraServicesAPPLICATIONINSIGHTSNormalCollectorConfig[] | cdktf.IResolvable) {
    this._normalCollectorConfig.internalValue = value;
  }
  public resetNormalCollectorConfig() {
    this._normalCollectorConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get normalCollectorConfigInput() {
    return this._normalCollectorConfig.internalValue;
  }
}

export class DeviceGroupExtraServicesAPPLICATIONINSIGHTSList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesAPPLICATIONINSIGHTS[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesAPPLICATIONINSIGHTSOutputReference {
    return new DeviceGroupExtraServicesAPPLICATIONINSIGHTSOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesAPPSERVICETags {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#name DeviceGroup#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#operation DeviceGroup#operation}
  */
  readonly operation?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#value DeviceGroup#value}
  */
  readonly value?: string;
}

export function deviceGroupExtraServicesAPPSERVICETagsToTerraform(struct?: DeviceGroupExtraServicesAPPSERVICETags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    operation: cdktf.stringToTerraform(struct!.operation),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function deviceGroupExtraServicesAPPSERVICETagsToHclTerraform(struct?: DeviceGroupExtraServicesAPPSERVICETags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operation: {
      value: cdktf.stringToHclTerraform(struct!.operation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesAPPSERVICETagsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesAPPSERVICETags | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._operation !== undefined) {
      hasAnyValues = true;
      internalValueResult.operation = this._operation;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesAPPSERVICETags | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._operation = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._operation = value.operation;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // operation - computed: false, optional: true, required: false
  private _operation?: string; 
  public get operation() {
    return this.getStringAttribute('operation');
  }
  public set operation(value: string) {
    this._operation = value;
  }
  public resetOperation() {
    this._operation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operationInput() {
    return this._operation;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DeviceGroupExtraServicesAPPSERVICETagsList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesAPPSERVICETags[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesAPPSERVICETagsOutputReference {
    return new DeviceGroupExtraServicesAPPSERVICETagsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesAPPSERVICENormalCollectorConfigCollectors {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#applies_to DeviceGroup#applies_to}
  */
  readonly appliesTo?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#auto_balanced_collector_group_id DeviceGroup#auto_balanced_collector_group_id}
  */
  readonly autoBalancedCollectorGroupId?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#collector_id DeviceGroup#collector_id}
  */
  readonly collectorId?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#priority DeviceGroup#priority}
  */
  readonly priority?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#use_public_ip DeviceGroup#use_public_ip}
  */
  readonly usePublicIp?: boolean | cdktf.IResolvable;
}

export function deviceGroupExtraServicesAPPSERVICENormalCollectorConfigCollectorsToTerraform(struct?: DeviceGroupExtraServicesAPPSERVICENormalCollectorConfigCollectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    applies_to: cdktf.stringToTerraform(struct!.appliesTo),
    auto_balanced_collector_group_id: cdktf.numberToTerraform(struct!.autoBalancedCollectorGroupId),
    collector_id: cdktf.numberToTerraform(struct!.collectorId),
    priority: cdktf.numberToTerraform(struct!.priority),
    use_public_ip: cdktf.booleanToTerraform(struct!.usePublicIp),
  }
}


export function deviceGroupExtraServicesAPPSERVICENormalCollectorConfigCollectorsToHclTerraform(struct?: DeviceGroupExtraServicesAPPSERVICENormalCollectorConfigCollectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    applies_to: {
      value: cdktf.stringToHclTerraform(struct!.appliesTo),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auto_balanced_collector_group_id: {
      value: cdktf.numberToHclTerraform(struct!.autoBalancedCollectorGroupId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    collector_id: {
      value: cdktf.numberToHclTerraform(struct!.collectorId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    priority: {
      value: cdktf.numberToHclTerraform(struct!.priority),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    use_public_ip: {
      value: cdktf.booleanToHclTerraform(struct!.usePublicIp),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesAPPSERVICENormalCollectorConfigCollectorsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesAPPSERVICENormalCollectorConfigCollectors | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._appliesTo !== undefined) {
      hasAnyValues = true;
      internalValueResult.appliesTo = this._appliesTo;
    }
    if (this._autoBalancedCollectorGroupId !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoBalancedCollectorGroupId = this._autoBalancedCollectorGroupId;
    }
    if (this._collectorId !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectorId = this._collectorId;
    }
    if (this._priority !== undefined) {
      hasAnyValues = true;
      internalValueResult.priority = this._priority;
    }
    if (this._usePublicIp !== undefined) {
      hasAnyValues = true;
      internalValueResult.usePublicIp = this._usePublicIp;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesAPPSERVICENormalCollectorConfigCollectors | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._appliesTo = undefined;
      this._autoBalancedCollectorGroupId = undefined;
      this._collectorId = undefined;
      this._priority = undefined;
      this._usePublicIp = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._appliesTo = value.appliesTo;
      this._autoBalancedCollectorGroupId = value.autoBalancedCollectorGroupId;
      this._collectorId = value.collectorId;
      this._priority = value.priority;
      this._usePublicIp = value.usePublicIp;
    }
  }

  // applies_to - computed: false, optional: true, required: false
  private _appliesTo?: string; 
  public get appliesTo() {
    return this.getStringAttribute('applies_to');
  }
  public set appliesTo(value: string) {
    this._appliesTo = value;
  }
  public resetAppliesTo() {
    this._appliesTo = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appliesToInput() {
    return this._appliesTo;
  }

  // auto_balanced_collector_group_id - computed: false, optional: true, required: false
  private _autoBalancedCollectorGroupId?: number; 
  public get autoBalancedCollectorGroupId() {
    return this.getNumberAttribute('auto_balanced_collector_group_id');
  }
  public set autoBalancedCollectorGroupId(value: number) {
    this._autoBalancedCollectorGroupId = value;
  }
  public resetAutoBalancedCollectorGroupId() {
    this._autoBalancedCollectorGroupId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoBalancedCollectorGroupIdInput() {
    return this._autoBalancedCollectorGroupId;
  }

  // collector_id - computed: false, optional: true, required: false
  private _collectorId?: number; 
  public get collectorId() {
    return this.getNumberAttribute('collector_id');
  }
  public set collectorId(value: number) {
    this._collectorId = value;
  }
  public resetCollectorId() {
    this._collectorId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorIdInput() {
    return this._collectorId;
  }

  // priority - computed: false, optional: true, required: false
  private _priority?: number; 
  public get priority() {
    return this.getNumberAttribute('priority');
  }
  public set priority(value: number) {
    this._priority = value;
  }
  public resetPriority() {
    this._priority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get priorityInput() {
    return this._priority;
  }

  // use_public_ip - computed: false, optional: true, required: false
  private _usePublicIp?: boolean | cdktf.IResolvable; 
  public get usePublicIp() {
    return this.getBooleanAttribute('use_public_ip');
  }
  public set usePublicIp(value: boolean | cdktf.IResolvable) {
    this._usePublicIp = value;
  }
  public resetUsePublicIp() {
    this._usePublicIp = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usePublicIpInput() {
    return this._usePublicIp;
  }
}

export class DeviceGroupExtraServicesAPPSERVICENormalCollectorConfigCollectorsList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesAPPSERVICENormalCollectorConfigCollectors[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesAPPSERVICENormalCollectorConfigCollectorsOutputReference {
    return new DeviceGroupExtraServicesAPPSERVICENormalCollectorConfigCollectorsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesAPPSERVICENormalCollectorConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#collectors DeviceGroup#collectors}
  */
  readonly collectors?: DeviceGroupExtraServicesAPPSERVICENormalCollectorConfigCollectors[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#enabled DeviceGroup#enabled}
  */
  readonly enabled: boolean | cdktf.IResolvable;
}

export function deviceGroupExtraServicesAPPSERVICENormalCollectorConfigToTerraform(struct?: DeviceGroupExtraServicesAPPSERVICENormalCollectorConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    collectors: cdktf.listMapper(deviceGroupExtraServicesAPPSERVICENormalCollectorConfigCollectorsToTerraform, false)(struct!.collectors),
    enabled: cdktf.booleanToTerraform(struct!.enabled),
  }
}


export function deviceGroupExtraServicesAPPSERVICENormalCollectorConfigToHclTerraform(struct?: DeviceGroupExtraServicesAPPSERVICENormalCollectorConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    collectors: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesAPPSERVICENormalCollectorConfigCollectorsToHclTerraform, false)(struct!.collectors),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesAPPSERVICENormalCollectorConfigCollectorsList",
    },
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesAPPSERVICENormalCollectorConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesAPPSERVICENormalCollectorConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._collectors?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectors = this._collectors?.internalValue;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesAPPSERVICENormalCollectorConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._collectors.internalValue = undefined;
      this._enabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._collectors.internalValue = value.collectors;
      this._enabled = value.enabled;
    }
  }

  // collectors - computed: false, optional: true, required: false
  private _collectors = new DeviceGroupExtraServicesAPPSERVICENormalCollectorConfigCollectorsList(this, "collectors", false);
  public get collectors() {
    return this._collectors;
  }
  public putCollectors(value: DeviceGroupExtraServicesAPPSERVICENormalCollectorConfigCollectors[] | cdktf.IResolvable) {
    this._collectors.internalValue = value;
  }
  public resetCollectors() {
    this._collectors.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorsInput() {
    return this._collectors.internalValue;
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }
}

export class DeviceGroupExtraServicesAPPSERVICENormalCollectorConfigList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesAPPSERVICENormalCollectorConfig[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesAPPSERVICENormalCollectorConfigOutputReference {
    return new DeviceGroupExtraServicesAPPSERVICENormalCollectorConfigOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesAPPSERVICE {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#custom_n_s_p_schedule DeviceGroup#custom_n_s_p_schedule}
  */
  readonly customNSPSchedule?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#dead_operation DeviceGroup#dead_operation}
  */
  readonly deadOperation?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#device_display_name_template DeviceGroup#device_display_name_template}
  */
  readonly deviceDisplayNameTemplate?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#disable_stop_terminate_host_monitor DeviceGroup#disable_stop_terminate_host_monitor}
  */
  readonly disableStopTerminateHostMonitor?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#disable_terminated_host_alerting DeviceGroup#disable_terminated_host_alerting}
  */
  readonly disableTerminatedHostAlerting?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#monitoring_region_infos DeviceGroup#monitoring_region_infos}
  */
  readonly monitoringRegionInfos?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#monitoring_regions DeviceGroup#monitoring_regions}
  */
  readonly monitoringRegions?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#name_filter DeviceGroup#name_filter}
  */
  readonly nameFilter?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#select_all DeviceGroup#select_all}
  */
  readonly selectAll?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#tags DeviceGroup#tags}
  */
  readonly tags?: DeviceGroupExtraServicesAPPSERVICETags[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#use_default DeviceGroup#use_default}
  */
  readonly useDefault: boolean | cdktf.IResolvable;
  /**
  * normal_collector_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#normal_collector_config DeviceGroup#normal_collector_config}
  */
  readonly normalCollectorConfig?: DeviceGroupExtraServicesAPPSERVICENormalCollectorConfig[] | cdktf.IResolvable;
}

export function deviceGroupExtraServicesAPPSERVICEToTerraform(struct?: DeviceGroupExtraServicesAPPSERVICE | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    custom_n_s_p_schedule: cdktf.stringToTerraform(struct!.customNSPSchedule),
    dead_operation: cdktf.stringToTerraform(struct!.deadOperation),
    device_display_name_template: cdktf.stringToTerraform(struct!.deviceDisplayNameTemplate),
    disable_stop_terminate_host_monitor: cdktf.booleanToTerraform(struct!.disableStopTerminateHostMonitor),
    disable_terminated_host_alerting: cdktf.booleanToTerraform(struct!.disableTerminatedHostAlerting),
    monitoring_region_infos: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.monitoringRegionInfos),
    monitoring_regions: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.monitoringRegions),
    name_filter: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.nameFilter),
    select_all: cdktf.booleanToTerraform(struct!.selectAll),
    tags: cdktf.listMapper(deviceGroupExtraServicesAPPSERVICETagsToTerraform, false)(struct!.tags),
    use_default: cdktf.booleanToTerraform(struct!.useDefault),
    normal_collector_config: cdktf.listMapper(deviceGroupExtraServicesAPPSERVICENormalCollectorConfigToTerraform, true)(struct!.normalCollectorConfig),
  }
}


export function deviceGroupExtraServicesAPPSERVICEToHclTerraform(struct?: DeviceGroupExtraServicesAPPSERVICE | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    custom_n_s_p_schedule: {
      value: cdktf.stringToHclTerraform(struct!.customNSPSchedule),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dead_operation: {
      value: cdktf.stringToHclTerraform(struct!.deadOperation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    device_display_name_template: {
      value: cdktf.stringToHclTerraform(struct!.deviceDisplayNameTemplate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disable_stop_terminate_host_monitor: {
      value: cdktf.booleanToHclTerraform(struct!.disableStopTerminateHostMonitor),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    disable_terminated_host_alerting: {
      value: cdktf.booleanToHclTerraform(struct!.disableTerminatedHostAlerting),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    monitoring_region_infos: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.monitoringRegionInfos),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    monitoring_regions: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.monitoringRegions),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    name_filter: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.nameFilter),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    select_all: {
      value: cdktf.booleanToHclTerraform(struct!.selectAll),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tags: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesAPPSERVICETagsToHclTerraform, false)(struct!.tags),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesAPPSERVICETagsList",
    },
    use_default: {
      value: cdktf.booleanToHclTerraform(struct!.useDefault),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    normal_collector_config: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesAPPSERVICENormalCollectorConfigToHclTerraform, true)(struct!.normalCollectorConfig),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesAPPSERVICENormalCollectorConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesAPPSERVICEOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesAPPSERVICE | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._customNSPSchedule !== undefined) {
      hasAnyValues = true;
      internalValueResult.customNSPSchedule = this._customNSPSchedule;
    }
    if (this._deadOperation !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadOperation = this._deadOperation;
    }
    if (this._deviceDisplayNameTemplate !== undefined) {
      hasAnyValues = true;
      internalValueResult.deviceDisplayNameTemplate = this._deviceDisplayNameTemplate;
    }
    if (this._disableStopTerminateHostMonitor !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableStopTerminateHostMonitor = this._disableStopTerminateHostMonitor;
    }
    if (this._disableTerminatedHostAlerting !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableTerminatedHostAlerting = this._disableTerminatedHostAlerting;
    }
    if (this._monitoringRegionInfos !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoringRegionInfos = this._monitoringRegionInfos;
    }
    if (this._monitoringRegions !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoringRegions = this._monitoringRegions;
    }
    if (this._nameFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.nameFilter = this._nameFilter;
    }
    if (this._selectAll !== undefined) {
      hasAnyValues = true;
      internalValueResult.selectAll = this._selectAll;
    }
    if (this._tags?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags?.internalValue;
    }
    if (this._useDefault !== undefined) {
      hasAnyValues = true;
      internalValueResult.useDefault = this._useDefault;
    }
    if (this._normalCollectorConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.normalCollectorConfig = this._normalCollectorConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesAPPSERVICE | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._customNSPSchedule = undefined;
      this._deadOperation = undefined;
      this._deviceDisplayNameTemplate = undefined;
      this._disableStopTerminateHostMonitor = undefined;
      this._disableTerminatedHostAlerting = undefined;
      this._monitoringRegionInfos = undefined;
      this._monitoringRegions = undefined;
      this._nameFilter = undefined;
      this._selectAll = undefined;
      this._tags.internalValue = undefined;
      this._useDefault = undefined;
      this._normalCollectorConfig.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._customNSPSchedule = value.customNSPSchedule;
      this._deadOperation = value.deadOperation;
      this._deviceDisplayNameTemplate = value.deviceDisplayNameTemplate;
      this._disableStopTerminateHostMonitor = value.disableStopTerminateHostMonitor;
      this._disableTerminatedHostAlerting = value.disableTerminatedHostAlerting;
      this._monitoringRegionInfos = value.monitoringRegionInfos;
      this._monitoringRegions = value.monitoringRegions;
      this._nameFilter = value.nameFilter;
      this._selectAll = value.selectAll;
      this._tags.internalValue = value.tags;
      this._useDefault = value.useDefault;
      this._normalCollectorConfig.internalValue = value.normalCollectorConfig;
    }
  }

  // custom_n_s_p_schedule - computed: false, optional: true, required: false
  private _customNSPSchedule?: string; 
  public get customNSPSchedule() {
    return this.getStringAttribute('custom_n_s_p_schedule');
  }
  public set customNSPSchedule(value: string) {
    this._customNSPSchedule = value;
  }
  public resetCustomNSPSchedule() {
    this._customNSPSchedule = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customNSPScheduleInput() {
    return this._customNSPSchedule;
  }

  // dead_operation - computed: false, optional: true, required: false
  private _deadOperation?: string; 
  public get deadOperation() {
    return this.getStringAttribute('dead_operation');
  }
  public set deadOperation(value: string) {
    this._deadOperation = value;
  }
  public resetDeadOperation() {
    this._deadOperation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadOperationInput() {
    return this._deadOperation;
  }

  // device_display_name_template - computed: false, optional: true, required: false
  private _deviceDisplayNameTemplate?: string; 
  public get deviceDisplayNameTemplate() {
    return this.getStringAttribute('device_display_name_template');
  }
  public set deviceDisplayNameTemplate(value: string) {
    this._deviceDisplayNameTemplate = value;
  }
  public resetDeviceDisplayNameTemplate() {
    this._deviceDisplayNameTemplate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deviceDisplayNameTemplateInput() {
    return this._deviceDisplayNameTemplate;
  }

  // disable_stop_terminate_host_monitor - computed: false, optional: true, required: false
  private _disableStopTerminateHostMonitor?: boolean | cdktf.IResolvable; 
  public get disableStopTerminateHostMonitor() {
    return this.getBooleanAttribute('disable_stop_terminate_host_monitor');
  }
  public set disableStopTerminateHostMonitor(value: boolean | cdktf.IResolvable) {
    this._disableStopTerminateHostMonitor = value;
  }
  public resetDisableStopTerminateHostMonitor() {
    this._disableStopTerminateHostMonitor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableStopTerminateHostMonitorInput() {
    return this._disableStopTerminateHostMonitor;
  }

  // disable_terminated_host_alerting - computed: false, optional: true, required: false
  private _disableTerminatedHostAlerting?: boolean | cdktf.IResolvable; 
  public get disableTerminatedHostAlerting() {
    return this.getBooleanAttribute('disable_terminated_host_alerting');
  }
  public set disableTerminatedHostAlerting(value: boolean | cdktf.IResolvable) {
    this._disableTerminatedHostAlerting = value;
  }
  public resetDisableTerminatedHostAlerting() {
    this._disableTerminatedHostAlerting = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableTerminatedHostAlertingInput() {
    return this._disableTerminatedHostAlerting;
  }

  // monitoring_region_infos - computed: false, optional: true, required: false
  private _monitoringRegionInfos?: string[]; 
  public get monitoringRegionInfos() {
    return cdktf.Fn.tolist(this.getListAttribute('monitoring_region_infos'));
  }
  public set monitoringRegionInfos(value: string[]) {
    this._monitoringRegionInfos = value;
  }
  public resetMonitoringRegionInfos() {
    this._monitoringRegionInfos = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoringRegionInfosInput() {
    return this._monitoringRegionInfos;
  }

  // monitoring_regions - computed: false, optional: true, required: false
  private _monitoringRegions?: string[]; 
  public get monitoringRegions() {
    return cdktf.Fn.tolist(this.getListAttribute('monitoring_regions'));
  }
  public set monitoringRegions(value: string[]) {
    this._monitoringRegions = value;
  }
  public resetMonitoringRegions() {
    this._monitoringRegions = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoringRegionsInput() {
    return this._monitoringRegions;
  }

  // name_filter - computed: false, optional: true, required: false
  private _nameFilter?: string[]; 
  public get nameFilter() {
    return cdktf.Fn.tolist(this.getListAttribute('name_filter'));
  }
  public set nameFilter(value: string[]) {
    this._nameFilter = value;
  }
  public resetNameFilter() {
    this._nameFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameFilterInput() {
    return this._nameFilter;
  }

  // select_all - computed: false, optional: true, required: false
  private _selectAll?: boolean | cdktf.IResolvable; 
  public get selectAll() {
    return this.getBooleanAttribute('select_all');
  }
  public set selectAll(value: boolean | cdktf.IResolvable) {
    this._selectAll = value;
  }
  public resetSelectAll() {
    this._selectAll = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectAllInput() {
    return this._selectAll;
  }

  // tags - computed: false, optional: true, required: false
  private _tags = new DeviceGroupExtraServicesAPPSERVICETagsList(this, "tags", false);
  public get tags() {
    return this._tags;
  }
  public putTags(value: DeviceGroupExtraServicesAPPSERVICETags[] | cdktf.IResolvable) {
    this._tags.internalValue = value;
  }
  public resetTags() {
    this._tags.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags.internalValue;
  }

  // use_default - computed: false, optional: false, required: true
  private _useDefault?: boolean | cdktf.IResolvable; 
  public get useDefault() {
    return this.getBooleanAttribute('use_default');
  }
  public set useDefault(value: boolean | cdktf.IResolvable) {
    this._useDefault = value;
  }
  // Temporarily expose input value. Use with caution.
  public get useDefaultInput() {
    return this._useDefault;
  }

  // normal_collector_config - computed: false, optional: true, required: false
  private _normalCollectorConfig = new DeviceGroupExtraServicesAPPSERVICENormalCollectorConfigList(this, "normal_collector_config", false);
  public get normalCollectorConfig() {
    return this._normalCollectorConfig;
  }
  public putNormalCollectorConfig(value: DeviceGroupExtraServicesAPPSERVICENormalCollectorConfig[] | cdktf.IResolvable) {
    this._normalCollectorConfig.internalValue = value;
  }
  public resetNormalCollectorConfig() {
    this._normalCollectorConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get normalCollectorConfigInput() {
    return this._normalCollectorConfig.internalValue;
  }
}

export class DeviceGroupExtraServicesAPPSERVICEList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesAPPSERVICE[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesAPPSERVICEOutputReference {
    return new DeviceGroupExtraServicesAPPSERVICEOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesAPPSERVICEPLANTags {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#name DeviceGroup#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#operation DeviceGroup#operation}
  */
  readonly operation?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#value DeviceGroup#value}
  */
  readonly value?: string;
}

export function deviceGroupExtraServicesAPPSERVICEPLANTagsToTerraform(struct?: DeviceGroupExtraServicesAPPSERVICEPLANTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    operation: cdktf.stringToTerraform(struct!.operation),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function deviceGroupExtraServicesAPPSERVICEPLANTagsToHclTerraform(struct?: DeviceGroupExtraServicesAPPSERVICEPLANTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operation: {
      value: cdktf.stringToHclTerraform(struct!.operation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesAPPSERVICEPLANTagsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesAPPSERVICEPLANTags | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._operation !== undefined) {
      hasAnyValues = true;
      internalValueResult.operation = this._operation;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesAPPSERVICEPLANTags | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._operation = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._operation = value.operation;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // operation - computed: false, optional: true, required: false
  private _operation?: string; 
  public get operation() {
    return this.getStringAttribute('operation');
  }
  public set operation(value: string) {
    this._operation = value;
  }
  public resetOperation() {
    this._operation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operationInput() {
    return this._operation;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DeviceGroupExtraServicesAPPSERVICEPLANTagsList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesAPPSERVICEPLANTags[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesAPPSERVICEPLANTagsOutputReference {
    return new DeviceGroupExtraServicesAPPSERVICEPLANTagsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesAPPSERVICEPLANNormalCollectorConfigCollectors {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#applies_to DeviceGroup#applies_to}
  */
  readonly appliesTo?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#auto_balanced_collector_group_id DeviceGroup#auto_balanced_collector_group_id}
  */
  readonly autoBalancedCollectorGroupId?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#collector_id DeviceGroup#collector_id}
  */
  readonly collectorId?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#priority DeviceGroup#priority}
  */
  readonly priority?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#use_public_ip DeviceGroup#use_public_ip}
  */
  readonly usePublicIp?: boolean | cdktf.IResolvable;
}

export function deviceGroupExtraServicesAPPSERVICEPLANNormalCollectorConfigCollectorsToTerraform(struct?: DeviceGroupExtraServicesAPPSERVICEPLANNormalCollectorConfigCollectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    applies_to: cdktf.stringToTerraform(struct!.appliesTo),
    auto_balanced_collector_group_id: cdktf.numberToTerraform(struct!.autoBalancedCollectorGroupId),
    collector_id: cdktf.numberToTerraform(struct!.collectorId),
    priority: cdktf.numberToTerraform(struct!.priority),
    use_public_ip: cdktf.booleanToTerraform(struct!.usePublicIp),
  }
}


export function deviceGroupExtraServicesAPPSERVICEPLANNormalCollectorConfigCollectorsToHclTerraform(struct?: DeviceGroupExtraServicesAPPSERVICEPLANNormalCollectorConfigCollectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    applies_to: {
      value: cdktf.stringToHclTerraform(struct!.appliesTo),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auto_balanced_collector_group_id: {
      value: cdktf.numberToHclTerraform(struct!.autoBalancedCollectorGroupId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    collector_id: {
      value: cdktf.numberToHclTerraform(struct!.collectorId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    priority: {
      value: cdktf.numberToHclTerraform(struct!.priority),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    use_public_ip: {
      value: cdktf.booleanToHclTerraform(struct!.usePublicIp),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesAPPSERVICEPLANNormalCollectorConfigCollectorsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesAPPSERVICEPLANNormalCollectorConfigCollectors | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._appliesTo !== undefined) {
      hasAnyValues = true;
      internalValueResult.appliesTo = this._appliesTo;
    }
    if (this._autoBalancedCollectorGroupId !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoBalancedCollectorGroupId = this._autoBalancedCollectorGroupId;
    }
    if (this._collectorId !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectorId = this._collectorId;
    }
    if (this._priority !== undefined) {
      hasAnyValues = true;
      internalValueResult.priority = this._priority;
    }
    if (this._usePublicIp !== undefined) {
      hasAnyValues = true;
      internalValueResult.usePublicIp = this._usePublicIp;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesAPPSERVICEPLANNormalCollectorConfigCollectors | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._appliesTo = undefined;
      this._autoBalancedCollectorGroupId = undefined;
      this._collectorId = undefined;
      this._priority = undefined;
      this._usePublicIp = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._appliesTo = value.appliesTo;
      this._autoBalancedCollectorGroupId = value.autoBalancedCollectorGroupId;
      this._collectorId = value.collectorId;
      this._priority = value.priority;
      this._usePublicIp = value.usePublicIp;
    }
  }

  // applies_to - computed: false, optional: true, required: false
  private _appliesTo?: string; 
  public get appliesTo() {
    return this.getStringAttribute('applies_to');
  }
  public set appliesTo(value: string) {
    this._appliesTo = value;
  }
  public resetAppliesTo() {
    this._appliesTo = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appliesToInput() {
    return this._appliesTo;
  }

  // auto_balanced_collector_group_id - computed: false, optional: true, required: false
  private _autoBalancedCollectorGroupId?: number; 
  public get autoBalancedCollectorGroupId() {
    return this.getNumberAttribute('auto_balanced_collector_group_id');
  }
  public set autoBalancedCollectorGroupId(value: number) {
    this._autoBalancedCollectorGroupId = value;
  }
  public resetAutoBalancedCollectorGroupId() {
    this._autoBalancedCollectorGroupId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoBalancedCollectorGroupIdInput() {
    return this._autoBalancedCollectorGroupId;
  }

  // collector_id - computed: false, optional: true, required: false
  private _collectorId?: number; 
  public get collectorId() {
    return this.getNumberAttribute('collector_id');
  }
  public set collectorId(value: number) {
    this._collectorId = value;
  }
  public resetCollectorId() {
    this._collectorId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorIdInput() {
    return this._collectorId;
  }

  // priority - computed: false, optional: true, required: false
  private _priority?: number; 
  public get priority() {
    return this.getNumberAttribute('priority');
  }
  public set priority(value: number) {
    this._priority = value;
  }
  public resetPriority() {
    this._priority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get priorityInput() {
    return this._priority;
  }

  // use_public_ip - computed: false, optional: true, required: false
  private _usePublicIp?: boolean | cdktf.IResolvable; 
  public get usePublicIp() {
    return this.getBooleanAttribute('use_public_ip');
  }
  public set usePublicIp(value: boolean | cdktf.IResolvable) {
    this._usePublicIp = value;
  }
  public resetUsePublicIp() {
    this._usePublicIp = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usePublicIpInput() {
    return this._usePublicIp;
  }
}

export class DeviceGroupExtraServicesAPPSERVICEPLANNormalCollectorConfigCollectorsList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesAPPSERVICEPLANNormalCollectorConfigCollectors[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesAPPSERVICEPLANNormalCollectorConfigCollectorsOutputReference {
    return new DeviceGroupExtraServicesAPPSERVICEPLANNormalCollectorConfigCollectorsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesAPPSERVICEPLANNormalCollectorConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#collectors DeviceGroup#collectors}
  */
  readonly collectors?: DeviceGroupExtraServicesAPPSERVICEPLANNormalCollectorConfigCollectors[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#enabled DeviceGroup#enabled}
  */
  readonly enabled: boolean | cdktf.IResolvable;
}

export function deviceGroupExtraServicesAPPSERVICEPLANNormalCollectorConfigToTerraform(struct?: DeviceGroupExtraServicesAPPSERVICEPLANNormalCollectorConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    collectors: cdktf.listMapper(deviceGroupExtraServicesAPPSERVICEPLANNormalCollectorConfigCollectorsToTerraform, false)(struct!.collectors),
    enabled: cdktf.booleanToTerraform(struct!.enabled),
  }
}


export function deviceGroupExtraServicesAPPSERVICEPLANNormalCollectorConfigToHclTerraform(struct?: DeviceGroupExtraServicesAPPSERVICEPLANNormalCollectorConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    collectors: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesAPPSERVICEPLANNormalCollectorConfigCollectorsToHclTerraform, false)(struct!.collectors),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesAPPSERVICEPLANNormalCollectorConfigCollectorsList",
    },
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesAPPSERVICEPLANNormalCollectorConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesAPPSERVICEPLANNormalCollectorConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._collectors?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectors = this._collectors?.internalValue;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesAPPSERVICEPLANNormalCollectorConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._collectors.internalValue = undefined;
      this._enabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._collectors.internalValue = value.collectors;
      this._enabled = value.enabled;
    }
  }

  // collectors - computed: false, optional: true, required: false
  private _collectors = new DeviceGroupExtraServicesAPPSERVICEPLANNormalCollectorConfigCollectorsList(this, "collectors", false);
  public get collectors() {
    return this._collectors;
  }
  public putCollectors(value: DeviceGroupExtraServicesAPPSERVICEPLANNormalCollectorConfigCollectors[] | cdktf.IResolvable) {
    this._collectors.internalValue = value;
  }
  public resetCollectors() {
    this._collectors.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorsInput() {
    return this._collectors.internalValue;
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }
}

export class DeviceGroupExtraServicesAPPSERVICEPLANNormalCollectorConfigList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesAPPSERVICEPLANNormalCollectorConfig[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesAPPSERVICEPLANNormalCollectorConfigOutputReference {
    return new DeviceGroupExtraServicesAPPSERVICEPLANNormalCollectorConfigOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesAPPSERVICEPLAN {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#custom_n_s_p_schedule DeviceGroup#custom_n_s_p_schedule}
  */
  readonly customNSPSchedule?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#dead_operation DeviceGroup#dead_operation}
  */
  readonly deadOperation?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#device_display_name_template DeviceGroup#device_display_name_template}
  */
  readonly deviceDisplayNameTemplate?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#disable_stop_terminate_host_monitor DeviceGroup#disable_stop_terminate_host_monitor}
  */
  readonly disableStopTerminateHostMonitor?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#disable_terminated_host_alerting DeviceGroup#disable_terminated_host_alerting}
  */
  readonly disableTerminatedHostAlerting?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#monitoring_region_infos DeviceGroup#monitoring_region_infos}
  */
  readonly monitoringRegionInfos?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#monitoring_regions DeviceGroup#monitoring_regions}
  */
  readonly monitoringRegions?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#name_filter DeviceGroup#name_filter}
  */
  readonly nameFilter?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#select_all DeviceGroup#select_all}
  */
  readonly selectAll?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#tags DeviceGroup#tags}
  */
  readonly tags?: DeviceGroupExtraServicesAPPSERVICEPLANTags[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#use_default DeviceGroup#use_default}
  */
  readonly useDefault: boolean | cdktf.IResolvable;
  /**
  * normal_collector_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#normal_collector_config DeviceGroup#normal_collector_config}
  */
  readonly normalCollectorConfig?: DeviceGroupExtraServicesAPPSERVICEPLANNormalCollectorConfig[] | cdktf.IResolvable;
}

export function deviceGroupExtraServicesAPPSERVICEPLANToTerraform(struct?: DeviceGroupExtraServicesAPPSERVICEPLAN | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    custom_n_s_p_schedule: cdktf.stringToTerraform(struct!.customNSPSchedule),
    dead_operation: cdktf.stringToTerraform(struct!.deadOperation),
    device_display_name_template: cdktf.stringToTerraform(struct!.deviceDisplayNameTemplate),
    disable_stop_terminate_host_monitor: cdktf.booleanToTerraform(struct!.disableStopTerminateHostMonitor),
    disable_terminated_host_alerting: cdktf.booleanToTerraform(struct!.disableTerminatedHostAlerting),
    monitoring_region_infos: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.monitoringRegionInfos),
    monitoring_regions: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.monitoringRegions),
    name_filter: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.nameFilter),
    select_all: cdktf.booleanToTerraform(struct!.selectAll),
    tags: cdktf.listMapper(deviceGroupExtraServicesAPPSERVICEPLANTagsToTerraform, false)(struct!.tags),
    use_default: cdktf.booleanToTerraform(struct!.useDefault),
    normal_collector_config: cdktf.listMapper(deviceGroupExtraServicesAPPSERVICEPLANNormalCollectorConfigToTerraform, true)(struct!.normalCollectorConfig),
  }
}


export function deviceGroupExtraServicesAPPSERVICEPLANToHclTerraform(struct?: DeviceGroupExtraServicesAPPSERVICEPLAN | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    custom_n_s_p_schedule: {
      value: cdktf.stringToHclTerraform(struct!.customNSPSchedule),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dead_operation: {
      value: cdktf.stringToHclTerraform(struct!.deadOperation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    device_display_name_template: {
      value: cdktf.stringToHclTerraform(struct!.deviceDisplayNameTemplate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disable_stop_terminate_host_monitor: {
      value: cdktf.booleanToHclTerraform(struct!.disableStopTerminateHostMonitor),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    disable_terminated_host_alerting: {
      value: cdktf.booleanToHclTerraform(struct!.disableTerminatedHostAlerting),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    monitoring_region_infos: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.monitoringRegionInfos),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    monitoring_regions: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.monitoringRegions),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    name_filter: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.nameFilter),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    select_all: {
      value: cdktf.booleanToHclTerraform(struct!.selectAll),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tags: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesAPPSERVICEPLANTagsToHclTerraform, false)(struct!.tags),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesAPPSERVICEPLANTagsList",
    },
    use_default: {
      value: cdktf.booleanToHclTerraform(struct!.useDefault),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    normal_collector_config: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesAPPSERVICEPLANNormalCollectorConfigToHclTerraform, true)(struct!.normalCollectorConfig),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesAPPSERVICEPLANNormalCollectorConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesAPPSERVICEPLANOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesAPPSERVICEPLAN | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._customNSPSchedule !== undefined) {
      hasAnyValues = true;
      internalValueResult.customNSPSchedule = this._customNSPSchedule;
    }
    if (this._deadOperation !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadOperation = this._deadOperation;
    }
    if (this._deviceDisplayNameTemplate !== undefined) {
      hasAnyValues = true;
      internalValueResult.deviceDisplayNameTemplate = this._deviceDisplayNameTemplate;
    }
    if (this._disableStopTerminateHostMonitor !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableStopTerminateHostMonitor = this._disableStopTerminateHostMonitor;
    }
    if (this._disableTerminatedHostAlerting !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableTerminatedHostAlerting = this._disableTerminatedHostAlerting;
    }
    if (this._monitoringRegionInfos !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoringRegionInfos = this._monitoringRegionInfos;
    }
    if (this._monitoringRegions !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoringRegions = this._monitoringRegions;
    }
    if (this._nameFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.nameFilter = this._nameFilter;
    }
    if (this._selectAll !== undefined) {
      hasAnyValues = true;
      internalValueResult.selectAll = this._selectAll;
    }
    if (this._tags?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags?.internalValue;
    }
    if (this._useDefault !== undefined) {
      hasAnyValues = true;
      internalValueResult.useDefault = this._useDefault;
    }
    if (this._normalCollectorConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.normalCollectorConfig = this._normalCollectorConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesAPPSERVICEPLAN | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._customNSPSchedule = undefined;
      this._deadOperation = undefined;
      this._deviceDisplayNameTemplate = undefined;
      this._disableStopTerminateHostMonitor = undefined;
      this._disableTerminatedHostAlerting = undefined;
      this._monitoringRegionInfos = undefined;
      this._monitoringRegions = undefined;
      this._nameFilter = undefined;
      this._selectAll = undefined;
      this._tags.internalValue = undefined;
      this._useDefault = undefined;
      this._normalCollectorConfig.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._customNSPSchedule = value.customNSPSchedule;
      this._deadOperation = value.deadOperation;
      this._deviceDisplayNameTemplate = value.deviceDisplayNameTemplate;
      this._disableStopTerminateHostMonitor = value.disableStopTerminateHostMonitor;
      this._disableTerminatedHostAlerting = value.disableTerminatedHostAlerting;
      this._monitoringRegionInfos = value.monitoringRegionInfos;
      this._monitoringRegions = value.monitoringRegions;
      this._nameFilter = value.nameFilter;
      this._selectAll = value.selectAll;
      this._tags.internalValue = value.tags;
      this._useDefault = value.useDefault;
      this._normalCollectorConfig.internalValue = value.normalCollectorConfig;
    }
  }

  // custom_n_s_p_schedule - computed: false, optional: true, required: false
  private _customNSPSchedule?: string; 
  public get customNSPSchedule() {
    return this.getStringAttribute('custom_n_s_p_schedule');
  }
  public set customNSPSchedule(value: string) {
    this._customNSPSchedule = value;
  }
  public resetCustomNSPSchedule() {
    this._customNSPSchedule = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customNSPScheduleInput() {
    return this._customNSPSchedule;
  }

  // dead_operation - computed: false, optional: true, required: false
  private _deadOperation?: string; 
  public get deadOperation() {
    return this.getStringAttribute('dead_operation');
  }
  public set deadOperation(value: string) {
    this._deadOperation = value;
  }
  public resetDeadOperation() {
    this._deadOperation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadOperationInput() {
    return this._deadOperation;
  }

  // device_display_name_template - computed: false, optional: true, required: false
  private _deviceDisplayNameTemplate?: string; 
  public get deviceDisplayNameTemplate() {
    return this.getStringAttribute('device_display_name_template');
  }
  public set deviceDisplayNameTemplate(value: string) {
    this._deviceDisplayNameTemplate = value;
  }
  public resetDeviceDisplayNameTemplate() {
    this._deviceDisplayNameTemplate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deviceDisplayNameTemplateInput() {
    return this._deviceDisplayNameTemplate;
  }

  // disable_stop_terminate_host_monitor - computed: false, optional: true, required: false
  private _disableStopTerminateHostMonitor?: boolean | cdktf.IResolvable; 
  public get disableStopTerminateHostMonitor() {
    return this.getBooleanAttribute('disable_stop_terminate_host_monitor');
  }
  public set disableStopTerminateHostMonitor(value: boolean | cdktf.IResolvable) {
    this._disableStopTerminateHostMonitor = value;
  }
  public resetDisableStopTerminateHostMonitor() {
    this._disableStopTerminateHostMonitor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableStopTerminateHostMonitorInput() {
    return this._disableStopTerminateHostMonitor;
  }

  // disable_terminated_host_alerting - computed: false, optional: true, required: false
  private _disableTerminatedHostAlerting?: boolean | cdktf.IResolvable; 
  public get disableTerminatedHostAlerting() {
    return this.getBooleanAttribute('disable_terminated_host_alerting');
  }
  public set disableTerminatedHostAlerting(value: boolean | cdktf.IResolvable) {
    this._disableTerminatedHostAlerting = value;
  }
  public resetDisableTerminatedHostAlerting() {
    this._disableTerminatedHostAlerting = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableTerminatedHostAlertingInput() {
    return this._disableTerminatedHostAlerting;
  }

  // monitoring_region_infos - computed: false, optional: true, required: false
  private _monitoringRegionInfos?: string[]; 
  public get monitoringRegionInfos() {
    return cdktf.Fn.tolist(this.getListAttribute('monitoring_region_infos'));
  }
  public set monitoringRegionInfos(value: string[]) {
    this._monitoringRegionInfos = value;
  }
  public resetMonitoringRegionInfos() {
    this._monitoringRegionInfos = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoringRegionInfosInput() {
    return this._monitoringRegionInfos;
  }

  // monitoring_regions - computed: false, optional: true, required: false
  private _monitoringRegions?: string[]; 
  public get monitoringRegions() {
    return cdktf.Fn.tolist(this.getListAttribute('monitoring_regions'));
  }
  public set monitoringRegions(value: string[]) {
    this._monitoringRegions = value;
  }
  public resetMonitoringRegions() {
    this._monitoringRegions = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoringRegionsInput() {
    return this._monitoringRegions;
  }

  // name_filter - computed: false, optional: true, required: false
  private _nameFilter?: string[]; 
  public get nameFilter() {
    return cdktf.Fn.tolist(this.getListAttribute('name_filter'));
  }
  public set nameFilter(value: string[]) {
    this._nameFilter = value;
  }
  public resetNameFilter() {
    this._nameFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameFilterInput() {
    return this._nameFilter;
  }

  // select_all - computed: false, optional: true, required: false
  private _selectAll?: boolean | cdktf.IResolvable; 
  public get selectAll() {
    return this.getBooleanAttribute('select_all');
  }
  public set selectAll(value: boolean | cdktf.IResolvable) {
    this._selectAll = value;
  }
  public resetSelectAll() {
    this._selectAll = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectAllInput() {
    return this._selectAll;
  }

  // tags - computed: false, optional: true, required: false
  private _tags = new DeviceGroupExtraServicesAPPSERVICEPLANTagsList(this, "tags", false);
  public get tags() {
    return this._tags;
  }
  public putTags(value: DeviceGroupExtraServicesAPPSERVICEPLANTags[] | cdktf.IResolvable) {
    this._tags.internalValue = value;
  }
  public resetTags() {
    this._tags.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags.internalValue;
  }

  // use_default - computed: false, optional: false, required: true
  private _useDefault?: boolean | cdktf.IResolvable; 
  public get useDefault() {
    return this.getBooleanAttribute('use_default');
  }
  public set useDefault(value: boolean | cdktf.IResolvable) {
    this._useDefault = value;
  }
  // Temporarily expose input value. Use with caution.
  public get useDefaultInput() {
    return this._useDefault;
  }

  // normal_collector_config - computed: false, optional: true, required: false
  private _normalCollectorConfig = new DeviceGroupExtraServicesAPPSERVICEPLANNormalCollectorConfigList(this, "normal_collector_config", false);
  public get normalCollectorConfig() {
    return this._normalCollectorConfig;
  }
  public putNormalCollectorConfig(value: DeviceGroupExtraServicesAPPSERVICEPLANNormalCollectorConfig[] | cdktf.IResolvable) {
    this._normalCollectorConfig.internalValue = value;
  }
  public resetNormalCollectorConfig() {
    this._normalCollectorConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get normalCollectorConfigInput() {
    return this._normalCollectorConfig.internalValue;
  }
}

export class DeviceGroupExtraServicesAPPSERVICEPLANList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesAPPSERVICEPLAN[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesAPPSERVICEPLANOutputReference {
    return new DeviceGroupExtraServicesAPPSERVICEPLANOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesAPPSTREAMTags {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#name DeviceGroup#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#operation DeviceGroup#operation}
  */
  readonly operation?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#value DeviceGroup#value}
  */
  readonly value?: string;
}

export function deviceGroupExtraServicesAPPSTREAMTagsToTerraform(struct?: DeviceGroupExtraServicesAPPSTREAMTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    operation: cdktf.stringToTerraform(struct!.operation),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function deviceGroupExtraServicesAPPSTREAMTagsToHclTerraform(struct?: DeviceGroupExtraServicesAPPSTREAMTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operation: {
      value: cdktf.stringToHclTerraform(struct!.operation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesAPPSTREAMTagsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesAPPSTREAMTags | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._operation !== undefined) {
      hasAnyValues = true;
      internalValueResult.operation = this._operation;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesAPPSTREAMTags | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._operation = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._operation = value.operation;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // operation - computed: false, optional: true, required: false
  private _operation?: string; 
  public get operation() {
    return this.getStringAttribute('operation');
  }
  public set operation(value: string) {
    this._operation = value;
  }
  public resetOperation() {
    this._operation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operationInput() {
    return this._operation;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DeviceGroupExtraServicesAPPSTREAMTagsList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesAPPSTREAMTags[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesAPPSTREAMTagsOutputReference {
    return new DeviceGroupExtraServicesAPPSTREAMTagsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesAPPSTREAMNormalCollectorConfigCollectors {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#applies_to DeviceGroup#applies_to}
  */
  readonly appliesTo?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#auto_balanced_collector_group_id DeviceGroup#auto_balanced_collector_group_id}
  */
  readonly autoBalancedCollectorGroupId?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#collector_id DeviceGroup#collector_id}
  */
  readonly collectorId?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#priority DeviceGroup#priority}
  */
  readonly priority?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#use_public_ip DeviceGroup#use_public_ip}
  */
  readonly usePublicIp?: boolean | cdktf.IResolvable;
}

export function deviceGroupExtraServicesAPPSTREAMNormalCollectorConfigCollectorsToTerraform(struct?: DeviceGroupExtraServicesAPPSTREAMNormalCollectorConfigCollectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    applies_to: cdktf.stringToTerraform(struct!.appliesTo),
    auto_balanced_collector_group_id: cdktf.numberToTerraform(struct!.autoBalancedCollectorGroupId),
    collector_id: cdktf.numberToTerraform(struct!.collectorId),
    priority: cdktf.numberToTerraform(struct!.priority),
    use_public_ip: cdktf.booleanToTerraform(struct!.usePublicIp),
  }
}


export function deviceGroupExtraServicesAPPSTREAMNormalCollectorConfigCollectorsToHclTerraform(struct?: DeviceGroupExtraServicesAPPSTREAMNormalCollectorConfigCollectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    applies_to: {
      value: cdktf.stringToHclTerraform(struct!.appliesTo),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auto_balanced_collector_group_id: {
      value: cdktf.numberToHclTerraform(struct!.autoBalancedCollectorGroupId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    collector_id: {
      value: cdktf.numberToHclTerraform(struct!.collectorId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    priority: {
      value: cdktf.numberToHclTerraform(struct!.priority),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    use_public_ip: {
      value: cdktf.booleanToHclTerraform(struct!.usePublicIp),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesAPPSTREAMNormalCollectorConfigCollectorsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesAPPSTREAMNormalCollectorConfigCollectors | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._appliesTo !== undefined) {
      hasAnyValues = true;
      internalValueResult.appliesTo = this._appliesTo;
    }
    if (this._autoBalancedCollectorGroupId !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoBalancedCollectorGroupId = this._autoBalancedCollectorGroupId;
    }
    if (this._collectorId !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectorId = this._collectorId;
    }
    if (this._priority !== undefined) {
      hasAnyValues = true;
      internalValueResult.priority = this._priority;
    }
    if (this._usePublicIp !== undefined) {
      hasAnyValues = true;
      internalValueResult.usePublicIp = this._usePublicIp;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesAPPSTREAMNormalCollectorConfigCollectors | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._appliesTo = undefined;
      this._autoBalancedCollectorGroupId = undefined;
      this._collectorId = undefined;
      this._priority = undefined;
      this._usePublicIp = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._appliesTo = value.appliesTo;
      this._autoBalancedCollectorGroupId = value.autoBalancedCollectorGroupId;
      this._collectorId = value.collectorId;
      this._priority = value.priority;
      this._usePublicIp = value.usePublicIp;
    }
  }

  // applies_to - computed: false, optional: true, required: false
  private _appliesTo?: string; 
  public get appliesTo() {
    return this.getStringAttribute('applies_to');
  }
  public set appliesTo(value: string) {
    this._appliesTo = value;
  }
  public resetAppliesTo() {
    this._appliesTo = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appliesToInput() {
    return this._appliesTo;
  }

  // auto_balanced_collector_group_id - computed: false, optional: true, required: false
  private _autoBalancedCollectorGroupId?: number; 
  public get autoBalancedCollectorGroupId() {
    return this.getNumberAttribute('auto_balanced_collector_group_id');
  }
  public set autoBalancedCollectorGroupId(value: number) {
    this._autoBalancedCollectorGroupId = value;
  }
  public resetAutoBalancedCollectorGroupId() {
    this._autoBalancedCollectorGroupId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoBalancedCollectorGroupIdInput() {
    return this._autoBalancedCollectorGroupId;
  }

  // collector_id - computed: false, optional: true, required: false
  private _collectorId?: number; 
  public get collectorId() {
    return this.getNumberAttribute('collector_id');
  }
  public set collectorId(value: number) {
    this._collectorId = value;
  }
  public resetCollectorId() {
    this._collectorId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorIdInput() {
    return this._collectorId;
  }

  // priority - computed: false, optional: true, required: false
  private _priority?: number; 
  public get priority() {
    return this.getNumberAttribute('priority');
  }
  public set priority(value: number) {
    this._priority = value;
  }
  public resetPriority() {
    this._priority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get priorityInput() {
    return this._priority;
  }

  // use_public_ip - computed: false, optional: true, required: false
  private _usePublicIp?: boolean | cdktf.IResolvable; 
  public get usePublicIp() {
    return this.getBooleanAttribute('use_public_ip');
  }
  public set usePublicIp(value: boolean | cdktf.IResolvable) {
    this._usePublicIp = value;
  }
  public resetUsePublicIp() {
    this._usePublicIp = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usePublicIpInput() {
    return this._usePublicIp;
  }
}

export class DeviceGroupExtraServicesAPPSTREAMNormalCollectorConfigCollectorsList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesAPPSTREAMNormalCollectorConfigCollectors[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesAPPSTREAMNormalCollectorConfigCollectorsOutputReference {
    return new DeviceGroupExtraServicesAPPSTREAMNormalCollectorConfigCollectorsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesAPPSTREAMNormalCollectorConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#collectors DeviceGroup#collectors}
  */
  readonly collectors?: DeviceGroupExtraServicesAPPSTREAMNormalCollectorConfigCollectors[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#enabled DeviceGroup#enabled}
  */
  readonly enabled: boolean | cdktf.IResolvable;
}

export function deviceGroupExtraServicesAPPSTREAMNormalCollectorConfigToTerraform(struct?: DeviceGroupExtraServicesAPPSTREAMNormalCollectorConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    collectors: cdktf.listMapper(deviceGroupExtraServicesAPPSTREAMNormalCollectorConfigCollectorsToTerraform, false)(struct!.collectors),
    enabled: cdktf.booleanToTerraform(struct!.enabled),
  }
}


export function deviceGroupExtraServicesAPPSTREAMNormalCollectorConfigToHclTerraform(struct?: DeviceGroupExtraServicesAPPSTREAMNormalCollectorConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    collectors: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesAPPSTREAMNormalCollectorConfigCollectorsToHclTerraform, false)(struct!.collectors),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesAPPSTREAMNormalCollectorConfigCollectorsList",
    },
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesAPPSTREAMNormalCollectorConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesAPPSTREAMNormalCollectorConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._collectors?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectors = this._collectors?.internalValue;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesAPPSTREAMNormalCollectorConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._collectors.internalValue = undefined;
      this._enabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._collectors.internalValue = value.collectors;
      this._enabled = value.enabled;
    }
  }

  // collectors - computed: false, optional: true, required: false
  private _collectors = new DeviceGroupExtraServicesAPPSTREAMNormalCollectorConfigCollectorsList(this, "collectors", false);
  public get collectors() {
    return this._collectors;
  }
  public putCollectors(value: DeviceGroupExtraServicesAPPSTREAMNormalCollectorConfigCollectors[] | cdktf.IResolvable) {
    this._collectors.internalValue = value;
  }
  public resetCollectors() {
    this._collectors.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorsInput() {
    return this._collectors.internalValue;
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }
}

export class DeviceGroupExtraServicesAPPSTREAMNormalCollectorConfigList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesAPPSTREAMNormalCollectorConfig[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesAPPSTREAMNormalCollectorConfigOutputReference {
    return new DeviceGroupExtraServicesAPPSTREAMNormalCollectorConfigOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesAPPSTREAM {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#custom_n_s_p_schedule DeviceGroup#custom_n_s_p_schedule}
  */
  readonly customNSPSchedule?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#dead_operation DeviceGroup#dead_operation}
  */
  readonly deadOperation?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#device_display_name_template DeviceGroup#device_display_name_template}
  */
  readonly deviceDisplayNameTemplate?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#disable_stop_terminate_host_monitor DeviceGroup#disable_stop_terminate_host_monitor}
  */
  readonly disableStopTerminateHostMonitor?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#disable_terminated_host_alerting DeviceGroup#disable_terminated_host_alerting}
  */
  readonly disableTerminatedHostAlerting?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#monitoring_region_infos DeviceGroup#monitoring_region_infos}
  */
  readonly monitoringRegionInfos?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#monitoring_regions DeviceGroup#monitoring_regions}
  */
  readonly monitoringRegions?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#name_filter DeviceGroup#name_filter}
  */
  readonly nameFilter?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#select_all DeviceGroup#select_all}
  */
  readonly selectAll?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#tags DeviceGroup#tags}
  */
  readonly tags?: DeviceGroupExtraServicesAPPSTREAMTags[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#use_default DeviceGroup#use_default}
  */
  readonly useDefault: boolean | cdktf.IResolvable;
  /**
  * normal_collector_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#normal_collector_config DeviceGroup#normal_collector_config}
  */
  readonly normalCollectorConfig?: DeviceGroupExtraServicesAPPSTREAMNormalCollectorConfig[] | cdktf.IResolvable;
}

export function deviceGroupExtraServicesAPPSTREAMToTerraform(struct?: DeviceGroupExtraServicesAPPSTREAM | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    custom_n_s_p_schedule: cdktf.stringToTerraform(struct!.customNSPSchedule),
    dead_operation: cdktf.stringToTerraform(struct!.deadOperation),
    device_display_name_template: cdktf.stringToTerraform(struct!.deviceDisplayNameTemplate),
    disable_stop_terminate_host_monitor: cdktf.booleanToTerraform(struct!.disableStopTerminateHostMonitor),
    disable_terminated_host_alerting: cdktf.booleanToTerraform(struct!.disableTerminatedHostAlerting),
    monitoring_region_infos: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.monitoringRegionInfos),
    monitoring_regions: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.monitoringRegions),
    name_filter: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.nameFilter),
    select_all: cdktf.booleanToTerraform(struct!.selectAll),
    tags: cdktf.listMapper(deviceGroupExtraServicesAPPSTREAMTagsToTerraform, false)(struct!.tags),
    use_default: cdktf.booleanToTerraform(struct!.useDefault),
    normal_collector_config: cdktf.listMapper(deviceGroupExtraServicesAPPSTREAMNormalCollectorConfigToTerraform, true)(struct!.normalCollectorConfig),
  }
}


export function deviceGroupExtraServicesAPPSTREAMToHclTerraform(struct?: DeviceGroupExtraServicesAPPSTREAM | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    custom_n_s_p_schedule: {
      value: cdktf.stringToHclTerraform(struct!.customNSPSchedule),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dead_operation: {
      value: cdktf.stringToHclTerraform(struct!.deadOperation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    device_display_name_template: {
      value: cdktf.stringToHclTerraform(struct!.deviceDisplayNameTemplate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disable_stop_terminate_host_monitor: {
      value: cdktf.booleanToHclTerraform(struct!.disableStopTerminateHostMonitor),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    disable_terminated_host_alerting: {
      value: cdktf.booleanToHclTerraform(struct!.disableTerminatedHostAlerting),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    monitoring_region_infos: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.monitoringRegionInfos),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    monitoring_regions: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.monitoringRegions),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    name_filter: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.nameFilter),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    select_all: {
      value: cdktf.booleanToHclTerraform(struct!.selectAll),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tags: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesAPPSTREAMTagsToHclTerraform, false)(struct!.tags),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesAPPSTREAMTagsList",
    },
    use_default: {
      value: cdktf.booleanToHclTerraform(struct!.useDefault),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    normal_collector_config: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesAPPSTREAMNormalCollectorConfigToHclTerraform, true)(struct!.normalCollectorConfig),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesAPPSTREAMNormalCollectorConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesAPPSTREAMOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesAPPSTREAM | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._customNSPSchedule !== undefined) {
      hasAnyValues = true;
      internalValueResult.customNSPSchedule = this._customNSPSchedule;
    }
    if (this._deadOperation !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadOperation = this._deadOperation;
    }
    if (this._deviceDisplayNameTemplate !== undefined) {
      hasAnyValues = true;
      internalValueResult.deviceDisplayNameTemplate = this._deviceDisplayNameTemplate;
    }
    if (this._disableStopTerminateHostMonitor !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableStopTerminateHostMonitor = this._disableStopTerminateHostMonitor;
    }
    if (this._disableTerminatedHostAlerting !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableTerminatedHostAlerting = this._disableTerminatedHostAlerting;
    }
    if (this._monitoringRegionInfos !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoringRegionInfos = this._monitoringRegionInfos;
    }
    if (this._monitoringRegions !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoringRegions = this._monitoringRegions;
    }
    if (this._nameFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.nameFilter = this._nameFilter;
    }
    if (this._selectAll !== undefined) {
      hasAnyValues = true;
      internalValueResult.selectAll = this._selectAll;
    }
    if (this._tags?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags?.internalValue;
    }
    if (this._useDefault !== undefined) {
      hasAnyValues = true;
      internalValueResult.useDefault = this._useDefault;
    }
    if (this._normalCollectorConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.normalCollectorConfig = this._normalCollectorConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesAPPSTREAM | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._customNSPSchedule = undefined;
      this._deadOperation = undefined;
      this._deviceDisplayNameTemplate = undefined;
      this._disableStopTerminateHostMonitor = undefined;
      this._disableTerminatedHostAlerting = undefined;
      this._monitoringRegionInfos = undefined;
      this._monitoringRegions = undefined;
      this._nameFilter = undefined;
      this._selectAll = undefined;
      this._tags.internalValue = undefined;
      this._useDefault = undefined;
      this._normalCollectorConfig.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._customNSPSchedule = value.customNSPSchedule;
      this._deadOperation = value.deadOperation;
      this._deviceDisplayNameTemplate = value.deviceDisplayNameTemplate;
      this._disableStopTerminateHostMonitor = value.disableStopTerminateHostMonitor;
      this._disableTerminatedHostAlerting = value.disableTerminatedHostAlerting;
      this._monitoringRegionInfos = value.monitoringRegionInfos;
      this._monitoringRegions = value.monitoringRegions;
      this._nameFilter = value.nameFilter;
      this._selectAll = value.selectAll;
      this._tags.internalValue = value.tags;
      this._useDefault = value.useDefault;
      this._normalCollectorConfig.internalValue = value.normalCollectorConfig;
    }
  }

  // custom_n_s_p_schedule - computed: false, optional: true, required: false
  private _customNSPSchedule?: string; 
  public get customNSPSchedule() {
    return this.getStringAttribute('custom_n_s_p_schedule');
  }
  public set customNSPSchedule(value: string) {
    this._customNSPSchedule = value;
  }
  public resetCustomNSPSchedule() {
    this._customNSPSchedule = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customNSPScheduleInput() {
    return this._customNSPSchedule;
  }

  // dead_operation - computed: false, optional: true, required: false
  private _deadOperation?: string; 
  public get deadOperation() {
    return this.getStringAttribute('dead_operation');
  }
  public set deadOperation(value: string) {
    this._deadOperation = value;
  }
  public resetDeadOperation() {
    this._deadOperation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadOperationInput() {
    return this._deadOperation;
  }

  // device_display_name_template - computed: false, optional: true, required: false
  private _deviceDisplayNameTemplate?: string; 
  public get deviceDisplayNameTemplate() {
    return this.getStringAttribute('device_display_name_template');
  }
  public set deviceDisplayNameTemplate(value: string) {
    this._deviceDisplayNameTemplate = value;
  }
  public resetDeviceDisplayNameTemplate() {
    this._deviceDisplayNameTemplate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deviceDisplayNameTemplateInput() {
    return this._deviceDisplayNameTemplate;
  }

  // disable_stop_terminate_host_monitor - computed: false, optional: true, required: false
  private _disableStopTerminateHostMonitor?: boolean | cdktf.IResolvable; 
  public get disableStopTerminateHostMonitor() {
    return this.getBooleanAttribute('disable_stop_terminate_host_monitor');
  }
  public set disableStopTerminateHostMonitor(value: boolean | cdktf.IResolvable) {
    this._disableStopTerminateHostMonitor = value;
  }
  public resetDisableStopTerminateHostMonitor() {
    this._disableStopTerminateHostMonitor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableStopTerminateHostMonitorInput() {
    return this._disableStopTerminateHostMonitor;
  }

  // disable_terminated_host_alerting - computed: false, optional: true, required: false
  private _disableTerminatedHostAlerting?: boolean | cdktf.IResolvable; 
  public get disableTerminatedHostAlerting() {
    return this.getBooleanAttribute('disable_terminated_host_alerting');
  }
  public set disableTerminatedHostAlerting(value: boolean | cdktf.IResolvable) {
    this._disableTerminatedHostAlerting = value;
  }
  public resetDisableTerminatedHostAlerting() {
    this._disableTerminatedHostAlerting = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableTerminatedHostAlertingInput() {
    return this._disableTerminatedHostAlerting;
  }

  // monitoring_region_infos - computed: false, optional: true, required: false
  private _monitoringRegionInfos?: string[]; 
  public get monitoringRegionInfos() {
    return cdktf.Fn.tolist(this.getListAttribute('monitoring_region_infos'));
  }
  public set monitoringRegionInfos(value: string[]) {
    this._monitoringRegionInfos = value;
  }
  public resetMonitoringRegionInfos() {
    this._monitoringRegionInfos = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoringRegionInfosInput() {
    return this._monitoringRegionInfos;
  }

  // monitoring_regions - computed: false, optional: true, required: false
  private _monitoringRegions?: string[]; 
  public get monitoringRegions() {
    return cdktf.Fn.tolist(this.getListAttribute('monitoring_regions'));
  }
  public set monitoringRegions(value: string[]) {
    this._monitoringRegions = value;
  }
  public resetMonitoringRegions() {
    this._monitoringRegions = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoringRegionsInput() {
    return this._monitoringRegions;
  }

  // name_filter - computed: false, optional: true, required: false
  private _nameFilter?: string[]; 
  public get nameFilter() {
    return cdktf.Fn.tolist(this.getListAttribute('name_filter'));
  }
  public set nameFilter(value: string[]) {
    this._nameFilter = value;
  }
  public resetNameFilter() {
    this._nameFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameFilterInput() {
    return this._nameFilter;
  }

  // select_all - computed: false, optional: true, required: false
  private _selectAll?: boolean | cdktf.IResolvable; 
  public get selectAll() {
    return this.getBooleanAttribute('select_all');
  }
  public set selectAll(value: boolean | cdktf.IResolvable) {
    this._selectAll = value;
  }
  public resetSelectAll() {
    this._selectAll = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectAllInput() {
    return this._selectAll;
  }

  // tags - computed: false, optional: true, required: false
  private _tags = new DeviceGroupExtraServicesAPPSTREAMTagsList(this, "tags", false);
  public get tags() {
    return this._tags;
  }
  public putTags(value: DeviceGroupExtraServicesAPPSTREAMTags[] | cdktf.IResolvable) {
    this._tags.internalValue = value;
  }
  public resetTags() {
    this._tags.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags.internalValue;
  }

  // use_default - computed: false, optional: false, required: true
  private _useDefault?: boolean | cdktf.IResolvable; 
  public get useDefault() {
    return this.getBooleanAttribute('use_default');
  }
  public set useDefault(value: boolean | cdktf.IResolvable) {
    this._useDefault = value;
  }
  // Temporarily expose input value. Use with caution.
  public get useDefaultInput() {
    return this._useDefault;
  }

  // normal_collector_config - computed: false, optional: true, required: false
  private _normalCollectorConfig = new DeviceGroupExtraServicesAPPSTREAMNormalCollectorConfigList(this, "normal_collector_config", false);
  public get normalCollectorConfig() {
    return this._normalCollectorConfig;
  }
  public putNormalCollectorConfig(value: DeviceGroupExtraServicesAPPSTREAMNormalCollectorConfig[] | cdktf.IResolvable) {
    this._normalCollectorConfig.internalValue = value;
  }
  public resetNormalCollectorConfig() {
    this._normalCollectorConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get normalCollectorConfigInput() {
    return this._normalCollectorConfig.internalValue;
  }
}

export class DeviceGroupExtraServicesAPPSTREAMList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesAPPSTREAM[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesAPPSTREAMOutputReference {
    return new DeviceGroupExtraServicesAPPSTREAMOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesATHENATags {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#name DeviceGroup#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#operation DeviceGroup#operation}
  */
  readonly operation?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#value DeviceGroup#value}
  */
  readonly value?: string;
}

export function deviceGroupExtraServicesATHENATagsToTerraform(struct?: DeviceGroupExtraServicesATHENATags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    operation: cdktf.stringToTerraform(struct!.operation),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function deviceGroupExtraServicesATHENATagsToHclTerraform(struct?: DeviceGroupExtraServicesATHENATags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operation: {
      value: cdktf.stringToHclTerraform(struct!.operation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesATHENATagsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesATHENATags | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._operation !== undefined) {
      hasAnyValues = true;
      internalValueResult.operation = this._operation;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesATHENATags | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._operation = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._operation = value.operation;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // operation - computed: false, optional: true, required: false
  private _operation?: string; 
  public get operation() {
    return this.getStringAttribute('operation');
  }
  public set operation(value: string) {
    this._operation = value;
  }
  public resetOperation() {
    this._operation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operationInput() {
    return this._operation;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DeviceGroupExtraServicesATHENATagsList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesATHENATags[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesATHENATagsOutputReference {
    return new DeviceGroupExtraServicesATHENATagsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesATHENANormalCollectorConfigCollectors {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#applies_to DeviceGroup#applies_to}
  */
  readonly appliesTo?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#auto_balanced_collector_group_id DeviceGroup#auto_balanced_collector_group_id}
  */
  readonly autoBalancedCollectorGroupId?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#collector_id DeviceGroup#collector_id}
  */
  readonly collectorId?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#priority DeviceGroup#priority}
  */
  readonly priority?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#use_public_ip DeviceGroup#use_public_ip}
  */
  readonly usePublicIp?: boolean | cdktf.IResolvable;
}

export function deviceGroupExtraServicesATHENANormalCollectorConfigCollectorsToTerraform(struct?: DeviceGroupExtraServicesATHENANormalCollectorConfigCollectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    applies_to: cdktf.stringToTerraform(struct!.appliesTo),
    auto_balanced_collector_group_id: cdktf.numberToTerraform(struct!.autoBalancedCollectorGroupId),
    collector_id: cdktf.numberToTerraform(struct!.collectorId),
    priority: cdktf.numberToTerraform(struct!.priority),
    use_public_ip: cdktf.booleanToTerraform(struct!.usePublicIp),
  }
}


export function deviceGroupExtraServicesATHENANormalCollectorConfigCollectorsToHclTerraform(struct?: DeviceGroupExtraServicesATHENANormalCollectorConfigCollectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    applies_to: {
      value: cdktf.stringToHclTerraform(struct!.appliesTo),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auto_balanced_collector_group_id: {
      value: cdktf.numberToHclTerraform(struct!.autoBalancedCollectorGroupId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    collector_id: {
      value: cdktf.numberToHclTerraform(struct!.collectorId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    priority: {
      value: cdktf.numberToHclTerraform(struct!.priority),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    use_public_ip: {
      value: cdktf.booleanToHclTerraform(struct!.usePublicIp),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesATHENANormalCollectorConfigCollectorsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesATHENANormalCollectorConfigCollectors | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._appliesTo !== undefined) {
      hasAnyValues = true;
      internalValueResult.appliesTo = this._appliesTo;
    }
    if (this._autoBalancedCollectorGroupId !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoBalancedCollectorGroupId = this._autoBalancedCollectorGroupId;
    }
    if (this._collectorId !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectorId = this._collectorId;
    }
    if (this._priority !== undefined) {
      hasAnyValues = true;
      internalValueResult.priority = this._priority;
    }
    if (this._usePublicIp !== undefined) {
      hasAnyValues = true;
      internalValueResult.usePublicIp = this._usePublicIp;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesATHENANormalCollectorConfigCollectors | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._appliesTo = undefined;
      this._autoBalancedCollectorGroupId = undefined;
      this._collectorId = undefined;
      this._priority = undefined;
      this._usePublicIp = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._appliesTo = value.appliesTo;
      this._autoBalancedCollectorGroupId = value.autoBalancedCollectorGroupId;
      this._collectorId = value.collectorId;
      this._priority = value.priority;
      this._usePublicIp = value.usePublicIp;
    }
  }

  // applies_to - computed: false, optional: true, required: false
  private _appliesTo?: string; 
  public get appliesTo() {
    return this.getStringAttribute('applies_to');
  }
  public set appliesTo(value: string) {
    this._appliesTo = value;
  }
  public resetAppliesTo() {
    this._appliesTo = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appliesToInput() {
    return this._appliesTo;
  }

  // auto_balanced_collector_group_id - computed: false, optional: true, required: false
  private _autoBalancedCollectorGroupId?: number; 
  public get autoBalancedCollectorGroupId() {
    return this.getNumberAttribute('auto_balanced_collector_group_id');
  }
  public set autoBalancedCollectorGroupId(value: number) {
    this._autoBalancedCollectorGroupId = value;
  }
  public resetAutoBalancedCollectorGroupId() {
    this._autoBalancedCollectorGroupId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoBalancedCollectorGroupIdInput() {
    return this._autoBalancedCollectorGroupId;
  }

  // collector_id - computed: false, optional: true, required: false
  private _collectorId?: number; 
  public get collectorId() {
    return this.getNumberAttribute('collector_id');
  }
  public set collectorId(value: number) {
    this._collectorId = value;
  }
  public resetCollectorId() {
    this._collectorId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorIdInput() {
    return this._collectorId;
  }

  // priority - computed: false, optional: true, required: false
  private _priority?: number; 
  public get priority() {
    return this.getNumberAttribute('priority');
  }
  public set priority(value: number) {
    this._priority = value;
  }
  public resetPriority() {
    this._priority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get priorityInput() {
    return this._priority;
  }

  // use_public_ip - computed: false, optional: true, required: false
  private _usePublicIp?: boolean | cdktf.IResolvable; 
  public get usePublicIp() {
    return this.getBooleanAttribute('use_public_ip');
  }
  public set usePublicIp(value: boolean | cdktf.IResolvable) {
    this._usePublicIp = value;
  }
  public resetUsePublicIp() {
    this._usePublicIp = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usePublicIpInput() {
    return this._usePublicIp;
  }
}

export class DeviceGroupExtraServicesATHENANormalCollectorConfigCollectorsList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesATHENANormalCollectorConfigCollectors[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesATHENANormalCollectorConfigCollectorsOutputReference {
    return new DeviceGroupExtraServicesATHENANormalCollectorConfigCollectorsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesATHENANormalCollectorConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#collectors DeviceGroup#collectors}
  */
  readonly collectors?: DeviceGroupExtraServicesATHENANormalCollectorConfigCollectors[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#enabled DeviceGroup#enabled}
  */
  readonly enabled: boolean | cdktf.IResolvable;
}

export function deviceGroupExtraServicesATHENANormalCollectorConfigToTerraform(struct?: DeviceGroupExtraServicesATHENANormalCollectorConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    collectors: cdktf.listMapper(deviceGroupExtraServicesATHENANormalCollectorConfigCollectorsToTerraform, false)(struct!.collectors),
    enabled: cdktf.booleanToTerraform(struct!.enabled),
  }
}


export function deviceGroupExtraServicesATHENANormalCollectorConfigToHclTerraform(struct?: DeviceGroupExtraServicesATHENANormalCollectorConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    collectors: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesATHENANormalCollectorConfigCollectorsToHclTerraform, false)(struct!.collectors),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesATHENANormalCollectorConfigCollectorsList",
    },
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesATHENANormalCollectorConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesATHENANormalCollectorConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._collectors?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectors = this._collectors?.internalValue;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesATHENANormalCollectorConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._collectors.internalValue = undefined;
      this._enabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._collectors.internalValue = value.collectors;
      this._enabled = value.enabled;
    }
  }

  // collectors - computed: false, optional: true, required: false
  private _collectors = new DeviceGroupExtraServicesATHENANormalCollectorConfigCollectorsList(this, "collectors", false);
  public get collectors() {
    return this._collectors;
  }
  public putCollectors(value: DeviceGroupExtraServicesATHENANormalCollectorConfigCollectors[] | cdktf.IResolvable) {
    this._collectors.internalValue = value;
  }
  public resetCollectors() {
    this._collectors.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorsInput() {
    return this._collectors.internalValue;
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }
}

export class DeviceGroupExtraServicesATHENANormalCollectorConfigList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesATHENANormalCollectorConfig[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesATHENANormalCollectorConfigOutputReference {
    return new DeviceGroupExtraServicesATHENANormalCollectorConfigOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesATHENA {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#custom_n_s_p_schedule DeviceGroup#custom_n_s_p_schedule}
  */
  readonly customNSPSchedule?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#dead_operation DeviceGroup#dead_operation}
  */
  readonly deadOperation?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#device_display_name_template DeviceGroup#device_display_name_template}
  */
  readonly deviceDisplayNameTemplate?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#disable_stop_terminate_host_monitor DeviceGroup#disable_stop_terminate_host_monitor}
  */
  readonly disableStopTerminateHostMonitor?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#disable_terminated_host_alerting DeviceGroup#disable_terminated_host_alerting}
  */
  readonly disableTerminatedHostAlerting?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#monitoring_region_infos DeviceGroup#monitoring_region_infos}
  */
  readonly monitoringRegionInfos?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#monitoring_regions DeviceGroup#monitoring_regions}
  */
  readonly monitoringRegions?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#name_filter DeviceGroup#name_filter}
  */
  readonly nameFilter?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#select_all DeviceGroup#select_all}
  */
  readonly selectAll?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#tags DeviceGroup#tags}
  */
  readonly tags?: DeviceGroupExtraServicesATHENATags[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#use_default DeviceGroup#use_default}
  */
  readonly useDefault: boolean | cdktf.IResolvable;
  /**
  * normal_collector_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#normal_collector_config DeviceGroup#normal_collector_config}
  */
  readonly normalCollectorConfig?: DeviceGroupExtraServicesATHENANormalCollectorConfig[] | cdktf.IResolvable;
}

export function deviceGroupExtraServicesATHENAToTerraform(struct?: DeviceGroupExtraServicesATHENA | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    custom_n_s_p_schedule: cdktf.stringToTerraform(struct!.customNSPSchedule),
    dead_operation: cdktf.stringToTerraform(struct!.deadOperation),
    device_display_name_template: cdktf.stringToTerraform(struct!.deviceDisplayNameTemplate),
    disable_stop_terminate_host_monitor: cdktf.booleanToTerraform(struct!.disableStopTerminateHostMonitor),
    disable_terminated_host_alerting: cdktf.booleanToTerraform(struct!.disableTerminatedHostAlerting),
    monitoring_region_infos: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.monitoringRegionInfos),
    monitoring_regions: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.monitoringRegions),
    name_filter: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.nameFilter),
    select_all: cdktf.booleanToTerraform(struct!.selectAll),
    tags: cdktf.listMapper(deviceGroupExtraServicesATHENATagsToTerraform, false)(struct!.tags),
    use_default: cdktf.booleanToTerraform(struct!.useDefault),
    normal_collector_config: cdktf.listMapper(deviceGroupExtraServicesATHENANormalCollectorConfigToTerraform, true)(struct!.normalCollectorConfig),
  }
}


export function deviceGroupExtraServicesATHENAToHclTerraform(struct?: DeviceGroupExtraServicesATHENA | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    custom_n_s_p_schedule: {
      value: cdktf.stringToHclTerraform(struct!.customNSPSchedule),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dead_operation: {
      value: cdktf.stringToHclTerraform(struct!.deadOperation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    device_display_name_template: {
      value: cdktf.stringToHclTerraform(struct!.deviceDisplayNameTemplate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disable_stop_terminate_host_monitor: {
      value: cdktf.booleanToHclTerraform(struct!.disableStopTerminateHostMonitor),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    disable_terminated_host_alerting: {
      value: cdktf.booleanToHclTerraform(struct!.disableTerminatedHostAlerting),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    monitoring_region_infos: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.monitoringRegionInfos),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    monitoring_regions: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.monitoringRegions),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    name_filter: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.nameFilter),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    select_all: {
      value: cdktf.booleanToHclTerraform(struct!.selectAll),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tags: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesATHENATagsToHclTerraform, false)(struct!.tags),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesATHENATagsList",
    },
    use_default: {
      value: cdktf.booleanToHclTerraform(struct!.useDefault),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    normal_collector_config: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesATHENANormalCollectorConfigToHclTerraform, true)(struct!.normalCollectorConfig),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesATHENANormalCollectorConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesATHENAOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesATHENA | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._customNSPSchedule !== undefined) {
      hasAnyValues = true;
      internalValueResult.customNSPSchedule = this._customNSPSchedule;
    }
    if (this._deadOperation !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadOperation = this._deadOperation;
    }
    if (this._deviceDisplayNameTemplate !== undefined) {
      hasAnyValues = true;
      internalValueResult.deviceDisplayNameTemplate = this._deviceDisplayNameTemplate;
    }
    if (this._disableStopTerminateHostMonitor !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableStopTerminateHostMonitor = this._disableStopTerminateHostMonitor;
    }
    if (this._disableTerminatedHostAlerting !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableTerminatedHostAlerting = this._disableTerminatedHostAlerting;
    }
    if (this._monitoringRegionInfos !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoringRegionInfos = this._monitoringRegionInfos;
    }
    if (this._monitoringRegions !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoringRegions = this._monitoringRegions;
    }
    if (this._nameFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.nameFilter = this._nameFilter;
    }
    if (this._selectAll !== undefined) {
      hasAnyValues = true;
      internalValueResult.selectAll = this._selectAll;
    }
    if (this._tags?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags?.internalValue;
    }
    if (this._useDefault !== undefined) {
      hasAnyValues = true;
      internalValueResult.useDefault = this._useDefault;
    }
    if (this._normalCollectorConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.normalCollectorConfig = this._normalCollectorConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesATHENA | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._customNSPSchedule = undefined;
      this._deadOperation = undefined;
      this._deviceDisplayNameTemplate = undefined;
      this._disableStopTerminateHostMonitor = undefined;
      this._disableTerminatedHostAlerting = undefined;
      this._monitoringRegionInfos = undefined;
      this._monitoringRegions = undefined;
      this._nameFilter = undefined;
      this._selectAll = undefined;
      this._tags.internalValue = undefined;
      this._useDefault = undefined;
      this._normalCollectorConfig.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._customNSPSchedule = value.customNSPSchedule;
      this._deadOperation = value.deadOperation;
      this._deviceDisplayNameTemplate = value.deviceDisplayNameTemplate;
      this._disableStopTerminateHostMonitor = value.disableStopTerminateHostMonitor;
      this._disableTerminatedHostAlerting = value.disableTerminatedHostAlerting;
      this._monitoringRegionInfos = value.monitoringRegionInfos;
      this._monitoringRegions = value.monitoringRegions;
      this._nameFilter = value.nameFilter;
      this._selectAll = value.selectAll;
      this._tags.internalValue = value.tags;
      this._useDefault = value.useDefault;
      this._normalCollectorConfig.internalValue = value.normalCollectorConfig;
    }
  }

  // custom_n_s_p_schedule - computed: false, optional: true, required: false
  private _customNSPSchedule?: string; 
  public get customNSPSchedule() {
    return this.getStringAttribute('custom_n_s_p_schedule');
  }
  public set customNSPSchedule(value: string) {
    this._customNSPSchedule = value;
  }
  public resetCustomNSPSchedule() {
    this._customNSPSchedule = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customNSPScheduleInput() {
    return this._customNSPSchedule;
  }

  // dead_operation - computed: false, optional: true, required: false
  private _deadOperation?: string; 
  public get deadOperation() {
    return this.getStringAttribute('dead_operation');
  }
  public set deadOperation(value: string) {
    this._deadOperation = value;
  }
  public resetDeadOperation() {
    this._deadOperation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadOperationInput() {
    return this._deadOperation;
  }

  // device_display_name_template - computed: false, optional: true, required: false
  private _deviceDisplayNameTemplate?: string; 
  public get deviceDisplayNameTemplate() {
    return this.getStringAttribute('device_display_name_template');
  }
  public set deviceDisplayNameTemplate(value: string) {
    this._deviceDisplayNameTemplate = value;
  }
  public resetDeviceDisplayNameTemplate() {
    this._deviceDisplayNameTemplate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deviceDisplayNameTemplateInput() {
    return this._deviceDisplayNameTemplate;
  }

  // disable_stop_terminate_host_monitor - computed: false, optional: true, required: false
  private _disableStopTerminateHostMonitor?: boolean | cdktf.IResolvable; 
  public get disableStopTerminateHostMonitor() {
    return this.getBooleanAttribute('disable_stop_terminate_host_monitor');
  }
  public set disableStopTerminateHostMonitor(value: boolean | cdktf.IResolvable) {
    this._disableStopTerminateHostMonitor = value;
  }
  public resetDisableStopTerminateHostMonitor() {
    this._disableStopTerminateHostMonitor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableStopTerminateHostMonitorInput() {
    return this._disableStopTerminateHostMonitor;
  }

  // disable_terminated_host_alerting - computed: false, optional: true, required: false
  private _disableTerminatedHostAlerting?: boolean | cdktf.IResolvable; 
  public get disableTerminatedHostAlerting() {
    return this.getBooleanAttribute('disable_terminated_host_alerting');
  }
  public set disableTerminatedHostAlerting(value: boolean | cdktf.IResolvable) {
    this._disableTerminatedHostAlerting = value;
  }
  public resetDisableTerminatedHostAlerting() {
    this._disableTerminatedHostAlerting = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableTerminatedHostAlertingInput() {
    return this._disableTerminatedHostAlerting;
  }

  // monitoring_region_infos - computed: false, optional: true, required: false
  private _monitoringRegionInfos?: string[]; 
  public get monitoringRegionInfos() {
    return cdktf.Fn.tolist(this.getListAttribute('monitoring_region_infos'));
  }
  public set monitoringRegionInfos(value: string[]) {
    this._monitoringRegionInfos = value;
  }
  public resetMonitoringRegionInfos() {
    this._monitoringRegionInfos = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoringRegionInfosInput() {
    return this._monitoringRegionInfos;
  }

  // monitoring_regions - computed: false, optional: true, required: false
  private _monitoringRegions?: string[]; 
  public get monitoringRegions() {
    return cdktf.Fn.tolist(this.getListAttribute('monitoring_regions'));
  }
  public set monitoringRegions(value: string[]) {
    this._monitoringRegions = value;
  }
  public resetMonitoringRegions() {
    this._monitoringRegions = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoringRegionsInput() {
    return this._monitoringRegions;
  }

  // name_filter - computed: false, optional: true, required: false
  private _nameFilter?: string[]; 
  public get nameFilter() {
    return cdktf.Fn.tolist(this.getListAttribute('name_filter'));
  }
  public set nameFilter(value: string[]) {
    this._nameFilter = value;
  }
  public resetNameFilter() {
    this._nameFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameFilterInput() {
    return this._nameFilter;
  }

  // select_all - computed: false, optional: true, required: false
  private _selectAll?: boolean | cdktf.IResolvable; 
  public get selectAll() {
    return this.getBooleanAttribute('select_all');
  }
  public set selectAll(value: boolean | cdktf.IResolvable) {
    this._selectAll = value;
  }
  public resetSelectAll() {
    this._selectAll = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectAllInput() {
    return this._selectAll;
  }

  // tags - computed: false, optional: true, required: false
  private _tags = new DeviceGroupExtraServicesATHENATagsList(this, "tags", false);
  public get tags() {
    return this._tags;
  }
  public putTags(value: DeviceGroupExtraServicesATHENATags[] | cdktf.IResolvable) {
    this._tags.internalValue = value;
  }
  public resetTags() {
    this._tags.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags.internalValue;
  }

  // use_default - computed: false, optional: false, required: true
  private _useDefault?: boolean | cdktf.IResolvable; 
  public get useDefault() {
    return this.getBooleanAttribute('use_default');
  }
  public set useDefault(value: boolean | cdktf.IResolvable) {
    this._useDefault = value;
  }
  // Temporarily expose input value. Use with caution.
  public get useDefaultInput() {
    return this._useDefault;
  }

  // normal_collector_config - computed: false, optional: true, required: false
  private _normalCollectorConfig = new DeviceGroupExtraServicesATHENANormalCollectorConfigList(this, "normal_collector_config", false);
  public get normalCollectorConfig() {
    return this._normalCollectorConfig;
  }
  public putNormalCollectorConfig(value: DeviceGroupExtraServicesATHENANormalCollectorConfig[] | cdktf.IResolvable) {
    this._normalCollectorConfig.internalValue = value;
  }
  public resetNormalCollectorConfig() {
    this._normalCollectorConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get normalCollectorConfigInput() {
    return this._normalCollectorConfig.internalValue;
  }
}

export class DeviceGroupExtraServicesATHENAList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesATHENA[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesATHENAOutputReference {
    return new DeviceGroupExtraServicesATHENAOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesAUTOMATIONACCOUNTTags {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#name DeviceGroup#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#operation DeviceGroup#operation}
  */
  readonly operation?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#value DeviceGroup#value}
  */
  readonly value?: string;
}

export function deviceGroupExtraServicesAUTOMATIONACCOUNTTagsToTerraform(struct?: DeviceGroupExtraServicesAUTOMATIONACCOUNTTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    operation: cdktf.stringToTerraform(struct!.operation),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function deviceGroupExtraServicesAUTOMATIONACCOUNTTagsToHclTerraform(struct?: DeviceGroupExtraServicesAUTOMATIONACCOUNTTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operation: {
      value: cdktf.stringToHclTerraform(struct!.operation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesAUTOMATIONACCOUNTTagsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesAUTOMATIONACCOUNTTags | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._operation !== undefined) {
      hasAnyValues = true;
      internalValueResult.operation = this._operation;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesAUTOMATIONACCOUNTTags | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._operation = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._operation = value.operation;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // operation - computed: false, optional: true, required: false
  private _operation?: string; 
  public get operation() {
    return this.getStringAttribute('operation');
  }
  public set operation(value: string) {
    this._operation = value;
  }
  public resetOperation() {
    this._operation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operationInput() {
    return this._operation;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DeviceGroupExtraServicesAUTOMATIONACCOUNTTagsList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesAUTOMATIONACCOUNTTags[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesAUTOMATIONACCOUNTTagsOutputReference {
    return new DeviceGroupExtraServicesAUTOMATIONACCOUNTTagsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesAUTOMATIONACCOUNTNormalCollectorConfigCollectors {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#applies_to DeviceGroup#applies_to}
  */
  readonly appliesTo?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#auto_balanced_collector_group_id DeviceGroup#auto_balanced_collector_group_id}
  */
  readonly autoBalancedCollectorGroupId?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#collector_id DeviceGroup#collector_id}
  */
  readonly collectorId?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#priority DeviceGroup#priority}
  */
  readonly priority?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#use_public_ip DeviceGroup#use_public_ip}
  */
  readonly usePublicIp?: boolean | cdktf.IResolvable;
}

export function deviceGroupExtraServicesAUTOMATIONACCOUNTNormalCollectorConfigCollectorsToTerraform(struct?: DeviceGroupExtraServicesAUTOMATIONACCOUNTNormalCollectorConfigCollectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    applies_to: cdktf.stringToTerraform(struct!.appliesTo),
    auto_balanced_collector_group_id: cdktf.numberToTerraform(struct!.autoBalancedCollectorGroupId),
    collector_id: cdktf.numberToTerraform(struct!.collectorId),
    priority: cdktf.numberToTerraform(struct!.priority),
    use_public_ip: cdktf.booleanToTerraform(struct!.usePublicIp),
  }
}


export function deviceGroupExtraServicesAUTOMATIONACCOUNTNormalCollectorConfigCollectorsToHclTerraform(struct?: DeviceGroupExtraServicesAUTOMATIONACCOUNTNormalCollectorConfigCollectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    applies_to: {
      value: cdktf.stringToHclTerraform(struct!.appliesTo),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auto_balanced_collector_group_id: {
      value: cdktf.numberToHclTerraform(struct!.autoBalancedCollectorGroupId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    collector_id: {
      value: cdktf.numberToHclTerraform(struct!.collectorId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    priority: {
      value: cdktf.numberToHclTerraform(struct!.priority),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    use_public_ip: {
      value: cdktf.booleanToHclTerraform(struct!.usePublicIp),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesAUTOMATIONACCOUNTNormalCollectorConfigCollectorsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesAUTOMATIONACCOUNTNormalCollectorConfigCollectors | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._appliesTo !== undefined) {
      hasAnyValues = true;
      internalValueResult.appliesTo = this._appliesTo;
    }
    if (this._autoBalancedCollectorGroupId !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoBalancedCollectorGroupId = this._autoBalancedCollectorGroupId;
    }
    if (this._collectorId !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectorId = this._collectorId;
    }
    if (this._priority !== undefined) {
      hasAnyValues = true;
      internalValueResult.priority = this._priority;
    }
    if (this._usePublicIp !== undefined) {
      hasAnyValues = true;
      internalValueResult.usePublicIp = this._usePublicIp;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesAUTOMATIONACCOUNTNormalCollectorConfigCollectors | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._appliesTo = undefined;
      this._autoBalancedCollectorGroupId = undefined;
      this._collectorId = undefined;
      this._priority = undefined;
      this._usePublicIp = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._appliesTo = value.appliesTo;
      this._autoBalancedCollectorGroupId = value.autoBalancedCollectorGroupId;
      this._collectorId = value.collectorId;
      this._priority = value.priority;
      this._usePublicIp = value.usePublicIp;
    }
  }

  // applies_to - computed: false, optional: true, required: false
  private _appliesTo?: string; 
  public get appliesTo() {
    return this.getStringAttribute('applies_to');
  }
  public set appliesTo(value: string) {
    this._appliesTo = value;
  }
  public resetAppliesTo() {
    this._appliesTo = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appliesToInput() {
    return this._appliesTo;
  }

  // auto_balanced_collector_group_id - computed: false, optional: true, required: false
  private _autoBalancedCollectorGroupId?: number; 
  public get autoBalancedCollectorGroupId() {
    return this.getNumberAttribute('auto_balanced_collector_group_id');
  }
  public set autoBalancedCollectorGroupId(value: number) {
    this._autoBalancedCollectorGroupId = value;
  }
  public resetAutoBalancedCollectorGroupId() {
    this._autoBalancedCollectorGroupId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoBalancedCollectorGroupIdInput() {
    return this._autoBalancedCollectorGroupId;
  }

  // collector_id - computed: false, optional: true, required: false
  private _collectorId?: number; 
  public get collectorId() {
    return this.getNumberAttribute('collector_id');
  }
  public set collectorId(value: number) {
    this._collectorId = value;
  }
  public resetCollectorId() {
    this._collectorId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorIdInput() {
    return this._collectorId;
  }

  // priority - computed: false, optional: true, required: false
  private _priority?: number; 
  public get priority() {
    return this.getNumberAttribute('priority');
  }
  public set priority(value: number) {
    this._priority = value;
  }
  public resetPriority() {
    this._priority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get priorityInput() {
    return this._priority;
  }

  // use_public_ip - computed: false, optional: true, required: false
  private _usePublicIp?: boolean | cdktf.IResolvable; 
  public get usePublicIp() {
    return this.getBooleanAttribute('use_public_ip');
  }
  public set usePublicIp(value: boolean | cdktf.IResolvable) {
    this._usePublicIp = value;
  }
  public resetUsePublicIp() {
    this._usePublicIp = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usePublicIpInput() {
    return this._usePublicIp;
  }
}

export class DeviceGroupExtraServicesAUTOMATIONACCOUNTNormalCollectorConfigCollectorsList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesAUTOMATIONACCOUNTNormalCollectorConfigCollectors[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesAUTOMATIONACCOUNTNormalCollectorConfigCollectorsOutputReference {
    return new DeviceGroupExtraServicesAUTOMATIONACCOUNTNormalCollectorConfigCollectorsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesAUTOMATIONACCOUNTNormalCollectorConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#collectors DeviceGroup#collectors}
  */
  readonly collectors?: DeviceGroupExtraServicesAUTOMATIONACCOUNTNormalCollectorConfigCollectors[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#enabled DeviceGroup#enabled}
  */
  readonly enabled: boolean | cdktf.IResolvable;
}

export function deviceGroupExtraServicesAUTOMATIONACCOUNTNormalCollectorConfigToTerraform(struct?: DeviceGroupExtraServicesAUTOMATIONACCOUNTNormalCollectorConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    collectors: cdktf.listMapper(deviceGroupExtraServicesAUTOMATIONACCOUNTNormalCollectorConfigCollectorsToTerraform, false)(struct!.collectors),
    enabled: cdktf.booleanToTerraform(struct!.enabled),
  }
}


export function deviceGroupExtraServicesAUTOMATIONACCOUNTNormalCollectorConfigToHclTerraform(struct?: DeviceGroupExtraServicesAUTOMATIONACCOUNTNormalCollectorConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    collectors: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesAUTOMATIONACCOUNTNormalCollectorConfigCollectorsToHclTerraform, false)(struct!.collectors),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesAUTOMATIONACCOUNTNormalCollectorConfigCollectorsList",
    },
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesAUTOMATIONACCOUNTNormalCollectorConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesAUTOMATIONACCOUNTNormalCollectorConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._collectors?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectors = this._collectors?.internalValue;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesAUTOMATIONACCOUNTNormalCollectorConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._collectors.internalValue = undefined;
      this._enabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._collectors.internalValue = value.collectors;
      this._enabled = value.enabled;
    }
  }

  // collectors - computed: false, optional: true, required: false
  private _collectors = new DeviceGroupExtraServicesAUTOMATIONACCOUNTNormalCollectorConfigCollectorsList(this, "collectors", false);
  public get collectors() {
    return this._collectors;
  }
  public putCollectors(value: DeviceGroupExtraServicesAUTOMATIONACCOUNTNormalCollectorConfigCollectors[] | cdktf.IResolvable) {
    this._collectors.internalValue = value;
  }
  public resetCollectors() {
    this._collectors.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorsInput() {
    return this._collectors.internalValue;
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }
}

export class DeviceGroupExtraServicesAUTOMATIONACCOUNTNormalCollectorConfigList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesAUTOMATIONACCOUNTNormalCollectorConfig[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesAUTOMATIONACCOUNTNormalCollectorConfigOutputReference {
    return new DeviceGroupExtraServicesAUTOMATIONACCOUNTNormalCollectorConfigOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesAUTOMATIONACCOUNT {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#custom_n_s_p_schedule DeviceGroup#custom_n_s_p_schedule}
  */
  readonly customNSPSchedule?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#dead_operation DeviceGroup#dead_operation}
  */
  readonly deadOperation?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#device_display_name_template DeviceGroup#device_display_name_template}
  */
  readonly deviceDisplayNameTemplate?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#disable_stop_terminate_host_monitor DeviceGroup#disable_stop_terminate_host_monitor}
  */
  readonly disableStopTerminateHostMonitor?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#disable_terminated_host_alerting DeviceGroup#disable_terminated_host_alerting}
  */
  readonly disableTerminatedHostAlerting?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#monitoring_region_infos DeviceGroup#monitoring_region_infos}
  */
  readonly monitoringRegionInfos?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#monitoring_regions DeviceGroup#monitoring_regions}
  */
  readonly monitoringRegions?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#name_filter DeviceGroup#name_filter}
  */
  readonly nameFilter?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#select_all DeviceGroup#select_all}
  */
  readonly selectAll?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#tags DeviceGroup#tags}
  */
  readonly tags?: DeviceGroupExtraServicesAUTOMATIONACCOUNTTags[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#use_default DeviceGroup#use_default}
  */
  readonly useDefault: boolean | cdktf.IResolvable;
  /**
  * normal_collector_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#normal_collector_config DeviceGroup#normal_collector_config}
  */
  readonly normalCollectorConfig?: DeviceGroupExtraServicesAUTOMATIONACCOUNTNormalCollectorConfig[] | cdktf.IResolvable;
}

export function deviceGroupExtraServicesAUTOMATIONACCOUNTToTerraform(struct?: DeviceGroupExtraServicesAUTOMATIONACCOUNT | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    custom_n_s_p_schedule: cdktf.stringToTerraform(struct!.customNSPSchedule),
    dead_operation: cdktf.stringToTerraform(struct!.deadOperation),
    device_display_name_template: cdktf.stringToTerraform(struct!.deviceDisplayNameTemplate),
    disable_stop_terminate_host_monitor: cdktf.booleanToTerraform(struct!.disableStopTerminateHostMonitor),
    disable_terminated_host_alerting: cdktf.booleanToTerraform(struct!.disableTerminatedHostAlerting),
    monitoring_region_infos: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.monitoringRegionInfos),
    monitoring_regions: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.monitoringRegions),
    name_filter: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.nameFilter),
    select_all: cdktf.booleanToTerraform(struct!.selectAll),
    tags: cdktf.listMapper(deviceGroupExtraServicesAUTOMATIONACCOUNTTagsToTerraform, false)(struct!.tags),
    use_default: cdktf.booleanToTerraform(struct!.useDefault),
    normal_collector_config: cdktf.listMapper(deviceGroupExtraServicesAUTOMATIONACCOUNTNormalCollectorConfigToTerraform, true)(struct!.normalCollectorConfig),
  }
}


export function deviceGroupExtraServicesAUTOMATIONACCOUNTToHclTerraform(struct?: DeviceGroupExtraServicesAUTOMATIONACCOUNT | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    custom_n_s_p_schedule: {
      value: cdktf.stringToHclTerraform(struct!.customNSPSchedule),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dead_operation: {
      value: cdktf.stringToHclTerraform(struct!.deadOperation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    device_display_name_template: {
      value: cdktf.stringToHclTerraform(struct!.deviceDisplayNameTemplate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disable_stop_terminate_host_monitor: {
      value: cdktf.booleanToHclTerraform(struct!.disableStopTerminateHostMonitor),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    disable_terminated_host_alerting: {
      value: cdktf.booleanToHclTerraform(struct!.disableTerminatedHostAlerting),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    monitoring_region_infos: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.monitoringRegionInfos),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    monitoring_regions: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.monitoringRegions),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    name_filter: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.nameFilter),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    select_all: {
      value: cdktf.booleanToHclTerraform(struct!.selectAll),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tags: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesAUTOMATIONACCOUNTTagsToHclTerraform, false)(struct!.tags),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesAUTOMATIONACCOUNTTagsList",
    },
    use_default: {
      value: cdktf.booleanToHclTerraform(struct!.useDefault),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    normal_collector_config: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesAUTOMATIONACCOUNTNormalCollectorConfigToHclTerraform, true)(struct!.normalCollectorConfig),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesAUTOMATIONACCOUNTNormalCollectorConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesAUTOMATIONACCOUNTOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesAUTOMATIONACCOUNT | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._customNSPSchedule !== undefined) {
      hasAnyValues = true;
      internalValueResult.customNSPSchedule = this._customNSPSchedule;
    }
    if (this._deadOperation !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadOperation = this._deadOperation;
    }
    if (this._deviceDisplayNameTemplate !== undefined) {
      hasAnyValues = true;
      internalValueResult.deviceDisplayNameTemplate = this._deviceDisplayNameTemplate;
    }
    if (this._disableStopTerminateHostMonitor !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableStopTerminateHostMonitor = this._disableStopTerminateHostMonitor;
    }
    if (this._disableTerminatedHostAlerting !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableTerminatedHostAlerting = this._disableTerminatedHostAlerting;
    }
    if (this._monitoringRegionInfos !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoringRegionInfos = this._monitoringRegionInfos;
    }
    if (this._monitoringRegions !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoringRegions = this._monitoringRegions;
    }
    if (this._nameFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.nameFilter = this._nameFilter;
    }
    if (this._selectAll !== undefined) {
      hasAnyValues = true;
      internalValueResult.selectAll = this._selectAll;
    }
    if (this._tags?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags?.internalValue;
    }
    if (this._useDefault !== undefined) {
      hasAnyValues = true;
      internalValueResult.useDefault = this._useDefault;
    }
    if (this._normalCollectorConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.normalCollectorConfig = this._normalCollectorConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesAUTOMATIONACCOUNT | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._customNSPSchedule = undefined;
      this._deadOperation = undefined;
      this._deviceDisplayNameTemplate = undefined;
      this._disableStopTerminateHostMonitor = undefined;
      this._disableTerminatedHostAlerting = undefined;
      this._monitoringRegionInfos = undefined;
      this._monitoringRegions = undefined;
      this._nameFilter = undefined;
      this._selectAll = undefined;
      this._tags.internalValue = undefined;
      this._useDefault = undefined;
      this._normalCollectorConfig.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._customNSPSchedule = value.customNSPSchedule;
      this._deadOperation = value.deadOperation;
      this._deviceDisplayNameTemplate = value.deviceDisplayNameTemplate;
      this._disableStopTerminateHostMonitor = value.disableStopTerminateHostMonitor;
      this._disableTerminatedHostAlerting = value.disableTerminatedHostAlerting;
      this._monitoringRegionInfos = value.monitoringRegionInfos;
      this._monitoringRegions = value.monitoringRegions;
      this._nameFilter = value.nameFilter;
      this._selectAll = value.selectAll;
      this._tags.internalValue = value.tags;
      this._useDefault = value.useDefault;
      this._normalCollectorConfig.internalValue = value.normalCollectorConfig;
    }
  }

  // custom_n_s_p_schedule - computed: false, optional: true, required: false
  private _customNSPSchedule?: string; 
  public get customNSPSchedule() {
    return this.getStringAttribute('custom_n_s_p_schedule');
  }
  public set customNSPSchedule(value: string) {
    this._customNSPSchedule = value;
  }
  public resetCustomNSPSchedule() {
    this._customNSPSchedule = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customNSPScheduleInput() {
    return this._customNSPSchedule;
  }

  // dead_operation - computed: false, optional: true, required: false
  private _deadOperation?: string; 
  public get deadOperation() {
    return this.getStringAttribute('dead_operation');
  }
  public set deadOperation(value: string) {
    this._deadOperation = value;
  }
  public resetDeadOperation() {
    this._deadOperation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadOperationInput() {
    return this._deadOperation;
  }

  // device_display_name_template - computed: false, optional: true, required: false
  private _deviceDisplayNameTemplate?: string; 
  public get deviceDisplayNameTemplate() {
    return this.getStringAttribute('device_display_name_template');
  }
  public set deviceDisplayNameTemplate(value: string) {
    this._deviceDisplayNameTemplate = value;
  }
  public resetDeviceDisplayNameTemplate() {
    this._deviceDisplayNameTemplate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deviceDisplayNameTemplateInput() {
    return this._deviceDisplayNameTemplate;
  }

  // disable_stop_terminate_host_monitor - computed: false, optional: true, required: false
  private _disableStopTerminateHostMonitor?: boolean | cdktf.IResolvable; 
  public get disableStopTerminateHostMonitor() {
    return this.getBooleanAttribute('disable_stop_terminate_host_monitor');
  }
  public set disableStopTerminateHostMonitor(value: boolean | cdktf.IResolvable) {
    this._disableStopTerminateHostMonitor = value;
  }
  public resetDisableStopTerminateHostMonitor() {
    this._disableStopTerminateHostMonitor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableStopTerminateHostMonitorInput() {
    return this._disableStopTerminateHostMonitor;
  }

  // disable_terminated_host_alerting - computed: false, optional: true, required: false
  private _disableTerminatedHostAlerting?: boolean | cdktf.IResolvable; 
  public get disableTerminatedHostAlerting() {
    return this.getBooleanAttribute('disable_terminated_host_alerting');
  }
  public set disableTerminatedHostAlerting(value: boolean | cdktf.IResolvable) {
    this._disableTerminatedHostAlerting = value;
  }
  public resetDisableTerminatedHostAlerting() {
    this._disableTerminatedHostAlerting = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableTerminatedHostAlertingInput() {
    return this._disableTerminatedHostAlerting;
  }

  // monitoring_region_infos - computed: false, optional: true, required: false
  private _monitoringRegionInfos?: string[]; 
  public get monitoringRegionInfos() {
    return cdktf.Fn.tolist(this.getListAttribute('monitoring_region_infos'));
  }
  public set monitoringRegionInfos(value: string[]) {
    this._monitoringRegionInfos = value;
  }
  public resetMonitoringRegionInfos() {
    this._monitoringRegionInfos = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoringRegionInfosInput() {
    return this._monitoringRegionInfos;
  }

  // monitoring_regions - computed: false, optional: true, required: false
  private _monitoringRegions?: string[]; 
  public get monitoringRegions() {
    return cdktf.Fn.tolist(this.getListAttribute('monitoring_regions'));
  }
  public set monitoringRegions(value: string[]) {
    this._monitoringRegions = value;
  }
  public resetMonitoringRegions() {
    this._monitoringRegions = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoringRegionsInput() {
    return this._monitoringRegions;
  }

  // name_filter - computed: false, optional: true, required: false
  private _nameFilter?: string[]; 
  public get nameFilter() {
    return cdktf.Fn.tolist(this.getListAttribute('name_filter'));
  }
  public set nameFilter(value: string[]) {
    this._nameFilter = value;
  }
  public resetNameFilter() {
    this._nameFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameFilterInput() {
    return this._nameFilter;
  }

  // select_all - computed: false, optional: true, required: false
  private _selectAll?: boolean | cdktf.IResolvable; 
  public get selectAll() {
    return this.getBooleanAttribute('select_all');
  }
  public set selectAll(value: boolean | cdktf.IResolvable) {
    this._selectAll = value;
  }
  public resetSelectAll() {
    this._selectAll = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectAllInput() {
    return this._selectAll;
  }

  // tags - computed: false, optional: true, required: false
  private _tags = new DeviceGroupExtraServicesAUTOMATIONACCOUNTTagsList(this, "tags", false);
  public get tags() {
    return this._tags;
  }
  public putTags(value: DeviceGroupExtraServicesAUTOMATIONACCOUNTTags[] | cdktf.IResolvable) {
    this._tags.internalValue = value;
  }
  public resetTags() {
    this._tags.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags.internalValue;
  }

  // use_default - computed: false, optional: false, required: true
  private _useDefault?: boolean | cdktf.IResolvable; 
  public get useDefault() {
    return this.getBooleanAttribute('use_default');
  }
  public set useDefault(value: boolean | cdktf.IResolvable) {
    this._useDefault = value;
  }
  // Temporarily expose input value. Use with caution.
  public get useDefaultInput() {
    return this._useDefault;
  }

  // normal_collector_config - computed: false, optional: true, required: false
  private _normalCollectorConfig = new DeviceGroupExtraServicesAUTOMATIONACCOUNTNormalCollectorConfigList(this, "normal_collector_config", false);
  public get normalCollectorConfig() {
    return this._normalCollectorConfig;
  }
  public putNormalCollectorConfig(value: DeviceGroupExtraServicesAUTOMATIONACCOUNTNormalCollectorConfig[] | cdktf.IResolvable) {
    this._normalCollectorConfig.internalValue = value;
  }
  public resetNormalCollectorConfig() {
    this._normalCollectorConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get normalCollectorConfigInput() {
    return this._normalCollectorConfig.internalValue;
  }
}

export class DeviceGroupExtraServicesAUTOMATIONACCOUNTList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesAUTOMATIONACCOUNT[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesAUTOMATIONACCOUNTOutputReference {
    return new DeviceGroupExtraServicesAUTOMATIONACCOUNTOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesAUTOSCALINGTags {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#name DeviceGroup#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#operation DeviceGroup#operation}
  */
  readonly operation?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#value DeviceGroup#value}
  */
  readonly value?: string;
}

export function deviceGroupExtraServicesAUTOSCALINGTagsToTerraform(struct?: DeviceGroupExtraServicesAUTOSCALINGTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    operation: cdktf.stringToTerraform(struct!.operation),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function deviceGroupExtraServicesAUTOSCALINGTagsToHclTerraform(struct?: DeviceGroupExtraServicesAUTOSCALINGTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operation: {
      value: cdktf.stringToHclTerraform(struct!.operation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesAUTOSCALINGTagsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesAUTOSCALINGTags | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._operation !== undefined) {
      hasAnyValues = true;
      internalValueResult.operation = this._operation;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesAUTOSCALINGTags | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._operation = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._operation = value.operation;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // operation - computed: false, optional: true, required: false
  private _operation?: string; 
  public get operation() {
    return this.getStringAttribute('operation');
  }
  public set operation(value: string) {
    this._operation = value;
  }
  public resetOperation() {
    this._operation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operationInput() {
    return this._operation;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DeviceGroupExtraServicesAUTOSCALINGTagsList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesAUTOSCALINGTags[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesAUTOSCALINGTagsOutputReference {
    return new DeviceGroupExtraServicesAUTOSCALINGTagsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesAUTOSCALINGNormalCollectorConfigCollectors {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#applies_to DeviceGroup#applies_to}
  */
  readonly appliesTo?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#auto_balanced_collector_group_id DeviceGroup#auto_balanced_collector_group_id}
  */
  readonly autoBalancedCollectorGroupId?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#collector_id DeviceGroup#collector_id}
  */
  readonly collectorId?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#priority DeviceGroup#priority}
  */
  readonly priority?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#use_public_ip DeviceGroup#use_public_ip}
  */
  readonly usePublicIp?: boolean | cdktf.IResolvable;
}

export function deviceGroupExtraServicesAUTOSCALINGNormalCollectorConfigCollectorsToTerraform(struct?: DeviceGroupExtraServicesAUTOSCALINGNormalCollectorConfigCollectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    applies_to: cdktf.stringToTerraform(struct!.appliesTo),
    auto_balanced_collector_group_id: cdktf.numberToTerraform(struct!.autoBalancedCollectorGroupId),
    collector_id: cdktf.numberToTerraform(struct!.collectorId),
    priority: cdktf.numberToTerraform(struct!.priority),
    use_public_ip: cdktf.booleanToTerraform(struct!.usePublicIp),
  }
}


export function deviceGroupExtraServicesAUTOSCALINGNormalCollectorConfigCollectorsToHclTerraform(struct?: DeviceGroupExtraServicesAUTOSCALINGNormalCollectorConfigCollectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    applies_to: {
      value: cdktf.stringToHclTerraform(struct!.appliesTo),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auto_balanced_collector_group_id: {
      value: cdktf.numberToHclTerraform(struct!.autoBalancedCollectorGroupId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    collector_id: {
      value: cdktf.numberToHclTerraform(struct!.collectorId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    priority: {
      value: cdktf.numberToHclTerraform(struct!.priority),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    use_public_ip: {
      value: cdktf.booleanToHclTerraform(struct!.usePublicIp),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesAUTOSCALINGNormalCollectorConfigCollectorsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesAUTOSCALINGNormalCollectorConfigCollectors | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._appliesTo !== undefined) {
      hasAnyValues = true;
      internalValueResult.appliesTo = this._appliesTo;
    }
    if (this._autoBalancedCollectorGroupId !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoBalancedCollectorGroupId = this._autoBalancedCollectorGroupId;
    }
    if (this._collectorId !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectorId = this._collectorId;
    }
    if (this._priority !== undefined) {
      hasAnyValues = true;
      internalValueResult.priority = this._priority;
    }
    if (this._usePublicIp !== undefined) {
      hasAnyValues = true;
      internalValueResult.usePublicIp = this._usePublicIp;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesAUTOSCALINGNormalCollectorConfigCollectors | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._appliesTo = undefined;
      this._autoBalancedCollectorGroupId = undefined;
      this._collectorId = undefined;
      this._priority = undefined;
      this._usePublicIp = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._appliesTo = value.appliesTo;
      this._autoBalancedCollectorGroupId = value.autoBalancedCollectorGroupId;
      this._collectorId = value.collectorId;
      this._priority = value.priority;
      this._usePublicIp = value.usePublicIp;
    }
  }

  // applies_to - computed: false, optional: true, required: false
  private _appliesTo?: string; 
  public get appliesTo() {
    return this.getStringAttribute('applies_to');
  }
  public set appliesTo(value: string) {
    this._appliesTo = value;
  }
  public resetAppliesTo() {
    this._appliesTo = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appliesToInput() {
    return this._appliesTo;
  }

  // auto_balanced_collector_group_id - computed: false, optional: true, required: false
  private _autoBalancedCollectorGroupId?: number; 
  public get autoBalancedCollectorGroupId() {
    return this.getNumberAttribute('auto_balanced_collector_group_id');
  }
  public set autoBalancedCollectorGroupId(value: number) {
    this._autoBalancedCollectorGroupId = value;
  }
  public resetAutoBalancedCollectorGroupId() {
    this._autoBalancedCollectorGroupId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoBalancedCollectorGroupIdInput() {
    return this._autoBalancedCollectorGroupId;
  }

  // collector_id - computed: false, optional: true, required: false
  private _collectorId?: number; 
  public get collectorId() {
    return this.getNumberAttribute('collector_id');
  }
  public set collectorId(value: number) {
    this._collectorId = value;
  }
  public resetCollectorId() {
    this._collectorId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorIdInput() {
    return this._collectorId;
  }

  // priority - computed: false, optional: true, required: false
  private _priority?: number; 
  public get priority() {
    return this.getNumberAttribute('priority');
  }
  public set priority(value: number) {
    this._priority = value;
  }
  public resetPriority() {
    this._priority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get priorityInput() {
    return this._priority;
  }

  // use_public_ip - computed: false, optional: true, required: false
  private _usePublicIp?: boolean | cdktf.IResolvable; 
  public get usePublicIp() {
    return this.getBooleanAttribute('use_public_ip');
  }
  public set usePublicIp(value: boolean | cdktf.IResolvable) {
    this._usePublicIp = value;
  }
  public resetUsePublicIp() {
    this._usePublicIp = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usePublicIpInput() {
    return this._usePublicIp;
  }
}

export class DeviceGroupExtraServicesAUTOSCALINGNormalCollectorConfigCollectorsList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesAUTOSCALINGNormalCollectorConfigCollectors[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesAUTOSCALINGNormalCollectorConfigCollectorsOutputReference {
    return new DeviceGroupExtraServicesAUTOSCALINGNormalCollectorConfigCollectorsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesAUTOSCALINGNormalCollectorConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#collectors DeviceGroup#collectors}
  */
  readonly collectors?: DeviceGroupExtraServicesAUTOSCALINGNormalCollectorConfigCollectors[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#enabled DeviceGroup#enabled}
  */
  readonly enabled: boolean | cdktf.IResolvable;
}

export function deviceGroupExtraServicesAUTOSCALINGNormalCollectorConfigToTerraform(struct?: DeviceGroupExtraServicesAUTOSCALINGNormalCollectorConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    collectors: cdktf.listMapper(deviceGroupExtraServicesAUTOSCALINGNormalCollectorConfigCollectorsToTerraform, false)(struct!.collectors),
    enabled: cdktf.booleanToTerraform(struct!.enabled),
  }
}


export function deviceGroupExtraServicesAUTOSCALINGNormalCollectorConfigToHclTerraform(struct?: DeviceGroupExtraServicesAUTOSCALINGNormalCollectorConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    collectors: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesAUTOSCALINGNormalCollectorConfigCollectorsToHclTerraform, false)(struct!.collectors),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesAUTOSCALINGNormalCollectorConfigCollectorsList",
    },
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesAUTOSCALINGNormalCollectorConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesAUTOSCALINGNormalCollectorConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._collectors?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectors = this._collectors?.internalValue;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesAUTOSCALINGNormalCollectorConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._collectors.internalValue = undefined;
      this._enabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._collectors.internalValue = value.collectors;
      this._enabled = value.enabled;
    }
  }

  // collectors - computed: false, optional: true, required: false
  private _collectors = new DeviceGroupExtraServicesAUTOSCALINGNormalCollectorConfigCollectorsList(this, "collectors", false);
  public get collectors() {
    return this._collectors;
  }
  public putCollectors(value: DeviceGroupExtraServicesAUTOSCALINGNormalCollectorConfigCollectors[] | cdktf.IResolvable) {
    this._collectors.internalValue = value;
  }
  public resetCollectors() {
    this._collectors.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorsInput() {
    return this._collectors.internalValue;
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }
}

export class DeviceGroupExtraServicesAUTOSCALINGNormalCollectorConfigList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesAUTOSCALINGNormalCollectorConfig[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesAUTOSCALINGNormalCollectorConfigOutputReference {
    return new DeviceGroupExtraServicesAUTOSCALINGNormalCollectorConfigOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesAUTOSCALING {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#custom_n_s_p_schedule DeviceGroup#custom_n_s_p_schedule}
  */
  readonly customNSPSchedule?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#dead_operation DeviceGroup#dead_operation}
  */
  readonly deadOperation?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#device_display_name_template DeviceGroup#device_display_name_template}
  */
  readonly deviceDisplayNameTemplate?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#disable_stop_terminate_host_monitor DeviceGroup#disable_stop_terminate_host_monitor}
  */
  readonly disableStopTerminateHostMonitor?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#disable_terminated_host_alerting DeviceGroup#disable_terminated_host_alerting}
  */
  readonly disableTerminatedHostAlerting?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#monitoring_region_infos DeviceGroup#monitoring_region_infos}
  */
  readonly monitoringRegionInfos?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#monitoring_regions DeviceGroup#monitoring_regions}
  */
  readonly monitoringRegions?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#name_filter DeviceGroup#name_filter}
  */
  readonly nameFilter?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#select_all DeviceGroup#select_all}
  */
  readonly selectAll?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#tags DeviceGroup#tags}
  */
  readonly tags?: DeviceGroupExtraServicesAUTOSCALINGTags[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#use_default DeviceGroup#use_default}
  */
  readonly useDefault: boolean | cdktf.IResolvable;
  /**
  * normal_collector_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#normal_collector_config DeviceGroup#normal_collector_config}
  */
  readonly normalCollectorConfig?: DeviceGroupExtraServicesAUTOSCALINGNormalCollectorConfig[] | cdktf.IResolvable;
}

export function deviceGroupExtraServicesAUTOSCALINGToTerraform(struct?: DeviceGroupExtraServicesAUTOSCALING | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    custom_n_s_p_schedule: cdktf.stringToTerraform(struct!.customNSPSchedule),
    dead_operation: cdktf.stringToTerraform(struct!.deadOperation),
    device_display_name_template: cdktf.stringToTerraform(struct!.deviceDisplayNameTemplate),
    disable_stop_terminate_host_monitor: cdktf.booleanToTerraform(struct!.disableStopTerminateHostMonitor),
    disable_terminated_host_alerting: cdktf.booleanToTerraform(struct!.disableTerminatedHostAlerting),
    monitoring_region_infos: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.monitoringRegionInfos),
    monitoring_regions: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.monitoringRegions),
    name_filter: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.nameFilter),
    select_all: cdktf.booleanToTerraform(struct!.selectAll),
    tags: cdktf.listMapper(deviceGroupExtraServicesAUTOSCALINGTagsToTerraform, false)(struct!.tags),
    use_default: cdktf.booleanToTerraform(struct!.useDefault),
    normal_collector_config: cdktf.listMapper(deviceGroupExtraServicesAUTOSCALINGNormalCollectorConfigToTerraform, true)(struct!.normalCollectorConfig),
  }
}


export function deviceGroupExtraServicesAUTOSCALINGToHclTerraform(struct?: DeviceGroupExtraServicesAUTOSCALING | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    custom_n_s_p_schedule: {
      value: cdktf.stringToHclTerraform(struct!.customNSPSchedule),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dead_operation: {
      value: cdktf.stringToHclTerraform(struct!.deadOperation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    device_display_name_template: {
      value: cdktf.stringToHclTerraform(struct!.deviceDisplayNameTemplate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disable_stop_terminate_host_monitor: {
      value: cdktf.booleanToHclTerraform(struct!.disableStopTerminateHostMonitor),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    disable_terminated_host_alerting: {
      value: cdktf.booleanToHclTerraform(struct!.disableTerminatedHostAlerting),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    monitoring_region_infos: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.monitoringRegionInfos),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    monitoring_regions: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.monitoringRegions),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    name_filter: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.nameFilter),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    select_all: {
      value: cdktf.booleanToHclTerraform(struct!.selectAll),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tags: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesAUTOSCALINGTagsToHclTerraform, false)(struct!.tags),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesAUTOSCALINGTagsList",
    },
    use_default: {
      value: cdktf.booleanToHclTerraform(struct!.useDefault),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    normal_collector_config: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesAUTOSCALINGNormalCollectorConfigToHclTerraform, true)(struct!.normalCollectorConfig),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesAUTOSCALINGNormalCollectorConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesAUTOSCALINGOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesAUTOSCALING | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._customNSPSchedule !== undefined) {
      hasAnyValues = true;
      internalValueResult.customNSPSchedule = this._customNSPSchedule;
    }
    if (this._deadOperation !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadOperation = this._deadOperation;
    }
    if (this._deviceDisplayNameTemplate !== undefined) {
      hasAnyValues = true;
      internalValueResult.deviceDisplayNameTemplate = this._deviceDisplayNameTemplate;
    }
    if (this._disableStopTerminateHostMonitor !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableStopTerminateHostMonitor = this._disableStopTerminateHostMonitor;
    }
    if (this._disableTerminatedHostAlerting !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableTerminatedHostAlerting = this._disableTerminatedHostAlerting;
    }
    if (this._monitoringRegionInfos !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoringRegionInfos = this._monitoringRegionInfos;
    }
    if (this._monitoringRegions !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoringRegions = this._monitoringRegions;
    }
    if (this._nameFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.nameFilter = this._nameFilter;
    }
    if (this._selectAll !== undefined) {
      hasAnyValues = true;
      internalValueResult.selectAll = this._selectAll;
    }
    if (this._tags?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags?.internalValue;
    }
    if (this._useDefault !== undefined) {
      hasAnyValues = true;
      internalValueResult.useDefault = this._useDefault;
    }
    if (this._normalCollectorConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.normalCollectorConfig = this._normalCollectorConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesAUTOSCALING | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._customNSPSchedule = undefined;
      this._deadOperation = undefined;
      this._deviceDisplayNameTemplate = undefined;
      this._disableStopTerminateHostMonitor = undefined;
      this._disableTerminatedHostAlerting = undefined;
      this._monitoringRegionInfos = undefined;
      this._monitoringRegions = undefined;
      this._nameFilter = undefined;
      this._selectAll = undefined;
      this._tags.internalValue = undefined;
      this._useDefault = undefined;
      this._normalCollectorConfig.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._customNSPSchedule = value.customNSPSchedule;
      this._deadOperation = value.deadOperation;
      this._deviceDisplayNameTemplate = value.deviceDisplayNameTemplate;
      this._disableStopTerminateHostMonitor = value.disableStopTerminateHostMonitor;
      this._disableTerminatedHostAlerting = value.disableTerminatedHostAlerting;
      this._monitoringRegionInfos = value.monitoringRegionInfos;
      this._monitoringRegions = value.monitoringRegions;
      this._nameFilter = value.nameFilter;
      this._selectAll = value.selectAll;
      this._tags.internalValue = value.tags;
      this._useDefault = value.useDefault;
      this._normalCollectorConfig.internalValue = value.normalCollectorConfig;
    }
  }

  // custom_n_s_p_schedule - computed: false, optional: true, required: false
  private _customNSPSchedule?: string; 
  public get customNSPSchedule() {
    return this.getStringAttribute('custom_n_s_p_schedule');
  }
  public set customNSPSchedule(value: string) {
    this._customNSPSchedule = value;
  }
  public resetCustomNSPSchedule() {
    this._customNSPSchedule = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customNSPScheduleInput() {
    return this._customNSPSchedule;
  }

  // dead_operation - computed: false, optional: true, required: false
  private _deadOperation?: string; 
  public get deadOperation() {
    return this.getStringAttribute('dead_operation');
  }
  public set deadOperation(value: string) {
    this._deadOperation = value;
  }
  public resetDeadOperation() {
    this._deadOperation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadOperationInput() {
    return this._deadOperation;
  }

  // device_display_name_template - computed: false, optional: true, required: false
  private _deviceDisplayNameTemplate?: string; 
  public get deviceDisplayNameTemplate() {
    return this.getStringAttribute('device_display_name_template');
  }
  public set deviceDisplayNameTemplate(value: string) {
    this._deviceDisplayNameTemplate = value;
  }
  public resetDeviceDisplayNameTemplate() {
    this._deviceDisplayNameTemplate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deviceDisplayNameTemplateInput() {
    return this._deviceDisplayNameTemplate;
  }

  // disable_stop_terminate_host_monitor - computed: false, optional: true, required: false
  private _disableStopTerminateHostMonitor?: boolean | cdktf.IResolvable; 
  public get disableStopTerminateHostMonitor() {
    return this.getBooleanAttribute('disable_stop_terminate_host_monitor');
  }
  public set disableStopTerminateHostMonitor(value: boolean | cdktf.IResolvable) {
    this._disableStopTerminateHostMonitor = value;
  }
  public resetDisableStopTerminateHostMonitor() {
    this._disableStopTerminateHostMonitor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableStopTerminateHostMonitorInput() {
    return this._disableStopTerminateHostMonitor;
  }

  // disable_terminated_host_alerting - computed: false, optional: true, required: false
  private _disableTerminatedHostAlerting?: boolean | cdktf.IResolvable; 
  public get disableTerminatedHostAlerting() {
    return this.getBooleanAttribute('disable_terminated_host_alerting');
  }
  public set disableTerminatedHostAlerting(value: boolean | cdktf.IResolvable) {
    this._disableTerminatedHostAlerting = value;
  }
  public resetDisableTerminatedHostAlerting() {
    this._disableTerminatedHostAlerting = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableTerminatedHostAlertingInput() {
    return this._disableTerminatedHostAlerting;
  }

  // monitoring_region_infos - computed: false, optional: true, required: false
  private _monitoringRegionInfos?: string[]; 
  public get monitoringRegionInfos() {
    return cdktf.Fn.tolist(this.getListAttribute('monitoring_region_infos'));
  }
  public set monitoringRegionInfos(value: string[]) {
    this._monitoringRegionInfos = value;
  }
  public resetMonitoringRegionInfos() {
    this._monitoringRegionInfos = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoringRegionInfosInput() {
    return this._monitoringRegionInfos;
  }

  // monitoring_regions - computed: false, optional: true, required: false
  private _monitoringRegions?: string[]; 
  public get monitoringRegions() {
    return cdktf.Fn.tolist(this.getListAttribute('monitoring_regions'));
  }
  public set monitoringRegions(value: string[]) {
    this._monitoringRegions = value;
  }
  public resetMonitoringRegions() {
    this._monitoringRegions = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoringRegionsInput() {
    return this._monitoringRegions;
  }

  // name_filter - computed: false, optional: true, required: false
  private _nameFilter?: string[]; 
  public get nameFilter() {
    return cdktf.Fn.tolist(this.getListAttribute('name_filter'));
  }
  public set nameFilter(value: string[]) {
    this._nameFilter = value;
  }
  public resetNameFilter() {
    this._nameFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameFilterInput() {
    return this._nameFilter;
  }

  // select_all - computed: false, optional: true, required: false
  private _selectAll?: boolean | cdktf.IResolvable; 
  public get selectAll() {
    return this.getBooleanAttribute('select_all');
  }
  public set selectAll(value: boolean | cdktf.IResolvable) {
    this._selectAll = value;
  }
  public resetSelectAll() {
    this._selectAll = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectAllInput() {
    return this._selectAll;
  }

  // tags - computed: false, optional: true, required: false
  private _tags = new DeviceGroupExtraServicesAUTOSCALINGTagsList(this, "tags", false);
  public get tags() {
    return this._tags;
  }
  public putTags(value: DeviceGroupExtraServicesAUTOSCALINGTags[] | cdktf.IResolvable) {
    this._tags.internalValue = value;
  }
  public resetTags() {
    this._tags.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags.internalValue;
  }

  // use_default - computed: false, optional: false, required: true
  private _useDefault?: boolean | cdktf.IResolvable; 
  public get useDefault() {
    return this.getBooleanAttribute('use_default');
  }
  public set useDefault(value: boolean | cdktf.IResolvable) {
    this._useDefault = value;
  }
  // Temporarily expose input value. Use with caution.
  public get useDefaultInput() {
    return this._useDefault;
  }

  // normal_collector_config - computed: false, optional: true, required: false
  private _normalCollectorConfig = new DeviceGroupExtraServicesAUTOSCALINGNormalCollectorConfigList(this, "normal_collector_config", false);
  public get normalCollectorConfig() {
    return this._normalCollectorConfig;
  }
  public putNormalCollectorConfig(value: DeviceGroupExtraServicesAUTOSCALINGNormalCollectorConfig[] | cdktf.IResolvable) {
    this._normalCollectorConfig.internalValue = value;
  }
  public resetNormalCollectorConfig() {
    this._normalCollectorConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get normalCollectorConfigInput() {
    return this._normalCollectorConfig.internalValue;
  }
}

export class DeviceGroupExtraServicesAUTOSCALINGList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesAUTOSCALING[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesAUTOSCALINGOutputReference {
    return new DeviceGroupExtraServicesAUTOSCALINGOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesApiGATEWAYTags {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#name DeviceGroup#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#operation DeviceGroup#operation}
  */
  readonly operation?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#value DeviceGroup#value}
  */
  readonly value?: string;
}

export function deviceGroupExtraServicesApiGATEWAYTagsToTerraform(struct?: DeviceGroupExtraServicesApiGATEWAYTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    operation: cdktf.stringToTerraform(struct!.operation),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function deviceGroupExtraServicesApiGATEWAYTagsToHclTerraform(struct?: DeviceGroupExtraServicesApiGATEWAYTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operation: {
      value: cdktf.stringToHclTerraform(struct!.operation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesApiGATEWAYTagsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesApiGATEWAYTags | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._operation !== undefined) {
      hasAnyValues = true;
      internalValueResult.operation = this._operation;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesApiGATEWAYTags | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._operation = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._operation = value.operation;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // operation - computed: false, optional: true, required: false
  private _operation?: string; 
  public get operation() {
    return this.getStringAttribute('operation');
  }
  public set operation(value: string) {
    this._operation = value;
  }
  public resetOperation() {
    this._operation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operationInput() {
    return this._operation;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DeviceGroupExtraServicesApiGATEWAYTagsList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesApiGATEWAYTags[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesApiGATEWAYTagsOutputReference {
    return new DeviceGroupExtraServicesApiGATEWAYTagsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesApiGATEWAYNormalCollectorConfigCollectors {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#applies_to DeviceGroup#applies_to}
  */
  readonly appliesTo?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#auto_balanced_collector_group_id DeviceGroup#auto_balanced_collector_group_id}
  */
  readonly autoBalancedCollectorGroupId?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#collector_id DeviceGroup#collector_id}
  */
  readonly collectorId?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#priority DeviceGroup#priority}
  */
  readonly priority?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#use_public_ip DeviceGroup#use_public_ip}
  */
  readonly usePublicIp?: boolean | cdktf.IResolvable;
}

export function deviceGroupExtraServicesApiGATEWAYNormalCollectorConfigCollectorsToTerraform(struct?: DeviceGroupExtraServicesApiGATEWAYNormalCollectorConfigCollectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    applies_to: cdktf.stringToTerraform(struct!.appliesTo),
    auto_balanced_collector_group_id: cdktf.numberToTerraform(struct!.autoBalancedCollectorGroupId),
    collector_id: cdktf.numberToTerraform(struct!.collectorId),
    priority: cdktf.numberToTerraform(struct!.priority),
    use_public_ip: cdktf.booleanToTerraform(struct!.usePublicIp),
  }
}


export function deviceGroupExtraServicesApiGATEWAYNormalCollectorConfigCollectorsToHclTerraform(struct?: DeviceGroupExtraServicesApiGATEWAYNormalCollectorConfigCollectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    applies_to: {
      value: cdktf.stringToHclTerraform(struct!.appliesTo),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auto_balanced_collector_group_id: {
      value: cdktf.numberToHclTerraform(struct!.autoBalancedCollectorGroupId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    collector_id: {
      value: cdktf.numberToHclTerraform(struct!.collectorId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    priority: {
      value: cdktf.numberToHclTerraform(struct!.priority),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    use_public_ip: {
      value: cdktf.booleanToHclTerraform(struct!.usePublicIp),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesApiGATEWAYNormalCollectorConfigCollectorsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesApiGATEWAYNormalCollectorConfigCollectors | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._appliesTo !== undefined) {
      hasAnyValues = true;
      internalValueResult.appliesTo = this._appliesTo;
    }
    if (this._autoBalancedCollectorGroupId !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoBalancedCollectorGroupId = this._autoBalancedCollectorGroupId;
    }
    if (this._collectorId !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectorId = this._collectorId;
    }
    if (this._priority !== undefined) {
      hasAnyValues = true;
      internalValueResult.priority = this._priority;
    }
    if (this._usePublicIp !== undefined) {
      hasAnyValues = true;
      internalValueResult.usePublicIp = this._usePublicIp;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesApiGATEWAYNormalCollectorConfigCollectors | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._appliesTo = undefined;
      this._autoBalancedCollectorGroupId = undefined;
      this._collectorId = undefined;
      this._priority = undefined;
      this._usePublicIp = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._appliesTo = value.appliesTo;
      this._autoBalancedCollectorGroupId = value.autoBalancedCollectorGroupId;
      this._collectorId = value.collectorId;
      this._priority = value.priority;
      this._usePublicIp = value.usePublicIp;
    }
  }

  // applies_to - computed: false, optional: true, required: false
  private _appliesTo?: string; 
  public get appliesTo() {
    return this.getStringAttribute('applies_to');
  }
  public set appliesTo(value: string) {
    this._appliesTo = value;
  }
  public resetAppliesTo() {
    this._appliesTo = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appliesToInput() {
    return this._appliesTo;
  }

  // auto_balanced_collector_group_id - computed: false, optional: true, required: false
  private _autoBalancedCollectorGroupId?: number; 
  public get autoBalancedCollectorGroupId() {
    return this.getNumberAttribute('auto_balanced_collector_group_id');
  }
  public set autoBalancedCollectorGroupId(value: number) {
    this._autoBalancedCollectorGroupId = value;
  }
  public resetAutoBalancedCollectorGroupId() {
    this._autoBalancedCollectorGroupId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoBalancedCollectorGroupIdInput() {
    return this._autoBalancedCollectorGroupId;
  }

  // collector_id - computed: false, optional: true, required: false
  private _collectorId?: number; 
  public get collectorId() {
    return this.getNumberAttribute('collector_id');
  }
  public set collectorId(value: number) {
    this._collectorId = value;
  }
  public resetCollectorId() {
    this._collectorId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorIdInput() {
    return this._collectorId;
  }

  // priority - computed: false, optional: true, required: false
  private _priority?: number; 
  public get priority() {
    return this.getNumberAttribute('priority');
  }
  public set priority(value: number) {
    this._priority = value;
  }
  public resetPriority() {
    this._priority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get priorityInput() {
    return this._priority;
  }

  // use_public_ip - computed: false, optional: true, required: false
  private _usePublicIp?: boolean | cdktf.IResolvable; 
  public get usePublicIp() {
    return this.getBooleanAttribute('use_public_ip');
  }
  public set usePublicIp(value: boolean | cdktf.IResolvable) {
    this._usePublicIp = value;
  }
  public resetUsePublicIp() {
    this._usePublicIp = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usePublicIpInput() {
    return this._usePublicIp;
  }
}

export class DeviceGroupExtraServicesApiGATEWAYNormalCollectorConfigCollectorsList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesApiGATEWAYNormalCollectorConfigCollectors[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesApiGATEWAYNormalCollectorConfigCollectorsOutputReference {
    return new DeviceGroupExtraServicesApiGATEWAYNormalCollectorConfigCollectorsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesApiGATEWAYNormalCollectorConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#collectors DeviceGroup#collectors}
  */
  readonly collectors?: DeviceGroupExtraServicesApiGATEWAYNormalCollectorConfigCollectors[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#enabled DeviceGroup#enabled}
  */
  readonly enabled: boolean | cdktf.IResolvable;
}

export function deviceGroupExtraServicesApiGATEWAYNormalCollectorConfigToTerraform(struct?: DeviceGroupExtraServicesApiGATEWAYNormalCollectorConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    collectors: cdktf.listMapper(deviceGroupExtraServicesApiGATEWAYNormalCollectorConfigCollectorsToTerraform, false)(struct!.collectors),
    enabled: cdktf.booleanToTerraform(struct!.enabled),
  }
}


export function deviceGroupExtraServicesApiGATEWAYNormalCollectorConfigToHclTerraform(struct?: DeviceGroupExtraServicesApiGATEWAYNormalCollectorConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    collectors: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesApiGATEWAYNormalCollectorConfigCollectorsToHclTerraform, false)(struct!.collectors),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesApiGATEWAYNormalCollectorConfigCollectorsList",
    },
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesApiGATEWAYNormalCollectorConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesApiGATEWAYNormalCollectorConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._collectors?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectors = this._collectors?.internalValue;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesApiGATEWAYNormalCollectorConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._collectors.internalValue = undefined;
      this._enabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._collectors.internalValue = value.collectors;
      this._enabled = value.enabled;
    }
  }

  // collectors - computed: false, optional: true, required: false
  private _collectors = new DeviceGroupExtraServicesApiGATEWAYNormalCollectorConfigCollectorsList(this, "collectors", false);
  public get collectors() {
    return this._collectors;
  }
  public putCollectors(value: DeviceGroupExtraServicesApiGATEWAYNormalCollectorConfigCollectors[] | cdktf.IResolvable) {
    this._collectors.internalValue = value;
  }
  public resetCollectors() {
    this._collectors.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorsInput() {
    return this._collectors.internalValue;
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }
}

export class DeviceGroupExtraServicesApiGATEWAYNormalCollectorConfigList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesApiGATEWAYNormalCollectorConfig[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesApiGATEWAYNormalCollectorConfigOutputReference {
    return new DeviceGroupExtraServicesApiGATEWAYNormalCollectorConfigOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesApiGATEWAY {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#custom_n_s_p_schedule DeviceGroup#custom_n_s_p_schedule}
  */
  readonly customNSPSchedule?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#dead_operation DeviceGroup#dead_operation}
  */
  readonly deadOperation?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#device_display_name_template DeviceGroup#device_display_name_template}
  */
  readonly deviceDisplayNameTemplate?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#disable_stop_terminate_host_monitor DeviceGroup#disable_stop_terminate_host_monitor}
  */
  readonly disableStopTerminateHostMonitor?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#disable_terminated_host_alerting DeviceGroup#disable_terminated_host_alerting}
  */
  readonly disableTerminatedHostAlerting?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#monitoring_region_infos DeviceGroup#monitoring_region_infos}
  */
  readonly monitoringRegionInfos?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#monitoring_regions DeviceGroup#monitoring_regions}
  */
  readonly monitoringRegions?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#name_filter DeviceGroup#name_filter}
  */
  readonly nameFilter?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#select_all DeviceGroup#select_all}
  */
  readonly selectAll?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#tags DeviceGroup#tags}
  */
  readonly tags?: DeviceGroupExtraServicesApiGATEWAYTags[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#use_default DeviceGroup#use_default}
  */
  readonly useDefault: boolean | cdktf.IResolvable;
  /**
  * normal_collector_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#normal_collector_config DeviceGroup#normal_collector_config}
  */
  readonly normalCollectorConfig?: DeviceGroupExtraServicesApiGATEWAYNormalCollectorConfig[] | cdktf.IResolvable;
}

export function deviceGroupExtraServicesApiGATEWAYToTerraform(struct?: DeviceGroupExtraServicesApiGATEWAY | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    custom_n_s_p_schedule: cdktf.stringToTerraform(struct!.customNSPSchedule),
    dead_operation: cdktf.stringToTerraform(struct!.deadOperation),
    device_display_name_template: cdktf.stringToTerraform(struct!.deviceDisplayNameTemplate),
    disable_stop_terminate_host_monitor: cdktf.booleanToTerraform(struct!.disableStopTerminateHostMonitor),
    disable_terminated_host_alerting: cdktf.booleanToTerraform(struct!.disableTerminatedHostAlerting),
    monitoring_region_infos: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.monitoringRegionInfos),
    monitoring_regions: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.monitoringRegions),
    name_filter: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.nameFilter),
    select_all: cdktf.booleanToTerraform(struct!.selectAll),
    tags: cdktf.listMapper(deviceGroupExtraServicesApiGATEWAYTagsToTerraform, false)(struct!.tags),
    use_default: cdktf.booleanToTerraform(struct!.useDefault),
    normal_collector_config: cdktf.listMapper(deviceGroupExtraServicesApiGATEWAYNormalCollectorConfigToTerraform, true)(struct!.normalCollectorConfig),
  }
}


export function deviceGroupExtraServicesApiGATEWAYToHclTerraform(struct?: DeviceGroupExtraServicesApiGATEWAY | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    custom_n_s_p_schedule: {
      value: cdktf.stringToHclTerraform(struct!.customNSPSchedule),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dead_operation: {
      value: cdktf.stringToHclTerraform(struct!.deadOperation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    device_display_name_template: {
      value: cdktf.stringToHclTerraform(struct!.deviceDisplayNameTemplate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disable_stop_terminate_host_monitor: {
      value: cdktf.booleanToHclTerraform(struct!.disableStopTerminateHostMonitor),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    disable_terminated_host_alerting: {
      value: cdktf.booleanToHclTerraform(struct!.disableTerminatedHostAlerting),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    monitoring_region_infos: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.monitoringRegionInfos),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    monitoring_regions: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.monitoringRegions),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    name_filter: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.nameFilter),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    select_all: {
      value: cdktf.booleanToHclTerraform(struct!.selectAll),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tags: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesApiGATEWAYTagsToHclTerraform, false)(struct!.tags),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesApiGATEWAYTagsList",
    },
    use_default: {
      value: cdktf.booleanToHclTerraform(struct!.useDefault),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    normal_collector_config: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesApiGATEWAYNormalCollectorConfigToHclTerraform, true)(struct!.normalCollectorConfig),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesApiGATEWAYNormalCollectorConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesApiGATEWAYOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesApiGATEWAY | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._customNSPSchedule !== undefined) {
      hasAnyValues = true;
      internalValueResult.customNSPSchedule = this._customNSPSchedule;
    }
    if (this._deadOperation !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadOperation = this._deadOperation;
    }
    if (this._deviceDisplayNameTemplate !== undefined) {
      hasAnyValues = true;
      internalValueResult.deviceDisplayNameTemplate = this._deviceDisplayNameTemplate;
    }
    if (this._disableStopTerminateHostMonitor !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableStopTerminateHostMonitor = this._disableStopTerminateHostMonitor;
    }
    if (this._disableTerminatedHostAlerting !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableTerminatedHostAlerting = this._disableTerminatedHostAlerting;
    }
    if (this._monitoringRegionInfos !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoringRegionInfos = this._monitoringRegionInfos;
    }
    if (this._monitoringRegions !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoringRegions = this._monitoringRegions;
    }
    if (this._nameFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.nameFilter = this._nameFilter;
    }
    if (this._selectAll !== undefined) {
      hasAnyValues = true;
      internalValueResult.selectAll = this._selectAll;
    }
    if (this._tags?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags?.internalValue;
    }
    if (this._useDefault !== undefined) {
      hasAnyValues = true;
      internalValueResult.useDefault = this._useDefault;
    }
    if (this._normalCollectorConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.normalCollectorConfig = this._normalCollectorConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesApiGATEWAY | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._customNSPSchedule = undefined;
      this._deadOperation = undefined;
      this._deviceDisplayNameTemplate = undefined;
      this._disableStopTerminateHostMonitor = undefined;
      this._disableTerminatedHostAlerting = undefined;
      this._monitoringRegionInfos = undefined;
      this._monitoringRegions = undefined;
      this._nameFilter = undefined;
      this._selectAll = undefined;
      this._tags.internalValue = undefined;
      this._useDefault = undefined;
      this._normalCollectorConfig.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._customNSPSchedule = value.customNSPSchedule;
      this._deadOperation = value.deadOperation;
      this._deviceDisplayNameTemplate = value.deviceDisplayNameTemplate;
      this._disableStopTerminateHostMonitor = value.disableStopTerminateHostMonitor;
      this._disableTerminatedHostAlerting = value.disableTerminatedHostAlerting;
      this._monitoringRegionInfos = value.monitoringRegionInfos;
      this._monitoringRegions = value.monitoringRegions;
      this._nameFilter = value.nameFilter;
      this._selectAll = value.selectAll;
      this._tags.internalValue = value.tags;
      this._useDefault = value.useDefault;
      this._normalCollectorConfig.internalValue = value.normalCollectorConfig;
    }
  }

  // custom_n_s_p_schedule - computed: false, optional: true, required: false
  private _customNSPSchedule?: string; 
  public get customNSPSchedule() {
    return this.getStringAttribute('custom_n_s_p_schedule');
  }
  public set customNSPSchedule(value: string) {
    this._customNSPSchedule = value;
  }
  public resetCustomNSPSchedule() {
    this._customNSPSchedule = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customNSPScheduleInput() {
    return this._customNSPSchedule;
  }

  // dead_operation - computed: false, optional: true, required: false
  private _deadOperation?: string; 
  public get deadOperation() {
    return this.getStringAttribute('dead_operation');
  }
  public set deadOperation(value: string) {
    this._deadOperation = value;
  }
  public resetDeadOperation() {
    this._deadOperation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadOperationInput() {
    return this._deadOperation;
  }

  // device_display_name_template - computed: false, optional: true, required: false
  private _deviceDisplayNameTemplate?: string; 
  public get deviceDisplayNameTemplate() {
    return this.getStringAttribute('device_display_name_template');
  }
  public set deviceDisplayNameTemplate(value: string) {
    this._deviceDisplayNameTemplate = value;
  }
  public resetDeviceDisplayNameTemplate() {
    this._deviceDisplayNameTemplate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deviceDisplayNameTemplateInput() {
    return this._deviceDisplayNameTemplate;
  }

  // disable_stop_terminate_host_monitor - computed: false, optional: true, required: false
  private _disableStopTerminateHostMonitor?: boolean | cdktf.IResolvable; 
  public get disableStopTerminateHostMonitor() {
    return this.getBooleanAttribute('disable_stop_terminate_host_monitor');
  }
  public set disableStopTerminateHostMonitor(value: boolean | cdktf.IResolvable) {
    this._disableStopTerminateHostMonitor = value;
  }
  public resetDisableStopTerminateHostMonitor() {
    this._disableStopTerminateHostMonitor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableStopTerminateHostMonitorInput() {
    return this._disableStopTerminateHostMonitor;
  }

  // disable_terminated_host_alerting - computed: false, optional: true, required: false
  private _disableTerminatedHostAlerting?: boolean | cdktf.IResolvable; 
  public get disableTerminatedHostAlerting() {
    return this.getBooleanAttribute('disable_terminated_host_alerting');
  }
  public set disableTerminatedHostAlerting(value: boolean | cdktf.IResolvable) {
    this._disableTerminatedHostAlerting = value;
  }
  public resetDisableTerminatedHostAlerting() {
    this._disableTerminatedHostAlerting = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableTerminatedHostAlertingInput() {
    return this._disableTerminatedHostAlerting;
  }

  // monitoring_region_infos - computed: false, optional: true, required: false
  private _monitoringRegionInfos?: string[]; 
  public get monitoringRegionInfos() {
    return cdktf.Fn.tolist(this.getListAttribute('monitoring_region_infos'));
  }
  public set monitoringRegionInfos(value: string[]) {
    this._monitoringRegionInfos = value;
  }
  public resetMonitoringRegionInfos() {
    this._monitoringRegionInfos = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoringRegionInfosInput() {
    return this._monitoringRegionInfos;
  }

  // monitoring_regions - computed: false, optional: true, required: false
  private _monitoringRegions?: string[]; 
  public get monitoringRegions() {
    return cdktf.Fn.tolist(this.getListAttribute('monitoring_regions'));
  }
  public set monitoringRegions(value: string[]) {
    this._monitoringRegions = value;
  }
  public resetMonitoringRegions() {
    this._monitoringRegions = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoringRegionsInput() {
    return this._monitoringRegions;
  }

  // name_filter - computed: false, optional: true, required: false
  private _nameFilter?: string[]; 
  public get nameFilter() {
    return cdktf.Fn.tolist(this.getListAttribute('name_filter'));
  }
  public set nameFilter(value: string[]) {
    this._nameFilter = value;
  }
  public resetNameFilter() {
    this._nameFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameFilterInput() {
    return this._nameFilter;
  }

  // select_all - computed: false, optional: true, required: false
  private _selectAll?: boolean | cdktf.IResolvable; 
  public get selectAll() {
    return this.getBooleanAttribute('select_all');
  }
  public set selectAll(value: boolean | cdktf.IResolvable) {
    this._selectAll = value;
  }
  public resetSelectAll() {
    this._selectAll = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectAllInput() {
    return this._selectAll;
  }

  // tags - computed: false, optional: true, required: false
  private _tags = new DeviceGroupExtraServicesApiGATEWAYTagsList(this, "tags", false);
  public get tags() {
    return this._tags;
  }
  public putTags(value: DeviceGroupExtraServicesApiGATEWAYTags[] | cdktf.IResolvable) {
    this._tags.internalValue = value;
  }
  public resetTags() {
    this._tags.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags.internalValue;
  }

  // use_default - computed: false, optional: false, required: true
  private _useDefault?: boolean | cdktf.IResolvable; 
  public get useDefault() {
    return this.getBooleanAttribute('use_default');
  }
  public set useDefault(value: boolean | cdktf.IResolvable) {
    this._useDefault = value;
  }
  // Temporarily expose input value. Use with caution.
  public get useDefaultInput() {
    return this._useDefault;
  }

  // normal_collector_config - computed: false, optional: true, required: false
  private _normalCollectorConfig = new DeviceGroupExtraServicesApiGATEWAYNormalCollectorConfigList(this, "normal_collector_config", false);
  public get normalCollectorConfig() {
    return this._normalCollectorConfig;
  }
  public putNormalCollectorConfig(value: DeviceGroupExtraServicesApiGATEWAYNormalCollectorConfig[] | cdktf.IResolvable) {
    this._normalCollectorConfig.internalValue = value;
  }
  public resetNormalCollectorConfig() {
    this._normalCollectorConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get normalCollectorConfigInput() {
    return this._normalCollectorConfig.internalValue;
  }
}

export class DeviceGroupExtraServicesApiGATEWAYList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesApiGATEWAY[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesApiGATEWAYOutputReference {
    return new DeviceGroupExtraServicesApiGATEWAYOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesApiMANAGEMENTTags {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#name DeviceGroup#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#operation DeviceGroup#operation}
  */
  readonly operation?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#value DeviceGroup#value}
  */
  readonly value?: string;
}

export function deviceGroupExtraServicesApiMANAGEMENTTagsToTerraform(struct?: DeviceGroupExtraServicesApiMANAGEMENTTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    operation: cdktf.stringToTerraform(struct!.operation),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function deviceGroupExtraServicesApiMANAGEMENTTagsToHclTerraform(struct?: DeviceGroupExtraServicesApiMANAGEMENTTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operation: {
      value: cdktf.stringToHclTerraform(struct!.operation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesApiMANAGEMENTTagsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesApiMANAGEMENTTags | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._operation !== undefined) {
      hasAnyValues = true;
      internalValueResult.operation = this._operation;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesApiMANAGEMENTTags | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._operation = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._operation = value.operation;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // operation - computed: false, optional: true, required: false
  private _operation?: string; 
  public get operation() {
    return this.getStringAttribute('operation');
  }
  public set operation(value: string) {
    this._operation = value;
  }
  public resetOperation() {
    this._operation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operationInput() {
    return this._operation;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DeviceGroupExtraServicesApiMANAGEMENTTagsList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesApiMANAGEMENTTags[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesApiMANAGEMENTTagsOutputReference {
    return new DeviceGroupExtraServicesApiMANAGEMENTTagsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesApiMANAGEMENTNormalCollectorConfigCollectors {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#applies_to DeviceGroup#applies_to}
  */
  readonly appliesTo?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#auto_balanced_collector_group_id DeviceGroup#auto_balanced_collector_group_id}
  */
  readonly autoBalancedCollectorGroupId?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#collector_id DeviceGroup#collector_id}
  */
  readonly collectorId?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#priority DeviceGroup#priority}
  */
  readonly priority?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#use_public_ip DeviceGroup#use_public_ip}
  */
  readonly usePublicIp?: boolean | cdktf.IResolvable;
}

export function deviceGroupExtraServicesApiMANAGEMENTNormalCollectorConfigCollectorsToTerraform(struct?: DeviceGroupExtraServicesApiMANAGEMENTNormalCollectorConfigCollectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    applies_to: cdktf.stringToTerraform(struct!.appliesTo),
    auto_balanced_collector_group_id: cdktf.numberToTerraform(struct!.autoBalancedCollectorGroupId),
    collector_id: cdktf.numberToTerraform(struct!.collectorId),
    priority: cdktf.numberToTerraform(struct!.priority),
    use_public_ip: cdktf.booleanToTerraform(struct!.usePublicIp),
  }
}


export function deviceGroupExtraServicesApiMANAGEMENTNormalCollectorConfigCollectorsToHclTerraform(struct?: DeviceGroupExtraServicesApiMANAGEMENTNormalCollectorConfigCollectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    applies_to: {
      value: cdktf.stringToHclTerraform(struct!.appliesTo),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auto_balanced_collector_group_id: {
      value: cdktf.numberToHclTerraform(struct!.autoBalancedCollectorGroupId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    collector_id: {
      value: cdktf.numberToHclTerraform(struct!.collectorId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    priority: {
      value: cdktf.numberToHclTerraform(struct!.priority),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    use_public_ip: {
      value: cdktf.booleanToHclTerraform(struct!.usePublicIp),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesApiMANAGEMENTNormalCollectorConfigCollectorsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesApiMANAGEMENTNormalCollectorConfigCollectors | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._appliesTo !== undefined) {
      hasAnyValues = true;
      internalValueResult.appliesTo = this._appliesTo;
    }
    if (this._autoBalancedCollectorGroupId !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoBalancedCollectorGroupId = this._autoBalancedCollectorGroupId;
    }
    if (this._collectorId !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectorId = this._collectorId;
    }
    if (this._priority !== undefined) {
      hasAnyValues = true;
      internalValueResult.priority = this._priority;
    }
    if (this._usePublicIp !== undefined) {
      hasAnyValues = true;
      internalValueResult.usePublicIp = this._usePublicIp;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesApiMANAGEMENTNormalCollectorConfigCollectors | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._appliesTo = undefined;
      this._autoBalancedCollectorGroupId = undefined;
      this._collectorId = undefined;
      this._priority = undefined;
      this._usePublicIp = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._appliesTo = value.appliesTo;
      this._autoBalancedCollectorGroupId = value.autoBalancedCollectorGroupId;
      this._collectorId = value.collectorId;
      this._priority = value.priority;
      this._usePublicIp = value.usePublicIp;
    }
  }

  // applies_to - computed: false, optional: true, required: false
  private _appliesTo?: string; 
  public get appliesTo() {
    return this.getStringAttribute('applies_to');
  }
  public set appliesTo(value: string) {
    this._appliesTo = value;
  }
  public resetAppliesTo() {
    this._appliesTo = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appliesToInput() {
    return this._appliesTo;
  }

  // auto_balanced_collector_group_id - computed: false, optional: true, required: false
  private _autoBalancedCollectorGroupId?: number; 
  public get autoBalancedCollectorGroupId() {
    return this.getNumberAttribute('auto_balanced_collector_group_id');
  }
  public set autoBalancedCollectorGroupId(value: number) {
    this._autoBalancedCollectorGroupId = value;
  }
  public resetAutoBalancedCollectorGroupId() {
    this._autoBalancedCollectorGroupId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoBalancedCollectorGroupIdInput() {
    return this._autoBalancedCollectorGroupId;
  }

  // collector_id - computed: false, optional: true, required: false
  private _collectorId?: number; 
  public get collectorId() {
    return this.getNumberAttribute('collector_id');
  }
  public set collectorId(value: number) {
    this._collectorId = value;
  }
  public resetCollectorId() {
    this._collectorId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorIdInput() {
    return this._collectorId;
  }

  // priority - computed: false, optional: true, required: false
  private _priority?: number; 
  public get priority() {
    return this.getNumberAttribute('priority');
  }
  public set priority(value: number) {
    this._priority = value;
  }
  public resetPriority() {
    this._priority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get priorityInput() {
    return this._priority;
  }

  // use_public_ip - computed: false, optional: true, required: false
  private _usePublicIp?: boolean | cdktf.IResolvable; 
  public get usePublicIp() {
    return this.getBooleanAttribute('use_public_ip');
  }
  public set usePublicIp(value: boolean | cdktf.IResolvable) {
    this._usePublicIp = value;
  }
  public resetUsePublicIp() {
    this._usePublicIp = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usePublicIpInput() {
    return this._usePublicIp;
  }
}

export class DeviceGroupExtraServicesApiMANAGEMENTNormalCollectorConfigCollectorsList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesApiMANAGEMENTNormalCollectorConfigCollectors[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesApiMANAGEMENTNormalCollectorConfigCollectorsOutputReference {
    return new DeviceGroupExtraServicesApiMANAGEMENTNormalCollectorConfigCollectorsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesApiMANAGEMENTNormalCollectorConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#collectors DeviceGroup#collectors}
  */
  readonly collectors?: DeviceGroupExtraServicesApiMANAGEMENTNormalCollectorConfigCollectors[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#enabled DeviceGroup#enabled}
  */
  readonly enabled: boolean | cdktf.IResolvable;
}

export function deviceGroupExtraServicesApiMANAGEMENTNormalCollectorConfigToTerraform(struct?: DeviceGroupExtraServicesApiMANAGEMENTNormalCollectorConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    collectors: cdktf.listMapper(deviceGroupExtraServicesApiMANAGEMENTNormalCollectorConfigCollectorsToTerraform, false)(struct!.collectors),
    enabled: cdktf.booleanToTerraform(struct!.enabled),
  }
}


export function deviceGroupExtraServicesApiMANAGEMENTNormalCollectorConfigToHclTerraform(struct?: DeviceGroupExtraServicesApiMANAGEMENTNormalCollectorConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    collectors: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesApiMANAGEMENTNormalCollectorConfigCollectorsToHclTerraform, false)(struct!.collectors),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesApiMANAGEMENTNormalCollectorConfigCollectorsList",
    },
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesApiMANAGEMENTNormalCollectorConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesApiMANAGEMENTNormalCollectorConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._collectors?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectors = this._collectors?.internalValue;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesApiMANAGEMENTNormalCollectorConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._collectors.internalValue = undefined;
      this._enabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._collectors.internalValue = value.collectors;
      this._enabled = value.enabled;
    }
  }

  // collectors - computed: false, optional: true, required: false
  private _collectors = new DeviceGroupExtraServicesApiMANAGEMENTNormalCollectorConfigCollectorsList(this, "collectors", false);
  public get collectors() {
    return this._collectors;
  }
  public putCollectors(value: DeviceGroupExtraServicesApiMANAGEMENTNormalCollectorConfigCollectors[] | cdktf.IResolvable) {
    this._collectors.internalValue = value;
  }
  public resetCollectors() {
    this._collectors.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorsInput() {
    return this._collectors.internalValue;
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }
}

export class DeviceGroupExtraServicesApiMANAGEMENTNormalCollectorConfigList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesApiMANAGEMENTNormalCollectorConfig[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesApiMANAGEMENTNormalCollectorConfigOutputReference {
    return new DeviceGroupExtraServicesApiMANAGEMENTNormalCollectorConfigOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesApiMANAGEMENT {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#custom_n_s_p_schedule DeviceGroup#custom_n_s_p_schedule}
  */
  readonly customNSPSchedule?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#dead_operation DeviceGroup#dead_operation}
  */
  readonly deadOperation?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#device_display_name_template DeviceGroup#device_display_name_template}
  */
  readonly deviceDisplayNameTemplate?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#disable_stop_terminate_host_monitor DeviceGroup#disable_stop_terminate_host_monitor}
  */
  readonly disableStopTerminateHostMonitor?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#disable_terminated_host_alerting DeviceGroup#disable_terminated_host_alerting}
  */
  readonly disableTerminatedHostAlerting?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#monitoring_region_infos DeviceGroup#monitoring_region_infos}
  */
  readonly monitoringRegionInfos?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#monitoring_regions DeviceGroup#monitoring_regions}
  */
  readonly monitoringRegions?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#name_filter DeviceGroup#name_filter}
  */
  readonly nameFilter?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#select_all DeviceGroup#select_all}
  */
  readonly selectAll?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#tags DeviceGroup#tags}
  */
  readonly tags?: DeviceGroupExtraServicesApiMANAGEMENTTags[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#use_default DeviceGroup#use_default}
  */
  readonly useDefault: boolean | cdktf.IResolvable;
  /**
  * normal_collector_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#normal_collector_config DeviceGroup#normal_collector_config}
  */
  readonly normalCollectorConfig?: DeviceGroupExtraServicesApiMANAGEMENTNormalCollectorConfig[] | cdktf.IResolvable;
}

export function deviceGroupExtraServicesApiMANAGEMENTToTerraform(struct?: DeviceGroupExtraServicesApiMANAGEMENT | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    custom_n_s_p_schedule: cdktf.stringToTerraform(struct!.customNSPSchedule),
    dead_operation: cdktf.stringToTerraform(struct!.deadOperation),
    device_display_name_template: cdktf.stringToTerraform(struct!.deviceDisplayNameTemplate),
    disable_stop_terminate_host_monitor: cdktf.booleanToTerraform(struct!.disableStopTerminateHostMonitor),
    disable_terminated_host_alerting: cdktf.booleanToTerraform(struct!.disableTerminatedHostAlerting),
    monitoring_region_infos: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.monitoringRegionInfos),
    monitoring_regions: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.monitoringRegions),
    name_filter: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.nameFilter),
    select_all: cdktf.booleanToTerraform(struct!.selectAll),
    tags: cdktf.listMapper(deviceGroupExtraServicesApiMANAGEMENTTagsToTerraform, false)(struct!.tags),
    use_default: cdktf.booleanToTerraform(struct!.useDefault),
    normal_collector_config: cdktf.listMapper(deviceGroupExtraServicesApiMANAGEMENTNormalCollectorConfigToTerraform, true)(struct!.normalCollectorConfig),
  }
}


export function deviceGroupExtraServicesApiMANAGEMENTToHclTerraform(struct?: DeviceGroupExtraServicesApiMANAGEMENT | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    custom_n_s_p_schedule: {
      value: cdktf.stringToHclTerraform(struct!.customNSPSchedule),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dead_operation: {
      value: cdktf.stringToHclTerraform(struct!.deadOperation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    device_display_name_template: {
      value: cdktf.stringToHclTerraform(struct!.deviceDisplayNameTemplate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disable_stop_terminate_host_monitor: {
      value: cdktf.booleanToHclTerraform(struct!.disableStopTerminateHostMonitor),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    disable_terminated_host_alerting: {
      value: cdktf.booleanToHclTerraform(struct!.disableTerminatedHostAlerting),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    monitoring_region_infos: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.monitoringRegionInfos),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    monitoring_regions: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.monitoringRegions),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    name_filter: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.nameFilter),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    select_all: {
      value: cdktf.booleanToHclTerraform(struct!.selectAll),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tags: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesApiMANAGEMENTTagsToHclTerraform, false)(struct!.tags),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesApiMANAGEMENTTagsList",
    },
    use_default: {
      value: cdktf.booleanToHclTerraform(struct!.useDefault),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    normal_collector_config: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesApiMANAGEMENTNormalCollectorConfigToHclTerraform, true)(struct!.normalCollectorConfig),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesApiMANAGEMENTNormalCollectorConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesApiMANAGEMENTOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesApiMANAGEMENT | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._customNSPSchedule !== undefined) {
      hasAnyValues = true;
      internalValueResult.customNSPSchedule = this._customNSPSchedule;
    }
    if (this._deadOperation !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadOperation = this._deadOperation;
    }
    if (this._deviceDisplayNameTemplate !== undefined) {
      hasAnyValues = true;
      internalValueResult.deviceDisplayNameTemplate = this._deviceDisplayNameTemplate;
    }
    if (this._disableStopTerminateHostMonitor !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableStopTerminateHostMonitor = this._disableStopTerminateHostMonitor;
    }
    if (this._disableTerminatedHostAlerting !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableTerminatedHostAlerting = this._disableTerminatedHostAlerting;
    }
    if (this._monitoringRegionInfos !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoringRegionInfos = this._monitoringRegionInfos;
    }
    if (this._monitoringRegions !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoringRegions = this._monitoringRegions;
    }
    if (this._nameFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.nameFilter = this._nameFilter;
    }
    if (this._selectAll !== undefined) {
      hasAnyValues = true;
      internalValueResult.selectAll = this._selectAll;
    }
    if (this._tags?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags?.internalValue;
    }
    if (this._useDefault !== undefined) {
      hasAnyValues = true;
      internalValueResult.useDefault = this._useDefault;
    }
    if (this._normalCollectorConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.normalCollectorConfig = this._normalCollectorConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesApiMANAGEMENT | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._customNSPSchedule = undefined;
      this._deadOperation = undefined;
      this._deviceDisplayNameTemplate = undefined;
      this._disableStopTerminateHostMonitor = undefined;
      this._disableTerminatedHostAlerting = undefined;
      this._monitoringRegionInfos = undefined;
      this._monitoringRegions = undefined;
      this._nameFilter = undefined;
      this._selectAll = undefined;
      this._tags.internalValue = undefined;
      this._useDefault = undefined;
      this._normalCollectorConfig.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._customNSPSchedule = value.customNSPSchedule;
      this._deadOperation = value.deadOperation;
      this._deviceDisplayNameTemplate = value.deviceDisplayNameTemplate;
      this._disableStopTerminateHostMonitor = value.disableStopTerminateHostMonitor;
      this._disableTerminatedHostAlerting = value.disableTerminatedHostAlerting;
      this._monitoringRegionInfos = value.monitoringRegionInfos;
      this._monitoringRegions = value.monitoringRegions;
      this._nameFilter = value.nameFilter;
      this._selectAll = value.selectAll;
      this._tags.internalValue = value.tags;
      this._useDefault = value.useDefault;
      this._normalCollectorConfig.internalValue = value.normalCollectorConfig;
    }
  }

  // custom_n_s_p_schedule - computed: false, optional: true, required: false
  private _customNSPSchedule?: string; 
  public get customNSPSchedule() {
    return this.getStringAttribute('custom_n_s_p_schedule');
  }
  public set customNSPSchedule(value: string) {
    this._customNSPSchedule = value;
  }
  public resetCustomNSPSchedule() {
    this._customNSPSchedule = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customNSPScheduleInput() {
    return this._customNSPSchedule;
  }

  // dead_operation - computed: false, optional: true, required: false
  private _deadOperation?: string; 
  public get deadOperation() {
    return this.getStringAttribute('dead_operation');
  }
  public set deadOperation(value: string) {
    this._deadOperation = value;
  }
  public resetDeadOperation() {
    this._deadOperation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadOperationInput() {
    return this._deadOperation;
  }

  // device_display_name_template - computed: false, optional: true, required: false
  private _deviceDisplayNameTemplate?: string; 
  public get deviceDisplayNameTemplate() {
    return this.getStringAttribute('device_display_name_template');
  }
  public set deviceDisplayNameTemplate(value: string) {
    this._deviceDisplayNameTemplate = value;
  }
  public resetDeviceDisplayNameTemplate() {
    this._deviceDisplayNameTemplate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deviceDisplayNameTemplateInput() {
    return this._deviceDisplayNameTemplate;
  }

  // disable_stop_terminate_host_monitor - computed: false, optional: true, required: false
  private _disableStopTerminateHostMonitor?: boolean | cdktf.IResolvable; 
  public get disableStopTerminateHostMonitor() {
    return this.getBooleanAttribute('disable_stop_terminate_host_monitor');
  }
  public set disableStopTerminateHostMonitor(value: boolean | cdktf.IResolvable) {
    this._disableStopTerminateHostMonitor = value;
  }
  public resetDisableStopTerminateHostMonitor() {
    this._disableStopTerminateHostMonitor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableStopTerminateHostMonitorInput() {
    return this._disableStopTerminateHostMonitor;
  }

  // disable_terminated_host_alerting - computed: false, optional: true, required: false
  private _disableTerminatedHostAlerting?: boolean | cdktf.IResolvable; 
  public get disableTerminatedHostAlerting() {
    return this.getBooleanAttribute('disable_terminated_host_alerting');
  }
  public set disableTerminatedHostAlerting(value: boolean | cdktf.IResolvable) {
    this._disableTerminatedHostAlerting = value;
  }
  public resetDisableTerminatedHostAlerting() {
    this._disableTerminatedHostAlerting = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableTerminatedHostAlertingInput() {
    return this._disableTerminatedHostAlerting;
  }

  // monitoring_region_infos - computed: false, optional: true, required: false
  private _monitoringRegionInfos?: string[]; 
  public get monitoringRegionInfos() {
    return cdktf.Fn.tolist(this.getListAttribute('monitoring_region_infos'));
  }
  public set monitoringRegionInfos(value: string[]) {
    this._monitoringRegionInfos = value;
  }
  public resetMonitoringRegionInfos() {
    this._monitoringRegionInfos = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoringRegionInfosInput() {
    return this._monitoringRegionInfos;
  }

  // monitoring_regions - computed: false, optional: true, required: false
  private _monitoringRegions?: string[]; 
  public get monitoringRegions() {
    return cdktf.Fn.tolist(this.getListAttribute('monitoring_regions'));
  }
  public set monitoringRegions(value: string[]) {
    this._monitoringRegions = value;
  }
  public resetMonitoringRegions() {
    this._monitoringRegions = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoringRegionsInput() {
    return this._monitoringRegions;
  }

  // name_filter - computed: false, optional: true, required: false
  private _nameFilter?: string[]; 
  public get nameFilter() {
    return cdktf.Fn.tolist(this.getListAttribute('name_filter'));
  }
  public set nameFilter(value: string[]) {
    this._nameFilter = value;
  }
  public resetNameFilter() {
    this._nameFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameFilterInput() {
    return this._nameFilter;
  }

  // select_all - computed: false, optional: true, required: false
  private _selectAll?: boolean | cdktf.IResolvable; 
  public get selectAll() {
    return this.getBooleanAttribute('select_all');
  }
  public set selectAll(value: boolean | cdktf.IResolvable) {
    this._selectAll = value;
  }
  public resetSelectAll() {
    this._selectAll = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectAllInput() {
    return this._selectAll;
  }

  // tags - computed: false, optional: true, required: false
  private _tags = new DeviceGroupExtraServicesApiMANAGEMENTTagsList(this, "tags", false);
  public get tags() {
    return this._tags;
  }
  public putTags(value: DeviceGroupExtraServicesApiMANAGEMENTTags[] | cdktf.IResolvable) {
    this._tags.internalValue = value;
  }
  public resetTags() {
    this._tags.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags.internalValue;
  }

  // use_default - computed: false, optional: false, required: true
  private _useDefault?: boolean | cdktf.IResolvable; 
  public get useDefault() {
    return this.getBooleanAttribute('use_default');
  }
  public set useDefault(value: boolean | cdktf.IResolvable) {
    this._useDefault = value;
  }
  // Temporarily expose input value. Use with caution.
  public get useDefaultInput() {
    return this._useDefault;
  }

  // normal_collector_config - computed: false, optional: true, required: false
  private _normalCollectorConfig = new DeviceGroupExtraServicesApiMANAGEMENTNormalCollectorConfigList(this, "normal_collector_config", false);
  public get normalCollectorConfig() {
    return this._normalCollectorConfig;
  }
  public putNormalCollectorConfig(value: DeviceGroupExtraServicesApiMANAGEMENTNormalCollectorConfig[] | cdktf.IResolvable) {
    this._normalCollectorConfig.internalValue = value;
  }
  public resetNormalCollectorConfig() {
    this._normalCollectorConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get normalCollectorConfigInput() {
    return this._normalCollectorConfig.internalValue;
  }
}

export class DeviceGroupExtraServicesApiMANAGEMENTList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesApiMANAGEMENT[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesApiMANAGEMENTOutputReference {
    return new DeviceGroupExtraServicesApiMANAGEMENTOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesBACKUPPROTECTEDITEMSTags {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#name DeviceGroup#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#operation DeviceGroup#operation}
  */
  readonly operation?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#value DeviceGroup#value}
  */
  readonly value?: string;
}

export function deviceGroupExtraServicesBACKUPPROTECTEDITEMSTagsToTerraform(struct?: DeviceGroupExtraServicesBACKUPPROTECTEDITEMSTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    operation: cdktf.stringToTerraform(struct!.operation),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function deviceGroupExtraServicesBACKUPPROTECTEDITEMSTagsToHclTerraform(struct?: DeviceGroupExtraServicesBACKUPPROTECTEDITEMSTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operation: {
      value: cdktf.stringToHclTerraform(struct!.operation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesBACKUPPROTECTEDITEMSTagsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesBACKUPPROTECTEDITEMSTags | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._operation !== undefined) {
      hasAnyValues = true;
      internalValueResult.operation = this._operation;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesBACKUPPROTECTEDITEMSTags | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._operation = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._operation = value.operation;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // operation - computed: false, optional: true, required: false
  private _operation?: string; 
  public get operation() {
    return this.getStringAttribute('operation');
  }
  public set operation(value: string) {
    this._operation = value;
  }
  public resetOperation() {
    this._operation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operationInput() {
    return this._operation;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DeviceGroupExtraServicesBACKUPPROTECTEDITEMSTagsList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesBACKUPPROTECTEDITEMSTags[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesBACKUPPROTECTEDITEMSTagsOutputReference {
    return new DeviceGroupExtraServicesBACKUPPROTECTEDITEMSTagsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesBACKUPPROTECTEDITEMSNormalCollectorConfigCollectors {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#applies_to DeviceGroup#applies_to}
  */
  readonly appliesTo?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#auto_balanced_collector_group_id DeviceGroup#auto_balanced_collector_group_id}
  */
  readonly autoBalancedCollectorGroupId?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#collector_id DeviceGroup#collector_id}
  */
  readonly collectorId?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#priority DeviceGroup#priority}
  */
  readonly priority?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#use_public_ip DeviceGroup#use_public_ip}
  */
  readonly usePublicIp?: boolean | cdktf.IResolvable;
}

export function deviceGroupExtraServicesBACKUPPROTECTEDITEMSNormalCollectorConfigCollectorsToTerraform(struct?: DeviceGroupExtraServicesBACKUPPROTECTEDITEMSNormalCollectorConfigCollectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    applies_to: cdktf.stringToTerraform(struct!.appliesTo),
    auto_balanced_collector_group_id: cdktf.numberToTerraform(struct!.autoBalancedCollectorGroupId),
    collector_id: cdktf.numberToTerraform(struct!.collectorId),
    priority: cdktf.numberToTerraform(struct!.priority),
    use_public_ip: cdktf.booleanToTerraform(struct!.usePublicIp),
  }
}


export function deviceGroupExtraServicesBACKUPPROTECTEDITEMSNormalCollectorConfigCollectorsToHclTerraform(struct?: DeviceGroupExtraServicesBACKUPPROTECTEDITEMSNormalCollectorConfigCollectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    applies_to: {
      value: cdktf.stringToHclTerraform(struct!.appliesTo),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auto_balanced_collector_group_id: {
      value: cdktf.numberToHclTerraform(struct!.autoBalancedCollectorGroupId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    collector_id: {
      value: cdktf.numberToHclTerraform(struct!.collectorId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    priority: {
      value: cdktf.numberToHclTerraform(struct!.priority),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    use_public_ip: {
      value: cdktf.booleanToHclTerraform(struct!.usePublicIp),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesBACKUPPROTECTEDITEMSNormalCollectorConfigCollectorsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesBACKUPPROTECTEDITEMSNormalCollectorConfigCollectors | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._appliesTo !== undefined) {
      hasAnyValues = true;
      internalValueResult.appliesTo = this._appliesTo;
    }
    if (this._autoBalancedCollectorGroupId !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoBalancedCollectorGroupId = this._autoBalancedCollectorGroupId;
    }
    if (this._collectorId !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectorId = this._collectorId;
    }
    if (this._priority !== undefined) {
      hasAnyValues = true;
      internalValueResult.priority = this._priority;
    }
    if (this._usePublicIp !== undefined) {
      hasAnyValues = true;
      internalValueResult.usePublicIp = this._usePublicIp;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesBACKUPPROTECTEDITEMSNormalCollectorConfigCollectors | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._appliesTo = undefined;
      this._autoBalancedCollectorGroupId = undefined;
      this._collectorId = undefined;
      this._priority = undefined;
      this._usePublicIp = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._appliesTo = value.appliesTo;
      this._autoBalancedCollectorGroupId = value.autoBalancedCollectorGroupId;
      this._collectorId = value.collectorId;
      this._priority = value.priority;
      this._usePublicIp = value.usePublicIp;
    }
  }

  // applies_to - computed: false, optional: true, required: false
  private _appliesTo?: string; 
  public get appliesTo() {
    return this.getStringAttribute('applies_to');
  }
  public set appliesTo(value: string) {
    this._appliesTo = value;
  }
  public resetAppliesTo() {
    this._appliesTo = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appliesToInput() {
    return this._appliesTo;
  }

  // auto_balanced_collector_group_id - computed: false, optional: true, required: false
  private _autoBalancedCollectorGroupId?: number; 
  public get autoBalancedCollectorGroupId() {
    return this.getNumberAttribute('auto_balanced_collector_group_id');
  }
  public set autoBalancedCollectorGroupId(value: number) {
    this._autoBalancedCollectorGroupId = value;
  }
  public resetAutoBalancedCollectorGroupId() {
    this._autoBalancedCollectorGroupId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoBalancedCollectorGroupIdInput() {
    return this._autoBalancedCollectorGroupId;
  }

  // collector_id - computed: false, optional: true, required: false
  private _collectorId?: number; 
  public get collectorId() {
    return this.getNumberAttribute('collector_id');
  }
  public set collectorId(value: number) {
    this._collectorId = value;
  }
  public resetCollectorId() {
    this._collectorId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorIdInput() {
    return this._collectorId;
  }

  // priority - computed: false, optional: true, required: false
  private _priority?: number; 
  public get priority() {
    return this.getNumberAttribute('priority');
  }
  public set priority(value: number) {
    this._priority = value;
  }
  public resetPriority() {
    this._priority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get priorityInput() {
    return this._priority;
  }

  // use_public_ip - computed: false, optional: true, required: false
  private _usePublicIp?: boolean | cdktf.IResolvable; 
  public get usePublicIp() {
    return this.getBooleanAttribute('use_public_ip');
  }
  public set usePublicIp(value: boolean | cdktf.IResolvable) {
    this._usePublicIp = value;
  }
  public resetUsePublicIp() {
    this._usePublicIp = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usePublicIpInput() {
    return this._usePublicIp;
  }
}

export class DeviceGroupExtraServicesBACKUPPROTECTEDITEMSNormalCollectorConfigCollectorsList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesBACKUPPROTECTEDITEMSNormalCollectorConfigCollectors[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesBACKUPPROTECTEDITEMSNormalCollectorConfigCollectorsOutputReference {
    return new DeviceGroupExtraServicesBACKUPPROTECTEDITEMSNormalCollectorConfigCollectorsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesBACKUPPROTECTEDITEMSNormalCollectorConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#collectors DeviceGroup#collectors}
  */
  readonly collectors?: DeviceGroupExtraServicesBACKUPPROTECTEDITEMSNormalCollectorConfigCollectors[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#enabled DeviceGroup#enabled}
  */
  readonly enabled: boolean | cdktf.IResolvable;
}

export function deviceGroupExtraServicesBACKUPPROTECTEDITEMSNormalCollectorConfigToTerraform(struct?: DeviceGroupExtraServicesBACKUPPROTECTEDITEMSNormalCollectorConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    collectors: cdktf.listMapper(deviceGroupExtraServicesBACKUPPROTECTEDITEMSNormalCollectorConfigCollectorsToTerraform, false)(struct!.collectors),
    enabled: cdktf.booleanToTerraform(struct!.enabled),
  }
}


export function deviceGroupExtraServicesBACKUPPROTECTEDITEMSNormalCollectorConfigToHclTerraform(struct?: DeviceGroupExtraServicesBACKUPPROTECTEDITEMSNormalCollectorConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    collectors: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesBACKUPPROTECTEDITEMSNormalCollectorConfigCollectorsToHclTerraform, false)(struct!.collectors),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesBACKUPPROTECTEDITEMSNormalCollectorConfigCollectorsList",
    },
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesBACKUPPROTECTEDITEMSNormalCollectorConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesBACKUPPROTECTEDITEMSNormalCollectorConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._collectors?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectors = this._collectors?.internalValue;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesBACKUPPROTECTEDITEMSNormalCollectorConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._collectors.internalValue = undefined;
      this._enabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._collectors.internalValue = value.collectors;
      this._enabled = value.enabled;
    }
  }

  // collectors - computed: false, optional: true, required: false
  private _collectors = new DeviceGroupExtraServicesBACKUPPROTECTEDITEMSNormalCollectorConfigCollectorsList(this, "collectors", false);
  public get collectors() {
    return this._collectors;
  }
  public putCollectors(value: DeviceGroupExtraServicesBACKUPPROTECTEDITEMSNormalCollectorConfigCollectors[] | cdktf.IResolvable) {
    this._collectors.internalValue = value;
  }
  public resetCollectors() {
    this._collectors.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorsInput() {
    return this._collectors.internalValue;
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }
}

export class DeviceGroupExtraServicesBACKUPPROTECTEDITEMSNormalCollectorConfigList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesBACKUPPROTECTEDITEMSNormalCollectorConfig[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesBACKUPPROTECTEDITEMSNormalCollectorConfigOutputReference {
    return new DeviceGroupExtraServicesBACKUPPROTECTEDITEMSNormalCollectorConfigOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesBACKUPPROTECTEDITEMS {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#custom_n_s_p_schedule DeviceGroup#custom_n_s_p_schedule}
  */
  readonly customNSPSchedule?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#dead_operation DeviceGroup#dead_operation}
  */
  readonly deadOperation?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#device_display_name_template DeviceGroup#device_display_name_template}
  */
  readonly deviceDisplayNameTemplate?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#disable_stop_terminate_host_monitor DeviceGroup#disable_stop_terminate_host_monitor}
  */
  readonly disableStopTerminateHostMonitor?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#disable_terminated_host_alerting DeviceGroup#disable_terminated_host_alerting}
  */
  readonly disableTerminatedHostAlerting?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#monitoring_region_infos DeviceGroup#monitoring_region_infos}
  */
  readonly monitoringRegionInfos?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#monitoring_regions DeviceGroup#monitoring_regions}
  */
  readonly monitoringRegions?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#name_filter DeviceGroup#name_filter}
  */
  readonly nameFilter?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#select_all DeviceGroup#select_all}
  */
  readonly selectAll?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#tags DeviceGroup#tags}
  */
  readonly tags?: DeviceGroupExtraServicesBACKUPPROTECTEDITEMSTags[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#use_default DeviceGroup#use_default}
  */
  readonly useDefault: boolean | cdktf.IResolvable;
  /**
  * normal_collector_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#normal_collector_config DeviceGroup#normal_collector_config}
  */
  readonly normalCollectorConfig?: DeviceGroupExtraServicesBACKUPPROTECTEDITEMSNormalCollectorConfig[] | cdktf.IResolvable;
}

export function deviceGroupExtraServicesBACKUPPROTECTEDITEMSToTerraform(struct?: DeviceGroupExtraServicesBACKUPPROTECTEDITEMS | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    custom_n_s_p_schedule: cdktf.stringToTerraform(struct!.customNSPSchedule),
    dead_operation: cdktf.stringToTerraform(struct!.deadOperation),
    device_display_name_template: cdktf.stringToTerraform(struct!.deviceDisplayNameTemplate),
    disable_stop_terminate_host_monitor: cdktf.booleanToTerraform(struct!.disableStopTerminateHostMonitor),
    disable_terminated_host_alerting: cdktf.booleanToTerraform(struct!.disableTerminatedHostAlerting),
    monitoring_region_infos: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.monitoringRegionInfos),
    monitoring_regions: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.monitoringRegions),
    name_filter: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.nameFilter),
    select_all: cdktf.booleanToTerraform(struct!.selectAll),
    tags: cdktf.listMapper(deviceGroupExtraServicesBACKUPPROTECTEDITEMSTagsToTerraform, false)(struct!.tags),
    use_default: cdktf.booleanToTerraform(struct!.useDefault),
    normal_collector_config: cdktf.listMapper(deviceGroupExtraServicesBACKUPPROTECTEDITEMSNormalCollectorConfigToTerraform, true)(struct!.normalCollectorConfig),
  }
}


export function deviceGroupExtraServicesBACKUPPROTECTEDITEMSToHclTerraform(struct?: DeviceGroupExtraServicesBACKUPPROTECTEDITEMS | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    custom_n_s_p_schedule: {
      value: cdktf.stringToHclTerraform(struct!.customNSPSchedule),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dead_operation: {
      value: cdktf.stringToHclTerraform(struct!.deadOperation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    device_display_name_template: {
      value: cdktf.stringToHclTerraform(struct!.deviceDisplayNameTemplate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disable_stop_terminate_host_monitor: {
      value: cdktf.booleanToHclTerraform(struct!.disableStopTerminateHostMonitor),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    disable_terminated_host_alerting: {
      value: cdktf.booleanToHclTerraform(struct!.disableTerminatedHostAlerting),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    monitoring_region_infos: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.monitoringRegionInfos),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    monitoring_regions: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.monitoringRegions),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    name_filter: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.nameFilter),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    select_all: {
      value: cdktf.booleanToHclTerraform(struct!.selectAll),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tags: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesBACKUPPROTECTEDITEMSTagsToHclTerraform, false)(struct!.tags),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesBACKUPPROTECTEDITEMSTagsList",
    },
    use_default: {
      value: cdktf.booleanToHclTerraform(struct!.useDefault),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    normal_collector_config: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesBACKUPPROTECTEDITEMSNormalCollectorConfigToHclTerraform, true)(struct!.normalCollectorConfig),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesBACKUPPROTECTEDITEMSNormalCollectorConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesBACKUPPROTECTEDITEMSOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesBACKUPPROTECTEDITEMS | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._customNSPSchedule !== undefined) {
      hasAnyValues = true;
      internalValueResult.customNSPSchedule = this._customNSPSchedule;
    }
    if (this._deadOperation !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadOperation = this._deadOperation;
    }
    if (this._deviceDisplayNameTemplate !== undefined) {
      hasAnyValues = true;
      internalValueResult.deviceDisplayNameTemplate = this._deviceDisplayNameTemplate;
    }
    if (this._disableStopTerminateHostMonitor !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableStopTerminateHostMonitor = this._disableStopTerminateHostMonitor;
    }
    if (this._disableTerminatedHostAlerting !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableTerminatedHostAlerting = this._disableTerminatedHostAlerting;
    }
    if (this._monitoringRegionInfos !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoringRegionInfos = this._monitoringRegionInfos;
    }
    if (this._monitoringRegions !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoringRegions = this._monitoringRegions;
    }
    if (this._nameFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.nameFilter = this._nameFilter;
    }
    if (this._selectAll !== undefined) {
      hasAnyValues = true;
      internalValueResult.selectAll = this._selectAll;
    }
    if (this._tags?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags?.internalValue;
    }
    if (this._useDefault !== undefined) {
      hasAnyValues = true;
      internalValueResult.useDefault = this._useDefault;
    }
    if (this._normalCollectorConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.normalCollectorConfig = this._normalCollectorConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesBACKUPPROTECTEDITEMS | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._customNSPSchedule = undefined;
      this._deadOperation = undefined;
      this._deviceDisplayNameTemplate = undefined;
      this._disableStopTerminateHostMonitor = undefined;
      this._disableTerminatedHostAlerting = undefined;
      this._monitoringRegionInfos = undefined;
      this._monitoringRegions = undefined;
      this._nameFilter = undefined;
      this._selectAll = undefined;
      this._tags.internalValue = undefined;
      this._useDefault = undefined;
      this._normalCollectorConfig.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._customNSPSchedule = value.customNSPSchedule;
      this._deadOperation = value.deadOperation;
      this._deviceDisplayNameTemplate = value.deviceDisplayNameTemplate;
      this._disableStopTerminateHostMonitor = value.disableStopTerminateHostMonitor;
      this._disableTerminatedHostAlerting = value.disableTerminatedHostAlerting;
      this._monitoringRegionInfos = value.monitoringRegionInfos;
      this._monitoringRegions = value.monitoringRegions;
      this._nameFilter = value.nameFilter;
      this._selectAll = value.selectAll;
      this._tags.internalValue = value.tags;
      this._useDefault = value.useDefault;
      this._normalCollectorConfig.internalValue = value.normalCollectorConfig;
    }
  }

  // custom_n_s_p_schedule - computed: false, optional: true, required: false
  private _customNSPSchedule?: string; 
  public get customNSPSchedule() {
    return this.getStringAttribute('custom_n_s_p_schedule');
  }
  public set customNSPSchedule(value: string) {
    this._customNSPSchedule = value;
  }
  public resetCustomNSPSchedule() {
    this._customNSPSchedule = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customNSPScheduleInput() {
    return this._customNSPSchedule;
  }

  // dead_operation - computed: false, optional: true, required: false
  private _deadOperation?: string; 
  public get deadOperation() {
    return this.getStringAttribute('dead_operation');
  }
  public set deadOperation(value: string) {
    this._deadOperation = value;
  }
  public resetDeadOperation() {
    this._deadOperation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadOperationInput() {
    return this._deadOperation;
  }

  // device_display_name_template - computed: false, optional: true, required: false
  private _deviceDisplayNameTemplate?: string; 
  public get deviceDisplayNameTemplate() {
    return this.getStringAttribute('device_display_name_template');
  }
  public set deviceDisplayNameTemplate(value: string) {
    this._deviceDisplayNameTemplate = value;
  }
  public resetDeviceDisplayNameTemplate() {
    this._deviceDisplayNameTemplate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deviceDisplayNameTemplateInput() {
    return this._deviceDisplayNameTemplate;
  }

  // disable_stop_terminate_host_monitor - computed: false, optional: true, required: false
  private _disableStopTerminateHostMonitor?: boolean | cdktf.IResolvable; 
  public get disableStopTerminateHostMonitor() {
    return this.getBooleanAttribute('disable_stop_terminate_host_monitor');
  }
  public set disableStopTerminateHostMonitor(value: boolean | cdktf.IResolvable) {
    this._disableStopTerminateHostMonitor = value;
  }
  public resetDisableStopTerminateHostMonitor() {
    this._disableStopTerminateHostMonitor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableStopTerminateHostMonitorInput() {
    return this._disableStopTerminateHostMonitor;
  }

  // disable_terminated_host_alerting - computed: false, optional: true, required: false
  private _disableTerminatedHostAlerting?: boolean | cdktf.IResolvable; 
  public get disableTerminatedHostAlerting() {
    return this.getBooleanAttribute('disable_terminated_host_alerting');
  }
  public set disableTerminatedHostAlerting(value: boolean | cdktf.IResolvable) {
    this._disableTerminatedHostAlerting = value;
  }
  public resetDisableTerminatedHostAlerting() {
    this._disableTerminatedHostAlerting = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableTerminatedHostAlertingInput() {
    return this._disableTerminatedHostAlerting;
  }

  // monitoring_region_infos - computed: false, optional: true, required: false
  private _monitoringRegionInfos?: string[]; 
  public get monitoringRegionInfos() {
    return cdktf.Fn.tolist(this.getListAttribute('monitoring_region_infos'));
  }
  public set monitoringRegionInfos(value: string[]) {
    this._monitoringRegionInfos = value;
  }
  public resetMonitoringRegionInfos() {
    this._monitoringRegionInfos = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoringRegionInfosInput() {
    return this._monitoringRegionInfos;
  }

  // monitoring_regions - computed: false, optional: true, required: false
  private _monitoringRegions?: string[]; 
  public get monitoringRegions() {
    return cdktf.Fn.tolist(this.getListAttribute('monitoring_regions'));
  }
  public set monitoringRegions(value: string[]) {
    this._monitoringRegions = value;
  }
  public resetMonitoringRegions() {
    this._monitoringRegions = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoringRegionsInput() {
    return this._monitoringRegions;
  }

  // name_filter - computed: false, optional: true, required: false
  private _nameFilter?: string[]; 
  public get nameFilter() {
    return cdktf.Fn.tolist(this.getListAttribute('name_filter'));
  }
  public set nameFilter(value: string[]) {
    this._nameFilter = value;
  }
  public resetNameFilter() {
    this._nameFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameFilterInput() {
    return this._nameFilter;
  }

  // select_all - computed: false, optional: true, required: false
  private _selectAll?: boolean | cdktf.IResolvable; 
  public get selectAll() {
    return this.getBooleanAttribute('select_all');
  }
  public set selectAll(value: boolean | cdktf.IResolvable) {
    this._selectAll = value;
  }
  public resetSelectAll() {
    this._selectAll = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectAllInput() {
    return this._selectAll;
  }

  // tags - computed: false, optional: true, required: false
  private _tags = new DeviceGroupExtraServicesBACKUPPROTECTEDITEMSTagsList(this, "tags", false);
  public get tags() {
    return this._tags;
  }
  public putTags(value: DeviceGroupExtraServicesBACKUPPROTECTEDITEMSTags[] | cdktf.IResolvable) {
    this._tags.internalValue = value;
  }
  public resetTags() {
    this._tags.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags.internalValue;
  }

  // use_default - computed: false, optional: false, required: true
  private _useDefault?: boolean | cdktf.IResolvable; 
  public get useDefault() {
    return this.getBooleanAttribute('use_default');
  }
  public set useDefault(value: boolean | cdktf.IResolvable) {
    this._useDefault = value;
  }
  // Temporarily expose input value. Use with caution.
  public get useDefaultInput() {
    return this._useDefault;
  }

  // normal_collector_config - computed: false, optional: true, required: false
  private _normalCollectorConfig = new DeviceGroupExtraServicesBACKUPPROTECTEDITEMSNormalCollectorConfigList(this, "normal_collector_config", false);
  public get normalCollectorConfig() {
    return this._normalCollectorConfig;
  }
  public putNormalCollectorConfig(value: DeviceGroupExtraServicesBACKUPPROTECTEDITEMSNormalCollectorConfig[] | cdktf.IResolvable) {
    this._normalCollectorConfig.internalValue = value;
  }
  public resetNormalCollectorConfig() {
    this._normalCollectorConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get normalCollectorConfigInput() {
    return this._normalCollectorConfig.internalValue;
  }
}

export class DeviceGroupExtraServicesBACKUPPROTECTEDITEMSList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesBACKUPPROTECTEDITEMS[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesBACKUPPROTECTEDITEMSOutputReference {
    return new DeviceGroupExtraServicesBACKUPPROTECTEDITEMSOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesBLOBSTORAGETags {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#name DeviceGroup#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#operation DeviceGroup#operation}
  */
  readonly operation?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#value DeviceGroup#value}
  */
  readonly value?: string;
}

export function deviceGroupExtraServicesBLOBSTORAGETagsToTerraform(struct?: DeviceGroupExtraServicesBLOBSTORAGETags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    operation: cdktf.stringToTerraform(struct!.operation),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function deviceGroupExtraServicesBLOBSTORAGETagsToHclTerraform(struct?: DeviceGroupExtraServicesBLOBSTORAGETags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operation: {
      value: cdktf.stringToHclTerraform(struct!.operation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesBLOBSTORAGETagsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesBLOBSTORAGETags | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._operation !== undefined) {
      hasAnyValues = true;
      internalValueResult.operation = this._operation;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesBLOBSTORAGETags | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._operation = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._operation = value.operation;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // operation - computed: false, optional: true, required: false
  private _operation?: string; 
  public get operation() {
    return this.getStringAttribute('operation');
  }
  public set operation(value: string) {
    this._operation = value;
  }
  public resetOperation() {
    this._operation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operationInput() {
    return this._operation;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DeviceGroupExtraServicesBLOBSTORAGETagsList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesBLOBSTORAGETags[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesBLOBSTORAGETagsOutputReference {
    return new DeviceGroupExtraServicesBLOBSTORAGETagsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesBLOBSTORAGENormalCollectorConfigCollectors {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#applies_to DeviceGroup#applies_to}
  */
  readonly appliesTo?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#auto_balanced_collector_group_id DeviceGroup#auto_balanced_collector_group_id}
  */
  readonly autoBalancedCollectorGroupId?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#collector_id DeviceGroup#collector_id}
  */
  readonly collectorId?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#priority DeviceGroup#priority}
  */
  readonly priority?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#use_public_ip DeviceGroup#use_public_ip}
  */
  readonly usePublicIp?: boolean | cdktf.IResolvable;
}

export function deviceGroupExtraServicesBLOBSTORAGENormalCollectorConfigCollectorsToTerraform(struct?: DeviceGroupExtraServicesBLOBSTORAGENormalCollectorConfigCollectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    applies_to: cdktf.stringToTerraform(struct!.appliesTo),
    auto_balanced_collector_group_id: cdktf.numberToTerraform(struct!.autoBalancedCollectorGroupId),
    collector_id: cdktf.numberToTerraform(struct!.collectorId),
    priority: cdktf.numberToTerraform(struct!.priority),
    use_public_ip: cdktf.booleanToTerraform(struct!.usePublicIp),
  }
}


export function deviceGroupExtraServicesBLOBSTORAGENormalCollectorConfigCollectorsToHclTerraform(struct?: DeviceGroupExtraServicesBLOBSTORAGENormalCollectorConfigCollectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    applies_to: {
      value: cdktf.stringToHclTerraform(struct!.appliesTo),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auto_balanced_collector_group_id: {
      value: cdktf.numberToHclTerraform(struct!.autoBalancedCollectorGroupId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    collector_id: {
      value: cdktf.numberToHclTerraform(struct!.collectorId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    priority: {
      value: cdktf.numberToHclTerraform(struct!.priority),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    use_public_ip: {
      value: cdktf.booleanToHclTerraform(struct!.usePublicIp),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesBLOBSTORAGENormalCollectorConfigCollectorsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesBLOBSTORAGENormalCollectorConfigCollectors | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._appliesTo !== undefined) {
      hasAnyValues = true;
      internalValueResult.appliesTo = this._appliesTo;
    }
    if (this._autoBalancedCollectorGroupId !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoBalancedCollectorGroupId = this._autoBalancedCollectorGroupId;
    }
    if (this._collectorId !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectorId = this._collectorId;
    }
    if (this._priority !== undefined) {
      hasAnyValues = true;
      internalValueResult.priority = this._priority;
    }
    if (this._usePublicIp !== undefined) {
      hasAnyValues = true;
      internalValueResult.usePublicIp = this._usePublicIp;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesBLOBSTORAGENormalCollectorConfigCollectors | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._appliesTo = undefined;
      this._autoBalancedCollectorGroupId = undefined;
      this._collectorId = undefined;
      this._priority = undefined;
      this._usePublicIp = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._appliesTo = value.appliesTo;
      this._autoBalancedCollectorGroupId = value.autoBalancedCollectorGroupId;
      this._collectorId = value.collectorId;
      this._priority = value.priority;
      this._usePublicIp = value.usePublicIp;
    }
  }

  // applies_to - computed: false, optional: true, required: false
  private _appliesTo?: string; 
  public get appliesTo() {
    return this.getStringAttribute('applies_to');
  }
  public set appliesTo(value: string) {
    this._appliesTo = value;
  }
  public resetAppliesTo() {
    this._appliesTo = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appliesToInput() {
    return this._appliesTo;
  }

  // auto_balanced_collector_group_id - computed: false, optional: true, required: false
  private _autoBalancedCollectorGroupId?: number; 
  public get autoBalancedCollectorGroupId() {
    return this.getNumberAttribute('auto_balanced_collector_group_id');
  }
  public set autoBalancedCollectorGroupId(value: number) {
    this._autoBalancedCollectorGroupId = value;
  }
  public resetAutoBalancedCollectorGroupId() {
    this._autoBalancedCollectorGroupId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoBalancedCollectorGroupIdInput() {
    return this._autoBalancedCollectorGroupId;
  }

  // collector_id - computed: false, optional: true, required: false
  private _collectorId?: number; 
  public get collectorId() {
    return this.getNumberAttribute('collector_id');
  }
  public set collectorId(value: number) {
    this._collectorId = value;
  }
  public resetCollectorId() {
    this._collectorId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorIdInput() {
    return this._collectorId;
  }

  // priority - computed: false, optional: true, required: false
  private _priority?: number; 
  public get priority() {
    return this.getNumberAttribute('priority');
  }
  public set priority(value: number) {
    this._priority = value;
  }
  public resetPriority() {
    this._priority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get priorityInput() {
    return this._priority;
  }

  // use_public_ip - computed: false, optional: true, required: false
  private _usePublicIp?: boolean | cdktf.IResolvable; 
  public get usePublicIp() {
    return this.getBooleanAttribute('use_public_ip');
  }
  public set usePublicIp(value: boolean | cdktf.IResolvable) {
    this._usePublicIp = value;
  }
  public resetUsePublicIp() {
    this._usePublicIp = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usePublicIpInput() {
    return this._usePublicIp;
  }
}

export class DeviceGroupExtraServicesBLOBSTORAGENormalCollectorConfigCollectorsList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesBLOBSTORAGENormalCollectorConfigCollectors[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesBLOBSTORAGENormalCollectorConfigCollectorsOutputReference {
    return new DeviceGroupExtraServicesBLOBSTORAGENormalCollectorConfigCollectorsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesBLOBSTORAGENormalCollectorConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#collectors DeviceGroup#collectors}
  */
  readonly collectors?: DeviceGroupExtraServicesBLOBSTORAGENormalCollectorConfigCollectors[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#enabled DeviceGroup#enabled}
  */
  readonly enabled: boolean | cdktf.IResolvable;
}

export function deviceGroupExtraServicesBLOBSTORAGENormalCollectorConfigToTerraform(struct?: DeviceGroupExtraServicesBLOBSTORAGENormalCollectorConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    collectors: cdktf.listMapper(deviceGroupExtraServicesBLOBSTORAGENormalCollectorConfigCollectorsToTerraform, false)(struct!.collectors),
    enabled: cdktf.booleanToTerraform(struct!.enabled),
  }
}


export function deviceGroupExtraServicesBLOBSTORAGENormalCollectorConfigToHclTerraform(struct?: DeviceGroupExtraServicesBLOBSTORAGENormalCollectorConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    collectors: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesBLOBSTORAGENormalCollectorConfigCollectorsToHclTerraform, false)(struct!.collectors),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesBLOBSTORAGENormalCollectorConfigCollectorsList",
    },
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesBLOBSTORAGENormalCollectorConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesBLOBSTORAGENormalCollectorConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._collectors?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectors = this._collectors?.internalValue;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesBLOBSTORAGENormalCollectorConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._collectors.internalValue = undefined;
      this._enabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._collectors.internalValue = value.collectors;
      this._enabled = value.enabled;
    }
  }

  // collectors - computed: false, optional: true, required: false
  private _collectors = new DeviceGroupExtraServicesBLOBSTORAGENormalCollectorConfigCollectorsList(this, "collectors", false);
  public get collectors() {
    return this._collectors;
  }
  public putCollectors(value: DeviceGroupExtraServicesBLOBSTORAGENormalCollectorConfigCollectors[] | cdktf.IResolvable) {
    this._collectors.internalValue = value;
  }
  public resetCollectors() {
    this._collectors.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorsInput() {
    return this._collectors.internalValue;
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }
}

export class DeviceGroupExtraServicesBLOBSTORAGENormalCollectorConfigList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesBLOBSTORAGENormalCollectorConfig[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesBLOBSTORAGENormalCollectorConfigOutputReference {
    return new DeviceGroupExtraServicesBLOBSTORAGENormalCollectorConfigOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesBLOBSTORAGE {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#custom_n_s_p_schedule DeviceGroup#custom_n_s_p_schedule}
  */
  readonly customNSPSchedule?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#dead_operation DeviceGroup#dead_operation}
  */
  readonly deadOperation?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#device_display_name_template DeviceGroup#device_display_name_template}
  */
  readonly deviceDisplayNameTemplate?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#disable_stop_terminate_host_monitor DeviceGroup#disable_stop_terminate_host_monitor}
  */
  readonly disableStopTerminateHostMonitor?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#disable_terminated_host_alerting DeviceGroup#disable_terminated_host_alerting}
  */
  readonly disableTerminatedHostAlerting?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#monitoring_region_infos DeviceGroup#monitoring_region_infos}
  */
  readonly monitoringRegionInfos?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#monitoring_regions DeviceGroup#monitoring_regions}
  */
  readonly monitoringRegions?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#name_filter DeviceGroup#name_filter}
  */
  readonly nameFilter?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#select_all DeviceGroup#select_all}
  */
  readonly selectAll?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#tags DeviceGroup#tags}
  */
  readonly tags?: DeviceGroupExtraServicesBLOBSTORAGETags[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#use_default DeviceGroup#use_default}
  */
  readonly useDefault: boolean | cdktf.IResolvable;
  /**
  * normal_collector_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#normal_collector_config DeviceGroup#normal_collector_config}
  */
  readonly normalCollectorConfig?: DeviceGroupExtraServicesBLOBSTORAGENormalCollectorConfig[] | cdktf.IResolvable;
}

export function deviceGroupExtraServicesBLOBSTORAGEToTerraform(struct?: DeviceGroupExtraServicesBLOBSTORAGE | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    custom_n_s_p_schedule: cdktf.stringToTerraform(struct!.customNSPSchedule),
    dead_operation: cdktf.stringToTerraform(struct!.deadOperation),
    device_display_name_template: cdktf.stringToTerraform(struct!.deviceDisplayNameTemplate),
    disable_stop_terminate_host_monitor: cdktf.booleanToTerraform(struct!.disableStopTerminateHostMonitor),
    disable_terminated_host_alerting: cdktf.booleanToTerraform(struct!.disableTerminatedHostAlerting),
    monitoring_region_infos: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.monitoringRegionInfos),
    monitoring_regions: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.monitoringRegions),
    name_filter: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.nameFilter),
    select_all: cdktf.booleanToTerraform(struct!.selectAll),
    tags: cdktf.listMapper(deviceGroupExtraServicesBLOBSTORAGETagsToTerraform, false)(struct!.tags),
    use_default: cdktf.booleanToTerraform(struct!.useDefault),
    normal_collector_config: cdktf.listMapper(deviceGroupExtraServicesBLOBSTORAGENormalCollectorConfigToTerraform, true)(struct!.normalCollectorConfig),
  }
}


export function deviceGroupExtraServicesBLOBSTORAGEToHclTerraform(struct?: DeviceGroupExtraServicesBLOBSTORAGE | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    custom_n_s_p_schedule: {
      value: cdktf.stringToHclTerraform(struct!.customNSPSchedule),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dead_operation: {
      value: cdktf.stringToHclTerraform(struct!.deadOperation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    device_display_name_template: {
      value: cdktf.stringToHclTerraform(struct!.deviceDisplayNameTemplate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disable_stop_terminate_host_monitor: {
      value: cdktf.booleanToHclTerraform(struct!.disableStopTerminateHostMonitor),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    disable_terminated_host_alerting: {
      value: cdktf.booleanToHclTerraform(struct!.disableTerminatedHostAlerting),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    monitoring_region_infos: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.monitoringRegionInfos),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    monitoring_regions: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.monitoringRegions),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    name_filter: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.nameFilter),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    select_all: {
      value: cdktf.booleanToHclTerraform(struct!.selectAll),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tags: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesBLOBSTORAGETagsToHclTerraform, false)(struct!.tags),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesBLOBSTORAGETagsList",
    },
    use_default: {
      value: cdktf.booleanToHclTerraform(struct!.useDefault),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    normal_collector_config: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesBLOBSTORAGENormalCollectorConfigToHclTerraform, true)(struct!.normalCollectorConfig),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesBLOBSTORAGENormalCollectorConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesBLOBSTORAGEOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesBLOBSTORAGE | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._customNSPSchedule !== undefined) {
      hasAnyValues = true;
      internalValueResult.customNSPSchedule = this._customNSPSchedule;
    }
    if (this._deadOperation !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadOperation = this._deadOperation;
    }
    if (this._deviceDisplayNameTemplate !== undefined) {
      hasAnyValues = true;
      internalValueResult.deviceDisplayNameTemplate = this._deviceDisplayNameTemplate;
    }
    if (this._disableStopTerminateHostMonitor !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableStopTerminateHostMonitor = this._disableStopTerminateHostMonitor;
    }
    if (this._disableTerminatedHostAlerting !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableTerminatedHostAlerting = this._disableTerminatedHostAlerting;
    }
    if (this._monitoringRegionInfos !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoringRegionInfos = this._monitoringRegionInfos;
    }
    if (this._monitoringRegions !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoringRegions = this._monitoringRegions;
    }
    if (this._nameFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.nameFilter = this._nameFilter;
    }
    if (this._selectAll !== undefined) {
      hasAnyValues = true;
      internalValueResult.selectAll = this._selectAll;
    }
    if (this._tags?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags?.internalValue;
    }
    if (this._useDefault !== undefined) {
      hasAnyValues = true;
      internalValueResult.useDefault = this._useDefault;
    }
    if (this._normalCollectorConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.normalCollectorConfig = this._normalCollectorConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesBLOBSTORAGE | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._customNSPSchedule = undefined;
      this._deadOperation = undefined;
      this._deviceDisplayNameTemplate = undefined;
      this._disableStopTerminateHostMonitor = undefined;
      this._disableTerminatedHostAlerting = undefined;
      this._monitoringRegionInfos = undefined;
      this._monitoringRegions = undefined;
      this._nameFilter = undefined;
      this._selectAll = undefined;
      this._tags.internalValue = undefined;
      this._useDefault = undefined;
      this._normalCollectorConfig.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._customNSPSchedule = value.customNSPSchedule;
      this._deadOperation = value.deadOperation;
      this._deviceDisplayNameTemplate = value.deviceDisplayNameTemplate;
      this._disableStopTerminateHostMonitor = value.disableStopTerminateHostMonitor;
      this._disableTerminatedHostAlerting = value.disableTerminatedHostAlerting;
      this._monitoringRegionInfos = value.monitoringRegionInfos;
      this._monitoringRegions = value.monitoringRegions;
      this._nameFilter = value.nameFilter;
      this._selectAll = value.selectAll;
      this._tags.internalValue = value.tags;
      this._useDefault = value.useDefault;
      this._normalCollectorConfig.internalValue = value.normalCollectorConfig;
    }
  }

  // custom_n_s_p_schedule - computed: false, optional: true, required: false
  private _customNSPSchedule?: string; 
  public get customNSPSchedule() {
    return this.getStringAttribute('custom_n_s_p_schedule');
  }
  public set customNSPSchedule(value: string) {
    this._customNSPSchedule = value;
  }
  public resetCustomNSPSchedule() {
    this._customNSPSchedule = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customNSPScheduleInput() {
    return this._customNSPSchedule;
  }

  // dead_operation - computed: false, optional: true, required: false
  private _deadOperation?: string; 
  public get deadOperation() {
    return this.getStringAttribute('dead_operation');
  }
  public set deadOperation(value: string) {
    this._deadOperation = value;
  }
  public resetDeadOperation() {
    this._deadOperation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadOperationInput() {
    return this._deadOperation;
  }

  // device_display_name_template - computed: false, optional: true, required: false
  private _deviceDisplayNameTemplate?: string; 
  public get deviceDisplayNameTemplate() {
    return this.getStringAttribute('device_display_name_template');
  }
  public set deviceDisplayNameTemplate(value: string) {
    this._deviceDisplayNameTemplate = value;
  }
  public resetDeviceDisplayNameTemplate() {
    this._deviceDisplayNameTemplate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deviceDisplayNameTemplateInput() {
    return this._deviceDisplayNameTemplate;
  }

  // disable_stop_terminate_host_monitor - computed: false, optional: true, required: false
  private _disableStopTerminateHostMonitor?: boolean | cdktf.IResolvable; 
  public get disableStopTerminateHostMonitor() {
    return this.getBooleanAttribute('disable_stop_terminate_host_monitor');
  }
  public set disableStopTerminateHostMonitor(value: boolean | cdktf.IResolvable) {
    this._disableStopTerminateHostMonitor = value;
  }
  public resetDisableStopTerminateHostMonitor() {
    this._disableStopTerminateHostMonitor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableStopTerminateHostMonitorInput() {
    return this._disableStopTerminateHostMonitor;
  }

  // disable_terminated_host_alerting - computed: false, optional: true, required: false
  private _disableTerminatedHostAlerting?: boolean | cdktf.IResolvable; 
  public get disableTerminatedHostAlerting() {
    return this.getBooleanAttribute('disable_terminated_host_alerting');
  }
  public set disableTerminatedHostAlerting(value: boolean | cdktf.IResolvable) {
    this._disableTerminatedHostAlerting = value;
  }
  public resetDisableTerminatedHostAlerting() {
    this._disableTerminatedHostAlerting = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableTerminatedHostAlertingInput() {
    return this._disableTerminatedHostAlerting;
  }

  // monitoring_region_infos - computed: false, optional: true, required: false
  private _monitoringRegionInfos?: string[]; 
  public get monitoringRegionInfos() {
    return cdktf.Fn.tolist(this.getListAttribute('monitoring_region_infos'));
  }
  public set monitoringRegionInfos(value: string[]) {
    this._monitoringRegionInfos = value;
  }
  public resetMonitoringRegionInfos() {
    this._monitoringRegionInfos = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoringRegionInfosInput() {
    return this._monitoringRegionInfos;
  }

  // monitoring_regions - computed: false, optional: true, required: false
  private _monitoringRegions?: string[]; 
  public get monitoringRegions() {
    return cdktf.Fn.tolist(this.getListAttribute('monitoring_regions'));
  }
  public set monitoringRegions(value: string[]) {
    this._monitoringRegions = value;
  }
  public resetMonitoringRegions() {
    this._monitoringRegions = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoringRegionsInput() {
    return this._monitoringRegions;
  }

  // name_filter - computed: false, optional: true, required: false
  private _nameFilter?: string[]; 
  public get nameFilter() {
    return cdktf.Fn.tolist(this.getListAttribute('name_filter'));
  }
  public set nameFilter(value: string[]) {
    this._nameFilter = value;
  }
  public resetNameFilter() {
    this._nameFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameFilterInput() {
    return this._nameFilter;
  }

  // select_all - computed: false, optional: true, required: false
  private _selectAll?: boolean | cdktf.IResolvable; 
  public get selectAll() {
    return this.getBooleanAttribute('select_all');
  }
  public set selectAll(value: boolean | cdktf.IResolvable) {
    this._selectAll = value;
  }
  public resetSelectAll() {
    this._selectAll = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectAllInput() {
    return this._selectAll;
  }

  // tags - computed: false, optional: true, required: false
  private _tags = new DeviceGroupExtraServicesBLOBSTORAGETagsList(this, "tags", false);
  public get tags() {
    return this._tags;
  }
  public putTags(value: DeviceGroupExtraServicesBLOBSTORAGETags[] | cdktf.IResolvable) {
    this._tags.internalValue = value;
  }
  public resetTags() {
    this._tags.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags.internalValue;
  }

  // use_default - computed: false, optional: false, required: true
  private _useDefault?: boolean | cdktf.IResolvable; 
  public get useDefault() {
    return this.getBooleanAttribute('use_default');
  }
  public set useDefault(value: boolean | cdktf.IResolvable) {
    this._useDefault = value;
  }
  // Temporarily expose input value. Use with caution.
  public get useDefaultInput() {
    return this._useDefault;
  }

  // normal_collector_config - computed: false, optional: true, required: false
  private _normalCollectorConfig = new DeviceGroupExtraServicesBLOBSTORAGENormalCollectorConfigList(this, "normal_collector_config", false);
  public get normalCollectorConfig() {
    return this._normalCollectorConfig;
  }
  public putNormalCollectorConfig(value: DeviceGroupExtraServicesBLOBSTORAGENormalCollectorConfig[] | cdktf.IResolvable) {
    this._normalCollectorConfig.internalValue = value;
  }
  public resetNormalCollectorConfig() {
    this._normalCollectorConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get normalCollectorConfigInput() {
    return this._normalCollectorConfig.internalValue;
  }
}

export class DeviceGroupExtraServicesBLOBSTORAGEList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesBLOBSTORAGE[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesBLOBSTORAGEOutputReference {
    return new DeviceGroupExtraServicesBLOBSTORAGEOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesCLOUDFRONTTags {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#name DeviceGroup#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#operation DeviceGroup#operation}
  */
  readonly operation?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#value DeviceGroup#value}
  */
  readonly value?: string;
}

export function deviceGroupExtraServicesCLOUDFRONTTagsToTerraform(struct?: DeviceGroupExtraServicesCLOUDFRONTTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    operation: cdktf.stringToTerraform(struct!.operation),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function deviceGroupExtraServicesCLOUDFRONTTagsToHclTerraform(struct?: DeviceGroupExtraServicesCLOUDFRONTTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operation: {
      value: cdktf.stringToHclTerraform(struct!.operation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesCLOUDFRONTTagsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesCLOUDFRONTTags | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._operation !== undefined) {
      hasAnyValues = true;
      internalValueResult.operation = this._operation;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesCLOUDFRONTTags | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._operation = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._operation = value.operation;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // operation - computed: false, optional: true, required: false
  private _operation?: string; 
  public get operation() {
    return this.getStringAttribute('operation');
  }
  public set operation(value: string) {
    this._operation = value;
  }
  public resetOperation() {
    this._operation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operationInput() {
    return this._operation;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DeviceGroupExtraServicesCLOUDFRONTTagsList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesCLOUDFRONTTags[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesCLOUDFRONTTagsOutputReference {
    return new DeviceGroupExtraServicesCLOUDFRONTTagsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesCLOUDFRONTNormalCollectorConfigCollectors {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#applies_to DeviceGroup#applies_to}
  */
  readonly appliesTo?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#auto_balanced_collector_group_id DeviceGroup#auto_balanced_collector_group_id}
  */
  readonly autoBalancedCollectorGroupId?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#collector_id DeviceGroup#collector_id}
  */
  readonly collectorId?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#priority DeviceGroup#priority}
  */
  readonly priority?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#use_public_ip DeviceGroup#use_public_ip}
  */
  readonly usePublicIp?: boolean | cdktf.IResolvable;
}

export function deviceGroupExtraServicesCLOUDFRONTNormalCollectorConfigCollectorsToTerraform(struct?: DeviceGroupExtraServicesCLOUDFRONTNormalCollectorConfigCollectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    applies_to: cdktf.stringToTerraform(struct!.appliesTo),
    auto_balanced_collector_group_id: cdktf.numberToTerraform(struct!.autoBalancedCollectorGroupId),
    collector_id: cdktf.numberToTerraform(struct!.collectorId),
    priority: cdktf.numberToTerraform(struct!.priority),
    use_public_ip: cdktf.booleanToTerraform(struct!.usePublicIp),
  }
}


export function deviceGroupExtraServicesCLOUDFRONTNormalCollectorConfigCollectorsToHclTerraform(struct?: DeviceGroupExtraServicesCLOUDFRONTNormalCollectorConfigCollectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    applies_to: {
      value: cdktf.stringToHclTerraform(struct!.appliesTo),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auto_balanced_collector_group_id: {
      value: cdktf.numberToHclTerraform(struct!.autoBalancedCollectorGroupId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    collector_id: {
      value: cdktf.numberToHclTerraform(struct!.collectorId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    priority: {
      value: cdktf.numberToHclTerraform(struct!.priority),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    use_public_ip: {
      value: cdktf.booleanToHclTerraform(struct!.usePublicIp),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesCLOUDFRONTNormalCollectorConfigCollectorsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesCLOUDFRONTNormalCollectorConfigCollectors | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._appliesTo !== undefined) {
      hasAnyValues = true;
      internalValueResult.appliesTo = this._appliesTo;
    }
    if (this._autoBalancedCollectorGroupId !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoBalancedCollectorGroupId = this._autoBalancedCollectorGroupId;
    }
    if (this._collectorId !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectorId = this._collectorId;
    }
    if (this._priority !== undefined) {
      hasAnyValues = true;
      internalValueResult.priority = this._priority;
    }
    if (this._usePublicIp !== undefined) {
      hasAnyValues = true;
      internalValueResult.usePublicIp = this._usePublicIp;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesCLOUDFRONTNormalCollectorConfigCollectors | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._appliesTo = undefined;
      this._autoBalancedCollectorGroupId = undefined;
      this._collectorId = undefined;
      this._priority = undefined;
      this._usePublicIp = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._appliesTo = value.appliesTo;
      this._autoBalancedCollectorGroupId = value.autoBalancedCollectorGroupId;
      this._collectorId = value.collectorId;
      this._priority = value.priority;
      this._usePublicIp = value.usePublicIp;
    }
  }

  // applies_to - computed: false, optional: true, required: false
  private _appliesTo?: string; 
  public get appliesTo() {
    return this.getStringAttribute('applies_to');
  }
  public set appliesTo(value: string) {
    this._appliesTo = value;
  }
  public resetAppliesTo() {
    this._appliesTo = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appliesToInput() {
    return this._appliesTo;
  }

  // auto_balanced_collector_group_id - computed: false, optional: true, required: false
  private _autoBalancedCollectorGroupId?: number; 
  public get autoBalancedCollectorGroupId() {
    return this.getNumberAttribute('auto_balanced_collector_group_id');
  }
  public set autoBalancedCollectorGroupId(value: number) {
    this._autoBalancedCollectorGroupId = value;
  }
  public resetAutoBalancedCollectorGroupId() {
    this._autoBalancedCollectorGroupId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoBalancedCollectorGroupIdInput() {
    return this._autoBalancedCollectorGroupId;
  }

  // collector_id - computed: false, optional: true, required: false
  private _collectorId?: number; 
  public get collectorId() {
    return this.getNumberAttribute('collector_id');
  }
  public set collectorId(value: number) {
    this._collectorId = value;
  }
  public resetCollectorId() {
    this._collectorId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorIdInput() {
    return this._collectorId;
  }

  // priority - computed: false, optional: true, required: false
  private _priority?: number; 
  public get priority() {
    return this.getNumberAttribute('priority');
  }
  public set priority(value: number) {
    this._priority = value;
  }
  public resetPriority() {
    this._priority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get priorityInput() {
    return this._priority;
  }

  // use_public_ip - computed: false, optional: true, required: false
  private _usePublicIp?: boolean | cdktf.IResolvable; 
  public get usePublicIp() {
    return this.getBooleanAttribute('use_public_ip');
  }
  public set usePublicIp(value: boolean | cdktf.IResolvable) {
    this._usePublicIp = value;
  }
  public resetUsePublicIp() {
    this._usePublicIp = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usePublicIpInput() {
    return this._usePublicIp;
  }
}

export class DeviceGroupExtraServicesCLOUDFRONTNormalCollectorConfigCollectorsList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesCLOUDFRONTNormalCollectorConfigCollectors[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesCLOUDFRONTNormalCollectorConfigCollectorsOutputReference {
    return new DeviceGroupExtraServicesCLOUDFRONTNormalCollectorConfigCollectorsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesCLOUDFRONTNormalCollectorConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#collectors DeviceGroup#collectors}
  */
  readonly collectors?: DeviceGroupExtraServicesCLOUDFRONTNormalCollectorConfigCollectors[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#enabled DeviceGroup#enabled}
  */
  readonly enabled: boolean | cdktf.IResolvable;
}

export function deviceGroupExtraServicesCLOUDFRONTNormalCollectorConfigToTerraform(struct?: DeviceGroupExtraServicesCLOUDFRONTNormalCollectorConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    collectors: cdktf.listMapper(deviceGroupExtraServicesCLOUDFRONTNormalCollectorConfigCollectorsToTerraform, false)(struct!.collectors),
    enabled: cdktf.booleanToTerraform(struct!.enabled),
  }
}


export function deviceGroupExtraServicesCLOUDFRONTNormalCollectorConfigToHclTerraform(struct?: DeviceGroupExtraServicesCLOUDFRONTNormalCollectorConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    collectors: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesCLOUDFRONTNormalCollectorConfigCollectorsToHclTerraform, false)(struct!.collectors),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesCLOUDFRONTNormalCollectorConfigCollectorsList",
    },
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesCLOUDFRONTNormalCollectorConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesCLOUDFRONTNormalCollectorConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._collectors?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectors = this._collectors?.internalValue;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesCLOUDFRONTNormalCollectorConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._collectors.internalValue = undefined;
      this._enabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._collectors.internalValue = value.collectors;
      this._enabled = value.enabled;
    }
  }

  // collectors - computed: false, optional: true, required: false
  private _collectors = new DeviceGroupExtraServicesCLOUDFRONTNormalCollectorConfigCollectorsList(this, "collectors", false);
  public get collectors() {
    return this._collectors;
  }
  public putCollectors(value: DeviceGroupExtraServicesCLOUDFRONTNormalCollectorConfigCollectors[] | cdktf.IResolvable) {
    this._collectors.internalValue = value;
  }
  public resetCollectors() {
    this._collectors.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorsInput() {
    return this._collectors.internalValue;
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }
}

export class DeviceGroupExtraServicesCLOUDFRONTNormalCollectorConfigList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesCLOUDFRONTNormalCollectorConfig[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesCLOUDFRONTNormalCollectorConfigOutputReference {
    return new DeviceGroupExtraServicesCLOUDFRONTNormalCollectorConfigOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesCLOUDFRONT {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#custom_n_s_p_schedule DeviceGroup#custom_n_s_p_schedule}
  */
  readonly customNSPSchedule?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#dead_operation DeviceGroup#dead_operation}
  */
  readonly deadOperation?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#device_display_name_template DeviceGroup#device_display_name_template}
  */
  readonly deviceDisplayNameTemplate?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#disable_stop_terminate_host_monitor DeviceGroup#disable_stop_terminate_host_monitor}
  */
  readonly disableStopTerminateHostMonitor?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#disable_terminated_host_alerting DeviceGroup#disable_terminated_host_alerting}
  */
  readonly disableTerminatedHostAlerting?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#monitoring_region_infos DeviceGroup#monitoring_region_infos}
  */
  readonly monitoringRegionInfos?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#monitoring_regions DeviceGroup#monitoring_regions}
  */
  readonly monitoringRegions?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#name_filter DeviceGroup#name_filter}
  */
  readonly nameFilter?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#select_all DeviceGroup#select_all}
  */
  readonly selectAll?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#tags DeviceGroup#tags}
  */
  readonly tags?: DeviceGroupExtraServicesCLOUDFRONTTags[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#use_default DeviceGroup#use_default}
  */
  readonly useDefault: boolean | cdktf.IResolvable;
  /**
  * normal_collector_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#normal_collector_config DeviceGroup#normal_collector_config}
  */
  readonly normalCollectorConfig?: DeviceGroupExtraServicesCLOUDFRONTNormalCollectorConfig[] | cdktf.IResolvable;
}

export function deviceGroupExtraServicesCLOUDFRONTToTerraform(struct?: DeviceGroupExtraServicesCLOUDFRONT | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    custom_n_s_p_schedule: cdktf.stringToTerraform(struct!.customNSPSchedule),
    dead_operation: cdktf.stringToTerraform(struct!.deadOperation),
    device_display_name_template: cdktf.stringToTerraform(struct!.deviceDisplayNameTemplate),
    disable_stop_terminate_host_monitor: cdktf.booleanToTerraform(struct!.disableStopTerminateHostMonitor),
    disable_terminated_host_alerting: cdktf.booleanToTerraform(struct!.disableTerminatedHostAlerting),
    monitoring_region_infos: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.monitoringRegionInfos),
    monitoring_regions: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.monitoringRegions),
    name_filter: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.nameFilter),
    select_all: cdktf.booleanToTerraform(struct!.selectAll),
    tags: cdktf.listMapper(deviceGroupExtraServicesCLOUDFRONTTagsToTerraform, false)(struct!.tags),
    use_default: cdktf.booleanToTerraform(struct!.useDefault),
    normal_collector_config: cdktf.listMapper(deviceGroupExtraServicesCLOUDFRONTNormalCollectorConfigToTerraform, true)(struct!.normalCollectorConfig),
  }
}


export function deviceGroupExtraServicesCLOUDFRONTToHclTerraform(struct?: DeviceGroupExtraServicesCLOUDFRONT | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    custom_n_s_p_schedule: {
      value: cdktf.stringToHclTerraform(struct!.customNSPSchedule),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dead_operation: {
      value: cdktf.stringToHclTerraform(struct!.deadOperation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    device_display_name_template: {
      value: cdktf.stringToHclTerraform(struct!.deviceDisplayNameTemplate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disable_stop_terminate_host_monitor: {
      value: cdktf.booleanToHclTerraform(struct!.disableStopTerminateHostMonitor),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    disable_terminated_host_alerting: {
      value: cdktf.booleanToHclTerraform(struct!.disableTerminatedHostAlerting),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    monitoring_region_infos: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.monitoringRegionInfos),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    monitoring_regions: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.monitoringRegions),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    name_filter: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.nameFilter),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    select_all: {
      value: cdktf.booleanToHclTerraform(struct!.selectAll),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tags: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesCLOUDFRONTTagsToHclTerraform, false)(struct!.tags),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesCLOUDFRONTTagsList",
    },
    use_default: {
      value: cdktf.booleanToHclTerraform(struct!.useDefault),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    normal_collector_config: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesCLOUDFRONTNormalCollectorConfigToHclTerraform, true)(struct!.normalCollectorConfig),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesCLOUDFRONTNormalCollectorConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesCLOUDFRONTOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesCLOUDFRONT | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._customNSPSchedule !== undefined) {
      hasAnyValues = true;
      internalValueResult.customNSPSchedule = this._customNSPSchedule;
    }
    if (this._deadOperation !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadOperation = this._deadOperation;
    }
    if (this._deviceDisplayNameTemplate !== undefined) {
      hasAnyValues = true;
      internalValueResult.deviceDisplayNameTemplate = this._deviceDisplayNameTemplate;
    }
    if (this._disableStopTerminateHostMonitor !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableStopTerminateHostMonitor = this._disableStopTerminateHostMonitor;
    }
    if (this._disableTerminatedHostAlerting !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableTerminatedHostAlerting = this._disableTerminatedHostAlerting;
    }
    if (this._monitoringRegionInfos !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoringRegionInfos = this._monitoringRegionInfos;
    }
    if (this._monitoringRegions !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoringRegions = this._monitoringRegions;
    }
    if (this._nameFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.nameFilter = this._nameFilter;
    }
    if (this._selectAll !== undefined) {
      hasAnyValues = true;
      internalValueResult.selectAll = this._selectAll;
    }
    if (this._tags?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags?.internalValue;
    }
    if (this._useDefault !== undefined) {
      hasAnyValues = true;
      internalValueResult.useDefault = this._useDefault;
    }
    if (this._normalCollectorConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.normalCollectorConfig = this._normalCollectorConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesCLOUDFRONT | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._customNSPSchedule = undefined;
      this._deadOperation = undefined;
      this._deviceDisplayNameTemplate = undefined;
      this._disableStopTerminateHostMonitor = undefined;
      this._disableTerminatedHostAlerting = undefined;
      this._monitoringRegionInfos = undefined;
      this._monitoringRegions = undefined;
      this._nameFilter = undefined;
      this._selectAll = undefined;
      this._tags.internalValue = undefined;
      this._useDefault = undefined;
      this._normalCollectorConfig.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._customNSPSchedule = value.customNSPSchedule;
      this._deadOperation = value.deadOperation;
      this._deviceDisplayNameTemplate = value.deviceDisplayNameTemplate;
      this._disableStopTerminateHostMonitor = value.disableStopTerminateHostMonitor;
      this._disableTerminatedHostAlerting = value.disableTerminatedHostAlerting;
      this._monitoringRegionInfos = value.monitoringRegionInfos;
      this._monitoringRegions = value.monitoringRegions;
      this._nameFilter = value.nameFilter;
      this._selectAll = value.selectAll;
      this._tags.internalValue = value.tags;
      this._useDefault = value.useDefault;
      this._normalCollectorConfig.internalValue = value.normalCollectorConfig;
    }
  }

  // custom_n_s_p_schedule - computed: false, optional: true, required: false
  private _customNSPSchedule?: string; 
  public get customNSPSchedule() {
    return this.getStringAttribute('custom_n_s_p_schedule');
  }
  public set customNSPSchedule(value: string) {
    this._customNSPSchedule = value;
  }
  public resetCustomNSPSchedule() {
    this._customNSPSchedule = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customNSPScheduleInput() {
    return this._customNSPSchedule;
  }

  // dead_operation - computed: false, optional: true, required: false
  private _deadOperation?: string; 
  public get deadOperation() {
    return this.getStringAttribute('dead_operation');
  }
  public set deadOperation(value: string) {
    this._deadOperation = value;
  }
  public resetDeadOperation() {
    this._deadOperation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadOperationInput() {
    return this._deadOperation;
  }

  // device_display_name_template - computed: false, optional: true, required: false
  private _deviceDisplayNameTemplate?: string; 
  public get deviceDisplayNameTemplate() {
    return this.getStringAttribute('device_display_name_template');
  }
  public set deviceDisplayNameTemplate(value: string) {
    this._deviceDisplayNameTemplate = value;
  }
  public resetDeviceDisplayNameTemplate() {
    this._deviceDisplayNameTemplate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deviceDisplayNameTemplateInput() {
    return this._deviceDisplayNameTemplate;
  }

  // disable_stop_terminate_host_monitor - computed: false, optional: true, required: false
  private _disableStopTerminateHostMonitor?: boolean | cdktf.IResolvable; 
  public get disableStopTerminateHostMonitor() {
    return this.getBooleanAttribute('disable_stop_terminate_host_monitor');
  }
  public set disableStopTerminateHostMonitor(value: boolean | cdktf.IResolvable) {
    this._disableStopTerminateHostMonitor = value;
  }
  public resetDisableStopTerminateHostMonitor() {
    this._disableStopTerminateHostMonitor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableStopTerminateHostMonitorInput() {
    return this._disableStopTerminateHostMonitor;
  }

  // disable_terminated_host_alerting - computed: false, optional: true, required: false
  private _disableTerminatedHostAlerting?: boolean | cdktf.IResolvable; 
  public get disableTerminatedHostAlerting() {
    return this.getBooleanAttribute('disable_terminated_host_alerting');
  }
  public set disableTerminatedHostAlerting(value: boolean | cdktf.IResolvable) {
    this._disableTerminatedHostAlerting = value;
  }
  public resetDisableTerminatedHostAlerting() {
    this._disableTerminatedHostAlerting = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableTerminatedHostAlertingInput() {
    return this._disableTerminatedHostAlerting;
  }

  // monitoring_region_infos - computed: false, optional: true, required: false
  private _monitoringRegionInfos?: string[]; 
  public get monitoringRegionInfos() {
    return cdktf.Fn.tolist(this.getListAttribute('monitoring_region_infos'));
  }
  public set monitoringRegionInfos(value: string[]) {
    this._monitoringRegionInfos = value;
  }
  public resetMonitoringRegionInfos() {
    this._monitoringRegionInfos = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoringRegionInfosInput() {
    return this._monitoringRegionInfos;
  }

  // monitoring_regions - computed: false, optional: true, required: false
  private _monitoringRegions?: string[]; 
  public get monitoringRegions() {
    return cdktf.Fn.tolist(this.getListAttribute('monitoring_regions'));
  }
  public set monitoringRegions(value: string[]) {
    this._monitoringRegions = value;
  }
  public resetMonitoringRegions() {
    this._monitoringRegions = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoringRegionsInput() {
    return this._monitoringRegions;
  }

  // name_filter - computed: false, optional: true, required: false
  private _nameFilter?: string[]; 
  public get nameFilter() {
    return cdktf.Fn.tolist(this.getListAttribute('name_filter'));
  }
  public set nameFilter(value: string[]) {
    this._nameFilter = value;
  }
  public resetNameFilter() {
    this._nameFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameFilterInput() {
    return this._nameFilter;
  }

  // select_all - computed: false, optional: true, required: false
  private _selectAll?: boolean | cdktf.IResolvable; 
  public get selectAll() {
    return this.getBooleanAttribute('select_all');
  }
  public set selectAll(value: boolean | cdktf.IResolvable) {
    this._selectAll = value;
  }
  public resetSelectAll() {
    this._selectAll = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectAllInput() {
    return this._selectAll;
  }

  // tags - computed: false, optional: true, required: false
  private _tags = new DeviceGroupExtraServicesCLOUDFRONTTagsList(this, "tags", false);
  public get tags() {
    return this._tags;
  }
  public putTags(value: DeviceGroupExtraServicesCLOUDFRONTTags[] | cdktf.IResolvable) {
    this._tags.internalValue = value;
  }
  public resetTags() {
    this._tags.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags.internalValue;
  }

  // use_default - computed: false, optional: false, required: true
  private _useDefault?: boolean | cdktf.IResolvable; 
  public get useDefault() {
    return this.getBooleanAttribute('use_default');
  }
  public set useDefault(value: boolean | cdktf.IResolvable) {
    this._useDefault = value;
  }
  // Temporarily expose input value. Use with caution.
  public get useDefaultInput() {
    return this._useDefault;
  }

  // normal_collector_config - computed: false, optional: true, required: false
  private _normalCollectorConfig = new DeviceGroupExtraServicesCLOUDFRONTNormalCollectorConfigList(this, "normal_collector_config", false);
  public get normalCollectorConfig() {
    return this._normalCollectorConfig;
  }
  public putNormalCollectorConfig(value: DeviceGroupExtraServicesCLOUDFRONTNormalCollectorConfig[] | cdktf.IResolvable) {
    this._normalCollectorConfig.internalValue = value;
  }
  public resetNormalCollectorConfig() {
    this._normalCollectorConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get normalCollectorConfigInput() {
    return this._normalCollectorConfig.internalValue;
  }
}

export class DeviceGroupExtraServicesCLOUDFRONTList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesCLOUDFRONT[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesCLOUDFRONTOutputReference {
    return new DeviceGroupExtraServicesCLOUDFRONTOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesCLOUDSEARCHTags {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#name DeviceGroup#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#operation DeviceGroup#operation}
  */
  readonly operation?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#value DeviceGroup#value}
  */
  readonly value?: string;
}

export function deviceGroupExtraServicesCLOUDSEARCHTagsToTerraform(struct?: DeviceGroupExtraServicesCLOUDSEARCHTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    operation: cdktf.stringToTerraform(struct!.operation),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function deviceGroupExtraServicesCLOUDSEARCHTagsToHclTerraform(struct?: DeviceGroupExtraServicesCLOUDSEARCHTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operation: {
      value: cdktf.stringToHclTerraform(struct!.operation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesCLOUDSEARCHTagsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesCLOUDSEARCHTags | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._operation !== undefined) {
      hasAnyValues = true;
      internalValueResult.operation = this._operation;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesCLOUDSEARCHTags | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._operation = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._operation = value.operation;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // operation - computed: false, optional: true, required: false
  private _operation?: string; 
  public get operation() {
    return this.getStringAttribute('operation');
  }
  public set operation(value: string) {
    this._operation = value;
  }
  public resetOperation() {
    this._operation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operationInput() {
    return this._operation;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DeviceGroupExtraServicesCLOUDSEARCHTagsList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesCLOUDSEARCHTags[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesCLOUDSEARCHTagsOutputReference {
    return new DeviceGroupExtraServicesCLOUDSEARCHTagsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesCLOUDSEARCHNormalCollectorConfigCollectors {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#applies_to DeviceGroup#applies_to}
  */
  readonly appliesTo?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#auto_balanced_collector_group_id DeviceGroup#auto_balanced_collector_group_id}
  */
  readonly autoBalancedCollectorGroupId?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#collector_id DeviceGroup#collector_id}
  */
  readonly collectorId?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#priority DeviceGroup#priority}
  */
  readonly priority?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#use_public_ip DeviceGroup#use_public_ip}
  */
  readonly usePublicIp?: boolean | cdktf.IResolvable;
}

export function deviceGroupExtraServicesCLOUDSEARCHNormalCollectorConfigCollectorsToTerraform(struct?: DeviceGroupExtraServicesCLOUDSEARCHNormalCollectorConfigCollectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    applies_to: cdktf.stringToTerraform(struct!.appliesTo),
    auto_balanced_collector_group_id: cdktf.numberToTerraform(struct!.autoBalancedCollectorGroupId),
    collector_id: cdktf.numberToTerraform(struct!.collectorId),
    priority: cdktf.numberToTerraform(struct!.priority),
    use_public_ip: cdktf.booleanToTerraform(struct!.usePublicIp),
  }
}


export function deviceGroupExtraServicesCLOUDSEARCHNormalCollectorConfigCollectorsToHclTerraform(struct?: DeviceGroupExtraServicesCLOUDSEARCHNormalCollectorConfigCollectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    applies_to: {
      value: cdktf.stringToHclTerraform(struct!.appliesTo),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auto_balanced_collector_group_id: {
      value: cdktf.numberToHclTerraform(struct!.autoBalancedCollectorGroupId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    collector_id: {
      value: cdktf.numberToHclTerraform(struct!.collectorId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    priority: {
      value: cdktf.numberToHclTerraform(struct!.priority),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    use_public_ip: {
      value: cdktf.booleanToHclTerraform(struct!.usePublicIp),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesCLOUDSEARCHNormalCollectorConfigCollectorsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesCLOUDSEARCHNormalCollectorConfigCollectors | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._appliesTo !== undefined) {
      hasAnyValues = true;
      internalValueResult.appliesTo = this._appliesTo;
    }
    if (this._autoBalancedCollectorGroupId !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoBalancedCollectorGroupId = this._autoBalancedCollectorGroupId;
    }
    if (this._collectorId !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectorId = this._collectorId;
    }
    if (this._priority !== undefined) {
      hasAnyValues = true;
      internalValueResult.priority = this._priority;
    }
    if (this._usePublicIp !== undefined) {
      hasAnyValues = true;
      internalValueResult.usePublicIp = this._usePublicIp;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesCLOUDSEARCHNormalCollectorConfigCollectors | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._appliesTo = undefined;
      this._autoBalancedCollectorGroupId = undefined;
      this._collectorId = undefined;
      this._priority = undefined;
      this._usePublicIp = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._appliesTo = value.appliesTo;
      this._autoBalancedCollectorGroupId = value.autoBalancedCollectorGroupId;
      this._collectorId = value.collectorId;
      this._priority = value.priority;
      this._usePublicIp = value.usePublicIp;
    }
  }

  // applies_to - computed: false, optional: true, required: false
  private _appliesTo?: string; 
  public get appliesTo() {
    return this.getStringAttribute('applies_to');
  }
  public set appliesTo(value: string) {
    this._appliesTo = value;
  }
  public resetAppliesTo() {
    this._appliesTo = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appliesToInput() {
    return this._appliesTo;
  }

  // auto_balanced_collector_group_id - computed: false, optional: true, required: false
  private _autoBalancedCollectorGroupId?: number; 
  public get autoBalancedCollectorGroupId() {
    return this.getNumberAttribute('auto_balanced_collector_group_id');
  }
  public set autoBalancedCollectorGroupId(value: number) {
    this._autoBalancedCollectorGroupId = value;
  }
  public resetAutoBalancedCollectorGroupId() {
    this._autoBalancedCollectorGroupId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoBalancedCollectorGroupIdInput() {
    return this._autoBalancedCollectorGroupId;
  }

  // collector_id - computed: false, optional: true, required: false
  private _collectorId?: number; 
  public get collectorId() {
    return this.getNumberAttribute('collector_id');
  }
  public set collectorId(value: number) {
    this._collectorId = value;
  }
  public resetCollectorId() {
    this._collectorId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorIdInput() {
    return this._collectorId;
  }

  // priority - computed: false, optional: true, required: false
  private _priority?: number; 
  public get priority() {
    return this.getNumberAttribute('priority');
  }
  public set priority(value: number) {
    this._priority = value;
  }
  public resetPriority() {
    this._priority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get priorityInput() {
    return this._priority;
  }

  // use_public_ip - computed: false, optional: true, required: false
  private _usePublicIp?: boolean | cdktf.IResolvable; 
  public get usePublicIp() {
    return this.getBooleanAttribute('use_public_ip');
  }
  public set usePublicIp(value: boolean | cdktf.IResolvable) {
    this._usePublicIp = value;
  }
  public resetUsePublicIp() {
    this._usePublicIp = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usePublicIpInput() {
    return this._usePublicIp;
  }
}

export class DeviceGroupExtraServicesCLOUDSEARCHNormalCollectorConfigCollectorsList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesCLOUDSEARCHNormalCollectorConfigCollectors[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesCLOUDSEARCHNormalCollectorConfigCollectorsOutputReference {
    return new DeviceGroupExtraServicesCLOUDSEARCHNormalCollectorConfigCollectorsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesCLOUDSEARCHNormalCollectorConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#collectors DeviceGroup#collectors}
  */
  readonly collectors?: DeviceGroupExtraServicesCLOUDSEARCHNormalCollectorConfigCollectors[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#enabled DeviceGroup#enabled}
  */
  readonly enabled: boolean | cdktf.IResolvable;
}

export function deviceGroupExtraServicesCLOUDSEARCHNormalCollectorConfigToTerraform(struct?: DeviceGroupExtraServicesCLOUDSEARCHNormalCollectorConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    collectors: cdktf.listMapper(deviceGroupExtraServicesCLOUDSEARCHNormalCollectorConfigCollectorsToTerraform, false)(struct!.collectors),
    enabled: cdktf.booleanToTerraform(struct!.enabled),
  }
}


export function deviceGroupExtraServicesCLOUDSEARCHNormalCollectorConfigToHclTerraform(struct?: DeviceGroupExtraServicesCLOUDSEARCHNormalCollectorConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    collectors: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesCLOUDSEARCHNormalCollectorConfigCollectorsToHclTerraform, false)(struct!.collectors),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesCLOUDSEARCHNormalCollectorConfigCollectorsList",
    },
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesCLOUDSEARCHNormalCollectorConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesCLOUDSEARCHNormalCollectorConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._collectors?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectors = this._collectors?.internalValue;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesCLOUDSEARCHNormalCollectorConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._collectors.internalValue = undefined;
      this._enabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._collectors.internalValue = value.collectors;
      this._enabled = value.enabled;
    }
  }

  // collectors - computed: false, optional: true, required: false
  private _collectors = new DeviceGroupExtraServicesCLOUDSEARCHNormalCollectorConfigCollectorsList(this, "collectors", false);
  public get collectors() {
    return this._collectors;
  }
  public putCollectors(value: DeviceGroupExtraServicesCLOUDSEARCHNormalCollectorConfigCollectors[] | cdktf.IResolvable) {
    this._collectors.internalValue = value;
  }
  public resetCollectors() {
    this._collectors.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorsInput() {
    return this._collectors.internalValue;
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }
}

export class DeviceGroupExtraServicesCLOUDSEARCHNormalCollectorConfigList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesCLOUDSEARCHNormalCollectorConfig[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesCLOUDSEARCHNormalCollectorConfigOutputReference {
    return new DeviceGroupExtraServicesCLOUDSEARCHNormalCollectorConfigOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesCLOUDSEARCH {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#custom_n_s_p_schedule DeviceGroup#custom_n_s_p_schedule}
  */
  readonly customNSPSchedule?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#dead_operation DeviceGroup#dead_operation}
  */
  readonly deadOperation?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#device_display_name_template DeviceGroup#device_display_name_template}
  */
  readonly deviceDisplayNameTemplate?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#disable_stop_terminate_host_monitor DeviceGroup#disable_stop_terminate_host_monitor}
  */
  readonly disableStopTerminateHostMonitor?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#disable_terminated_host_alerting DeviceGroup#disable_terminated_host_alerting}
  */
  readonly disableTerminatedHostAlerting?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#monitoring_region_infos DeviceGroup#monitoring_region_infos}
  */
  readonly monitoringRegionInfos?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#monitoring_regions DeviceGroup#monitoring_regions}
  */
  readonly monitoringRegions?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#name_filter DeviceGroup#name_filter}
  */
  readonly nameFilter?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#select_all DeviceGroup#select_all}
  */
  readonly selectAll?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#tags DeviceGroup#tags}
  */
  readonly tags?: DeviceGroupExtraServicesCLOUDSEARCHTags[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#use_default DeviceGroup#use_default}
  */
  readonly useDefault: boolean | cdktf.IResolvable;
  /**
  * normal_collector_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#normal_collector_config DeviceGroup#normal_collector_config}
  */
  readonly normalCollectorConfig?: DeviceGroupExtraServicesCLOUDSEARCHNormalCollectorConfig[] | cdktf.IResolvable;
}

export function deviceGroupExtraServicesCLOUDSEARCHToTerraform(struct?: DeviceGroupExtraServicesCLOUDSEARCH | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    custom_n_s_p_schedule: cdktf.stringToTerraform(struct!.customNSPSchedule),
    dead_operation: cdktf.stringToTerraform(struct!.deadOperation),
    device_display_name_template: cdktf.stringToTerraform(struct!.deviceDisplayNameTemplate),
    disable_stop_terminate_host_monitor: cdktf.booleanToTerraform(struct!.disableStopTerminateHostMonitor),
    disable_terminated_host_alerting: cdktf.booleanToTerraform(struct!.disableTerminatedHostAlerting),
    monitoring_region_infos: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.monitoringRegionInfos),
    monitoring_regions: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.monitoringRegions),
    name_filter: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.nameFilter),
    select_all: cdktf.booleanToTerraform(struct!.selectAll),
    tags: cdktf.listMapper(deviceGroupExtraServicesCLOUDSEARCHTagsToTerraform, false)(struct!.tags),
    use_default: cdktf.booleanToTerraform(struct!.useDefault),
    normal_collector_config: cdktf.listMapper(deviceGroupExtraServicesCLOUDSEARCHNormalCollectorConfigToTerraform, true)(struct!.normalCollectorConfig),
  }
}


export function deviceGroupExtraServicesCLOUDSEARCHToHclTerraform(struct?: DeviceGroupExtraServicesCLOUDSEARCH | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    custom_n_s_p_schedule: {
      value: cdktf.stringToHclTerraform(struct!.customNSPSchedule),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dead_operation: {
      value: cdktf.stringToHclTerraform(struct!.deadOperation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    device_display_name_template: {
      value: cdktf.stringToHclTerraform(struct!.deviceDisplayNameTemplate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disable_stop_terminate_host_monitor: {
      value: cdktf.booleanToHclTerraform(struct!.disableStopTerminateHostMonitor),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    disable_terminated_host_alerting: {
      value: cdktf.booleanToHclTerraform(struct!.disableTerminatedHostAlerting),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    monitoring_region_infos: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.monitoringRegionInfos),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    monitoring_regions: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.monitoringRegions),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    name_filter: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.nameFilter),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    select_all: {
      value: cdktf.booleanToHclTerraform(struct!.selectAll),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tags: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesCLOUDSEARCHTagsToHclTerraform, false)(struct!.tags),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesCLOUDSEARCHTagsList",
    },
    use_default: {
      value: cdktf.booleanToHclTerraform(struct!.useDefault),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    normal_collector_config: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesCLOUDSEARCHNormalCollectorConfigToHclTerraform, true)(struct!.normalCollectorConfig),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesCLOUDSEARCHNormalCollectorConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesCLOUDSEARCHOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesCLOUDSEARCH | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._customNSPSchedule !== undefined) {
      hasAnyValues = true;
      internalValueResult.customNSPSchedule = this._customNSPSchedule;
    }
    if (this._deadOperation !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadOperation = this._deadOperation;
    }
    if (this._deviceDisplayNameTemplate !== undefined) {
      hasAnyValues = true;
      internalValueResult.deviceDisplayNameTemplate = this._deviceDisplayNameTemplate;
    }
    if (this._disableStopTerminateHostMonitor !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableStopTerminateHostMonitor = this._disableStopTerminateHostMonitor;
    }
    if (this._disableTerminatedHostAlerting !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableTerminatedHostAlerting = this._disableTerminatedHostAlerting;
    }
    if (this._monitoringRegionInfos !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoringRegionInfos = this._monitoringRegionInfos;
    }
    if (this._monitoringRegions !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoringRegions = this._monitoringRegions;
    }
    if (this._nameFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.nameFilter = this._nameFilter;
    }
    if (this._selectAll !== undefined) {
      hasAnyValues = true;
      internalValueResult.selectAll = this._selectAll;
    }
    if (this._tags?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags?.internalValue;
    }
    if (this._useDefault !== undefined) {
      hasAnyValues = true;
      internalValueResult.useDefault = this._useDefault;
    }
    if (this._normalCollectorConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.normalCollectorConfig = this._normalCollectorConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesCLOUDSEARCH | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._customNSPSchedule = undefined;
      this._deadOperation = undefined;
      this._deviceDisplayNameTemplate = undefined;
      this._disableStopTerminateHostMonitor = undefined;
      this._disableTerminatedHostAlerting = undefined;
      this._monitoringRegionInfos = undefined;
      this._monitoringRegions = undefined;
      this._nameFilter = undefined;
      this._selectAll = undefined;
      this._tags.internalValue = undefined;
      this._useDefault = undefined;
      this._normalCollectorConfig.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._customNSPSchedule = value.customNSPSchedule;
      this._deadOperation = value.deadOperation;
      this._deviceDisplayNameTemplate = value.deviceDisplayNameTemplate;
      this._disableStopTerminateHostMonitor = value.disableStopTerminateHostMonitor;
      this._disableTerminatedHostAlerting = value.disableTerminatedHostAlerting;
      this._monitoringRegionInfos = value.monitoringRegionInfos;
      this._monitoringRegions = value.monitoringRegions;
      this._nameFilter = value.nameFilter;
      this._selectAll = value.selectAll;
      this._tags.internalValue = value.tags;
      this._useDefault = value.useDefault;
      this._normalCollectorConfig.internalValue = value.normalCollectorConfig;
    }
  }

  // custom_n_s_p_schedule - computed: false, optional: true, required: false
  private _customNSPSchedule?: string; 
  public get customNSPSchedule() {
    return this.getStringAttribute('custom_n_s_p_schedule');
  }
  public set customNSPSchedule(value: string) {
    this._customNSPSchedule = value;
  }
  public resetCustomNSPSchedule() {
    this._customNSPSchedule = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customNSPScheduleInput() {
    return this._customNSPSchedule;
  }

  // dead_operation - computed: false, optional: true, required: false
  private _deadOperation?: string; 
  public get deadOperation() {
    return this.getStringAttribute('dead_operation');
  }
  public set deadOperation(value: string) {
    this._deadOperation = value;
  }
  public resetDeadOperation() {
    this._deadOperation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadOperationInput() {
    return this._deadOperation;
  }

  // device_display_name_template - computed: false, optional: true, required: false
  private _deviceDisplayNameTemplate?: string; 
  public get deviceDisplayNameTemplate() {
    return this.getStringAttribute('device_display_name_template');
  }
  public set deviceDisplayNameTemplate(value: string) {
    this._deviceDisplayNameTemplate = value;
  }
  public resetDeviceDisplayNameTemplate() {
    this._deviceDisplayNameTemplate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deviceDisplayNameTemplateInput() {
    return this._deviceDisplayNameTemplate;
  }

  // disable_stop_terminate_host_monitor - computed: false, optional: true, required: false
  private _disableStopTerminateHostMonitor?: boolean | cdktf.IResolvable; 
  public get disableStopTerminateHostMonitor() {
    return this.getBooleanAttribute('disable_stop_terminate_host_monitor');
  }
  public set disableStopTerminateHostMonitor(value: boolean | cdktf.IResolvable) {
    this._disableStopTerminateHostMonitor = value;
  }
  public resetDisableStopTerminateHostMonitor() {
    this._disableStopTerminateHostMonitor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableStopTerminateHostMonitorInput() {
    return this._disableStopTerminateHostMonitor;
  }

  // disable_terminated_host_alerting - computed: false, optional: true, required: false
  private _disableTerminatedHostAlerting?: boolean | cdktf.IResolvable; 
  public get disableTerminatedHostAlerting() {
    return this.getBooleanAttribute('disable_terminated_host_alerting');
  }
  public set disableTerminatedHostAlerting(value: boolean | cdktf.IResolvable) {
    this._disableTerminatedHostAlerting = value;
  }
  public resetDisableTerminatedHostAlerting() {
    this._disableTerminatedHostAlerting = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableTerminatedHostAlertingInput() {
    return this._disableTerminatedHostAlerting;
  }

  // monitoring_region_infos - computed: false, optional: true, required: false
  private _monitoringRegionInfos?: string[]; 
  public get monitoringRegionInfos() {
    return cdktf.Fn.tolist(this.getListAttribute('monitoring_region_infos'));
  }
  public set monitoringRegionInfos(value: string[]) {
    this._monitoringRegionInfos = value;
  }
  public resetMonitoringRegionInfos() {
    this._monitoringRegionInfos = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoringRegionInfosInput() {
    return this._monitoringRegionInfos;
  }

  // monitoring_regions - computed: false, optional: true, required: false
  private _monitoringRegions?: string[]; 
  public get monitoringRegions() {
    return cdktf.Fn.tolist(this.getListAttribute('monitoring_regions'));
  }
  public set monitoringRegions(value: string[]) {
    this._monitoringRegions = value;
  }
  public resetMonitoringRegions() {
    this._monitoringRegions = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoringRegionsInput() {
    return this._monitoringRegions;
  }

  // name_filter - computed: false, optional: true, required: false
  private _nameFilter?: string[]; 
  public get nameFilter() {
    return cdktf.Fn.tolist(this.getListAttribute('name_filter'));
  }
  public set nameFilter(value: string[]) {
    this._nameFilter = value;
  }
  public resetNameFilter() {
    this._nameFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameFilterInput() {
    return this._nameFilter;
  }

  // select_all - computed: false, optional: true, required: false
  private _selectAll?: boolean | cdktf.IResolvable; 
  public get selectAll() {
    return this.getBooleanAttribute('select_all');
  }
  public set selectAll(value: boolean | cdktf.IResolvable) {
    this._selectAll = value;
  }
  public resetSelectAll() {
    this._selectAll = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectAllInput() {
    return this._selectAll;
  }

  // tags - computed: false, optional: true, required: false
  private _tags = new DeviceGroupExtraServicesCLOUDSEARCHTagsList(this, "tags", false);
  public get tags() {
    return this._tags;
  }
  public putTags(value: DeviceGroupExtraServicesCLOUDSEARCHTags[] | cdktf.IResolvable) {
    this._tags.internalValue = value;
  }
  public resetTags() {
    this._tags.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags.internalValue;
  }

  // use_default - computed: false, optional: false, required: true
  private _useDefault?: boolean | cdktf.IResolvable; 
  public get useDefault() {
    return this.getBooleanAttribute('use_default');
  }
  public set useDefault(value: boolean | cdktf.IResolvable) {
    this._useDefault = value;
  }
  // Temporarily expose input value. Use with caution.
  public get useDefaultInput() {
    return this._useDefault;
  }

  // normal_collector_config - computed: false, optional: true, required: false
  private _normalCollectorConfig = new DeviceGroupExtraServicesCLOUDSEARCHNormalCollectorConfigList(this, "normal_collector_config", false);
  public get normalCollectorConfig() {
    return this._normalCollectorConfig;
  }
  public putNormalCollectorConfig(value: DeviceGroupExtraServicesCLOUDSEARCHNormalCollectorConfig[] | cdktf.IResolvable) {
    this._normalCollectorConfig.internalValue = value;
  }
  public resetNormalCollectorConfig() {
    this._normalCollectorConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get normalCollectorConfigInput() {
    return this._normalCollectorConfig.internalValue;
  }
}

export class DeviceGroupExtraServicesCLOUDSEARCHList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesCLOUDSEARCH[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesCLOUDSEARCHOutputReference {
    return new DeviceGroupExtraServicesCLOUDSEARCHOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesCODEBUiLDTags {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#name DeviceGroup#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#operation DeviceGroup#operation}
  */
  readonly operation?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#value DeviceGroup#value}
  */
  readonly value?: string;
}

export function deviceGroupExtraServicesCODEBUiLDTagsToTerraform(struct?: DeviceGroupExtraServicesCODEBUiLDTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    operation: cdktf.stringToTerraform(struct!.operation),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function deviceGroupExtraServicesCODEBUiLDTagsToHclTerraform(struct?: DeviceGroupExtraServicesCODEBUiLDTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operation: {
      value: cdktf.stringToHclTerraform(struct!.operation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesCODEBUiLDTagsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesCODEBUiLDTags | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._operation !== undefined) {
      hasAnyValues = true;
      internalValueResult.operation = this._operation;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesCODEBUiLDTags | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._operation = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._operation = value.operation;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // operation - computed: false, optional: true, required: false
  private _operation?: string; 
  public get operation() {
    return this.getStringAttribute('operation');
  }
  public set operation(value: string) {
    this._operation = value;
  }
  public resetOperation() {
    this._operation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operationInput() {
    return this._operation;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DeviceGroupExtraServicesCODEBUiLDTagsList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesCODEBUiLDTags[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesCODEBUiLDTagsOutputReference {
    return new DeviceGroupExtraServicesCODEBUiLDTagsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesCODEBUiLDNormalCollectorConfigCollectors {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#applies_to DeviceGroup#applies_to}
  */
  readonly appliesTo?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#auto_balanced_collector_group_id DeviceGroup#auto_balanced_collector_group_id}
  */
  readonly autoBalancedCollectorGroupId?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#collector_id DeviceGroup#collector_id}
  */
  readonly collectorId?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#priority DeviceGroup#priority}
  */
  readonly priority?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#use_public_ip DeviceGroup#use_public_ip}
  */
  readonly usePublicIp?: boolean | cdktf.IResolvable;
}

export function deviceGroupExtraServicesCODEBUiLDNormalCollectorConfigCollectorsToTerraform(struct?: DeviceGroupExtraServicesCODEBUiLDNormalCollectorConfigCollectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    applies_to: cdktf.stringToTerraform(struct!.appliesTo),
    auto_balanced_collector_group_id: cdktf.numberToTerraform(struct!.autoBalancedCollectorGroupId),
    collector_id: cdktf.numberToTerraform(struct!.collectorId),
    priority: cdktf.numberToTerraform(struct!.priority),
    use_public_ip: cdktf.booleanToTerraform(struct!.usePublicIp),
  }
}


export function deviceGroupExtraServicesCODEBUiLDNormalCollectorConfigCollectorsToHclTerraform(struct?: DeviceGroupExtraServicesCODEBUiLDNormalCollectorConfigCollectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    applies_to: {
      value: cdktf.stringToHclTerraform(struct!.appliesTo),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auto_balanced_collector_group_id: {
      value: cdktf.numberToHclTerraform(struct!.autoBalancedCollectorGroupId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    collector_id: {
      value: cdktf.numberToHclTerraform(struct!.collectorId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    priority: {
      value: cdktf.numberToHclTerraform(struct!.priority),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    use_public_ip: {
      value: cdktf.booleanToHclTerraform(struct!.usePublicIp),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesCODEBUiLDNormalCollectorConfigCollectorsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesCODEBUiLDNormalCollectorConfigCollectors | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._appliesTo !== undefined) {
      hasAnyValues = true;
      internalValueResult.appliesTo = this._appliesTo;
    }
    if (this._autoBalancedCollectorGroupId !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoBalancedCollectorGroupId = this._autoBalancedCollectorGroupId;
    }
    if (this._collectorId !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectorId = this._collectorId;
    }
    if (this._priority !== undefined) {
      hasAnyValues = true;
      internalValueResult.priority = this._priority;
    }
    if (this._usePublicIp !== undefined) {
      hasAnyValues = true;
      internalValueResult.usePublicIp = this._usePublicIp;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesCODEBUiLDNormalCollectorConfigCollectors | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._appliesTo = undefined;
      this._autoBalancedCollectorGroupId = undefined;
      this._collectorId = undefined;
      this._priority = undefined;
      this._usePublicIp = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._appliesTo = value.appliesTo;
      this._autoBalancedCollectorGroupId = value.autoBalancedCollectorGroupId;
      this._collectorId = value.collectorId;
      this._priority = value.priority;
      this._usePublicIp = value.usePublicIp;
    }
  }

  // applies_to - computed: false, optional: true, required: false
  private _appliesTo?: string; 
  public get appliesTo() {
    return this.getStringAttribute('applies_to');
  }
  public set appliesTo(value: string) {
    this._appliesTo = value;
  }
  public resetAppliesTo() {
    this._appliesTo = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appliesToInput() {
    return this._appliesTo;
  }

  // auto_balanced_collector_group_id - computed: false, optional: true, required: false
  private _autoBalancedCollectorGroupId?: number; 
  public get autoBalancedCollectorGroupId() {
    return this.getNumberAttribute('auto_balanced_collector_group_id');
  }
  public set autoBalancedCollectorGroupId(value: number) {
    this._autoBalancedCollectorGroupId = value;
  }
  public resetAutoBalancedCollectorGroupId() {
    this._autoBalancedCollectorGroupId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoBalancedCollectorGroupIdInput() {
    return this._autoBalancedCollectorGroupId;
  }

  // collector_id - computed: false, optional: true, required: false
  private _collectorId?: number; 
  public get collectorId() {
    return this.getNumberAttribute('collector_id');
  }
  public set collectorId(value: number) {
    this._collectorId = value;
  }
  public resetCollectorId() {
    this._collectorId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorIdInput() {
    return this._collectorId;
  }

  // priority - computed: false, optional: true, required: false
  private _priority?: number; 
  public get priority() {
    return this.getNumberAttribute('priority');
  }
  public set priority(value: number) {
    this._priority = value;
  }
  public resetPriority() {
    this._priority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get priorityInput() {
    return this._priority;
  }

  // use_public_ip - computed: false, optional: true, required: false
  private _usePublicIp?: boolean | cdktf.IResolvable; 
  public get usePublicIp() {
    return this.getBooleanAttribute('use_public_ip');
  }
  public set usePublicIp(value: boolean | cdktf.IResolvable) {
    this._usePublicIp = value;
  }
  public resetUsePublicIp() {
    this._usePublicIp = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usePublicIpInput() {
    return this._usePublicIp;
  }
}

export class DeviceGroupExtraServicesCODEBUiLDNormalCollectorConfigCollectorsList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesCODEBUiLDNormalCollectorConfigCollectors[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesCODEBUiLDNormalCollectorConfigCollectorsOutputReference {
    return new DeviceGroupExtraServicesCODEBUiLDNormalCollectorConfigCollectorsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesCODEBUiLDNormalCollectorConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#collectors DeviceGroup#collectors}
  */
  readonly collectors?: DeviceGroupExtraServicesCODEBUiLDNormalCollectorConfigCollectors[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#enabled DeviceGroup#enabled}
  */
  readonly enabled: boolean | cdktf.IResolvable;
}

export function deviceGroupExtraServicesCODEBUiLDNormalCollectorConfigToTerraform(struct?: DeviceGroupExtraServicesCODEBUiLDNormalCollectorConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    collectors: cdktf.listMapper(deviceGroupExtraServicesCODEBUiLDNormalCollectorConfigCollectorsToTerraform, false)(struct!.collectors),
    enabled: cdktf.booleanToTerraform(struct!.enabled),
  }
}


export function deviceGroupExtraServicesCODEBUiLDNormalCollectorConfigToHclTerraform(struct?: DeviceGroupExtraServicesCODEBUiLDNormalCollectorConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    collectors: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesCODEBUiLDNormalCollectorConfigCollectorsToHclTerraform, false)(struct!.collectors),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesCODEBUiLDNormalCollectorConfigCollectorsList",
    },
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesCODEBUiLDNormalCollectorConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesCODEBUiLDNormalCollectorConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._collectors?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectors = this._collectors?.internalValue;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesCODEBUiLDNormalCollectorConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._collectors.internalValue = undefined;
      this._enabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._collectors.internalValue = value.collectors;
      this._enabled = value.enabled;
    }
  }

  // collectors - computed: false, optional: true, required: false
  private _collectors = new DeviceGroupExtraServicesCODEBUiLDNormalCollectorConfigCollectorsList(this, "collectors", false);
  public get collectors() {
    return this._collectors;
  }
  public putCollectors(value: DeviceGroupExtraServicesCODEBUiLDNormalCollectorConfigCollectors[] | cdktf.IResolvable) {
    this._collectors.internalValue = value;
  }
  public resetCollectors() {
    this._collectors.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorsInput() {
    return this._collectors.internalValue;
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }
}

export class DeviceGroupExtraServicesCODEBUiLDNormalCollectorConfigList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesCODEBUiLDNormalCollectorConfig[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesCODEBUiLDNormalCollectorConfigOutputReference {
    return new DeviceGroupExtraServicesCODEBUiLDNormalCollectorConfigOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesCODEBUiLD {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#custom_n_s_p_schedule DeviceGroup#custom_n_s_p_schedule}
  */
  readonly customNSPSchedule?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#dead_operation DeviceGroup#dead_operation}
  */
  readonly deadOperation?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#device_display_name_template DeviceGroup#device_display_name_template}
  */
  readonly deviceDisplayNameTemplate?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#disable_stop_terminate_host_monitor DeviceGroup#disable_stop_terminate_host_monitor}
  */
  readonly disableStopTerminateHostMonitor?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#disable_terminated_host_alerting DeviceGroup#disable_terminated_host_alerting}
  */
  readonly disableTerminatedHostAlerting?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#monitoring_region_infos DeviceGroup#monitoring_region_infos}
  */
  readonly monitoringRegionInfos?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#monitoring_regions DeviceGroup#monitoring_regions}
  */
  readonly monitoringRegions?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#name_filter DeviceGroup#name_filter}
  */
  readonly nameFilter?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#select_all DeviceGroup#select_all}
  */
  readonly selectAll?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#tags DeviceGroup#tags}
  */
  readonly tags?: DeviceGroupExtraServicesCODEBUiLDTags[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#use_default DeviceGroup#use_default}
  */
  readonly useDefault: boolean | cdktf.IResolvable;
  /**
  * normal_collector_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#normal_collector_config DeviceGroup#normal_collector_config}
  */
  readonly normalCollectorConfig?: DeviceGroupExtraServicesCODEBUiLDNormalCollectorConfig[] | cdktf.IResolvable;
}

export function deviceGroupExtraServicesCODEBUiLDToTerraform(struct?: DeviceGroupExtraServicesCODEBUiLD | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    custom_n_s_p_schedule: cdktf.stringToTerraform(struct!.customNSPSchedule),
    dead_operation: cdktf.stringToTerraform(struct!.deadOperation),
    device_display_name_template: cdktf.stringToTerraform(struct!.deviceDisplayNameTemplate),
    disable_stop_terminate_host_monitor: cdktf.booleanToTerraform(struct!.disableStopTerminateHostMonitor),
    disable_terminated_host_alerting: cdktf.booleanToTerraform(struct!.disableTerminatedHostAlerting),
    monitoring_region_infos: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.monitoringRegionInfos),
    monitoring_regions: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.monitoringRegions),
    name_filter: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.nameFilter),
    select_all: cdktf.booleanToTerraform(struct!.selectAll),
    tags: cdktf.listMapper(deviceGroupExtraServicesCODEBUiLDTagsToTerraform, false)(struct!.tags),
    use_default: cdktf.booleanToTerraform(struct!.useDefault),
    normal_collector_config: cdktf.listMapper(deviceGroupExtraServicesCODEBUiLDNormalCollectorConfigToTerraform, true)(struct!.normalCollectorConfig),
  }
}


export function deviceGroupExtraServicesCODEBUiLDToHclTerraform(struct?: DeviceGroupExtraServicesCODEBUiLD | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    custom_n_s_p_schedule: {
      value: cdktf.stringToHclTerraform(struct!.customNSPSchedule),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dead_operation: {
      value: cdktf.stringToHclTerraform(struct!.deadOperation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    device_display_name_template: {
      value: cdktf.stringToHclTerraform(struct!.deviceDisplayNameTemplate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disable_stop_terminate_host_monitor: {
      value: cdktf.booleanToHclTerraform(struct!.disableStopTerminateHostMonitor),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    disable_terminated_host_alerting: {
      value: cdktf.booleanToHclTerraform(struct!.disableTerminatedHostAlerting),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    monitoring_region_infos: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.monitoringRegionInfos),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    monitoring_regions: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.monitoringRegions),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    name_filter: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.nameFilter),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    select_all: {
      value: cdktf.booleanToHclTerraform(struct!.selectAll),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tags: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesCODEBUiLDTagsToHclTerraform, false)(struct!.tags),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesCODEBUiLDTagsList",
    },
    use_default: {
      value: cdktf.booleanToHclTerraform(struct!.useDefault),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    normal_collector_config: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesCODEBUiLDNormalCollectorConfigToHclTerraform, true)(struct!.normalCollectorConfig),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesCODEBUiLDNormalCollectorConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesCODEBUiLDOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesCODEBUiLD | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._customNSPSchedule !== undefined) {
      hasAnyValues = true;
      internalValueResult.customNSPSchedule = this._customNSPSchedule;
    }
    if (this._deadOperation !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadOperation = this._deadOperation;
    }
    if (this._deviceDisplayNameTemplate !== undefined) {
      hasAnyValues = true;
      internalValueResult.deviceDisplayNameTemplate = this._deviceDisplayNameTemplate;
    }
    if (this._disableStopTerminateHostMonitor !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableStopTerminateHostMonitor = this._disableStopTerminateHostMonitor;
    }
    if (this._disableTerminatedHostAlerting !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableTerminatedHostAlerting = this._disableTerminatedHostAlerting;
    }
    if (this._monitoringRegionInfos !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoringRegionInfos = this._monitoringRegionInfos;
    }
    if (this._monitoringRegions !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoringRegions = this._monitoringRegions;
    }
    if (this._nameFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.nameFilter = this._nameFilter;
    }
    if (this._selectAll !== undefined) {
      hasAnyValues = true;
      internalValueResult.selectAll = this._selectAll;
    }
    if (this._tags?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags?.internalValue;
    }
    if (this._useDefault !== undefined) {
      hasAnyValues = true;
      internalValueResult.useDefault = this._useDefault;
    }
    if (this._normalCollectorConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.normalCollectorConfig = this._normalCollectorConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesCODEBUiLD | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._customNSPSchedule = undefined;
      this._deadOperation = undefined;
      this._deviceDisplayNameTemplate = undefined;
      this._disableStopTerminateHostMonitor = undefined;
      this._disableTerminatedHostAlerting = undefined;
      this._monitoringRegionInfos = undefined;
      this._monitoringRegions = undefined;
      this._nameFilter = undefined;
      this._selectAll = undefined;
      this._tags.internalValue = undefined;
      this._useDefault = undefined;
      this._normalCollectorConfig.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._customNSPSchedule = value.customNSPSchedule;
      this._deadOperation = value.deadOperation;
      this._deviceDisplayNameTemplate = value.deviceDisplayNameTemplate;
      this._disableStopTerminateHostMonitor = value.disableStopTerminateHostMonitor;
      this._disableTerminatedHostAlerting = value.disableTerminatedHostAlerting;
      this._monitoringRegionInfos = value.monitoringRegionInfos;
      this._monitoringRegions = value.monitoringRegions;
      this._nameFilter = value.nameFilter;
      this._selectAll = value.selectAll;
      this._tags.internalValue = value.tags;
      this._useDefault = value.useDefault;
      this._normalCollectorConfig.internalValue = value.normalCollectorConfig;
    }
  }

  // custom_n_s_p_schedule - computed: false, optional: true, required: false
  private _customNSPSchedule?: string; 
  public get customNSPSchedule() {
    return this.getStringAttribute('custom_n_s_p_schedule');
  }
  public set customNSPSchedule(value: string) {
    this._customNSPSchedule = value;
  }
  public resetCustomNSPSchedule() {
    this._customNSPSchedule = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customNSPScheduleInput() {
    return this._customNSPSchedule;
  }

  // dead_operation - computed: false, optional: true, required: false
  private _deadOperation?: string; 
  public get deadOperation() {
    return this.getStringAttribute('dead_operation');
  }
  public set deadOperation(value: string) {
    this._deadOperation = value;
  }
  public resetDeadOperation() {
    this._deadOperation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadOperationInput() {
    return this._deadOperation;
  }

  // device_display_name_template - computed: false, optional: true, required: false
  private _deviceDisplayNameTemplate?: string; 
  public get deviceDisplayNameTemplate() {
    return this.getStringAttribute('device_display_name_template');
  }
  public set deviceDisplayNameTemplate(value: string) {
    this._deviceDisplayNameTemplate = value;
  }
  public resetDeviceDisplayNameTemplate() {
    this._deviceDisplayNameTemplate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deviceDisplayNameTemplateInput() {
    return this._deviceDisplayNameTemplate;
  }

  // disable_stop_terminate_host_monitor - computed: false, optional: true, required: false
  private _disableStopTerminateHostMonitor?: boolean | cdktf.IResolvable; 
  public get disableStopTerminateHostMonitor() {
    return this.getBooleanAttribute('disable_stop_terminate_host_monitor');
  }
  public set disableStopTerminateHostMonitor(value: boolean | cdktf.IResolvable) {
    this._disableStopTerminateHostMonitor = value;
  }
  public resetDisableStopTerminateHostMonitor() {
    this._disableStopTerminateHostMonitor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableStopTerminateHostMonitorInput() {
    return this._disableStopTerminateHostMonitor;
  }

  // disable_terminated_host_alerting - computed: false, optional: true, required: false
  private _disableTerminatedHostAlerting?: boolean | cdktf.IResolvable; 
  public get disableTerminatedHostAlerting() {
    return this.getBooleanAttribute('disable_terminated_host_alerting');
  }
  public set disableTerminatedHostAlerting(value: boolean | cdktf.IResolvable) {
    this._disableTerminatedHostAlerting = value;
  }
  public resetDisableTerminatedHostAlerting() {
    this._disableTerminatedHostAlerting = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableTerminatedHostAlertingInput() {
    return this._disableTerminatedHostAlerting;
  }

  // monitoring_region_infos - computed: false, optional: true, required: false
  private _monitoringRegionInfos?: string[]; 
  public get monitoringRegionInfos() {
    return cdktf.Fn.tolist(this.getListAttribute('monitoring_region_infos'));
  }
  public set monitoringRegionInfos(value: string[]) {
    this._monitoringRegionInfos = value;
  }
  public resetMonitoringRegionInfos() {
    this._monitoringRegionInfos = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoringRegionInfosInput() {
    return this._monitoringRegionInfos;
  }

  // monitoring_regions - computed: false, optional: true, required: false
  private _monitoringRegions?: string[]; 
  public get monitoringRegions() {
    return cdktf.Fn.tolist(this.getListAttribute('monitoring_regions'));
  }
  public set monitoringRegions(value: string[]) {
    this._monitoringRegions = value;
  }
  public resetMonitoringRegions() {
    this._monitoringRegions = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoringRegionsInput() {
    return this._monitoringRegions;
  }

  // name_filter - computed: false, optional: true, required: false
  private _nameFilter?: string[]; 
  public get nameFilter() {
    return cdktf.Fn.tolist(this.getListAttribute('name_filter'));
  }
  public set nameFilter(value: string[]) {
    this._nameFilter = value;
  }
  public resetNameFilter() {
    this._nameFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameFilterInput() {
    return this._nameFilter;
  }

  // select_all - computed: false, optional: true, required: false
  private _selectAll?: boolean | cdktf.IResolvable; 
  public get selectAll() {
    return this.getBooleanAttribute('select_all');
  }
  public set selectAll(value: boolean | cdktf.IResolvable) {
    this._selectAll = value;
  }
  public resetSelectAll() {
    this._selectAll = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectAllInput() {
    return this._selectAll;
  }

  // tags - computed: false, optional: true, required: false
  private _tags = new DeviceGroupExtraServicesCODEBUiLDTagsList(this, "tags", false);
  public get tags() {
    return this._tags;
  }
  public putTags(value: DeviceGroupExtraServicesCODEBUiLDTags[] | cdktf.IResolvable) {
    this._tags.internalValue = value;
  }
  public resetTags() {
    this._tags.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags.internalValue;
  }

  // use_default - computed: false, optional: false, required: true
  private _useDefault?: boolean | cdktf.IResolvable; 
  public get useDefault() {
    return this.getBooleanAttribute('use_default');
  }
  public set useDefault(value: boolean | cdktf.IResolvable) {
    this._useDefault = value;
  }
  // Temporarily expose input value. Use with caution.
  public get useDefaultInput() {
    return this._useDefault;
  }

  // normal_collector_config - computed: false, optional: true, required: false
  private _normalCollectorConfig = new DeviceGroupExtraServicesCODEBUiLDNormalCollectorConfigList(this, "normal_collector_config", false);
  public get normalCollectorConfig() {
    return this._normalCollectorConfig;
  }
  public putNormalCollectorConfig(value: DeviceGroupExtraServicesCODEBUiLDNormalCollectorConfig[] | cdktf.IResolvable) {
    this._normalCollectorConfig.internalValue = value;
  }
  public resetNormalCollectorConfig() {
    this._normalCollectorConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get normalCollectorConfigInput() {
    return this._normalCollectorConfig.internalValue;
  }
}

export class DeviceGroupExtraServicesCODEBUiLDList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesCODEBUiLD[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesCODEBUiLDOutputReference {
    return new DeviceGroupExtraServicesCODEBUiLDOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesCOGNITIVESEARCHTags {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#name DeviceGroup#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#operation DeviceGroup#operation}
  */
  readonly operation?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#value DeviceGroup#value}
  */
  readonly value?: string;
}

export function deviceGroupExtraServicesCOGNITIVESEARCHTagsToTerraform(struct?: DeviceGroupExtraServicesCOGNITIVESEARCHTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    operation: cdktf.stringToTerraform(struct!.operation),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function deviceGroupExtraServicesCOGNITIVESEARCHTagsToHclTerraform(struct?: DeviceGroupExtraServicesCOGNITIVESEARCHTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operation: {
      value: cdktf.stringToHclTerraform(struct!.operation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesCOGNITIVESEARCHTagsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesCOGNITIVESEARCHTags | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._operation !== undefined) {
      hasAnyValues = true;
      internalValueResult.operation = this._operation;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesCOGNITIVESEARCHTags | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._operation = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._operation = value.operation;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // operation - computed: false, optional: true, required: false
  private _operation?: string; 
  public get operation() {
    return this.getStringAttribute('operation');
  }
  public set operation(value: string) {
    this._operation = value;
  }
  public resetOperation() {
    this._operation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operationInput() {
    return this._operation;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DeviceGroupExtraServicesCOGNITIVESEARCHTagsList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesCOGNITIVESEARCHTags[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesCOGNITIVESEARCHTagsOutputReference {
    return new DeviceGroupExtraServicesCOGNITIVESEARCHTagsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesCOGNITIVESEARCHNormalCollectorConfigCollectors {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#applies_to DeviceGroup#applies_to}
  */
  readonly appliesTo?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#auto_balanced_collector_group_id DeviceGroup#auto_balanced_collector_group_id}
  */
  readonly autoBalancedCollectorGroupId?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#collector_id DeviceGroup#collector_id}
  */
  readonly collectorId?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#priority DeviceGroup#priority}
  */
  readonly priority?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#use_public_ip DeviceGroup#use_public_ip}
  */
  readonly usePublicIp?: boolean | cdktf.IResolvable;
}

export function deviceGroupExtraServicesCOGNITIVESEARCHNormalCollectorConfigCollectorsToTerraform(struct?: DeviceGroupExtraServicesCOGNITIVESEARCHNormalCollectorConfigCollectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    applies_to: cdktf.stringToTerraform(struct!.appliesTo),
    auto_balanced_collector_group_id: cdktf.numberToTerraform(struct!.autoBalancedCollectorGroupId),
    collector_id: cdktf.numberToTerraform(struct!.collectorId),
    priority: cdktf.numberToTerraform(struct!.priority),
    use_public_ip: cdktf.booleanToTerraform(struct!.usePublicIp),
  }
}


export function deviceGroupExtraServicesCOGNITIVESEARCHNormalCollectorConfigCollectorsToHclTerraform(struct?: DeviceGroupExtraServicesCOGNITIVESEARCHNormalCollectorConfigCollectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    applies_to: {
      value: cdktf.stringToHclTerraform(struct!.appliesTo),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auto_balanced_collector_group_id: {
      value: cdktf.numberToHclTerraform(struct!.autoBalancedCollectorGroupId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    collector_id: {
      value: cdktf.numberToHclTerraform(struct!.collectorId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    priority: {
      value: cdktf.numberToHclTerraform(struct!.priority),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    use_public_ip: {
      value: cdktf.booleanToHclTerraform(struct!.usePublicIp),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesCOGNITIVESEARCHNormalCollectorConfigCollectorsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesCOGNITIVESEARCHNormalCollectorConfigCollectors | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._appliesTo !== undefined) {
      hasAnyValues = true;
      internalValueResult.appliesTo = this._appliesTo;
    }
    if (this._autoBalancedCollectorGroupId !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoBalancedCollectorGroupId = this._autoBalancedCollectorGroupId;
    }
    if (this._collectorId !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectorId = this._collectorId;
    }
    if (this._priority !== undefined) {
      hasAnyValues = true;
      internalValueResult.priority = this._priority;
    }
    if (this._usePublicIp !== undefined) {
      hasAnyValues = true;
      internalValueResult.usePublicIp = this._usePublicIp;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesCOGNITIVESEARCHNormalCollectorConfigCollectors | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._appliesTo = undefined;
      this._autoBalancedCollectorGroupId = undefined;
      this._collectorId = undefined;
      this._priority = undefined;
      this._usePublicIp = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._appliesTo = value.appliesTo;
      this._autoBalancedCollectorGroupId = value.autoBalancedCollectorGroupId;
      this._collectorId = value.collectorId;
      this._priority = value.priority;
      this._usePublicIp = value.usePublicIp;
    }
  }

  // applies_to - computed: false, optional: true, required: false
  private _appliesTo?: string; 
  public get appliesTo() {
    return this.getStringAttribute('applies_to');
  }
  public set appliesTo(value: string) {
    this._appliesTo = value;
  }
  public resetAppliesTo() {
    this._appliesTo = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appliesToInput() {
    return this._appliesTo;
  }

  // auto_balanced_collector_group_id - computed: false, optional: true, required: false
  private _autoBalancedCollectorGroupId?: number; 
  public get autoBalancedCollectorGroupId() {
    return this.getNumberAttribute('auto_balanced_collector_group_id');
  }
  public set autoBalancedCollectorGroupId(value: number) {
    this._autoBalancedCollectorGroupId = value;
  }
  public resetAutoBalancedCollectorGroupId() {
    this._autoBalancedCollectorGroupId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoBalancedCollectorGroupIdInput() {
    return this._autoBalancedCollectorGroupId;
  }

  // collector_id - computed: false, optional: true, required: false
  private _collectorId?: number; 
  public get collectorId() {
    return this.getNumberAttribute('collector_id');
  }
  public set collectorId(value: number) {
    this._collectorId = value;
  }
  public resetCollectorId() {
    this._collectorId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorIdInput() {
    return this._collectorId;
  }

  // priority - computed: false, optional: true, required: false
  private _priority?: number; 
  public get priority() {
    return this.getNumberAttribute('priority');
  }
  public set priority(value: number) {
    this._priority = value;
  }
  public resetPriority() {
    this._priority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get priorityInput() {
    return this._priority;
  }

  // use_public_ip - computed: false, optional: true, required: false
  private _usePublicIp?: boolean | cdktf.IResolvable; 
  public get usePublicIp() {
    return this.getBooleanAttribute('use_public_ip');
  }
  public set usePublicIp(value: boolean | cdktf.IResolvable) {
    this._usePublicIp = value;
  }
  public resetUsePublicIp() {
    this._usePublicIp = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usePublicIpInput() {
    return this._usePublicIp;
  }
}

export class DeviceGroupExtraServicesCOGNITIVESEARCHNormalCollectorConfigCollectorsList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesCOGNITIVESEARCHNormalCollectorConfigCollectors[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesCOGNITIVESEARCHNormalCollectorConfigCollectorsOutputReference {
    return new DeviceGroupExtraServicesCOGNITIVESEARCHNormalCollectorConfigCollectorsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesCOGNITIVESEARCHNormalCollectorConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#collectors DeviceGroup#collectors}
  */
  readonly collectors?: DeviceGroupExtraServicesCOGNITIVESEARCHNormalCollectorConfigCollectors[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#enabled DeviceGroup#enabled}
  */
  readonly enabled: boolean | cdktf.IResolvable;
}

export function deviceGroupExtraServicesCOGNITIVESEARCHNormalCollectorConfigToTerraform(struct?: DeviceGroupExtraServicesCOGNITIVESEARCHNormalCollectorConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    collectors: cdktf.listMapper(deviceGroupExtraServicesCOGNITIVESEARCHNormalCollectorConfigCollectorsToTerraform, false)(struct!.collectors),
    enabled: cdktf.booleanToTerraform(struct!.enabled),
  }
}


export function deviceGroupExtraServicesCOGNITIVESEARCHNormalCollectorConfigToHclTerraform(struct?: DeviceGroupExtraServicesCOGNITIVESEARCHNormalCollectorConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    collectors: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesCOGNITIVESEARCHNormalCollectorConfigCollectorsToHclTerraform, false)(struct!.collectors),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesCOGNITIVESEARCHNormalCollectorConfigCollectorsList",
    },
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesCOGNITIVESEARCHNormalCollectorConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesCOGNITIVESEARCHNormalCollectorConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._collectors?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectors = this._collectors?.internalValue;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesCOGNITIVESEARCHNormalCollectorConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._collectors.internalValue = undefined;
      this._enabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._collectors.internalValue = value.collectors;
      this._enabled = value.enabled;
    }
  }

  // collectors - computed: false, optional: true, required: false
  private _collectors = new DeviceGroupExtraServicesCOGNITIVESEARCHNormalCollectorConfigCollectorsList(this, "collectors", false);
  public get collectors() {
    return this._collectors;
  }
  public putCollectors(value: DeviceGroupExtraServicesCOGNITIVESEARCHNormalCollectorConfigCollectors[] | cdktf.IResolvable) {
    this._collectors.internalValue = value;
  }
  public resetCollectors() {
    this._collectors.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorsInput() {
    return this._collectors.internalValue;
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }
}

export class DeviceGroupExtraServicesCOGNITIVESEARCHNormalCollectorConfigList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesCOGNITIVESEARCHNormalCollectorConfig[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesCOGNITIVESEARCHNormalCollectorConfigOutputReference {
    return new DeviceGroupExtraServicesCOGNITIVESEARCHNormalCollectorConfigOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesCOGNITIVESEARCH {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#custom_n_s_p_schedule DeviceGroup#custom_n_s_p_schedule}
  */
  readonly customNSPSchedule?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#dead_operation DeviceGroup#dead_operation}
  */
  readonly deadOperation?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#device_display_name_template DeviceGroup#device_display_name_template}
  */
  readonly deviceDisplayNameTemplate?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#disable_stop_terminate_host_monitor DeviceGroup#disable_stop_terminate_host_monitor}
  */
  readonly disableStopTerminateHostMonitor?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#disable_terminated_host_alerting DeviceGroup#disable_terminated_host_alerting}
  */
  readonly disableTerminatedHostAlerting?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#monitoring_region_infos DeviceGroup#monitoring_region_infos}
  */
  readonly monitoringRegionInfos?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#monitoring_regions DeviceGroup#monitoring_regions}
  */
  readonly monitoringRegions?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#name_filter DeviceGroup#name_filter}
  */
  readonly nameFilter?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#select_all DeviceGroup#select_all}
  */
  readonly selectAll?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#tags DeviceGroup#tags}
  */
  readonly tags?: DeviceGroupExtraServicesCOGNITIVESEARCHTags[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#use_default DeviceGroup#use_default}
  */
  readonly useDefault: boolean | cdktf.IResolvable;
  /**
  * normal_collector_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#normal_collector_config DeviceGroup#normal_collector_config}
  */
  readonly normalCollectorConfig?: DeviceGroupExtraServicesCOGNITIVESEARCHNormalCollectorConfig[] | cdktf.IResolvable;
}

export function deviceGroupExtraServicesCOGNITIVESEARCHToTerraform(struct?: DeviceGroupExtraServicesCOGNITIVESEARCH | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    custom_n_s_p_schedule: cdktf.stringToTerraform(struct!.customNSPSchedule),
    dead_operation: cdktf.stringToTerraform(struct!.deadOperation),
    device_display_name_template: cdktf.stringToTerraform(struct!.deviceDisplayNameTemplate),
    disable_stop_terminate_host_monitor: cdktf.booleanToTerraform(struct!.disableStopTerminateHostMonitor),
    disable_terminated_host_alerting: cdktf.booleanToTerraform(struct!.disableTerminatedHostAlerting),
    monitoring_region_infos: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.monitoringRegionInfos),
    monitoring_regions: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.monitoringRegions),
    name_filter: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.nameFilter),
    select_all: cdktf.booleanToTerraform(struct!.selectAll),
    tags: cdktf.listMapper(deviceGroupExtraServicesCOGNITIVESEARCHTagsToTerraform, false)(struct!.tags),
    use_default: cdktf.booleanToTerraform(struct!.useDefault),
    normal_collector_config: cdktf.listMapper(deviceGroupExtraServicesCOGNITIVESEARCHNormalCollectorConfigToTerraform, true)(struct!.normalCollectorConfig),
  }
}


export function deviceGroupExtraServicesCOGNITIVESEARCHToHclTerraform(struct?: DeviceGroupExtraServicesCOGNITIVESEARCH | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    custom_n_s_p_schedule: {
      value: cdktf.stringToHclTerraform(struct!.customNSPSchedule),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dead_operation: {
      value: cdktf.stringToHclTerraform(struct!.deadOperation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    device_display_name_template: {
      value: cdktf.stringToHclTerraform(struct!.deviceDisplayNameTemplate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disable_stop_terminate_host_monitor: {
      value: cdktf.booleanToHclTerraform(struct!.disableStopTerminateHostMonitor),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    disable_terminated_host_alerting: {
      value: cdktf.booleanToHclTerraform(struct!.disableTerminatedHostAlerting),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    monitoring_region_infos: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.monitoringRegionInfos),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    monitoring_regions: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.monitoringRegions),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    name_filter: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.nameFilter),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    select_all: {
      value: cdktf.booleanToHclTerraform(struct!.selectAll),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tags: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesCOGNITIVESEARCHTagsToHclTerraform, false)(struct!.tags),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesCOGNITIVESEARCHTagsList",
    },
    use_default: {
      value: cdktf.booleanToHclTerraform(struct!.useDefault),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    normal_collector_config: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesCOGNITIVESEARCHNormalCollectorConfigToHclTerraform, true)(struct!.normalCollectorConfig),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesCOGNITIVESEARCHNormalCollectorConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesCOGNITIVESEARCHOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesCOGNITIVESEARCH | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._customNSPSchedule !== undefined) {
      hasAnyValues = true;
      internalValueResult.customNSPSchedule = this._customNSPSchedule;
    }
    if (this._deadOperation !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadOperation = this._deadOperation;
    }
    if (this._deviceDisplayNameTemplate !== undefined) {
      hasAnyValues = true;
      internalValueResult.deviceDisplayNameTemplate = this._deviceDisplayNameTemplate;
    }
    if (this._disableStopTerminateHostMonitor !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableStopTerminateHostMonitor = this._disableStopTerminateHostMonitor;
    }
    if (this._disableTerminatedHostAlerting !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableTerminatedHostAlerting = this._disableTerminatedHostAlerting;
    }
    if (this._monitoringRegionInfos !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoringRegionInfos = this._monitoringRegionInfos;
    }
    if (this._monitoringRegions !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoringRegions = this._monitoringRegions;
    }
    if (this._nameFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.nameFilter = this._nameFilter;
    }
    if (this._selectAll !== undefined) {
      hasAnyValues = true;
      internalValueResult.selectAll = this._selectAll;
    }
    if (this._tags?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags?.internalValue;
    }
    if (this._useDefault !== undefined) {
      hasAnyValues = true;
      internalValueResult.useDefault = this._useDefault;
    }
    if (this._normalCollectorConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.normalCollectorConfig = this._normalCollectorConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesCOGNITIVESEARCH | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._customNSPSchedule = undefined;
      this._deadOperation = undefined;
      this._deviceDisplayNameTemplate = undefined;
      this._disableStopTerminateHostMonitor = undefined;
      this._disableTerminatedHostAlerting = undefined;
      this._monitoringRegionInfos = undefined;
      this._monitoringRegions = undefined;
      this._nameFilter = undefined;
      this._selectAll = undefined;
      this._tags.internalValue = undefined;
      this._useDefault = undefined;
      this._normalCollectorConfig.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._customNSPSchedule = value.customNSPSchedule;
      this._deadOperation = value.deadOperation;
      this._deviceDisplayNameTemplate = value.deviceDisplayNameTemplate;
      this._disableStopTerminateHostMonitor = value.disableStopTerminateHostMonitor;
      this._disableTerminatedHostAlerting = value.disableTerminatedHostAlerting;
      this._monitoringRegionInfos = value.monitoringRegionInfos;
      this._monitoringRegions = value.monitoringRegions;
      this._nameFilter = value.nameFilter;
      this._selectAll = value.selectAll;
      this._tags.internalValue = value.tags;
      this._useDefault = value.useDefault;
      this._normalCollectorConfig.internalValue = value.normalCollectorConfig;
    }
  }

  // custom_n_s_p_schedule - computed: false, optional: true, required: false
  private _customNSPSchedule?: string; 
  public get customNSPSchedule() {
    return this.getStringAttribute('custom_n_s_p_schedule');
  }
  public set customNSPSchedule(value: string) {
    this._customNSPSchedule = value;
  }
  public resetCustomNSPSchedule() {
    this._customNSPSchedule = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customNSPScheduleInput() {
    return this._customNSPSchedule;
  }

  // dead_operation - computed: false, optional: true, required: false
  private _deadOperation?: string; 
  public get deadOperation() {
    return this.getStringAttribute('dead_operation');
  }
  public set deadOperation(value: string) {
    this._deadOperation = value;
  }
  public resetDeadOperation() {
    this._deadOperation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadOperationInput() {
    return this._deadOperation;
  }

  // device_display_name_template - computed: false, optional: true, required: false
  private _deviceDisplayNameTemplate?: string; 
  public get deviceDisplayNameTemplate() {
    return this.getStringAttribute('device_display_name_template');
  }
  public set deviceDisplayNameTemplate(value: string) {
    this._deviceDisplayNameTemplate = value;
  }
  public resetDeviceDisplayNameTemplate() {
    this._deviceDisplayNameTemplate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deviceDisplayNameTemplateInput() {
    return this._deviceDisplayNameTemplate;
  }

  // disable_stop_terminate_host_monitor - computed: false, optional: true, required: false
  private _disableStopTerminateHostMonitor?: boolean | cdktf.IResolvable; 
  public get disableStopTerminateHostMonitor() {
    return this.getBooleanAttribute('disable_stop_terminate_host_monitor');
  }
  public set disableStopTerminateHostMonitor(value: boolean | cdktf.IResolvable) {
    this._disableStopTerminateHostMonitor = value;
  }
  public resetDisableStopTerminateHostMonitor() {
    this._disableStopTerminateHostMonitor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableStopTerminateHostMonitorInput() {
    return this._disableStopTerminateHostMonitor;
  }

  // disable_terminated_host_alerting - computed: false, optional: true, required: false
  private _disableTerminatedHostAlerting?: boolean | cdktf.IResolvable; 
  public get disableTerminatedHostAlerting() {
    return this.getBooleanAttribute('disable_terminated_host_alerting');
  }
  public set disableTerminatedHostAlerting(value: boolean | cdktf.IResolvable) {
    this._disableTerminatedHostAlerting = value;
  }
  public resetDisableTerminatedHostAlerting() {
    this._disableTerminatedHostAlerting = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableTerminatedHostAlertingInput() {
    return this._disableTerminatedHostAlerting;
  }

  // monitoring_region_infos - computed: false, optional: true, required: false
  private _monitoringRegionInfos?: string[]; 
  public get monitoringRegionInfos() {
    return cdktf.Fn.tolist(this.getListAttribute('monitoring_region_infos'));
  }
  public set monitoringRegionInfos(value: string[]) {
    this._monitoringRegionInfos = value;
  }
  public resetMonitoringRegionInfos() {
    this._monitoringRegionInfos = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoringRegionInfosInput() {
    return this._monitoringRegionInfos;
  }

  // monitoring_regions - computed: false, optional: true, required: false
  private _monitoringRegions?: string[]; 
  public get monitoringRegions() {
    return cdktf.Fn.tolist(this.getListAttribute('monitoring_regions'));
  }
  public set monitoringRegions(value: string[]) {
    this._monitoringRegions = value;
  }
  public resetMonitoringRegions() {
    this._monitoringRegions = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoringRegionsInput() {
    return this._monitoringRegions;
  }

  // name_filter - computed: false, optional: true, required: false
  private _nameFilter?: string[]; 
  public get nameFilter() {
    return cdktf.Fn.tolist(this.getListAttribute('name_filter'));
  }
  public set nameFilter(value: string[]) {
    this._nameFilter = value;
  }
  public resetNameFilter() {
    this._nameFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameFilterInput() {
    return this._nameFilter;
  }

  // select_all - computed: false, optional: true, required: false
  private _selectAll?: boolean | cdktf.IResolvable; 
  public get selectAll() {
    return this.getBooleanAttribute('select_all');
  }
  public set selectAll(value: boolean | cdktf.IResolvable) {
    this._selectAll = value;
  }
  public resetSelectAll() {
    this._selectAll = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectAllInput() {
    return this._selectAll;
  }

  // tags - computed: false, optional: true, required: false
  private _tags = new DeviceGroupExtraServicesCOGNITIVESEARCHTagsList(this, "tags", false);
  public get tags() {
    return this._tags;
  }
  public putTags(value: DeviceGroupExtraServicesCOGNITIVESEARCHTags[] | cdktf.IResolvable) {
    this._tags.internalValue = value;
  }
  public resetTags() {
    this._tags.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags.internalValue;
  }

  // use_default - computed: false, optional: false, required: true
  private _useDefault?: boolean | cdktf.IResolvable; 
  public get useDefault() {
    return this.getBooleanAttribute('use_default');
  }
  public set useDefault(value: boolean | cdktf.IResolvable) {
    this._useDefault = value;
  }
  // Temporarily expose input value. Use with caution.
  public get useDefaultInput() {
    return this._useDefault;
  }

  // normal_collector_config - computed: false, optional: true, required: false
  private _normalCollectorConfig = new DeviceGroupExtraServicesCOGNITIVESEARCHNormalCollectorConfigList(this, "normal_collector_config", false);
  public get normalCollectorConfig() {
    return this._normalCollectorConfig;
  }
  public putNormalCollectorConfig(value: DeviceGroupExtraServicesCOGNITIVESEARCHNormalCollectorConfig[] | cdktf.IResolvable) {
    this._normalCollectorConfig.internalValue = value;
  }
  public resetNormalCollectorConfig() {
    this._normalCollectorConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get normalCollectorConfigInput() {
    return this._normalCollectorConfig.internalValue;
  }
}

export class DeviceGroupExtraServicesCOGNITIVESEARCHList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesCOGNITIVESEARCH[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesCOGNITIVESEARCHOutputReference {
    return new DeviceGroupExtraServicesCOGNITIVESEARCHOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesCOGNITIVESERVICESTags {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#name DeviceGroup#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#operation DeviceGroup#operation}
  */
  readonly operation?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#value DeviceGroup#value}
  */
  readonly value?: string;
}

export function deviceGroupExtraServicesCOGNITIVESERVICESTagsToTerraform(struct?: DeviceGroupExtraServicesCOGNITIVESERVICESTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    operation: cdktf.stringToTerraform(struct!.operation),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function deviceGroupExtraServicesCOGNITIVESERVICESTagsToHclTerraform(struct?: DeviceGroupExtraServicesCOGNITIVESERVICESTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operation: {
      value: cdktf.stringToHclTerraform(struct!.operation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesCOGNITIVESERVICESTagsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesCOGNITIVESERVICESTags | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._operation !== undefined) {
      hasAnyValues = true;
      internalValueResult.operation = this._operation;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesCOGNITIVESERVICESTags | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._operation = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._operation = value.operation;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // operation - computed: false, optional: true, required: false
  private _operation?: string; 
  public get operation() {
    return this.getStringAttribute('operation');
  }
  public set operation(value: string) {
    this._operation = value;
  }
  public resetOperation() {
    this._operation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operationInput() {
    return this._operation;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DeviceGroupExtraServicesCOGNITIVESERVICESTagsList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesCOGNITIVESERVICESTags[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesCOGNITIVESERVICESTagsOutputReference {
    return new DeviceGroupExtraServicesCOGNITIVESERVICESTagsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesCOGNITIVESERVICESNormalCollectorConfigCollectors {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#applies_to DeviceGroup#applies_to}
  */
  readonly appliesTo?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#auto_balanced_collector_group_id DeviceGroup#auto_balanced_collector_group_id}
  */
  readonly autoBalancedCollectorGroupId?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#collector_id DeviceGroup#collector_id}
  */
  readonly collectorId?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#priority DeviceGroup#priority}
  */
  readonly priority?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#use_public_ip DeviceGroup#use_public_ip}
  */
  readonly usePublicIp?: boolean | cdktf.IResolvable;
}

export function deviceGroupExtraServicesCOGNITIVESERVICESNormalCollectorConfigCollectorsToTerraform(struct?: DeviceGroupExtraServicesCOGNITIVESERVICESNormalCollectorConfigCollectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    applies_to: cdktf.stringToTerraform(struct!.appliesTo),
    auto_balanced_collector_group_id: cdktf.numberToTerraform(struct!.autoBalancedCollectorGroupId),
    collector_id: cdktf.numberToTerraform(struct!.collectorId),
    priority: cdktf.numberToTerraform(struct!.priority),
    use_public_ip: cdktf.booleanToTerraform(struct!.usePublicIp),
  }
}


export function deviceGroupExtraServicesCOGNITIVESERVICESNormalCollectorConfigCollectorsToHclTerraform(struct?: DeviceGroupExtraServicesCOGNITIVESERVICESNormalCollectorConfigCollectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    applies_to: {
      value: cdktf.stringToHclTerraform(struct!.appliesTo),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auto_balanced_collector_group_id: {
      value: cdktf.numberToHclTerraform(struct!.autoBalancedCollectorGroupId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    collector_id: {
      value: cdktf.numberToHclTerraform(struct!.collectorId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    priority: {
      value: cdktf.numberToHclTerraform(struct!.priority),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    use_public_ip: {
      value: cdktf.booleanToHclTerraform(struct!.usePublicIp),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesCOGNITIVESERVICESNormalCollectorConfigCollectorsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesCOGNITIVESERVICESNormalCollectorConfigCollectors | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._appliesTo !== undefined) {
      hasAnyValues = true;
      internalValueResult.appliesTo = this._appliesTo;
    }
    if (this._autoBalancedCollectorGroupId !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoBalancedCollectorGroupId = this._autoBalancedCollectorGroupId;
    }
    if (this._collectorId !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectorId = this._collectorId;
    }
    if (this._priority !== undefined) {
      hasAnyValues = true;
      internalValueResult.priority = this._priority;
    }
    if (this._usePublicIp !== undefined) {
      hasAnyValues = true;
      internalValueResult.usePublicIp = this._usePublicIp;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesCOGNITIVESERVICESNormalCollectorConfigCollectors | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._appliesTo = undefined;
      this._autoBalancedCollectorGroupId = undefined;
      this._collectorId = undefined;
      this._priority = undefined;
      this._usePublicIp = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._appliesTo = value.appliesTo;
      this._autoBalancedCollectorGroupId = value.autoBalancedCollectorGroupId;
      this._collectorId = value.collectorId;
      this._priority = value.priority;
      this._usePublicIp = value.usePublicIp;
    }
  }

  // applies_to - computed: false, optional: true, required: false
  private _appliesTo?: string; 
  public get appliesTo() {
    return this.getStringAttribute('applies_to');
  }
  public set appliesTo(value: string) {
    this._appliesTo = value;
  }
  public resetAppliesTo() {
    this._appliesTo = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appliesToInput() {
    return this._appliesTo;
  }

  // auto_balanced_collector_group_id - computed: false, optional: true, required: false
  private _autoBalancedCollectorGroupId?: number; 
  public get autoBalancedCollectorGroupId() {
    return this.getNumberAttribute('auto_balanced_collector_group_id');
  }
  public set autoBalancedCollectorGroupId(value: number) {
    this._autoBalancedCollectorGroupId = value;
  }
  public resetAutoBalancedCollectorGroupId() {
    this._autoBalancedCollectorGroupId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoBalancedCollectorGroupIdInput() {
    return this._autoBalancedCollectorGroupId;
  }

  // collector_id - computed: false, optional: true, required: false
  private _collectorId?: number; 
  public get collectorId() {
    return this.getNumberAttribute('collector_id');
  }
  public set collectorId(value: number) {
    this._collectorId = value;
  }
  public resetCollectorId() {
    this._collectorId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorIdInput() {
    return this._collectorId;
  }

  // priority - computed: false, optional: true, required: false
  private _priority?: number; 
  public get priority() {
    return this.getNumberAttribute('priority');
  }
  public set priority(value: number) {
    this._priority = value;
  }
  public resetPriority() {
    this._priority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get priorityInput() {
    return this._priority;
  }

  // use_public_ip - computed: false, optional: true, required: false
  private _usePublicIp?: boolean | cdktf.IResolvable; 
  public get usePublicIp() {
    return this.getBooleanAttribute('use_public_ip');
  }
  public set usePublicIp(value: boolean | cdktf.IResolvable) {
    this._usePublicIp = value;
  }
  public resetUsePublicIp() {
    this._usePublicIp = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usePublicIpInput() {
    return this._usePublicIp;
  }
}

export class DeviceGroupExtraServicesCOGNITIVESERVICESNormalCollectorConfigCollectorsList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesCOGNITIVESERVICESNormalCollectorConfigCollectors[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesCOGNITIVESERVICESNormalCollectorConfigCollectorsOutputReference {
    return new DeviceGroupExtraServicesCOGNITIVESERVICESNormalCollectorConfigCollectorsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesCOGNITIVESERVICESNormalCollectorConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#collectors DeviceGroup#collectors}
  */
  readonly collectors?: DeviceGroupExtraServicesCOGNITIVESERVICESNormalCollectorConfigCollectors[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#enabled DeviceGroup#enabled}
  */
  readonly enabled: boolean | cdktf.IResolvable;
}

export function deviceGroupExtraServicesCOGNITIVESERVICESNormalCollectorConfigToTerraform(struct?: DeviceGroupExtraServicesCOGNITIVESERVICESNormalCollectorConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    collectors: cdktf.listMapper(deviceGroupExtraServicesCOGNITIVESERVICESNormalCollectorConfigCollectorsToTerraform, false)(struct!.collectors),
    enabled: cdktf.booleanToTerraform(struct!.enabled),
  }
}


export function deviceGroupExtraServicesCOGNITIVESERVICESNormalCollectorConfigToHclTerraform(struct?: DeviceGroupExtraServicesCOGNITIVESERVICESNormalCollectorConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    collectors: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesCOGNITIVESERVICESNormalCollectorConfigCollectorsToHclTerraform, false)(struct!.collectors),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesCOGNITIVESERVICESNormalCollectorConfigCollectorsList",
    },
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesCOGNITIVESERVICESNormalCollectorConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesCOGNITIVESERVICESNormalCollectorConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._collectors?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectors = this._collectors?.internalValue;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesCOGNITIVESERVICESNormalCollectorConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._collectors.internalValue = undefined;
      this._enabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._collectors.internalValue = value.collectors;
      this._enabled = value.enabled;
    }
  }

  // collectors - computed: false, optional: true, required: false
  private _collectors = new DeviceGroupExtraServicesCOGNITIVESERVICESNormalCollectorConfigCollectorsList(this, "collectors", false);
  public get collectors() {
    return this._collectors;
  }
  public putCollectors(value: DeviceGroupExtraServicesCOGNITIVESERVICESNormalCollectorConfigCollectors[] | cdktf.IResolvable) {
    this._collectors.internalValue = value;
  }
  public resetCollectors() {
    this._collectors.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorsInput() {
    return this._collectors.internalValue;
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }
}

export class DeviceGroupExtraServicesCOGNITIVESERVICESNormalCollectorConfigList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesCOGNITIVESERVICESNormalCollectorConfig[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesCOGNITIVESERVICESNormalCollectorConfigOutputReference {
    return new DeviceGroupExtraServicesCOGNITIVESERVICESNormalCollectorConfigOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesCOGNITIVESERVICES {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#custom_n_s_p_schedule DeviceGroup#custom_n_s_p_schedule}
  */
  readonly customNSPSchedule?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#dead_operation DeviceGroup#dead_operation}
  */
  readonly deadOperation?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#device_display_name_template DeviceGroup#device_display_name_template}
  */
  readonly deviceDisplayNameTemplate?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#disable_stop_terminate_host_monitor DeviceGroup#disable_stop_terminate_host_monitor}
  */
  readonly disableStopTerminateHostMonitor?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#disable_terminated_host_alerting DeviceGroup#disable_terminated_host_alerting}
  */
  readonly disableTerminatedHostAlerting?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#monitoring_region_infos DeviceGroup#monitoring_region_infos}
  */
  readonly monitoringRegionInfos?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#monitoring_regions DeviceGroup#monitoring_regions}
  */
  readonly monitoringRegions?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#name_filter DeviceGroup#name_filter}
  */
  readonly nameFilter?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#select_all DeviceGroup#select_all}
  */
  readonly selectAll?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#tags DeviceGroup#tags}
  */
  readonly tags?: DeviceGroupExtraServicesCOGNITIVESERVICESTags[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#use_default DeviceGroup#use_default}
  */
  readonly useDefault: boolean | cdktf.IResolvable;
  /**
  * normal_collector_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#normal_collector_config DeviceGroup#normal_collector_config}
  */
  readonly normalCollectorConfig?: DeviceGroupExtraServicesCOGNITIVESERVICESNormalCollectorConfig[] | cdktf.IResolvable;
}

export function deviceGroupExtraServicesCOGNITIVESERVICESToTerraform(struct?: DeviceGroupExtraServicesCOGNITIVESERVICES | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    custom_n_s_p_schedule: cdktf.stringToTerraform(struct!.customNSPSchedule),
    dead_operation: cdktf.stringToTerraform(struct!.deadOperation),
    device_display_name_template: cdktf.stringToTerraform(struct!.deviceDisplayNameTemplate),
    disable_stop_terminate_host_monitor: cdktf.booleanToTerraform(struct!.disableStopTerminateHostMonitor),
    disable_terminated_host_alerting: cdktf.booleanToTerraform(struct!.disableTerminatedHostAlerting),
    monitoring_region_infos: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.monitoringRegionInfos),
    monitoring_regions: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.monitoringRegions),
    name_filter: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.nameFilter),
    select_all: cdktf.booleanToTerraform(struct!.selectAll),
    tags: cdktf.listMapper(deviceGroupExtraServicesCOGNITIVESERVICESTagsToTerraform, false)(struct!.tags),
    use_default: cdktf.booleanToTerraform(struct!.useDefault),
    normal_collector_config: cdktf.listMapper(deviceGroupExtraServicesCOGNITIVESERVICESNormalCollectorConfigToTerraform, true)(struct!.normalCollectorConfig),
  }
}


export function deviceGroupExtraServicesCOGNITIVESERVICESToHclTerraform(struct?: DeviceGroupExtraServicesCOGNITIVESERVICES | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    custom_n_s_p_schedule: {
      value: cdktf.stringToHclTerraform(struct!.customNSPSchedule),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dead_operation: {
      value: cdktf.stringToHclTerraform(struct!.deadOperation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    device_display_name_template: {
      value: cdktf.stringToHclTerraform(struct!.deviceDisplayNameTemplate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disable_stop_terminate_host_monitor: {
      value: cdktf.booleanToHclTerraform(struct!.disableStopTerminateHostMonitor),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    disable_terminated_host_alerting: {
      value: cdktf.booleanToHclTerraform(struct!.disableTerminatedHostAlerting),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    monitoring_region_infos: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.monitoringRegionInfos),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    monitoring_regions: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.monitoringRegions),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    name_filter: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.nameFilter),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    select_all: {
      value: cdktf.booleanToHclTerraform(struct!.selectAll),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tags: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesCOGNITIVESERVICESTagsToHclTerraform, false)(struct!.tags),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesCOGNITIVESERVICESTagsList",
    },
    use_default: {
      value: cdktf.booleanToHclTerraform(struct!.useDefault),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    normal_collector_config: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesCOGNITIVESERVICESNormalCollectorConfigToHclTerraform, true)(struct!.normalCollectorConfig),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesCOGNITIVESERVICESNormalCollectorConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesCOGNITIVESERVICESOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesCOGNITIVESERVICES | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._customNSPSchedule !== undefined) {
      hasAnyValues = true;
      internalValueResult.customNSPSchedule = this._customNSPSchedule;
    }
    if (this._deadOperation !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadOperation = this._deadOperation;
    }
    if (this._deviceDisplayNameTemplate !== undefined) {
      hasAnyValues = true;
      internalValueResult.deviceDisplayNameTemplate = this._deviceDisplayNameTemplate;
    }
    if (this._disableStopTerminateHostMonitor !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableStopTerminateHostMonitor = this._disableStopTerminateHostMonitor;
    }
    if (this._disableTerminatedHostAlerting !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableTerminatedHostAlerting = this._disableTerminatedHostAlerting;
    }
    if (this._monitoringRegionInfos !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoringRegionInfos = this._monitoringRegionInfos;
    }
    if (this._monitoringRegions !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoringRegions = this._monitoringRegions;
    }
    if (this._nameFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.nameFilter = this._nameFilter;
    }
    if (this._selectAll !== undefined) {
      hasAnyValues = true;
      internalValueResult.selectAll = this._selectAll;
    }
    if (this._tags?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags?.internalValue;
    }
    if (this._useDefault !== undefined) {
      hasAnyValues = true;
      internalValueResult.useDefault = this._useDefault;
    }
    if (this._normalCollectorConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.normalCollectorConfig = this._normalCollectorConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesCOGNITIVESERVICES | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._customNSPSchedule = undefined;
      this._deadOperation = undefined;
      this._deviceDisplayNameTemplate = undefined;
      this._disableStopTerminateHostMonitor = undefined;
      this._disableTerminatedHostAlerting = undefined;
      this._monitoringRegionInfos = undefined;
      this._monitoringRegions = undefined;
      this._nameFilter = undefined;
      this._selectAll = undefined;
      this._tags.internalValue = undefined;
      this._useDefault = undefined;
      this._normalCollectorConfig.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._customNSPSchedule = value.customNSPSchedule;
      this._deadOperation = value.deadOperation;
      this._deviceDisplayNameTemplate = value.deviceDisplayNameTemplate;
      this._disableStopTerminateHostMonitor = value.disableStopTerminateHostMonitor;
      this._disableTerminatedHostAlerting = value.disableTerminatedHostAlerting;
      this._monitoringRegionInfos = value.monitoringRegionInfos;
      this._monitoringRegions = value.monitoringRegions;
      this._nameFilter = value.nameFilter;
      this._selectAll = value.selectAll;
      this._tags.internalValue = value.tags;
      this._useDefault = value.useDefault;
      this._normalCollectorConfig.internalValue = value.normalCollectorConfig;
    }
  }

  // custom_n_s_p_schedule - computed: false, optional: true, required: false
  private _customNSPSchedule?: string; 
  public get customNSPSchedule() {
    return this.getStringAttribute('custom_n_s_p_schedule');
  }
  public set customNSPSchedule(value: string) {
    this._customNSPSchedule = value;
  }
  public resetCustomNSPSchedule() {
    this._customNSPSchedule = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customNSPScheduleInput() {
    return this._customNSPSchedule;
  }

  // dead_operation - computed: false, optional: true, required: false
  private _deadOperation?: string; 
  public get deadOperation() {
    return this.getStringAttribute('dead_operation');
  }
  public set deadOperation(value: string) {
    this._deadOperation = value;
  }
  public resetDeadOperation() {
    this._deadOperation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadOperationInput() {
    return this._deadOperation;
  }

  // device_display_name_template - computed: false, optional: true, required: false
  private _deviceDisplayNameTemplate?: string; 
  public get deviceDisplayNameTemplate() {
    return this.getStringAttribute('device_display_name_template');
  }
  public set deviceDisplayNameTemplate(value: string) {
    this._deviceDisplayNameTemplate = value;
  }
  public resetDeviceDisplayNameTemplate() {
    this._deviceDisplayNameTemplate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deviceDisplayNameTemplateInput() {
    return this._deviceDisplayNameTemplate;
  }

  // disable_stop_terminate_host_monitor - computed: false, optional: true, required: false
  private _disableStopTerminateHostMonitor?: boolean | cdktf.IResolvable; 
  public get disableStopTerminateHostMonitor() {
    return this.getBooleanAttribute('disable_stop_terminate_host_monitor');
  }
  public set disableStopTerminateHostMonitor(value: boolean | cdktf.IResolvable) {
    this._disableStopTerminateHostMonitor = value;
  }
  public resetDisableStopTerminateHostMonitor() {
    this._disableStopTerminateHostMonitor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableStopTerminateHostMonitorInput() {
    return this._disableStopTerminateHostMonitor;
  }

  // disable_terminated_host_alerting - computed: false, optional: true, required: false
  private _disableTerminatedHostAlerting?: boolean | cdktf.IResolvable; 
  public get disableTerminatedHostAlerting() {
    return this.getBooleanAttribute('disable_terminated_host_alerting');
  }
  public set disableTerminatedHostAlerting(value: boolean | cdktf.IResolvable) {
    this._disableTerminatedHostAlerting = value;
  }
  public resetDisableTerminatedHostAlerting() {
    this._disableTerminatedHostAlerting = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableTerminatedHostAlertingInput() {
    return this._disableTerminatedHostAlerting;
  }

  // monitoring_region_infos - computed: false, optional: true, required: false
  private _monitoringRegionInfos?: string[]; 
  public get monitoringRegionInfos() {
    return cdktf.Fn.tolist(this.getListAttribute('monitoring_region_infos'));
  }
  public set monitoringRegionInfos(value: string[]) {
    this._monitoringRegionInfos = value;
  }
  public resetMonitoringRegionInfos() {
    this._monitoringRegionInfos = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoringRegionInfosInput() {
    return this._monitoringRegionInfos;
  }

  // monitoring_regions - computed: false, optional: true, required: false
  private _monitoringRegions?: string[]; 
  public get monitoringRegions() {
    return cdktf.Fn.tolist(this.getListAttribute('monitoring_regions'));
  }
  public set monitoringRegions(value: string[]) {
    this._monitoringRegions = value;
  }
  public resetMonitoringRegions() {
    this._monitoringRegions = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoringRegionsInput() {
    return this._monitoringRegions;
  }

  // name_filter - computed: false, optional: true, required: false
  private _nameFilter?: string[]; 
  public get nameFilter() {
    return cdktf.Fn.tolist(this.getListAttribute('name_filter'));
  }
  public set nameFilter(value: string[]) {
    this._nameFilter = value;
  }
  public resetNameFilter() {
    this._nameFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameFilterInput() {
    return this._nameFilter;
  }

  // select_all - computed: false, optional: true, required: false
  private _selectAll?: boolean | cdktf.IResolvable; 
  public get selectAll() {
    return this.getBooleanAttribute('select_all');
  }
  public set selectAll(value: boolean | cdktf.IResolvable) {
    this._selectAll = value;
  }
  public resetSelectAll() {
    this._selectAll = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectAllInput() {
    return this._selectAll;
  }

  // tags - computed: false, optional: true, required: false
  private _tags = new DeviceGroupExtraServicesCOGNITIVESERVICESTagsList(this, "tags", false);
  public get tags() {
    return this._tags;
  }
  public putTags(value: DeviceGroupExtraServicesCOGNITIVESERVICESTags[] | cdktf.IResolvable) {
    this._tags.internalValue = value;
  }
  public resetTags() {
    this._tags.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags.internalValue;
  }

  // use_default - computed: false, optional: false, required: true
  private _useDefault?: boolean | cdktf.IResolvable; 
  public get useDefault() {
    return this.getBooleanAttribute('use_default');
  }
  public set useDefault(value: boolean | cdktf.IResolvable) {
    this._useDefault = value;
  }
  // Temporarily expose input value. Use with caution.
  public get useDefaultInput() {
    return this._useDefault;
  }

  // normal_collector_config - computed: false, optional: true, required: false
  private _normalCollectorConfig = new DeviceGroupExtraServicesCOGNITIVESERVICESNormalCollectorConfigList(this, "normal_collector_config", false);
  public get normalCollectorConfig() {
    return this._normalCollectorConfig;
  }
  public putNormalCollectorConfig(value: DeviceGroupExtraServicesCOGNITIVESERVICESNormalCollectorConfig[] | cdktf.IResolvable) {
    this._normalCollectorConfig.internalValue = value;
  }
  public resetNormalCollectorConfig() {
    this._normalCollectorConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get normalCollectorConfigInput() {
    return this._normalCollectorConfig.internalValue;
  }
}

export class DeviceGroupExtraServicesCOGNITIVESERVICESList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesCOGNITIVESERVICES[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesCOGNITIVESERVICESOutputReference {
    return new DeviceGroupExtraServicesCOGNITIVESERVICESOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesCOGNITOTags {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#name DeviceGroup#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#operation DeviceGroup#operation}
  */
  readonly operation?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#value DeviceGroup#value}
  */
  readonly value?: string;
}

export function deviceGroupExtraServicesCOGNITOTagsToTerraform(struct?: DeviceGroupExtraServicesCOGNITOTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    operation: cdktf.stringToTerraform(struct!.operation),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function deviceGroupExtraServicesCOGNITOTagsToHclTerraform(struct?: DeviceGroupExtraServicesCOGNITOTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operation: {
      value: cdktf.stringToHclTerraform(struct!.operation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesCOGNITOTagsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesCOGNITOTags | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._operation !== undefined) {
      hasAnyValues = true;
      internalValueResult.operation = this._operation;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesCOGNITOTags | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._operation = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._operation = value.operation;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // operation - computed: false, optional: true, required: false
  private _operation?: string; 
  public get operation() {
    return this.getStringAttribute('operation');
  }
  public set operation(value: string) {
    this._operation = value;
  }
  public resetOperation() {
    this._operation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operationInput() {
    return this._operation;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DeviceGroupExtraServicesCOGNITOTagsList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesCOGNITOTags[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesCOGNITOTagsOutputReference {
    return new DeviceGroupExtraServicesCOGNITOTagsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesCOGNITONormalCollectorConfigCollectors {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#applies_to DeviceGroup#applies_to}
  */
  readonly appliesTo?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#auto_balanced_collector_group_id DeviceGroup#auto_balanced_collector_group_id}
  */
  readonly autoBalancedCollectorGroupId?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#collector_id DeviceGroup#collector_id}
  */
  readonly collectorId?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#priority DeviceGroup#priority}
  */
  readonly priority?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#use_public_ip DeviceGroup#use_public_ip}
  */
  readonly usePublicIp?: boolean | cdktf.IResolvable;
}

export function deviceGroupExtraServicesCOGNITONormalCollectorConfigCollectorsToTerraform(struct?: DeviceGroupExtraServicesCOGNITONormalCollectorConfigCollectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    applies_to: cdktf.stringToTerraform(struct!.appliesTo),
    auto_balanced_collector_group_id: cdktf.numberToTerraform(struct!.autoBalancedCollectorGroupId),
    collector_id: cdktf.numberToTerraform(struct!.collectorId),
    priority: cdktf.numberToTerraform(struct!.priority),
    use_public_ip: cdktf.booleanToTerraform(struct!.usePublicIp),
  }
}


export function deviceGroupExtraServicesCOGNITONormalCollectorConfigCollectorsToHclTerraform(struct?: DeviceGroupExtraServicesCOGNITONormalCollectorConfigCollectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    applies_to: {
      value: cdktf.stringToHclTerraform(struct!.appliesTo),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auto_balanced_collector_group_id: {
      value: cdktf.numberToHclTerraform(struct!.autoBalancedCollectorGroupId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    collector_id: {
      value: cdktf.numberToHclTerraform(struct!.collectorId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    priority: {
      value: cdktf.numberToHclTerraform(struct!.priority),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    use_public_ip: {
      value: cdktf.booleanToHclTerraform(struct!.usePublicIp),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesCOGNITONormalCollectorConfigCollectorsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesCOGNITONormalCollectorConfigCollectors | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._appliesTo !== undefined) {
      hasAnyValues = true;
      internalValueResult.appliesTo = this._appliesTo;
    }
    if (this._autoBalancedCollectorGroupId !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoBalancedCollectorGroupId = this._autoBalancedCollectorGroupId;
    }
    if (this._collectorId !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectorId = this._collectorId;
    }
    if (this._priority !== undefined) {
      hasAnyValues = true;
      internalValueResult.priority = this._priority;
    }
    if (this._usePublicIp !== undefined) {
      hasAnyValues = true;
      internalValueResult.usePublicIp = this._usePublicIp;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesCOGNITONormalCollectorConfigCollectors | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._appliesTo = undefined;
      this._autoBalancedCollectorGroupId = undefined;
      this._collectorId = undefined;
      this._priority = undefined;
      this._usePublicIp = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._appliesTo = value.appliesTo;
      this._autoBalancedCollectorGroupId = value.autoBalancedCollectorGroupId;
      this._collectorId = value.collectorId;
      this._priority = value.priority;
      this._usePublicIp = value.usePublicIp;
    }
  }

  // applies_to - computed: false, optional: true, required: false
  private _appliesTo?: string; 
  public get appliesTo() {
    return this.getStringAttribute('applies_to');
  }
  public set appliesTo(value: string) {
    this._appliesTo = value;
  }
  public resetAppliesTo() {
    this._appliesTo = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appliesToInput() {
    return this._appliesTo;
  }

  // auto_balanced_collector_group_id - computed: false, optional: true, required: false
  private _autoBalancedCollectorGroupId?: number; 
  public get autoBalancedCollectorGroupId() {
    return this.getNumberAttribute('auto_balanced_collector_group_id');
  }
  public set autoBalancedCollectorGroupId(value: number) {
    this._autoBalancedCollectorGroupId = value;
  }
  public resetAutoBalancedCollectorGroupId() {
    this._autoBalancedCollectorGroupId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoBalancedCollectorGroupIdInput() {
    return this._autoBalancedCollectorGroupId;
  }

  // collector_id - computed: false, optional: true, required: false
  private _collectorId?: number; 
  public get collectorId() {
    return this.getNumberAttribute('collector_id');
  }
  public set collectorId(value: number) {
    this._collectorId = value;
  }
  public resetCollectorId() {
    this._collectorId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorIdInput() {
    return this._collectorId;
  }

  // priority - computed: false, optional: true, required: false
  private _priority?: number; 
  public get priority() {
    return this.getNumberAttribute('priority');
  }
  public set priority(value: number) {
    this._priority = value;
  }
  public resetPriority() {
    this._priority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get priorityInput() {
    return this._priority;
  }

  // use_public_ip - computed: false, optional: true, required: false
  private _usePublicIp?: boolean | cdktf.IResolvable; 
  public get usePublicIp() {
    return this.getBooleanAttribute('use_public_ip');
  }
  public set usePublicIp(value: boolean | cdktf.IResolvable) {
    this._usePublicIp = value;
  }
  public resetUsePublicIp() {
    this._usePublicIp = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usePublicIpInput() {
    return this._usePublicIp;
  }
}

export class DeviceGroupExtraServicesCOGNITONormalCollectorConfigCollectorsList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesCOGNITONormalCollectorConfigCollectors[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesCOGNITONormalCollectorConfigCollectorsOutputReference {
    return new DeviceGroupExtraServicesCOGNITONormalCollectorConfigCollectorsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesCOGNITONormalCollectorConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#collectors DeviceGroup#collectors}
  */
  readonly collectors?: DeviceGroupExtraServicesCOGNITONormalCollectorConfigCollectors[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#enabled DeviceGroup#enabled}
  */
  readonly enabled: boolean | cdktf.IResolvable;
}

export function deviceGroupExtraServicesCOGNITONormalCollectorConfigToTerraform(struct?: DeviceGroupExtraServicesCOGNITONormalCollectorConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    collectors: cdktf.listMapper(deviceGroupExtraServicesCOGNITONormalCollectorConfigCollectorsToTerraform, false)(struct!.collectors),
    enabled: cdktf.booleanToTerraform(struct!.enabled),
  }
}


export function deviceGroupExtraServicesCOGNITONormalCollectorConfigToHclTerraform(struct?: DeviceGroupExtraServicesCOGNITONormalCollectorConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    collectors: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesCOGNITONormalCollectorConfigCollectorsToHclTerraform, false)(struct!.collectors),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesCOGNITONormalCollectorConfigCollectorsList",
    },
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesCOGNITONormalCollectorConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesCOGNITONormalCollectorConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._collectors?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectors = this._collectors?.internalValue;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesCOGNITONormalCollectorConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._collectors.internalValue = undefined;
      this._enabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._collectors.internalValue = value.collectors;
      this._enabled = value.enabled;
    }
  }

  // collectors - computed: false, optional: true, required: false
  private _collectors = new DeviceGroupExtraServicesCOGNITONormalCollectorConfigCollectorsList(this, "collectors", false);
  public get collectors() {
    return this._collectors;
  }
  public putCollectors(value: DeviceGroupExtraServicesCOGNITONormalCollectorConfigCollectors[] | cdktf.IResolvable) {
    this._collectors.internalValue = value;
  }
  public resetCollectors() {
    this._collectors.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorsInput() {
    return this._collectors.internalValue;
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }
}

export class DeviceGroupExtraServicesCOGNITONormalCollectorConfigList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesCOGNITONormalCollectorConfig[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesCOGNITONormalCollectorConfigOutputReference {
    return new DeviceGroupExtraServicesCOGNITONormalCollectorConfigOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesCOGNITO {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#custom_n_s_p_schedule DeviceGroup#custom_n_s_p_schedule}
  */
  readonly customNSPSchedule?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#dead_operation DeviceGroup#dead_operation}
  */
  readonly deadOperation?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#device_display_name_template DeviceGroup#device_display_name_template}
  */
  readonly deviceDisplayNameTemplate?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#disable_stop_terminate_host_monitor DeviceGroup#disable_stop_terminate_host_monitor}
  */
  readonly disableStopTerminateHostMonitor?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#disable_terminated_host_alerting DeviceGroup#disable_terminated_host_alerting}
  */
  readonly disableTerminatedHostAlerting?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#monitoring_region_infos DeviceGroup#monitoring_region_infos}
  */
  readonly monitoringRegionInfos?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#monitoring_regions DeviceGroup#monitoring_regions}
  */
  readonly monitoringRegions?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#name_filter DeviceGroup#name_filter}
  */
  readonly nameFilter?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#select_all DeviceGroup#select_all}
  */
  readonly selectAll?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#tags DeviceGroup#tags}
  */
  readonly tags?: DeviceGroupExtraServicesCOGNITOTags[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#use_default DeviceGroup#use_default}
  */
  readonly useDefault: boolean | cdktf.IResolvable;
  /**
  * normal_collector_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#normal_collector_config DeviceGroup#normal_collector_config}
  */
  readonly normalCollectorConfig?: DeviceGroupExtraServicesCOGNITONormalCollectorConfig[] | cdktf.IResolvable;
}

export function deviceGroupExtraServicesCOGNITOToTerraform(struct?: DeviceGroupExtraServicesCOGNITO | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    custom_n_s_p_schedule: cdktf.stringToTerraform(struct!.customNSPSchedule),
    dead_operation: cdktf.stringToTerraform(struct!.deadOperation),
    device_display_name_template: cdktf.stringToTerraform(struct!.deviceDisplayNameTemplate),
    disable_stop_terminate_host_monitor: cdktf.booleanToTerraform(struct!.disableStopTerminateHostMonitor),
    disable_terminated_host_alerting: cdktf.booleanToTerraform(struct!.disableTerminatedHostAlerting),
    monitoring_region_infos: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.monitoringRegionInfos),
    monitoring_regions: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.monitoringRegions),
    name_filter: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.nameFilter),
    select_all: cdktf.booleanToTerraform(struct!.selectAll),
    tags: cdktf.listMapper(deviceGroupExtraServicesCOGNITOTagsToTerraform, false)(struct!.tags),
    use_default: cdktf.booleanToTerraform(struct!.useDefault),
    normal_collector_config: cdktf.listMapper(deviceGroupExtraServicesCOGNITONormalCollectorConfigToTerraform, true)(struct!.normalCollectorConfig),
  }
}


export function deviceGroupExtraServicesCOGNITOToHclTerraform(struct?: DeviceGroupExtraServicesCOGNITO | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    custom_n_s_p_schedule: {
      value: cdktf.stringToHclTerraform(struct!.customNSPSchedule),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dead_operation: {
      value: cdktf.stringToHclTerraform(struct!.deadOperation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    device_display_name_template: {
      value: cdktf.stringToHclTerraform(struct!.deviceDisplayNameTemplate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disable_stop_terminate_host_monitor: {
      value: cdktf.booleanToHclTerraform(struct!.disableStopTerminateHostMonitor),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    disable_terminated_host_alerting: {
      value: cdktf.booleanToHclTerraform(struct!.disableTerminatedHostAlerting),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    monitoring_region_infos: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.monitoringRegionInfos),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    monitoring_regions: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.monitoringRegions),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    name_filter: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.nameFilter),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    select_all: {
      value: cdktf.booleanToHclTerraform(struct!.selectAll),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tags: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesCOGNITOTagsToHclTerraform, false)(struct!.tags),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesCOGNITOTagsList",
    },
    use_default: {
      value: cdktf.booleanToHclTerraform(struct!.useDefault),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    normal_collector_config: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesCOGNITONormalCollectorConfigToHclTerraform, true)(struct!.normalCollectorConfig),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesCOGNITONormalCollectorConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesCOGNITOOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesCOGNITO | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._customNSPSchedule !== undefined) {
      hasAnyValues = true;
      internalValueResult.customNSPSchedule = this._customNSPSchedule;
    }
    if (this._deadOperation !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadOperation = this._deadOperation;
    }
    if (this._deviceDisplayNameTemplate !== undefined) {
      hasAnyValues = true;
      internalValueResult.deviceDisplayNameTemplate = this._deviceDisplayNameTemplate;
    }
    if (this._disableStopTerminateHostMonitor !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableStopTerminateHostMonitor = this._disableStopTerminateHostMonitor;
    }
    if (this._disableTerminatedHostAlerting !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableTerminatedHostAlerting = this._disableTerminatedHostAlerting;
    }
    if (this._monitoringRegionInfos !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoringRegionInfos = this._monitoringRegionInfos;
    }
    if (this._monitoringRegions !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoringRegions = this._monitoringRegions;
    }
    if (this._nameFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.nameFilter = this._nameFilter;
    }
    if (this._selectAll !== undefined) {
      hasAnyValues = true;
      internalValueResult.selectAll = this._selectAll;
    }
    if (this._tags?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags?.internalValue;
    }
    if (this._useDefault !== undefined) {
      hasAnyValues = true;
      internalValueResult.useDefault = this._useDefault;
    }
    if (this._normalCollectorConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.normalCollectorConfig = this._normalCollectorConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesCOGNITO | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._customNSPSchedule = undefined;
      this._deadOperation = undefined;
      this._deviceDisplayNameTemplate = undefined;
      this._disableStopTerminateHostMonitor = undefined;
      this._disableTerminatedHostAlerting = undefined;
      this._monitoringRegionInfos = undefined;
      this._monitoringRegions = undefined;
      this._nameFilter = undefined;
      this._selectAll = undefined;
      this._tags.internalValue = undefined;
      this._useDefault = undefined;
      this._normalCollectorConfig.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._customNSPSchedule = value.customNSPSchedule;
      this._deadOperation = value.deadOperation;
      this._deviceDisplayNameTemplate = value.deviceDisplayNameTemplate;
      this._disableStopTerminateHostMonitor = value.disableStopTerminateHostMonitor;
      this._disableTerminatedHostAlerting = value.disableTerminatedHostAlerting;
      this._monitoringRegionInfos = value.monitoringRegionInfos;
      this._monitoringRegions = value.monitoringRegions;
      this._nameFilter = value.nameFilter;
      this._selectAll = value.selectAll;
      this._tags.internalValue = value.tags;
      this._useDefault = value.useDefault;
      this._normalCollectorConfig.internalValue = value.normalCollectorConfig;
    }
  }

  // custom_n_s_p_schedule - computed: false, optional: true, required: false
  private _customNSPSchedule?: string; 
  public get customNSPSchedule() {
    return this.getStringAttribute('custom_n_s_p_schedule');
  }
  public set customNSPSchedule(value: string) {
    this._customNSPSchedule = value;
  }
  public resetCustomNSPSchedule() {
    this._customNSPSchedule = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customNSPScheduleInput() {
    return this._customNSPSchedule;
  }

  // dead_operation - computed: false, optional: true, required: false
  private _deadOperation?: string; 
  public get deadOperation() {
    return this.getStringAttribute('dead_operation');
  }
  public set deadOperation(value: string) {
    this._deadOperation = value;
  }
  public resetDeadOperation() {
    this._deadOperation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadOperationInput() {
    return this._deadOperation;
  }

  // device_display_name_template - computed: false, optional: true, required: false
  private _deviceDisplayNameTemplate?: string; 
  public get deviceDisplayNameTemplate() {
    return this.getStringAttribute('device_display_name_template');
  }
  public set deviceDisplayNameTemplate(value: string) {
    this._deviceDisplayNameTemplate = value;
  }
  public resetDeviceDisplayNameTemplate() {
    this._deviceDisplayNameTemplate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deviceDisplayNameTemplateInput() {
    return this._deviceDisplayNameTemplate;
  }

  // disable_stop_terminate_host_monitor - computed: false, optional: true, required: false
  private _disableStopTerminateHostMonitor?: boolean | cdktf.IResolvable; 
  public get disableStopTerminateHostMonitor() {
    return this.getBooleanAttribute('disable_stop_terminate_host_monitor');
  }
  public set disableStopTerminateHostMonitor(value: boolean | cdktf.IResolvable) {
    this._disableStopTerminateHostMonitor = value;
  }
  public resetDisableStopTerminateHostMonitor() {
    this._disableStopTerminateHostMonitor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableStopTerminateHostMonitorInput() {
    return this._disableStopTerminateHostMonitor;
  }

  // disable_terminated_host_alerting - computed: false, optional: true, required: false
  private _disableTerminatedHostAlerting?: boolean | cdktf.IResolvable; 
  public get disableTerminatedHostAlerting() {
    return this.getBooleanAttribute('disable_terminated_host_alerting');
  }
  public set disableTerminatedHostAlerting(value: boolean | cdktf.IResolvable) {
    this._disableTerminatedHostAlerting = value;
  }
  public resetDisableTerminatedHostAlerting() {
    this._disableTerminatedHostAlerting = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableTerminatedHostAlertingInput() {
    return this._disableTerminatedHostAlerting;
  }

  // monitoring_region_infos - computed: false, optional: true, required: false
  private _monitoringRegionInfos?: string[]; 
  public get monitoringRegionInfos() {
    return cdktf.Fn.tolist(this.getListAttribute('monitoring_region_infos'));
  }
  public set monitoringRegionInfos(value: string[]) {
    this._monitoringRegionInfos = value;
  }
  public resetMonitoringRegionInfos() {
    this._monitoringRegionInfos = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoringRegionInfosInput() {
    return this._monitoringRegionInfos;
  }

  // monitoring_regions - computed: false, optional: true, required: false
  private _monitoringRegions?: string[]; 
  public get monitoringRegions() {
    return cdktf.Fn.tolist(this.getListAttribute('monitoring_regions'));
  }
  public set monitoringRegions(value: string[]) {
    this._monitoringRegions = value;
  }
  public resetMonitoringRegions() {
    this._monitoringRegions = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoringRegionsInput() {
    return this._monitoringRegions;
  }

  // name_filter - computed: false, optional: true, required: false
  private _nameFilter?: string[]; 
  public get nameFilter() {
    return cdktf.Fn.tolist(this.getListAttribute('name_filter'));
  }
  public set nameFilter(value: string[]) {
    this._nameFilter = value;
  }
  public resetNameFilter() {
    this._nameFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameFilterInput() {
    return this._nameFilter;
  }

  // select_all - computed: false, optional: true, required: false
  private _selectAll?: boolean | cdktf.IResolvable; 
  public get selectAll() {
    return this.getBooleanAttribute('select_all');
  }
  public set selectAll(value: boolean | cdktf.IResolvable) {
    this._selectAll = value;
  }
  public resetSelectAll() {
    this._selectAll = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectAllInput() {
    return this._selectAll;
  }

  // tags - computed: false, optional: true, required: false
  private _tags = new DeviceGroupExtraServicesCOGNITOTagsList(this, "tags", false);
  public get tags() {
    return this._tags;
  }
  public putTags(value: DeviceGroupExtraServicesCOGNITOTags[] | cdktf.IResolvable) {
    this._tags.internalValue = value;
  }
  public resetTags() {
    this._tags.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags.internalValue;
  }

  // use_default - computed: false, optional: false, required: true
  private _useDefault?: boolean | cdktf.IResolvable; 
  public get useDefault() {
    return this.getBooleanAttribute('use_default');
  }
  public set useDefault(value: boolean | cdktf.IResolvable) {
    this._useDefault = value;
  }
  // Temporarily expose input value. Use with caution.
  public get useDefaultInput() {
    return this._useDefault;
  }

  // normal_collector_config - computed: false, optional: true, required: false
  private _normalCollectorConfig = new DeviceGroupExtraServicesCOGNITONormalCollectorConfigList(this, "normal_collector_config", false);
  public get normalCollectorConfig() {
    return this._normalCollectorConfig;
  }
  public putNormalCollectorConfig(value: DeviceGroupExtraServicesCOGNITONormalCollectorConfig[] | cdktf.IResolvable) {
    this._normalCollectorConfig.internalValue = value;
  }
  public resetNormalCollectorConfig() {
    this._normalCollectorConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get normalCollectorConfigInput() {
    return this._normalCollectorConfig.internalValue;
  }
}

export class DeviceGroupExtraServicesCOGNITOList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesCOGNITO[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesCOGNITOOutputReference {
    return new DeviceGroupExtraServicesCOGNITOOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesCOSMOSDBTags {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#name DeviceGroup#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#operation DeviceGroup#operation}
  */
  readonly operation?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#value DeviceGroup#value}
  */
  readonly value?: string;
}

export function deviceGroupExtraServicesCOSMOSDBTagsToTerraform(struct?: DeviceGroupExtraServicesCOSMOSDBTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    operation: cdktf.stringToTerraform(struct!.operation),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function deviceGroupExtraServicesCOSMOSDBTagsToHclTerraform(struct?: DeviceGroupExtraServicesCOSMOSDBTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operation: {
      value: cdktf.stringToHclTerraform(struct!.operation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesCOSMOSDBTagsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesCOSMOSDBTags | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._operation !== undefined) {
      hasAnyValues = true;
      internalValueResult.operation = this._operation;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesCOSMOSDBTags | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._operation = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._operation = value.operation;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // operation - computed: false, optional: true, required: false
  private _operation?: string; 
  public get operation() {
    return this.getStringAttribute('operation');
  }
  public set operation(value: string) {
    this._operation = value;
  }
  public resetOperation() {
    this._operation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operationInput() {
    return this._operation;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DeviceGroupExtraServicesCOSMOSDBTagsList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesCOSMOSDBTags[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesCOSMOSDBTagsOutputReference {
    return new DeviceGroupExtraServicesCOSMOSDBTagsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesCOSMOSDBNormalCollectorConfigCollectors {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#applies_to DeviceGroup#applies_to}
  */
  readonly appliesTo?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#auto_balanced_collector_group_id DeviceGroup#auto_balanced_collector_group_id}
  */
  readonly autoBalancedCollectorGroupId?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#collector_id DeviceGroup#collector_id}
  */
  readonly collectorId?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#priority DeviceGroup#priority}
  */
  readonly priority?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#use_public_ip DeviceGroup#use_public_ip}
  */
  readonly usePublicIp?: boolean | cdktf.IResolvable;
}

export function deviceGroupExtraServicesCOSMOSDBNormalCollectorConfigCollectorsToTerraform(struct?: DeviceGroupExtraServicesCOSMOSDBNormalCollectorConfigCollectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    applies_to: cdktf.stringToTerraform(struct!.appliesTo),
    auto_balanced_collector_group_id: cdktf.numberToTerraform(struct!.autoBalancedCollectorGroupId),
    collector_id: cdktf.numberToTerraform(struct!.collectorId),
    priority: cdktf.numberToTerraform(struct!.priority),
    use_public_ip: cdktf.booleanToTerraform(struct!.usePublicIp),
  }
}


export function deviceGroupExtraServicesCOSMOSDBNormalCollectorConfigCollectorsToHclTerraform(struct?: DeviceGroupExtraServicesCOSMOSDBNormalCollectorConfigCollectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    applies_to: {
      value: cdktf.stringToHclTerraform(struct!.appliesTo),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auto_balanced_collector_group_id: {
      value: cdktf.numberToHclTerraform(struct!.autoBalancedCollectorGroupId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    collector_id: {
      value: cdktf.numberToHclTerraform(struct!.collectorId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    priority: {
      value: cdktf.numberToHclTerraform(struct!.priority),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    use_public_ip: {
      value: cdktf.booleanToHclTerraform(struct!.usePublicIp),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesCOSMOSDBNormalCollectorConfigCollectorsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesCOSMOSDBNormalCollectorConfigCollectors | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._appliesTo !== undefined) {
      hasAnyValues = true;
      internalValueResult.appliesTo = this._appliesTo;
    }
    if (this._autoBalancedCollectorGroupId !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoBalancedCollectorGroupId = this._autoBalancedCollectorGroupId;
    }
    if (this._collectorId !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectorId = this._collectorId;
    }
    if (this._priority !== undefined) {
      hasAnyValues = true;
      internalValueResult.priority = this._priority;
    }
    if (this._usePublicIp !== undefined) {
      hasAnyValues = true;
      internalValueResult.usePublicIp = this._usePublicIp;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesCOSMOSDBNormalCollectorConfigCollectors | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._appliesTo = undefined;
      this._autoBalancedCollectorGroupId = undefined;
      this._collectorId = undefined;
      this._priority = undefined;
      this._usePublicIp = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._appliesTo = value.appliesTo;
      this._autoBalancedCollectorGroupId = value.autoBalancedCollectorGroupId;
      this._collectorId = value.collectorId;
      this._priority = value.priority;
      this._usePublicIp = value.usePublicIp;
    }
  }

  // applies_to - computed: false, optional: true, required: false
  private _appliesTo?: string; 
  public get appliesTo() {
    return this.getStringAttribute('applies_to');
  }
  public set appliesTo(value: string) {
    this._appliesTo = value;
  }
  public resetAppliesTo() {
    this._appliesTo = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appliesToInput() {
    return this._appliesTo;
  }

  // auto_balanced_collector_group_id - computed: false, optional: true, required: false
  private _autoBalancedCollectorGroupId?: number; 
  public get autoBalancedCollectorGroupId() {
    return this.getNumberAttribute('auto_balanced_collector_group_id');
  }
  public set autoBalancedCollectorGroupId(value: number) {
    this._autoBalancedCollectorGroupId = value;
  }
  public resetAutoBalancedCollectorGroupId() {
    this._autoBalancedCollectorGroupId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoBalancedCollectorGroupIdInput() {
    return this._autoBalancedCollectorGroupId;
  }

  // collector_id - computed: false, optional: true, required: false
  private _collectorId?: number; 
  public get collectorId() {
    return this.getNumberAttribute('collector_id');
  }
  public set collectorId(value: number) {
    this._collectorId = value;
  }
  public resetCollectorId() {
    this._collectorId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorIdInput() {
    return this._collectorId;
  }

  // priority - computed: false, optional: true, required: false
  private _priority?: number; 
  public get priority() {
    return this.getNumberAttribute('priority');
  }
  public set priority(value: number) {
    this._priority = value;
  }
  public resetPriority() {
    this._priority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get priorityInput() {
    return this._priority;
  }

  // use_public_ip - computed: false, optional: true, required: false
  private _usePublicIp?: boolean | cdktf.IResolvable; 
  public get usePublicIp() {
    return this.getBooleanAttribute('use_public_ip');
  }
  public set usePublicIp(value: boolean | cdktf.IResolvable) {
    this._usePublicIp = value;
  }
  public resetUsePublicIp() {
    this._usePublicIp = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usePublicIpInput() {
    return this._usePublicIp;
  }
}

export class DeviceGroupExtraServicesCOSMOSDBNormalCollectorConfigCollectorsList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesCOSMOSDBNormalCollectorConfigCollectors[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesCOSMOSDBNormalCollectorConfigCollectorsOutputReference {
    return new DeviceGroupExtraServicesCOSMOSDBNormalCollectorConfigCollectorsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesCOSMOSDBNormalCollectorConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#collectors DeviceGroup#collectors}
  */
  readonly collectors?: DeviceGroupExtraServicesCOSMOSDBNormalCollectorConfigCollectors[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#enabled DeviceGroup#enabled}
  */
  readonly enabled: boolean | cdktf.IResolvable;
}

export function deviceGroupExtraServicesCOSMOSDBNormalCollectorConfigToTerraform(struct?: DeviceGroupExtraServicesCOSMOSDBNormalCollectorConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    collectors: cdktf.listMapper(deviceGroupExtraServicesCOSMOSDBNormalCollectorConfigCollectorsToTerraform, false)(struct!.collectors),
    enabled: cdktf.booleanToTerraform(struct!.enabled),
  }
}


export function deviceGroupExtraServicesCOSMOSDBNormalCollectorConfigToHclTerraform(struct?: DeviceGroupExtraServicesCOSMOSDBNormalCollectorConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    collectors: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesCOSMOSDBNormalCollectorConfigCollectorsToHclTerraform, false)(struct!.collectors),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesCOSMOSDBNormalCollectorConfigCollectorsList",
    },
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesCOSMOSDBNormalCollectorConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesCOSMOSDBNormalCollectorConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._collectors?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectors = this._collectors?.internalValue;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesCOSMOSDBNormalCollectorConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._collectors.internalValue = undefined;
      this._enabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._collectors.internalValue = value.collectors;
      this._enabled = value.enabled;
    }
  }

  // collectors - computed: false, optional: true, required: false
  private _collectors = new DeviceGroupExtraServicesCOSMOSDBNormalCollectorConfigCollectorsList(this, "collectors", false);
  public get collectors() {
    return this._collectors;
  }
  public putCollectors(value: DeviceGroupExtraServicesCOSMOSDBNormalCollectorConfigCollectors[] | cdktf.IResolvable) {
    this._collectors.internalValue = value;
  }
  public resetCollectors() {
    this._collectors.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorsInput() {
    return this._collectors.internalValue;
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }
}

export class DeviceGroupExtraServicesCOSMOSDBNormalCollectorConfigList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesCOSMOSDBNormalCollectorConfig[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesCOSMOSDBNormalCollectorConfigOutputReference {
    return new DeviceGroupExtraServicesCOSMOSDBNormalCollectorConfigOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesCOSMOSDB {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#custom_n_s_p_schedule DeviceGroup#custom_n_s_p_schedule}
  */
  readonly customNSPSchedule?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#dead_operation DeviceGroup#dead_operation}
  */
  readonly deadOperation?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#device_display_name_template DeviceGroup#device_display_name_template}
  */
  readonly deviceDisplayNameTemplate?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#disable_stop_terminate_host_monitor DeviceGroup#disable_stop_terminate_host_monitor}
  */
  readonly disableStopTerminateHostMonitor?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#disable_terminated_host_alerting DeviceGroup#disable_terminated_host_alerting}
  */
  readonly disableTerminatedHostAlerting?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#monitoring_region_infos DeviceGroup#monitoring_region_infos}
  */
  readonly monitoringRegionInfos?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#monitoring_regions DeviceGroup#monitoring_regions}
  */
  readonly monitoringRegions?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#name_filter DeviceGroup#name_filter}
  */
  readonly nameFilter?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#select_all DeviceGroup#select_all}
  */
  readonly selectAll?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#tags DeviceGroup#tags}
  */
  readonly tags?: DeviceGroupExtraServicesCOSMOSDBTags[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#use_default DeviceGroup#use_default}
  */
  readonly useDefault: boolean | cdktf.IResolvable;
  /**
  * normal_collector_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#normal_collector_config DeviceGroup#normal_collector_config}
  */
  readonly normalCollectorConfig?: DeviceGroupExtraServicesCOSMOSDBNormalCollectorConfig[] | cdktf.IResolvable;
}

export function deviceGroupExtraServicesCOSMOSDBToTerraform(struct?: DeviceGroupExtraServicesCOSMOSDB | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    custom_n_s_p_schedule: cdktf.stringToTerraform(struct!.customNSPSchedule),
    dead_operation: cdktf.stringToTerraform(struct!.deadOperation),
    device_display_name_template: cdktf.stringToTerraform(struct!.deviceDisplayNameTemplate),
    disable_stop_terminate_host_monitor: cdktf.booleanToTerraform(struct!.disableStopTerminateHostMonitor),
    disable_terminated_host_alerting: cdktf.booleanToTerraform(struct!.disableTerminatedHostAlerting),
    monitoring_region_infos: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.monitoringRegionInfos),
    monitoring_regions: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.monitoringRegions),
    name_filter: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.nameFilter),
    select_all: cdktf.booleanToTerraform(struct!.selectAll),
    tags: cdktf.listMapper(deviceGroupExtraServicesCOSMOSDBTagsToTerraform, false)(struct!.tags),
    use_default: cdktf.booleanToTerraform(struct!.useDefault),
    normal_collector_config: cdktf.listMapper(deviceGroupExtraServicesCOSMOSDBNormalCollectorConfigToTerraform, true)(struct!.normalCollectorConfig),
  }
}


export function deviceGroupExtraServicesCOSMOSDBToHclTerraform(struct?: DeviceGroupExtraServicesCOSMOSDB | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    custom_n_s_p_schedule: {
      value: cdktf.stringToHclTerraform(struct!.customNSPSchedule),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dead_operation: {
      value: cdktf.stringToHclTerraform(struct!.deadOperation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    device_display_name_template: {
      value: cdktf.stringToHclTerraform(struct!.deviceDisplayNameTemplate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disable_stop_terminate_host_monitor: {
      value: cdktf.booleanToHclTerraform(struct!.disableStopTerminateHostMonitor),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    disable_terminated_host_alerting: {
      value: cdktf.booleanToHclTerraform(struct!.disableTerminatedHostAlerting),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    monitoring_region_infos: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.monitoringRegionInfos),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    monitoring_regions: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.monitoringRegions),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    name_filter: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.nameFilter),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    select_all: {
      value: cdktf.booleanToHclTerraform(struct!.selectAll),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tags: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesCOSMOSDBTagsToHclTerraform, false)(struct!.tags),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesCOSMOSDBTagsList",
    },
    use_default: {
      value: cdktf.booleanToHclTerraform(struct!.useDefault),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    normal_collector_config: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesCOSMOSDBNormalCollectorConfigToHclTerraform, true)(struct!.normalCollectorConfig),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesCOSMOSDBNormalCollectorConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesCOSMOSDBOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesCOSMOSDB | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._customNSPSchedule !== undefined) {
      hasAnyValues = true;
      internalValueResult.customNSPSchedule = this._customNSPSchedule;
    }
    if (this._deadOperation !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadOperation = this._deadOperation;
    }
    if (this._deviceDisplayNameTemplate !== undefined) {
      hasAnyValues = true;
      internalValueResult.deviceDisplayNameTemplate = this._deviceDisplayNameTemplate;
    }
    if (this._disableStopTerminateHostMonitor !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableStopTerminateHostMonitor = this._disableStopTerminateHostMonitor;
    }
    if (this._disableTerminatedHostAlerting !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableTerminatedHostAlerting = this._disableTerminatedHostAlerting;
    }
    if (this._monitoringRegionInfos !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoringRegionInfos = this._monitoringRegionInfos;
    }
    if (this._monitoringRegions !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoringRegions = this._monitoringRegions;
    }
    if (this._nameFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.nameFilter = this._nameFilter;
    }
    if (this._selectAll !== undefined) {
      hasAnyValues = true;
      internalValueResult.selectAll = this._selectAll;
    }
    if (this._tags?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags?.internalValue;
    }
    if (this._useDefault !== undefined) {
      hasAnyValues = true;
      internalValueResult.useDefault = this._useDefault;
    }
    if (this._normalCollectorConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.normalCollectorConfig = this._normalCollectorConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesCOSMOSDB | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._customNSPSchedule = undefined;
      this._deadOperation = undefined;
      this._deviceDisplayNameTemplate = undefined;
      this._disableStopTerminateHostMonitor = undefined;
      this._disableTerminatedHostAlerting = undefined;
      this._monitoringRegionInfos = undefined;
      this._monitoringRegions = undefined;
      this._nameFilter = undefined;
      this._selectAll = undefined;
      this._tags.internalValue = undefined;
      this._useDefault = undefined;
      this._normalCollectorConfig.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._customNSPSchedule = value.customNSPSchedule;
      this._deadOperation = value.deadOperation;
      this._deviceDisplayNameTemplate = value.deviceDisplayNameTemplate;
      this._disableStopTerminateHostMonitor = value.disableStopTerminateHostMonitor;
      this._disableTerminatedHostAlerting = value.disableTerminatedHostAlerting;
      this._monitoringRegionInfos = value.monitoringRegionInfos;
      this._monitoringRegions = value.monitoringRegions;
      this._nameFilter = value.nameFilter;
      this._selectAll = value.selectAll;
      this._tags.internalValue = value.tags;
      this._useDefault = value.useDefault;
      this._normalCollectorConfig.internalValue = value.normalCollectorConfig;
    }
  }

  // custom_n_s_p_schedule - computed: false, optional: true, required: false
  private _customNSPSchedule?: string; 
  public get customNSPSchedule() {
    return this.getStringAttribute('custom_n_s_p_schedule');
  }
  public set customNSPSchedule(value: string) {
    this._customNSPSchedule = value;
  }
  public resetCustomNSPSchedule() {
    this._customNSPSchedule = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customNSPScheduleInput() {
    return this._customNSPSchedule;
  }

  // dead_operation - computed: false, optional: true, required: false
  private _deadOperation?: string; 
  public get deadOperation() {
    return this.getStringAttribute('dead_operation');
  }
  public set deadOperation(value: string) {
    this._deadOperation = value;
  }
  public resetDeadOperation() {
    this._deadOperation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadOperationInput() {
    return this._deadOperation;
  }

  // device_display_name_template - computed: false, optional: true, required: false
  private _deviceDisplayNameTemplate?: string; 
  public get deviceDisplayNameTemplate() {
    return this.getStringAttribute('device_display_name_template');
  }
  public set deviceDisplayNameTemplate(value: string) {
    this._deviceDisplayNameTemplate = value;
  }
  public resetDeviceDisplayNameTemplate() {
    this._deviceDisplayNameTemplate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deviceDisplayNameTemplateInput() {
    return this._deviceDisplayNameTemplate;
  }

  // disable_stop_terminate_host_monitor - computed: false, optional: true, required: false
  private _disableStopTerminateHostMonitor?: boolean | cdktf.IResolvable; 
  public get disableStopTerminateHostMonitor() {
    return this.getBooleanAttribute('disable_stop_terminate_host_monitor');
  }
  public set disableStopTerminateHostMonitor(value: boolean | cdktf.IResolvable) {
    this._disableStopTerminateHostMonitor = value;
  }
  public resetDisableStopTerminateHostMonitor() {
    this._disableStopTerminateHostMonitor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableStopTerminateHostMonitorInput() {
    return this._disableStopTerminateHostMonitor;
  }

  // disable_terminated_host_alerting - computed: false, optional: true, required: false
  private _disableTerminatedHostAlerting?: boolean | cdktf.IResolvable; 
  public get disableTerminatedHostAlerting() {
    return this.getBooleanAttribute('disable_terminated_host_alerting');
  }
  public set disableTerminatedHostAlerting(value: boolean | cdktf.IResolvable) {
    this._disableTerminatedHostAlerting = value;
  }
  public resetDisableTerminatedHostAlerting() {
    this._disableTerminatedHostAlerting = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableTerminatedHostAlertingInput() {
    return this._disableTerminatedHostAlerting;
  }

  // monitoring_region_infos - computed: false, optional: true, required: false
  private _monitoringRegionInfos?: string[]; 
  public get monitoringRegionInfos() {
    return cdktf.Fn.tolist(this.getListAttribute('monitoring_region_infos'));
  }
  public set monitoringRegionInfos(value: string[]) {
    this._monitoringRegionInfos = value;
  }
  public resetMonitoringRegionInfos() {
    this._monitoringRegionInfos = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoringRegionInfosInput() {
    return this._monitoringRegionInfos;
  }

  // monitoring_regions - computed: false, optional: true, required: false
  private _monitoringRegions?: string[]; 
  public get monitoringRegions() {
    return cdktf.Fn.tolist(this.getListAttribute('monitoring_regions'));
  }
  public set monitoringRegions(value: string[]) {
    this._monitoringRegions = value;
  }
  public resetMonitoringRegions() {
    this._monitoringRegions = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoringRegionsInput() {
    return this._monitoringRegions;
  }

  // name_filter - computed: false, optional: true, required: false
  private _nameFilter?: string[]; 
  public get nameFilter() {
    return cdktf.Fn.tolist(this.getListAttribute('name_filter'));
  }
  public set nameFilter(value: string[]) {
    this._nameFilter = value;
  }
  public resetNameFilter() {
    this._nameFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameFilterInput() {
    return this._nameFilter;
  }

  // select_all - computed: false, optional: true, required: false
  private _selectAll?: boolean | cdktf.IResolvable; 
  public get selectAll() {
    return this.getBooleanAttribute('select_all');
  }
  public set selectAll(value: boolean | cdktf.IResolvable) {
    this._selectAll = value;
  }
  public resetSelectAll() {
    this._selectAll = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectAllInput() {
    return this._selectAll;
  }

  // tags - computed: false, optional: true, required: false
  private _tags = new DeviceGroupExtraServicesCOSMOSDBTagsList(this, "tags", false);
  public get tags() {
    return this._tags;
  }
  public putTags(value: DeviceGroupExtraServicesCOSMOSDBTags[] | cdktf.IResolvable) {
    this._tags.internalValue = value;
  }
  public resetTags() {
    this._tags.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags.internalValue;
  }

  // use_default - computed: false, optional: false, required: true
  private _useDefault?: boolean | cdktf.IResolvable; 
  public get useDefault() {
    return this.getBooleanAttribute('use_default');
  }
  public set useDefault(value: boolean | cdktf.IResolvable) {
    this._useDefault = value;
  }
  // Temporarily expose input value. Use with caution.
  public get useDefaultInput() {
    return this._useDefault;
  }

  // normal_collector_config - computed: false, optional: true, required: false
  private _normalCollectorConfig = new DeviceGroupExtraServicesCOSMOSDBNormalCollectorConfigList(this, "normal_collector_config", false);
  public get normalCollectorConfig() {
    return this._normalCollectorConfig;
  }
  public putNormalCollectorConfig(value: DeviceGroupExtraServicesCOSMOSDBNormalCollectorConfig[] | cdktf.IResolvable) {
    this._normalCollectorConfig.internalValue = value;
  }
  public resetNormalCollectorConfig() {
    this._normalCollectorConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get normalCollectorConfigInput() {
    return this._normalCollectorConfig.internalValue;
  }
}

export class DeviceGroupExtraServicesCOSMOSDBList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesCOSMOSDB[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesCOSMOSDBOutputReference {
    return new DeviceGroupExtraServicesCOSMOSDBOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesDATAFACTORYTags {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#name DeviceGroup#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#operation DeviceGroup#operation}
  */
  readonly operation?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#value DeviceGroup#value}
  */
  readonly value?: string;
}

export function deviceGroupExtraServicesDATAFACTORYTagsToTerraform(struct?: DeviceGroupExtraServicesDATAFACTORYTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    operation: cdktf.stringToTerraform(struct!.operation),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function deviceGroupExtraServicesDATAFACTORYTagsToHclTerraform(struct?: DeviceGroupExtraServicesDATAFACTORYTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operation: {
      value: cdktf.stringToHclTerraform(struct!.operation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesDATAFACTORYTagsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesDATAFACTORYTags | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._operation !== undefined) {
      hasAnyValues = true;
      internalValueResult.operation = this._operation;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesDATAFACTORYTags | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._operation = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._operation = value.operation;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // operation - computed: false, optional: true, required: false
  private _operation?: string; 
  public get operation() {
    return this.getStringAttribute('operation');
  }
  public set operation(value: string) {
    this._operation = value;
  }
  public resetOperation() {
    this._operation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operationInput() {
    return this._operation;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DeviceGroupExtraServicesDATAFACTORYTagsList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesDATAFACTORYTags[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesDATAFACTORYTagsOutputReference {
    return new DeviceGroupExtraServicesDATAFACTORYTagsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesDATAFACTORYNormalCollectorConfigCollectors {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#applies_to DeviceGroup#applies_to}
  */
  readonly appliesTo?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#auto_balanced_collector_group_id DeviceGroup#auto_balanced_collector_group_id}
  */
  readonly autoBalancedCollectorGroupId?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#collector_id DeviceGroup#collector_id}
  */
  readonly collectorId?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#priority DeviceGroup#priority}
  */
  readonly priority?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#use_public_ip DeviceGroup#use_public_ip}
  */
  readonly usePublicIp?: boolean | cdktf.IResolvable;
}

export function deviceGroupExtraServicesDATAFACTORYNormalCollectorConfigCollectorsToTerraform(struct?: DeviceGroupExtraServicesDATAFACTORYNormalCollectorConfigCollectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    applies_to: cdktf.stringToTerraform(struct!.appliesTo),
    auto_balanced_collector_group_id: cdktf.numberToTerraform(struct!.autoBalancedCollectorGroupId),
    collector_id: cdktf.numberToTerraform(struct!.collectorId),
    priority: cdktf.numberToTerraform(struct!.priority),
    use_public_ip: cdktf.booleanToTerraform(struct!.usePublicIp),
  }
}


export function deviceGroupExtraServicesDATAFACTORYNormalCollectorConfigCollectorsToHclTerraform(struct?: DeviceGroupExtraServicesDATAFACTORYNormalCollectorConfigCollectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    applies_to: {
      value: cdktf.stringToHclTerraform(struct!.appliesTo),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auto_balanced_collector_group_id: {
      value: cdktf.numberToHclTerraform(struct!.autoBalancedCollectorGroupId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    collector_id: {
      value: cdktf.numberToHclTerraform(struct!.collectorId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    priority: {
      value: cdktf.numberToHclTerraform(struct!.priority),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    use_public_ip: {
      value: cdktf.booleanToHclTerraform(struct!.usePublicIp),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesDATAFACTORYNormalCollectorConfigCollectorsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesDATAFACTORYNormalCollectorConfigCollectors | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._appliesTo !== undefined) {
      hasAnyValues = true;
      internalValueResult.appliesTo = this._appliesTo;
    }
    if (this._autoBalancedCollectorGroupId !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoBalancedCollectorGroupId = this._autoBalancedCollectorGroupId;
    }
    if (this._collectorId !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectorId = this._collectorId;
    }
    if (this._priority !== undefined) {
      hasAnyValues = true;
      internalValueResult.priority = this._priority;
    }
    if (this._usePublicIp !== undefined) {
      hasAnyValues = true;
      internalValueResult.usePublicIp = this._usePublicIp;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesDATAFACTORYNormalCollectorConfigCollectors | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._appliesTo = undefined;
      this._autoBalancedCollectorGroupId = undefined;
      this._collectorId = undefined;
      this._priority = undefined;
      this._usePublicIp = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._appliesTo = value.appliesTo;
      this._autoBalancedCollectorGroupId = value.autoBalancedCollectorGroupId;
      this._collectorId = value.collectorId;
      this._priority = value.priority;
      this._usePublicIp = value.usePublicIp;
    }
  }

  // applies_to - computed: false, optional: true, required: false
  private _appliesTo?: string; 
  public get appliesTo() {
    return this.getStringAttribute('applies_to');
  }
  public set appliesTo(value: string) {
    this._appliesTo = value;
  }
  public resetAppliesTo() {
    this._appliesTo = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appliesToInput() {
    return this._appliesTo;
  }

  // auto_balanced_collector_group_id - computed: false, optional: true, required: false
  private _autoBalancedCollectorGroupId?: number; 
  public get autoBalancedCollectorGroupId() {
    return this.getNumberAttribute('auto_balanced_collector_group_id');
  }
  public set autoBalancedCollectorGroupId(value: number) {
    this._autoBalancedCollectorGroupId = value;
  }
  public resetAutoBalancedCollectorGroupId() {
    this._autoBalancedCollectorGroupId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoBalancedCollectorGroupIdInput() {
    return this._autoBalancedCollectorGroupId;
  }

  // collector_id - computed: false, optional: true, required: false
  private _collectorId?: number; 
  public get collectorId() {
    return this.getNumberAttribute('collector_id');
  }
  public set collectorId(value: number) {
    this._collectorId = value;
  }
  public resetCollectorId() {
    this._collectorId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorIdInput() {
    return this._collectorId;
  }

  // priority - computed: false, optional: true, required: false
  private _priority?: number; 
  public get priority() {
    return this.getNumberAttribute('priority');
  }
  public set priority(value: number) {
    this._priority = value;
  }
  public resetPriority() {
    this._priority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get priorityInput() {
    return this._priority;
  }

  // use_public_ip - computed: false, optional: true, required: false
  private _usePublicIp?: boolean | cdktf.IResolvable; 
  public get usePublicIp() {
    return this.getBooleanAttribute('use_public_ip');
  }
  public set usePublicIp(value: boolean | cdktf.IResolvable) {
    this._usePublicIp = value;
  }
  public resetUsePublicIp() {
    this._usePublicIp = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usePublicIpInput() {
    return this._usePublicIp;
  }
}

export class DeviceGroupExtraServicesDATAFACTORYNormalCollectorConfigCollectorsList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesDATAFACTORYNormalCollectorConfigCollectors[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesDATAFACTORYNormalCollectorConfigCollectorsOutputReference {
    return new DeviceGroupExtraServicesDATAFACTORYNormalCollectorConfigCollectorsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesDATAFACTORYNormalCollectorConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#collectors DeviceGroup#collectors}
  */
  readonly collectors?: DeviceGroupExtraServicesDATAFACTORYNormalCollectorConfigCollectors[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#enabled DeviceGroup#enabled}
  */
  readonly enabled: boolean | cdktf.IResolvable;
}

export function deviceGroupExtraServicesDATAFACTORYNormalCollectorConfigToTerraform(struct?: DeviceGroupExtraServicesDATAFACTORYNormalCollectorConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    collectors: cdktf.listMapper(deviceGroupExtraServicesDATAFACTORYNormalCollectorConfigCollectorsToTerraform, false)(struct!.collectors),
    enabled: cdktf.booleanToTerraform(struct!.enabled),
  }
}


export function deviceGroupExtraServicesDATAFACTORYNormalCollectorConfigToHclTerraform(struct?: DeviceGroupExtraServicesDATAFACTORYNormalCollectorConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    collectors: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesDATAFACTORYNormalCollectorConfigCollectorsToHclTerraform, false)(struct!.collectors),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesDATAFACTORYNormalCollectorConfigCollectorsList",
    },
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesDATAFACTORYNormalCollectorConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesDATAFACTORYNormalCollectorConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._collectors?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectors = this._collectors?.internalValue;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesDATAFACTORYNormalCollectorConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._collectors.internalValue = undefined;
      this._enabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._collectors.internalValue = value.collectors;
      this._enabled = value.enabled;
    }
  }

  // collectors - computed: false, optional: true, required: false
  private _collectors = new DeviceGroupExtraServicesDATAFACTORYNormalCollectorConfigCollectorsList(this, "collectors", false);
  public get collectors() {
    return this._collectors;
  }
  public putCollectors(value: DeviceGroupExtraServicesDATAFACTORYNormalCollectorConfigCollectors[] | cdktf.IResolvable) {
    this._collectors.internalValue = value;
  }
  public resetCollectors() {
    this._collectors.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorsInput() {
    return this._collectors.internalValue;
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }
}

export class DeviceGroupExtraServicesDATAFACTORYNormalCollectorConfigList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesDATAFACTORYNormalCollectorConfig[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesDATAFACTORYNormalCollectorConfigOutputReference {
    return new DeviceGroupExtraServicesDATAFACTORYNormalCollectorConfigOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesDATAFACTORY {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#custom_n_s_p_schedule DeviceGroup#custom_n_s_p_schedule}
  */
  readonly customNSPSchedule?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#dead_operation DeviceGroup#dead_operation}
  */
  readonly deadOperation?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#device_display_name_template DeviceGroup#device_display_name_template}
  */
  readonly deviceDisplayNameTemplate?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#disable_stop_terminate_host_monitor DeviceGroup#disable_stop_terminate_host_monitor}
  */
  readonly disableStopTerminateHostMonitor?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#disable_terminated_host_alerting DeviceGroup#disable_terminated_host_alerting}
  */
  readonly disableTerminatedHostAlerting?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#monitoring_region_infos DeviceGroup#monitoring_region_infos}
  */
  readonly monitoringRegionInfos?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#monitoring_regions DeviceGroup#monitoring_regions}
  */
  readonly monitoringRegions?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#name_filter DeviceGroup#name_filter}
  */
  readonly nameFilter?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#select_all DeviceGroup#select_all}
  */
  readonly selectAll?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#tags DeviceGroup#tags}
  */
  readonly tags?: DeviceGroupExtraServicesDATAFACTORYTags[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#use_default DeviceGroup#use_default}
  */
  readonly useDefault: boolean | cdktf.IResolvable;
  /**
  * normal_collector_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#normal_collector_config DeviceGroup#normal_collector_config}
  */
  readonly normalCollectorConfig?: DeviceGroupExtraServicesDATAFACTORYNormalCollectorConfig[] | cdktf.IResolvable;
}

export function deviceGroupExtraServicesDATAFACTORYToTerraform(struct?: DeviceGroupExtraServicesDATAFACTORY | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    custom_n_s_p_schedule: cdktf.stringToTerraform(struct!.customNSPSchedule),
    dead_operation: cdktf.stringToTerraform(struct!.deadOperation),
    device_display_name_template: cdktf.stringToTerraform(struct!.deviceDisplayNameTemplate),
    disable_stop_terminate_host_monitor: cdktf.booleanToTerraform(struct!.disableStopTerminateHostMonitor),
    disable_terminated_host_alerting: cdktf.booleanToTerraform(struct!.disableTerminatedHostAlerting),
    monitoring_region_infos: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.monitoringRegionInfos),
    monitoring_regions: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.monitoringRegions),
    name_filter: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.nameFilter),
    select_all: cdktf.booleanToTerraform(struct!.selectAll),
    tags: cdktf.listMapper(deviceGroupExtraServicesDATAFACTORYTagsToTerraform, false)(struct!.tags),
    use_default: cdktf.booleanToTerraform(struct!.useDefault),
    normal_collector_config: cdktf.listMapper(deviceGroupExtraServicesDATAFACTORYNormalCollectorConfigToTerraform, true)(struct!.normalCollectorConfig),
  }
}


export function deviceGroupExtraServicesDATAFACTORYToHclTerraform(struct?: DeviceGroupExtraServicesDATAFACTORY | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    custom_n_s_p_schedule: {
      value: cdktf.stringToHclTerraform(struct!.customNSPSchedule),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dead_operation: {
      value: cdktf.stringToHclTerraform(struct!.deadOperation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    device_display_name_template: {
      value: cdktf.stringToHclTerraform(struct!.deviceDisplayNameTemplate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disable_stop_terminate_host_monitor: {
      value: cdktf.booleanToHclTerraform(struct!.disableStopTerminateHostMonitor),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    disable_terminated_host_alerting: {
      value: cdktf.booleanToHclTerraform(struct!.disableTerminatedHostAlerting),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    monitoring_region_infos: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.monitoringRegionInfos),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    monitoring_regions: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.monitoringRegions),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    name_filter: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.nameFilter),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    select_all: {
      value: cdktf.booleanToHclTerraform(struct!.selectAll),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tags: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesDATAFACTORYTagsToHclTerraform, false)(struct!.tags),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesDATAFACTORYTagsList",
    },
    use_default: {
      value: cdktf.booleanToHclTerraform(struct!.useDefault),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    normal_collector_config: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesDATAFACTORYNormalCollectorConfigToHclTerraform, true)(struct!.normalCollectorConfig),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesDATAFACTORYNormalCollectorConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesDATAFACTORYOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesDATAFACTORY | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._customNSPSchedule !== undefined) {
      hasAnyValues = true;
      internalValueResult.customNSPSchedule = this._customNSPSchedule;
    }
    if (this._deadOperation !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadOperation = this._deadOperation;
    }
    if (this._deviceDisplayNameTemplate !== undefined) {
      hasAnyValues = true;
      internalValueResult.deviceDisplayNameTemplate = this._deviceDisplayNameTemplate;
    }
    if (this._disableStopTerminateHostMonitor !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableStopTerminateHostMonitor = this._disableStopTerminateHostMonitor;
    }
    if (this._disableTerminatedHostAlerting !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableTerminatedHostAlerting = this._disableTerminatedHostAlerting;
    }
    if (this._monitoringRegionInfos !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoringRegionInfos = this._monitoringRegionInfos;
    }
    if (this._monitoringRegions !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoringRegions = this._monitoringRegions;
    }
    if (this._nameFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.nameFilter = this._nameFilter;
    }
    if (this._selectAll !== undefined) {
      hasAnyValues = true;
      internalValueResult.selectAll = this._selectAll;
    }
    if (this._tags?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags?.internalValue;
    }
    if (this._useDefault !== undefined) {
      hasAnyValues = true;
      internalValueResult.useDefault = this._useDefault;
    }
    if (this._normalCollectorConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.normalCollectorConfig = this._normalCollectorConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesDATAFACTORY | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._customNSPSchedule = undefined;
      this._deadOperation = undefined;
      this._deviceDisplayNameTemplate = undefined;
      this._disableStopTerminateHostMonitor = undefined;
      this._disableTerminatedHostAlerting = undefined;
      this._monitoringRegionInfos = undefined;
      this._monitoringRegions = undefined;
      this._nameFilter = undefined;
      this._selectAll = undefined;
      this._tags.internalValue = undefined;
      this._useDefault = undefined;
      this._normalCollectorConfig.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._customNSPSchedule = value.customNSPSchedule;
      this._deadOperation = value.deadOperation;
      this._deviceDisplayNameTemplate = value.deviceDisplayNameTemplate;
      this._disableStopTerminateHostMonitor = value.disableStopTerminateHostMonitor;
      this._disableTerminatedHostAlerting = value.disableTerminatedHostAlerting;
      this._monitoringRegionInfos = value.monitoringRegionInfos;
      this._monitoringRegions = value.monitoringRegions;
      this._nameFilter = value.nameFilter;
      this._selectAll = value.selectAll;
      this._tags.internalValue = value.tags;
      this._useDefault = value.useDefault;
      this._normalCollectorConfig.internalValue = value.normalCollectorConfig;
    }
  }

  // custom_n_s_p_schedule - computed: false, optional: true, required: false
  private _customNSPSchedule?: string; 
  public get customNSPSchedule() {
    return this.getStringAttribute('custom_n_s_p_schedule');
  }
  public set customNSPSchedule(value: string) {
    this._customNSPSchedule = value;
  }
  public resetCustomNSPSchedule() {
    this._customNSPSchedule = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customNSPScheduleInput() {
    return this._customNSPSchedule;
  }

  // dead_operation - computed: false, optional: true, required: false
  private _deadOperation?: string; 
  public get deadOperation() {
    return this.getStringAttribute('dead_operation');
  }
  public set deadOperation(value: string) {
    this._deadOperation = value;
  }
  public resetDeadOperation() {
    this._deadOperation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadOperationInput() {
    return this._deadOperation;
  }

  // device_display_name_template - computed: false, optional: true, required: false
  private _deviceDisplayNameTemplate?: string; 
  public get deviceDisplayNameTemplate() {
    return this.getStringAttribute('device_display_name_template');
  }
  public set deviceDisplayNameTemplate(value: string) {
    this._deviceDisplayNameTemplate = value;
  }
  public resetDeviceDisplayNameTemplate() {
    this._deviceDisplayNameTemplate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deviceDisplayNameTemplateInput() {
    return this._deviceDisplayNameTemplate;
  }

  // disable_stop_terminate_host_monitor - computed: false, optional: true, required: false
  private _disableStopTerminateHostMonitor?: boolean | cdktf.IResolvable; 
  public get disableStopTerminateHostMonitor() {
    return this.getBooleanAttribute('disable_stop_terminate_host_monitor');
  }
  public set disableStopTerminateHostMonitor(value: boolean | cdktf.IResolvable) {
    this._disableStopTerminateHostMonitor = value;
  }
  public resetDisableStopTerminateHostMonitor() {
    this._disableStopTerminateHostMonitor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableStopTerminateHostMonitorInput() {
    return this._disableStopTerminateHostMonitor;
  }

  // disable_terminated_host_alerting - computed: false, optional: true, required: false
  private _disableTerminatedHostAlerting?: boolean | cdktf.IResolvable; 
  public get disableTerminatedHostAlerting() {
    return this.getBooleanAttribute('disable_terminated_host_alerting');
  }
  public set disableTerminatedHostAlerting(value: boolean | cdktf.IResolvable) {
    this._disableTerminatedHostAlerting = value;
  }
  public resetDisableTerminatedHostAlerting() {
    this._disableTerminatedHostAlerting = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableTerminatedHostAlertingInput() {
    return this._disableTerminatedHostAlerting;
  }

  // monitoring_region_infos - computed: false, optional: true, required: false
  private _monitoringRegionInfos?: string[]; 
  public get monitoringRegionInfos() {
    return cdktf.Fn.tolist(this.getListAttribute('monitoring_region_infos'));
  }
  public set monitoringRegionInfos(value: string[]) {
    this._monitoringRegionInfos = value;
  }
  public resetMonitoringRegionInfos() {
    this._monitoringRegionInfos = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoringRegionInfosInput() {
    return this._monitoringRegionInfos;
  }

  // monitoring_regions - computed: false, optional: true, required: false
  private _monitoringRegions?: string[]; 
  public get monitoringRegions() {
    return cdktf.Fn.tolist(this.getListAttribute('monitoring_regions'));
  }
  public set monitoringRegions(value: string[]) {
    this._monitoringRegions = value;
  }
  public resetMonitoringRegions() {
    this._monitoringRegions = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoringRegionsInput() {
    return this._monitoringRegions;
  }

  // name_filter - computed: false, optional: true, required: false
  private _nameFilter?: string[]; 
  public get nameFilter() {
    return cdktf.Fn.tolist(this.getListAttribute('name_filter'));
  }
  public set nameFilter(value: string[]) {
    this._nameFilter = value;
  }
  public resetNameFilter() {
    this._nameFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameFilterInput() {
    return this._nameFilter;
  }

  // select_all - computed: false, optional: true, required: false
  private _selectAll?: boolean | cdktf.IResolvable; 
  public get selectAll() {
    return this.getBooleanAttribute('select_all');
  }
  public set selectAll(value: boolean | cdktf.IResolvable) {
    this._selectAll = value;
  }
  public resetSelectAll() {
    this._selectAll = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectAllInput() {
    return this._selectAll;
  }

  // tags - computed: false, optional: true, required: false
  private _tags = new DeviceGroupExtraServicesDATAFACTORYTagsList(this, "tags", false);
  public get tags() {
    return this._tags;
  }
  public putTags(value: DeviceGroupExtraServicesDATAFACTORYTags[] | cdktf.IResolvable) {
    this._tags.internalValue = value;
  }
  public resetTags() {
    this._tags.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags.internalValue;
  }

  // use_default - computed: false, optional: false, required: true
  private _useDefault?: boolean | cdktf.IResolvable; 
  public get useDefault() {
    return this.getBooleanAttribute('use_default');
  }
  public set useDefault(value: boolean | cdktf.IResolvable) {
    this._useDefault = value;
  }
  // Temporarily expose input value. Use with caution.
  public get useDefaultInput() {
    return this._useDefault;
  }

  // normal_collector_config - computed: false, optional: true, required: false
  private _normalCollectorConfig = new DeviceGroupExtraServicesDATAFACTORYNormalCollectorConfigList(this, "normal_collector_config", false);
  public get normalCollectorConfig() {
    return this._normalCollectorConfig;
  }
  public putNormalCollectorConfig(value: DeviceGroupExtraServicesDATAFACTORYNormalCollectorConfig[] | cdktf.IResolvable) {
    this._normalCollectorConfig.internalValue = value;
  }
  public resetNormalCollectorConfig() {
    this._normalCollectorConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get normalCollectorConfigInput() {
    return this._normalCollectorConfig.internalValue;
  }
}

export class DeviceGroupExtraServicesDATAFACTORYList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesDATAFACTORY[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesDATAFACTORYOutputReference {
    return new DeviceGroupExtraServicesDATAFACTORYOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesDIRECTCONNECTTags {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#name DeviceGroup#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#operation DeviceGroup#operation}
  */
  readonly operation?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#value DeviceGroup#value}
  */
  readonly value?: string;
}

export function deviceGroupExtraServicesDIRECTCONNECTTagsToTerraform(struct?: DeviceGroupExtraServicesDIRECTCONNECTTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    operation: cdktf.stringToTerraform(struct!.operation),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function deviceGroupExtraServicesDIRECTCONNECTTagsToHclTerraform(struct?: DeviceGroupExtraServicesDIRECTCONNECTTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operation: {
      value: cdktf.stringToHclTerraform(struct!.operation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesDIRECTCONNECTTagsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesDIRECTCONNECTTags | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._operation !== undefined) {
      hasAnyValues = true;
      internalValueResult.operation = this._operation;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesDIRECTCONNECTTags | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._operation = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._operation = value.operation;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // operation - computed: false, optional: true, required: false
  private _operation?: string; 
  public get operation() {
    return this.getStringAttribute('operation');
  }
  public set operation(value: string) {
    this._operation = value;
  }
  public resetOperation() {
    this._operation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operationInput() {
    return this._operation;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DeviceGroupExtraServicesDIRECTCONNECTTagsList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesDIRECTCONNECTTags[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesDIRECTCONNECTTagsOutputReference {
    return new DeviceGroupExtraServicesDIRECTCONNECTTagsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesDIRECTCONNECTNormalCollectorConfigCollectors {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#applies_to DeviceGroup#applies_to}
  */
  readonly appliesTo?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#auto_balanced_collector_group_id DeviceGroup#auto_balanced_collector_group_id}
  */
  readonly autoBalancedCollectorGroupId?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#collector_id DeviceGroup#collector_id}
  */
  readonly collectorId?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#priority DeviceGroup#priority}
  */
  readonly priority?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#use_public_ip DeviceGroup#use_public_ip}
  */
  readonly usePublicIp?: boolean | cdktf.IResolvable;
}

export function deviceGroupExtraServicesDIRECTCONNECTNormalCollectorConfigCollectorsToTerraform(struct?: DeviceGroupExtraServicesDIRECTCONNECTNormalCollectorConfigCollectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    applies_to: cdktf.stringToTerraform(struct!.appliesTo),
    auto_balanced_collector_group_id: cdktf.numberToTerraform(struct!.autoBalancedCollectorGroupId),
    collector_id: cdktf.numberToTerraform(struct!.collectorId),
    priority: cdktf.numberToTerraform(struct!.priority),
    use_public_ip: cdktf.booleanToTerraform(struct!.usePublicIp),
  }
}


export function deviceGroupExtraServicesDIRECTCONNECTNormalCollectorConfigCollectorsToHclTerraform(struct?: DeviceGroupExtraServicesDIRECTCONNECTNormalCollectorConfigCollectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    applies_to: {
      value: cdktf.stringToHclTerraform(struct!.appliesTo),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auto_balanced_collector_group_id: {
      value: cdktf.numberToHclTerraform(struct!.autoBalancedCollectorGroupId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    collector_id: {
      value: cdktf.numberToHclTerraform(struct!.collectorId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    priority: {
      value: cdktf.numberToHclTerraform(struct!.priority),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    use_public_ip: {
      value: cdktf.booleanToHclTerraform(struct!.usePublicIp),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesDIRECTCONNECTNormalCollectorConfigCollectorsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesDIRECTCONNECTNormalCollectorConfigCollectors | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._appliesTo !== undefined) {
      hasAnyValues = true;
      internalValueResult.appliesTo = this._appliesTo;
    }
    if (this._autoBalancedCollectorGroupId !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoBalancedCollectorGroupId = this._autoBalancedCollectorGroupId;
    }
    if (this._collectorId !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectorId = this._collectorId;
    }
    if (this._priority !== undefined) {
      hasAnyValues = true;
      internalValueResult.priority = this._priority;
    }
    if (this._usePublicIp !== undefined) {
      hasAnyValues = true;
      internalValueResult.usePublicIp = this._usePublicIp;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesDIRECTCONNECTNormalCollectorConfigCollectors | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._appliesTo = undefined;
      this._autoBalancedCollectorGroupId = undefined;
      this._collectorId = undefined;
      this._priority = undefined;
      this._usePublicIp = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._appliesTo = value.appliesTo;
      this._autoBalancedCollectorGroupId = value.autoBalancedCollectorGroupId;
      this._collectorId = value.collectorId;
      this._priority = value.priority;
      this._usePublicIp = value.usePublicIp;
    }
  }

  // applies_to - computed: false, optional: true, required: false
  private _appliesTo?: string; 
  public get appliesTo() {
    return this.getStringAttribute('applies_to');
  }
  public set appliesTo(value: string) {
    this._appliesTo = value;
  }
  public resetAppliesTo() {
    this._appliesTo = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appliesToInput() {
    return this._appliesTo;
  }

  // auto_balanced_collector_group_id - computed: false, optional: true, required: false
  private _autoBalancedCollectorGroupId?: number; 
  public get autoBalancedCollectorGroupId() {
    return this.getNumberAttribute('auto_balanced_collector_group_id');
  }
  public set autoBalancedCollectorGroupId(value: number) {
    this._autoBalancedCollectorGroupId = value;
  }
  public resetAutoBalancedCollectorGroupId() {
    this._autoBalancedCollectorGroupId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoBalancedCollectorGroupIdInput() {
    return this._autoBalancedCollectorGroupId;
  }

  // collector_id - computed: false, optional: true, required: false
  private _collectorId?: number; 
  public get collectorId() {
    return this.getNumberAttribute('collector_id');
  }
  public set collectorId(value: number) {
    this._collectorId = value;
  }
  public resetCollectorId() {
    this._collectorId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorIdInput() {
    return this._collectorId;
  }

  // priority - computed: false, optional: true, required: false
  private _priority?: number; 
  public get priority() {
    return this.getNumberAttribute('priority');
  }
  public set priority(value: number) {
    this._priority = value;
  }
  public resetPriority() {
    this._priority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get priorityInput() {
    return this._priority;
  }

  // use_public_ip - computed: false, optional: true, required: false
  private _usePublicIp?: boolean | cdktf.IResolvable; 
  public get usePublicIp() {
    return this.getBooleanAttribute('use_public_ip');
  }
  public set usePublicIp(value: boolean | cdktf.IResolvable) {
    this._usePublicIp = value;
  }
  public resetUsePublicIp() {
    this._usePublicIp = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usePublicIpInput() {
    return this._usePublicIp;
  }
}

export class DeviceGroupExtraServicesDIRECTCONNECTNormalCollectorConfigCollectorsList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesDIRECTCONNECTNormalCollectorConfigCollectors[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesDIRECTCONNECTNormalCollectorConfigCollectorsOutputReference {
    return new DeviceGroupExtraServicesDIRECTCONNECTNormalCollectorConfigCollectorsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesDIRECTCONNECTNormalCollectorConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#collectors DeviceGroup#collectors}
  */
  readonly collectors?: DeviceGroupExtraServicesDIRECTCONNECTNormalCollectorConfigCollectors[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#enabled DeviceGroup#enabled}
  */
  readonly enabled: boolean | cdktf.IResolvable;
}

export function deviceGroupExtraServicesDIRECTCONNECTNormalCollectorConfigToTerraform(struct?: DeviceGroupExtraServicesDIRECTCONNECTNormalCollectorConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    collectors: cdktf.listMapper(deviceGroupExtraServicesDIRECTCONNECTNormalCollectorConfigCollectorsToTerraform, false)(struct!.collectors),
    enabled: cdktf.booleanToTerraform(struct!.enabled),
  }
}


export function deviceGroupExtraServicesDIRECTCONNECTNormalCollectorConfigToHclTerraform(struct?: DeviceGroupExtraServicesDIRECTCONNECTNormalCollectorConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    collectors: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesDIRECTCONNECTNormalCollectorConfigCollectorsToHclTerraform, false)(struct!.collectors),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesDIRECTCONNECTNormalCollectorConfigCollectorsList",
    },
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesDIRECTCONNECTNormalCollectorConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesDIRECTCONNECTNormalCollectorConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._collectors?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectors = this._collectors?.internalValue;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesDIRECTCONNECTNormalCollectorConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._collectors.internalValue = undefined;
      this._enabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._collectors.internalValue = value.collectors;
      this._enabled = value.enabled;
    }
  }

  // collectors - computed: false, optional: true, required: false
  private _collectors = new DeviceGroupExtraServicesDIRECTCONNECTNormalCollectorConfigCollectorsList(this, "collectors", false);
  public get collectors() {
    return this._collectors;
  }
  public putCollectors(value: DeviceGroupExtraServicesDIRECTCONNECTNormalCollectorConfigCollectors[] | cdktf.IResolvable) {
    this._collectors.internalValue = value;
  }
  public resetCollectors() {
    this._collectors.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorsInput() {
    return this._collectors.internalValue;
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }
}

export class DeviceGroupExtraServicesDIRECTCONNECTNormalCollectorConfigList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesDIRECTCONNECTNormalCollectorConfig[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesDIRECTCONNECTNormalCollectorConfigOutputReference {
    return new DeviceGroupExtraServicesDIRECTCONNECTNormalCollectorConfigOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DeviceGroupExtraServicesDIRECTCONNECT {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#custom_n_s_p_schedule DeviceGroup#custom_n_s_p_schedule}
  */
  readonly customNSPSchedule?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#dead_operation DeviceGroup#dead_operation}
  */
  readonly deadOperation?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#device_display_name_template DeviceGroup#device_display_name_template}
  */
  readonly deviceDisplayNameTemplate?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#disable_stop_terminate_host_monitor DeviceGroup#disable_stop_terminate_host_monitor}
  */
  readonly disableStopTerminateHostMonitor?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#disable_terminated_host_alerting DeviceGroup#disable_terminated_host_alerting}
  */
  readonly disableTerminatedHostAlerting?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#monitoring_region_infos DeviceGroup#monitoring_region_infos}
  */
  readonly monitoringRegionInfos?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#monitoring_regions DeviceGroup#monitoring_regions}
  */
  readonly monitoringRegions?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#name_filter DeviceGroup#name_filter}
  */
  readonly nameFilter?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#select_all DeviceGroup#select_all}
  */
  readonly selectAll?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#tags DeviceGroup#tags}
  */
  readonly tags?: DeviceGroupExtraServicesDIRECTCONNECTTags[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#use_default DeviceGroup#use_default}
  */
  readonly useDefault: boolean | cdktf.IResolvable;
  /**
  * normal_collector_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/logicmonitor/logicmonitor/2.0.25/docs/resources/device_group#normal_collector_config DeviceGroup#normal_collector_config}
  */
  readonly normalCollectorConfig?: DeviceGroupExtraServicesDIRECTCONNECTNormalCollectorConfig[] | cdktf.IResolvable;
}

export function deviceGroupExtraServicesDIRECTCONNECTToTerraform(struct?: DeviceGroupExtraServicesDIRECTCONNECT | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    custom_n_s_p_schedule: cdktf.stringToTerraform(struct!.customNSPSchedule),
    dead_operation: cdktf.stringToTerraform(struct!.deadOperation),
    device_display_name_template: cdktf.stringToTerraform(struct!.deviceDisplayNameTemplate),
    disable_stop_terminate_host_monitor: cdktf.booleanToTerraform(struct!.disableStopTerminateHostMonitor),
    disable_terminated_host_alerting: cdktf.booleanToTerraform(struct!.disableTerminatedHostAlerting),
    monitoring_region_infos: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.monitoringRegionInfos),
    monitoring_regions: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.monitoringRegions),
    name_filter: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.nameFilter),
    select_all: cdktf.booleanToTerraform(struct!.selectAll),
    tags: cdktf.listMapper(deviceGroupExtraServicesDIRECTCONNECTTagsToTerraform, false)(struct!.tags),
    use_default: cdktf.booleanToTerraform(struct!.useDefault),
    normal_collector_config: cdktf.listMapper(deviceGroupExtraServicesDIRECTCONNECTNormalCollectorConfigToTerraform, true)(struct!.normalCollectorConfig),
  }
}


export function deviceGroupExtraServicesDIRECTCONNECTToHclTerraform(struct?: DeviceGroupExtraServicesDIRECTCONNECT | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    custom_n_s_p_schedule: {
      value: cdktf.stringToHclTerraform(struct!.customNSPSchedule),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dead_operation: {
      value: cdktf.stringToHclTerraform(struct!.deadOperation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    device_display_name_template: {
      value: cdktf.stringToHclTerraform(struct!.deviceDisplayNameTemplate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disable_stop_terminate_host_monitor: {
      value: cdktf.booleanToHclTerraform(struct!.disableStopTerminateHostMonitor),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    disable_terminated_host_alerting: {
      value: cdktf.booleanToHclTerraform(struct!.disableTerminatedHostAlerting),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    monitoring_region_infos: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.monitoringRegionInfos),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    monitoring_regions: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.monitoringRegions),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    name_filter: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.nameFilter),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    select_all: {
      value: cdktf.booleanToHclTerraform(struct!.selectAll),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tags: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesDIRECTCONNECTTagsToHclTerraform, false)(struct!.tags),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesDIRECTCONNECTTagsList",
    },
    use_default: {
      value: cdktf.booleanToHclTerraform(struct!.useDefault),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    normal_collector_config: {
      value: cdktf.listMapperHcl(deviceGroupExtraServicesDIRECTCONNECTNormalCollectorConfigToHclTerraform, true)(struct!.normalCollectorConfig),
      isBlock: true,
      type: "list",
      storageClassType: "DeviceGroupExtraServicesDIRECTCONNECTNormalCollectorConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DeviceGroupExtraServicesDIRECTCONNECTOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DeviceGroupExtraServicesDIRECTCONNECT | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._customNSPSchedule !== undefined) {
      hasAnyValues = true;
      internalValueResult.customNSPSchedule = this._customNSPSchedule;
    }
    if (this._deadOperation !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadOperation = this._deadOperation;
    }
    if (this._deviceDisplayNameTemplate !== undefined) {
      hasAnyValues = true;
      internalValueResult.deviceDisplayNameTemplate = this._deviceDisplayNameTemplate;
    }
    if (this._disableStopTerminateHostMonitor !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableStopTerminateHostMonitor = this._disableStopTerminateHostMonitor;
    }
    if (this._disableTerminatedHostAlerting !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableTerminatedHostAlerting = this._disableTerminatedHostAlerting;
    }
    if (this._monitoringRegionInfos !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoringRegionInfos = this._monitoringRegionInfos;
    }
    if (this._monitoringRegions !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoringRegions = this._monitoringRegions;
    }
    if (this._nameFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.nameFilter = this._nameFilter;
    }
    if (this._selectAll !== undefined) {
      hasAnyValues = true;
      internalValueResult.selectAll = this._selectAll;
    }
    if (this._tags?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags?.internalValue;
    }
    if (this._useDefault !== undefined) {
      hasAnyValues = true;
      internalValueResult.useDefault = this._useDefault;
    }
    if (this._normalCollectorConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.normalCollectorConfig = this._normalCollectorConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DeviceGroupExtraServicesDIRECTCONNECT | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._customNSPSchedule = undefined;
      this._deadOperation = undefined;
      this._deviceDisplayNameTemplate = undefined;
      this._disableStopTerminateHostMonitor = undefined;
      this._disableTerminatedHostAlerting = undefined;
      this._monitoringRegionInfos = undefined;
      this._monitoringRegions = undefined;
      this._nameFilter = undefined;
      this._selectAll = undefined;
      this._tags.internalValue = undefined;
      this._useDefault = undefined;
      this._normalCollectorConfig.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._customNSPSchedule = value.customNSPSchedule;
      this._deadOperation = value.deadOperation;
      this._deviceDisplayNameTemplate = value.deviceDisplayNameTemplate;
      this._disableStopTerminateHostMonitor = value.disableStopTerminateHostMonitor;
      this._disableTerminatedHostAlerting = value.disableTerminatedHostAlerting;
      this._monitoringRegionInfos = value.monitoringRegionInfos;
      this._monitoringRegions = value.monitoringRegions;
      this._nameFilter = value.nameFilter;
      this._selectAll = value.selectAll;
      this._tags.internalValue = value.tags;
      this._useDefault = value.useDefault;
      this._normalCollectorConfig.internalValue = value.normalCollectorConfig;
    }
  }

  // custom_n_s_p_schedule - computed: false, optional: true, required: false
  private _customNSPSchedule?: string; 
  public get customNSPSchedule() {
    return this.getStringAttribute('custom_n_s_p_schedule');
  }
  public set customNSPSchedule(value: string) {
    this._customNSPSchedule = value;
  }
  public resetCustomNSPSchedule() {
    this._customNSPSchedule = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customNSPScheduleInput() {
    return this._customNSPSchedule;
  }

  // dead_operation - computed: false, optional: true, required: false
  private _deadOperation?: string; 
  public get deadOperation() {
    return this.getStringAttribute('dead_operation');
  }
  public set deadOperation(value: string) {
    this._deadOperation = value;
  }
  public resetDeadOperation() {
    this._deadOperation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadOperationInput() {
    return this._deadOperation;
  }

  // device_display_name_template - computed: false, optional: true, required: false
  private _deviceDisplayNameTemplate?: string; 
  public get deviceDisplayNameTemplate() {
    return this.getStringAttribute('device_display_name_template');
  }
  public set deviceDisplayNameTemplate(value: string) {
    this._deviceDisplayNameTemplate = value;
  }
  public resetDeviceDisplayNameTemplate() {
    this._deviceDisplayNameTemplate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deviceDisplayNameTemplateInput() {
    return this._deviceDisplayNameTemplate;
  }

  // disable_stop_terminate_host_monitor - computed: false, optional: true, required: false
  private _disableStopTerminateHostMonitor?: boolean | cdktf.IResolvable; 
  public get disableStopTerminateHostMonitor() {
    return this.getBooleanAttribute('disable_stop_terminate_host_monitor');
  }
  public set disableStopTerminateHostMonitor(value: boolean | cdktf.IResolvable) {
    this._disableStopTerminateHostMonitor = value;
  }
  public resetDisableStopTerminateHostMonitor() {
    this._disableStopTerminateHostMonitor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableStopTerminateHostMonitorInput() {
    return this._disableStopTerminateHostMonitor;
  }

  // disable_terminated_host_alerting - computed: false, optional: true, required: false
  private _disableTerminatedHostAlerting?: boolean | cdktf.IResolvable; 
  public get disableTerminatedHostAlerting() {
    return this.getBooleanAttribute('disable_terminated_host_alerting');
  }
  public set disableTerminatedHostAlerting(value: boolean | cdktf.IResolvable) {
    this._disableTerminatedHostAlerting = value;
  }
  public resetDisableTerminatedHostAlerting() {
    this._disableTerminatedHostAlerting = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableTerminatedHostAlertingInput() {
    return this._disableTerminatedHostAlerting;
  }

  // monitoring_region_infos - computed: false, optional: true, required: false
  private _monitoringRegionInfos?: string[]; 
  public get monitoringRegionInfos() {
    return cdktf.Fn.tolist(this.getListAttribute('monitoring_region_infos'));
  }
  public set monitoringRegionInfos(value: string[]) {
    this._monitoringRegionInfos = value;
  }
  public resetMonitoringRegionInfos() {
    this._monitoringRegionInfos = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoringRegionInfosInput() {
    return this._monitoringRegionInfos;
  }

  // monitoring_regions - computed: false, optional: true, required: false
  private _monitoringRegions?: string[]; 
  public get monitoringRegions() {
    return cdktf.Fn.tolist(this.getListAttribute('monitoring_regions'));
  }
  public set monitoringRegions(value: string[]) {
    this._monitoringRegions = value;
  }
  public resetMonitoringRegions() {
    this._monitoringRegions = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoringRegionsInput() {
    return this._monitoringRegions;
  }

  // name_filter - computed: false, optional: true, required: false
  private _nameFilter?: string[]; 
  public get nameFilter() {
    return cdktf.Fn.tolist(this.getListAttribute('name_filter'));
  }
  public set nameFilter(value: string[]) {
    this._nameFilter = value;
  }
  public resetNameFilter() {
    this._nameFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameFilterInput() {
    return this._nameFilter;
  }

  // select_all - computed: false, optional: true, required: false
  private _selectAll?: boolean | cdktf.IResolvable; 
  public get selectAll() {
    return this.getBooleanAttribute('select_all');
  }
  public set selectAll(value: boolean | cdktf.IResolvable) {
    this._selectAll = value;
  }
  public resetSelectAll() {
    this._selectAll = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectAllInput() {
    return this._selectAll;
  }

  // tags - computed: false, optional: true, required: false
  private _tags = new DeviceGroupExtraServicesDIRECTCONNECTTagsList(this, "tags", false);
  public get tags() {
    return this._tags;
  }
  public putTags(value: DeviceGroupExtraServicesDIRECTCONNECTTags[] | cdktf.IResolvable) {
    this._tags.internalValue = value;
  }
  public resetTags() {
    this._tags.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags.internalValue;
  }

  // use_default - computed: false, optional: false, required: true
  private _useDefault?: boolean | cdktf.IResolvable; 
  public get useDefault() {
    return this.getBooleanAttribute('use_default');
  }
  public set useDefault(value: boolean | cdktf.IResolvable) {
    this._useDefault = value;
  }
  // Temporarily expose input value. Use with caution.
  public get useDefaultInput() {
    return this._useDefault;
  }

  // normal_collector_config - computed: false, optional: true, required: false
  private _normalCollectorConfig = new DeviceGroupExtraServicesDIRECTCONNECTNormalCollectorConfigList(this, "normal_collector_config", false);
  public get normalCollectorConfig() {
    return this._normalCollectorConfig;
  }
  public putNormalCollectorConfig(value: DeviceGroupExtraServicesDIRECTCONNECTNormalCollectorConfig[] | cdktf.IResolvable) {
    this._normalCollectorConfig.internalValue = value;
  }
  public resetNormalCollectorConfig() {
    this._normalCollectorConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get normalCollectorConfigInput() {
    return this._normalCollectorConfig.internalValue;
  }
}

export class DeviceGroupExtraServicesDIRECTCONNECTList extends cdktf.ComplexList {
  public internalValue? : DeviceGroupExtraServicesDIRECTCONNECT[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DeviceGroupExtraServicesDIRECTCONNECTOutputReference {
    return new DeviceGroupExtraServicesDIRECTCONNECTOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
