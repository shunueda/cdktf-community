import * as cdktf from 'cdktf';
export interface VirtualRouterAdministrativeDistances {
  /**
  * administrative distance used for eBGP routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#ebgp VirtualRouter#ebgp}
  */
  readonly ebgp?: number;
  /**
  * administrative distance used for iBGP routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#ibgp VirtualRouter#ibgp}
  */
  readonly ibgp?: number;
  /**
  * administrative distance used for OSPF external routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#ospf_ext VirtualRouter#ospf_ext}
  */
  readonly ospfExt?: number;
  /**
  * administrative distance used for OSPF internal routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#ospf_int VirtualRouter#ospf_int}
  */
  readonly ospfInt?: number;
  /**
  * administrative distance used for OSPFv3 external routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#ospfv3_ext VirtualRouter#ospfv3_ext}
  */
  readonly ospfv3Ext?: number;
  /**
  * administrative distance used for OSPFv3 internal routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#ospfv3_int VirtualRouter#ospfv3_int}
  */
  readonly ospfv3Int?: number;
  /**
  * administrative distance used for RIP routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#rip VirtualRouter#rip}
  */
  readonly rip?: number;
  /**
  * administrative distance used for static routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#static VirtualRouter#static}
  */
  readonly static?: number;
  /**
  * administrative distance used for ipv6 static routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#static_ipv6 VirtualRouter#static_ipv6}
  */
  readonly staticIpv6?: number;
}

export function virtualRouterAdministrativeDistancesToTerraform(struct?: VirtualRouterAdministrativeDistances | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ebgp: cdktf.numberToTerraform(struct!.ebgp),
    ibgp: cdktf.numberToTerraform(struct!.ibgp),
    ospf_ext: cdktf.numberToTerraform(struct!.ospfExt),
    ospf_int: cdktf.numberToTerraform(struct!.ospfInt),
    ospfv3_ext: cdktf.numberToTerraform(struct!.ospfv3Ext),
    ospfv3_int: cdktf.numberToTerraform(struct!.ospfv3Int),
    rip: cdktf.numberToTerraform(struct!.rip),
    static: cdktf.numberToTerraform(struct!.static),
    static_ipv6: cdktf.numberToTerraform(struct!.staticIpv6),
  }
}


export function virtualRouterAdministrativeDistancesToHclTerraform(struct?: VirtualRouterAdministrativeDistances | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ebgp: {
      value: cdktf.numberToHclTerraform(struct!.ebgp),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    ibgp: {
      value: cdktf.numberToHclTerraform(struct!.ibgp),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    ospf_ext: {
      value: cdktf.numberToHclTerraform(struct!.ospfExt),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    ospf_int: {
      value: cdktf.numberToHclTerraform(struct!.ospfInt),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    ospfv3_ext: {
      value: cdktf.numberToHclTerraform(struct!.ospfv3Ext),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    ospfv3_int: {
      value: cdktf.numberToHclTerraform(struct!.ospfv3Int),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    rip: {
      value: cdktf.numberToHclTerraform(struct!.rip),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    static: {
      value: cdktf.numberToHclTerraform(struct!.static),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    static_ipv6: {
      value: cdktf.numberToHclTerraform(struct!.staticIpv6),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterAdministrativeDistancesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterAdministrativeDistances | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ebgp !== undefined) {
      hasAnyValues = true;
      internalValueResult.ebgp = this._ebgp;
    }
    if (this._ibgp !== undefined) {
      hasAnyValues = true;
      internalValueResult.ibgp = this._ibgp;
    }
    if (this._ospfExt !== undefined) {
      hasAnyValues = true;
      internalValueResult.ospfExt = this._ospfExt;
    }
    if (this._ospfInt !== undefined) {
      hasAnyValues = true;
      internalValueResult.ospfInt = this._ospfInt;
    }
    if (this._ospfv3Ext !== undefined) {
      hasAnyValues = true;
      internalValueResult.ospfv3Ext = this._ospfv3Ext;
    }
    if (this._ospfv3Int !== undefined) {
      hasAnyValues = true;
      internalValueResult.ospfv3Int = this._ospfv3Int;
    }
    if (this._rip !== undefined) {
      hasAnyValues = true;
      internalValueResult.rip = this._rip;
    }
    if (this._static !== undefined) {
      hasAnyValues = true;
      internalValueResult.static = this._static;
    }
    if (this._staticIpv6 !== undefined) {
      hasAnyValues = true;
      internalValueResult.staticIpv6 = this._staticIpv6;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterAdministrativeDistances | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ebgp = undefined;
      this._ibgp = undefined;
      this._ospfExt = undefined;
      this._ospfInt = undefined;
      this._ospfv3Ext = undefined;
      this._ospfv3Int = undefined;
      this._rip = undefined;
      this._static = undefined;
      this._staticIpv6 = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ebgp = value.ebgp;
      this._ibgp = value.ibgp;
      this._ospfExt = value.ospfExt;
      this._ospfInt = value.ospfInt;
      this._ospfv3Ext = value.ospfv3Ext;
      this._ospfv3Int = value.ospfv3Int;
      this._rip = value.rip;
      this._static = value.static;
      this._staticIpv6 = value.staticIpv6;
    }
  }

  // ebgp - computed: true, optional: true, required: false
  private _ebgp?: number; 
  public get ebgp() {
    return this.getNumberAttribute('ebgp');
  }
  public set ebgp(value: number) {
    this._ebgp = value;
  }
  public resetEbgp() {
    this._ebgp = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ebgpInput() {
    return this._ebgp;
  }

  // ibgp - computed: true, optional: true, required: false
  private _ibgp?: number; 
  public get ibgp() {
    return this.getNumberAttribute('ibgp');
  }
  public set ibgp(value: number) {
    this._ibgp = value;
  }
  public resetIbgp() {
    this._ibgp = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ibgpInput() {
    return this._ibgp;
  }

  // ospf_ext - computed: true, optional: true, required: false
  private _ospfExt?: number; 
  public get ospfExt() {
    return this.getNumberAttribute('ospf_ext');
  }
  public set ospfExt(value: number) {
    this._ospfExt = value;
  }
  public resetOspfExt() {
    this._ospfExt = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ospfExtInput() {
    return this._ospfExt;
  }

  // ospf_int - computed: true, optional: true, required: false
  private _ospfInt?: number; 
  public get ospfInt() {
    return this.getNumberAttribute('ospf_int');
  }
  public set ospfInt(value: number) {
    this._ospfInt = value;
  }
  public resetOspfInt() {
    this._ospfInt = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ospfIntInput() {
    return this._ospfInt;
  }

  // ospfv3_ext - computed: true, optional: true, required: false
  private _ospfv3Ext?: number; 
  public get ospfv3Ext() {
    return this.getNumberAttribute('ospfv3_ext');
  }
  public set ospfv3Ext(value: number) {
    this._ospfv3Ext = value;
  }
  public resetOspfv3Ext() {
    this._ospfv3Ext = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ospfv3ExtInput() {
    return this._ospfv3Ext;
  }

  // ospfv3_int - computed: true, optional: true, required: false
  private _ospfv3Int?: number; 
  public get ospfv3Int() {
    return this.getNumberAttribute('ospfv3_int');
  }
  public set ospfv3Int(value: number) {
    this._ospfv3Int = value;
  }
  public resetOspfv3Int() {
    this._ospfv3Int = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ospfv3IntInput() {
    return this._ospfv3Int;
  }

  // rip - computed: true, optional: true, required: false
  private _rip?: number; 
  public get rip() {
    return this.getNumberAttribute('rip');
  }
  public set rip(value: number) {
    this._rip = value;
  }
  public resetRip() {
    this._rip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ripInput() {
    return this._rip;
  }

  // static - computed: true, optional: true, required: false
  private _static?: number; 
  public get static() {
    return this.getNumberAttribute('static');
  }
  public set static(value: number) {
    this._static = value;
  }
  public resetStatic() {
    this._static = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get staticInput() {
    return this._static;
  }

  // static_ipv6 - computed: true, optional: true, required: false
  private _staticIpv6?: number; 
  public get staticIpv6() {
    return this.getNumberAttribute('static_ipv6');
  }
  public set staticIpv6(value: number) {
    this._staticIpv6 = value;
  }
  public resetStaticIpv6() {
    this._staticIpv6 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get staticIpv6Input() {
    return this._staticIpv6;
  }
}
export interface VirtualRouterEcmpAlgorithmBalancedRoundRobin {
}

export function virtualRouterEcmpAlgorithmBalancedRoundRobinToTerraform(struct?: VirtualRouterEcmpAlgorithmBalancedRoundRobin | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function virtualRouterEcmpAlgorithmBalancedRoundRobinToHclTerraform(struct?: VirtualRouterEcmpAlgorithmBalancedRoundRobin | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class VirtualRouterEcmpAlgorithmBalancedRoundRobinOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterEcmpAlgorithmBalancedRoundRobin | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterEcmpAlgorithmBalancedRoundRobin | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface VirtualRouterEcmpAlgorithmIpHash {
  /**
  * User-specified hash seed
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#hash_seed VirtualRouter#hash_seed}
  */
  readonly hashSeed?: number;
  /**
  * only use source address for hash
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#src_only VirtualRouter#src_only}
  */
  readonly srcOnly?: boolean | cdktf.IResolvable;
  /**
  * use source/destination port for hash
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#use_port VirtualRouter#use_port}
  */
  readonly usePort?: boolean | cdktf.IResolvable;
}

export function virtualRouterEcmpAlgorithmIpHashToTerraform(struct?: VirtualRouterEcmpAlgorithmIpHash | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    hash_seed: cdktf.numberToTerraform(struct!.hashSeed),
    src_only: cdktf.booleanToTerraform(struct!.srcOnly),
    use_port: cdktf.booleanToTerraform(struct!.usePort),
  }
}


export function virtualRouterEcmpAlgorithmIpHashToHclTerraform(struct?: VirtualRouterEcmpAlgorithmIpHash | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    hash_seed: {
      value: cdktf.numberToHclTerraform(struct!.hashSeed),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    src_only: {
      value: cdktf.booleanToHclTerraform(struct!.srcOnly),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    use_port: {
      value: cdktf.booleanToHclTerraform(struct!.usePort),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterEcmpAlgorithmIpHashOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterEcmpAlgorithmIpHash | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._hashSeed !== undefined) {
      hasAnyValues = true;
      internalValueResult.hashSeed = this._hashSeed;
    }
    if (this._srcOnly !== undefined) {
      hasAnyValues = true;
      internalValueResult.srcOnly = this._srcOnly;
    }
    if (this._usePort !== undefined) {
      hasAnyValues = true;
      internalValueResult.usePort = this._usePort;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterEcmpAlgorithmIpHash | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._hashSeed = undefined;
      this._srcOnly = undefined;
      this._usePort = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._hashSeed = value.hashSeed;
      this._srcOnly = value.srcOnly;
      this._usePort = value.usePort;
    }
  }

  // hash_seed - computed: true, optional: true, required: false
  private _hashSeed?: number; 
  public get hashSeed() {
    return this.getNumberAttribute('hash_seed');
  }
  public set hashSeed(value: number) {
    this._hashSeed = value;
  }
  public resetHashSeed() {
    this._hashSeed = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hashSeedInput() {
    return this._hashSeed;
  }

  // src_only - computed: false, optional: true, required: false
  private _srcOnly?: boolean | cdktf.IResolvable; 
  public get srcOnly() {
    return this.getBooleanAttribute('src_only');
  }
  public set srcOnly(value: boolean | cdktf.IResolvable) {
    this._srcOnly = value;
  }
  public resetSrcOnly() {
    this._srcOnly = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get srcOnlyInput() {
    return this._srcOnly;
  }

  // use_port - computed: false, optional: true, required: false
  private _usePort?: boolean | cdktf.IResolvable; 
  public get usePort() {
    return this.getBooleanAttribute('use_port');
  }
  public set usePort(value: boolean | cdktf.IResolvable) {
    this._usePort = value;
  }
  public resetUsePort() {
    this._usePort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usePortInput() {
    return this._usePort;
  }
}
export interface VirtualRouterEcmpAlgorithmIpModulo {
}

export function virtualRouterEcmpAlgorithmIpModuloToTerraform(struct?: VirtualRouterEcmpAlgorithmIpModulo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function virtualRouterEcmpAlgorithmIpModuloToHclTerraform(struct?: VirtualRouterEcmpAlgorithmIpModulo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class VirtualRouterEcmpAlgorithmIpModuloOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterEcmpAlgorithmIpModulo | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterEcmpAlgorithmIpModulo | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface VirtualRouterEcmpAlgorithmWeightedRoundRobinInterface {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#name VirtualRouter#name}
  */
  readonly name: string;
  /**
  * interface ECMP weight
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#weight VirtualRouter#weight}
  */
  readonly weight?: number;
}

export function virtualRouterEcmpAlgorithmWeightedRoundRobinInterfaceToTerraform(struct?: VirtualRouterEcmpAlgorithmWeightedRoundRobinInterface | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    weight: cdktf.numberToTerraform(struct!.weight),
  }
}


export function virtualRouterEcmpAlgorithmWeightedRoundRobinInterfaceToHclTerraform(struct?: VirtualRouterEcmpAlgorithmWeightedRoundRobinInterface | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    weight: {
      value: cdktf.numberToHclTerraform(struct!.weight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterEcmpAlgorithmWeightedRoundRobinInterfaceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): VirtualRouterEcmpAlgorithmWeightedRoundRobinInterface | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._weight !== undefined) {
      hasAnyValues = true;
      internalValueResult.weight = this._weight;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterEcmpAlgorithmWeightedRoundRobinInterface | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._weight = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._weight = value.weight;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // weight - computed: true, optional: true, required: false
  private _weight?: number; 
  public get weight() {
    return this.getNumberAttribute('weight');
  }
  public set weight(value: number) {
    this._weight = value;
  }
  public resetWeight() {
    this._weight = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get weightInput() {
    return this._weight;
  }
}

export class VirtualRouterEcmpAlgorithmWeightedRoundRobinInterfaceList extends cdktf.ComplexList {
  public internalValue? : VirtualRouterEcmpAlgorithmWeightedRoundRobinInterface[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): VirtualRouterEcmpAlgorithmWeightedRoundRobinInterfaceOutputReference {
    return new VirtualRouterEcmpAlgorithmWeightedRoundRobinInterfaceOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface VirtualRouterEcmpAlgorithmWeightedRoundRobin {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#interface VirtualRouter#interface}
  */
  readonly interface?: VirtualRouterEcmpAlgorithmWeightedRoundRobinInterface[] | cdktf.IResolvable;
}

export function virtualRouterEcmpAlgorithmWeightedRoundRobinToTerraform(struct?: VirtualRouterEcmpAlgorithmWeightedRoundRobin | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    interface: cdktf.listMapper(virtualRouterEcmpAlgorithmWeightedRoundRobinInterfaceToTerraform, false)(struct!.interface),
  }
}


export function virtualRouterEcmpAlgorithmWeightedRoundRobinToHclTerraform(struct?: VirtualRouterEcmpAlgorithmWeightedRoundRobin | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    interface: {
      value: cdktf.listMapperHcl(virtualRouterEcmpAlgorithmWeightedRoundRobinInterfaceToHclTerraform, false)(struct!.interface),
      isBlock: true,
      type: "list",
      storageClassType: "VirtualRouterEcmpAlgorithmWeightedRoundRobinInterfaceList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterEcmpAlgorithmWeightedRoundRobinOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterEcmpAlgorithmWeightedRoundRobin | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._interface?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.interface = this._interface?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterEcmpAlgorithmWeightedRoundRobin | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._interface.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._interface.internalValue = value.interface;
    }
  }

  // interface - computed: false, optional: true, required: false
  private _interface = new VirtualRouterEcmpAlgorithmWeightedRoundRobinInterfaceList(this, "interface", false);
  public get interface() {
    return this._interface;
  }
  public putInterface(value: VirtualRouterEcmpAlgorithmWeightedRoundRobinInterface[] | cdktf.IResolvable) {
    this._interface.internalValue = value;
  }
  public resetInterface() {
    this._interface.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfaceInput() {
    return this._interface.internalValue;
  }
}
export interface VirtualRouterEcmpAlgorithm {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#balanced_round_robin VirtualRouter#balanced_round_robin}
  */
  readonly balancedRoundRobin?: VirtualRouterEcmpAlgorithmBalancedRoundRobin;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#ip_hash VirtualRouter#ip_hash}
  */
  readonly ipHash?: VirtualRouterEcmpAlgorithmIpHash;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#ip_modulo VirtualRouter#ip_modulo}
  */
  readonly ipModulo?: VirtualRouterEcmpAlgorithmIpModulo;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#weighted_round_robin VirtualRouter#weighted_round_robin}
  */
  readonly weightedRoundRobin?: VirtualRouterEcmpAlgorithmWeightedRoundRobin;
}

export function virtualRouterEcmpAlgorithmToTerraform(struct?: VirtualRouterEcmpAlgorithm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    balanced_round_robin: virtualRouterEcmpAlgorithmBalancedRoundRobinToTerraform(struct!.balancedRoundRobin),
    ip_hash: virtualRouterEcmpAlgorithmIpHashToTerraform(struct!.ipHash),
    ip_modulo: virtualRouterEcmpAlgorithmIpModuloToTerraform(struct!.ipModulo),
    weighted_round_robin: virtualRouterEcmpAlgorithmWeightedRoundRobinToTerraform(struct!.weightedRoundRobin),
  }
}


export function virtualRouterEcmpAlgorithmToHclTerraform(struct?: VirtualRouterEcmpAlgorithm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    balanced_round_robin: {
      value: virtualRouterEcmpAlgorithmBalancedRoundRobinToHclTerraform(struct!.balancedRoundRobin),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterEcmpAlgorithmBalancedRoundRobin",
    },
    ip_hash: {
      value: virtualRouterEcmpAlgorithmIpHashToHclTerraform(struct!.ipHash),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterEcmpAlgorithmIpHash",
    },
    ip_modulo: {
      value: virtualRouterEcmpAlgorithmIpModuloToHclTerraform(struct!.ipModulo),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterEcmpAlgorithmIpModulo",
    },
    weighted_round_robin: {
      value: virtualRouterEcmpAlgorithmWeightedRoundRobinToHclTerraform(struct!.weightedRoundRobin),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterEcmpAlgorithmWeightedRoundRobin",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterEcmpAlgorithmOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterEcmpAlgorithm | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._balancedRoundRobin?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.balancedRoundRobin = this._balancedRoundRobin?.internalValue;
    }
    if (this._ipHash?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipHash = this._ipHash?.internalValue;
    }
    if (this._ipModulo?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipModulo = this._ipModulo?.internalValue;
    }
    if (this._weightedRoundRobin?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.weightedRoundRobin = this._weightedRoundRobin?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterEcmpAlgorithm | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._balancedRoundRobin.internalValue = undefined;
      this._ipHash.internalValue = undefined;
      this._ipModulo.internalValue = undefined;
      this._weightedRoundRobin.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._balancedRoundRobin.internalValue = value.balancedRoundRobin;
      this._ipHash.internalValue = value.ipHash;
      this._ipModulo.internalValue = value.ipModulo;
      this._weightedRoundRobin.internalValue = value.weightedRoundRobin;
    }
  }

  // balanced_round_robin - computed: false, optional: true, required: false
  private _balancedRoundRobin = new VirtualRouterEcmpAlgorithmBalancedRoundRobinOutputReference(this, "balanced_round_robin");
  public get balancedRoundRobin() {
    return this._balancedRoundRobin;
  }
  public putBalancedRoundRobin(value: VirtualRouterEcmpAlgorithmBalancedRoundRobin) {
    this._balancedRoundRobin.internalValue = value;
  }
  public resetBalancedRoundRobin() {
    this._balancedRoundRobin.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get balancedRoundRobinInput() {
    return this._balancedRoundRobin.internalValue;
  }

  // ip_hash - computed: false, optional: true, required: false
  private _ipHash = new VirtualRouterEcmpAlgorithmIpHashOutputReference(this, "ip_hash");
  public get ipHash() {
    return this._ipHash;
  }
  public putIpHash(value: VirtualRouterEcmpAlgorithmIpHash) {
    this._ipHash.internalValue = value;
  }
  public resetIpHash() {
    this._ipHash.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipHashInput() {
    return this._ipHash.internalValue;
  }

  // ip_modulo - computed: false, optional: true, required: false
  private _ipModulo = new VirtualRouterEcmpAlgorithmIpModuloOutputReference(this, "ip_modulo");
  public get ipModulo() {
    return this._ipModulo;
  }
  public putIpModulo(value: VirtualRouterEcmpAlgorithmIpModulo) {
    this._ipModulo.internalValue = value;
  }
  public resetIpModulo() {
    this._ipModulo.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipModuloInput() {
    return this._ipModulo.internalValue;
  }

  // weighted_round_robin - computed: false, optional: true, required: false
  private _weightedRoundRobin = new VirtualRouterEcmpAlgorithmWeightedRoundRobinOutputReference(this, "weighted_round_robin");
  public get weightedRoundRobin() {
    return this._weightedRoundRobin;
  }
  public putWeightedRoundRobin(value: VirtualRouterEcmpAlgorithmWeightedRoundRobin) {
    this._weightedRoundRobin.internalValue = value;
  }
  public resetWeightedRoundRobin() {
    this._weightedRoundRobin.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get weightedRoundRobinInput() {
    return this._weightedRoundRobin.internalValue;
  }
}
export interface VirtualRouterEcmp {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#algorithm VirtualRouter#algorithm}
  */
  readonly algorithm?: VirtualRouterEcmpAlgorithm;
  /**
  * enable Equal Cost Multipath routing, change this configuration will result in a virtual router restart
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#enable VirtualRouter#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * Maxmum number of ECMP paths supported, change this configuration will result in a virtual router restart
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#max_paths VirtualRouter#max_paths}
  */
  readonly maxPaths?: number;
  /**
  * force VPN traffic to exit interface that the source-ip belongs to
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#strict_source_path VirtualRouter#strict_source_path}
  */
  readonly strictSourcePath?: boolean | cdktf.IResolvable;
  /**
  * allows return packets to egress out of the ingress interface of the flow
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#symmetric_return VirtualRouter#symmetric_return}
  */
  readonly symmetricReturn?: boolean | cdktf.IResolvable;
}

export function virtualRouterEcmpToTerraform(struct?: VirtualRouterEcmp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    algorithm: virtualRouterEcmpAlgorithmToTerraform(struct!.algorithm),
    enable: cdktf.booleanToTerraform(struct!.enable),
    max_paths: cdktf.numberToTerraform(struct!.maxPaths),
    strict_source_path: cdktf.booleanToTerraform(struct!.strictSourcePath),
    symmetric_return: cdktf.booleanToTerraform(struct!.symmetricReturn),
  }
}


export function virtualRouterEcmpToHclTerraform(struct?: VirtualRouterEcmp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    algorithm: {
      value: virtualRouterEcmpAlgorithmToHclTerraform(struct!.algorithm),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterEcmpAlgorithm",
    },
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_paths: {
      value: cdktf.numberToHclTerraform(struct!.maxPaths),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    strict_source_path: {
      value: cdktf.booleanToHclTerraform(struct!.strictSourcePath),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    symmetric_return: {
      value: cdktf.booleanToHclTerraform(struct!.symmetricReturn),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterEcmpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterEcmp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._algorithm?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.algorithm = this._algorithm?.internalValue;
    }
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._maxPaths !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPaths = this._maxPaths;
    }
    if (this._strictSourcePath !== undefined) {
      hasAnyValues = true;
      internalValueResult.strictSourcePath = this._strictSourcePath;
    }
    if (this._symmetricReturn !== undefined) {
      hasAnyValues = true;
      internalValueResult.symmetricReturn = this._symmetricReturn;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterEcmp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._algorithm.internalValue = undefined;
      this._enable = undefined;
      this._maxPaths = undefined;
      this._strictSourcePath = undefined;
      this._symmetricReturn = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._algorithm.internalValue = value.algorithm;
      this._enable = value.enable;
      this._maxPaths = value.maxPaths;
      this._strictSourcePath = value.strictSourcePath;
      this._symmetricReturn = value.symmetricReturn;
    }
  }

  // algorithm - computed: false, optional: true, required: false
  private _algorithm = new VirtualRouterEcmpAlgorithmOutputReference(this, "algorithm");
  public get algorithm() {
    return this._algorithm;
  }
  public putAlgorithm(value: VirtualRouterEcmpAlgorithm) {
    this._algorithm.internalValue = value;
  }
  public resetAlgorithm() {
    this._algorithm.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get algorithmInput() {
    return this._algorithm.internalValue;
  }

  // enable - computed: false, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // max_paths - computed: true, optional: true, required: false
  private _maxPaths?: number; 
  public get maxPaths() {
    return this.getNumberAttribute('max_paths');
  }
  public set maxPaths(value: number) {
    this._maxPaths = value;
  }
  public resetMaxPaths() {
    this._maxPaths = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPathsInput() {
    return this._maxPaths;
  }

  // strict_source_path - computed: false, optional: true, required: false
  private _strictSourcePath?: boolean | cdktf.IResolvable; 
  public get strictSourcePath() {
    return this.getBooleanAttribute('strict_source_path');
  }
  public set strictSourcePath(value: boolean | cdktf.IResolvable) {
    this._strictSourcePath = value;
  }
  public resetStrictSourcePath() {
    this._strictSourcePath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get strictSourcePathInput() {
    return this._strictSourcePath;
  }

  // symmetric_return - computed: false, optional: true, required: false
  private _symmetricReturn?: boolean | cdktf.IResolvable; 
  public get symmetricReturn() {
    return this.getBooleanAttribute('symmetric_return');
  }
  public set symmetricReturn(value: boolean | cdktf.IResolvable) {
    this._symmetricReturn = value;
  }
  public resetSymmetricReturn() {
    this._symmetricReturn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get symmetricReturnInput() {
    return this._symmetricReturn;
  }
}
export interface VirtualRouterLocationNgfw {
  /**
  * The NGFW device
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#ngfw_device VirtualRouter#ngfw_device}
  */
  readonly ngfwDevice?: string;
}

export function virtualRouterLocationNgfwToTerraform(struct?: VirtualRouterLocationNgfw | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ngfw_device: cdktf.stringToTerraform(struct!.ngfwDevice),
  }
}


export function virtualRouterLocationNgfwToHclTerraform(struct?: VirtualRouterLocationNgfw | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ngfw_device: {
      value: cdktf.stringToHclTerraform(struct!.ngfwDevice),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterLocationNgfwOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterLocationNgfw | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ngfwDevice !== undefined) {
      hasAnyValues = true;
      internalValueResult.ngfwDevice = this._ngfwDevice;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterLocationNgfw | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ngfwDevice = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ngfwDevice = value.ngfwDevice;
    }
  }

  // ngfw_device - computed: true, optional: true, required: false
  private _ngfwDevice?: string; 
  public get ngfwDevice() {
    return this.getStringAttribute('ngfw_device');
  }
  public set ngfwDevice(value: string) {
    this._ngfwDevice = value;
  }
  public resetNgfwDevice() {
    this._ngfwDevice = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ngfwDeviceInput() {
    return this._ngfwDevice;
  }
}
export interface VirtualRouterLocationTemplate {
  /**
  * Specific Panorama template
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#name VirtualRouter#name}
  */
  readonly name?: string;
  /**
  * The NGFW device
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#ngfw_device VirtualRouter#ngfw_device}
  */
  readonly ngfwDevice?: string;
  /**
  * Specific Panorama device
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#panorama_device VirtualRouter#panorama_device}
  */
  readonly panoramaDevice?: string;
}

export function virtualRouterLocationTemplateToTerraform(struct?: VirtualRouterLocationTemplate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    ngfw_device: cdktf.stringToTerraform(struct!.ngfwDevice),
    panorama_device: cdktf.stringToTerraform(struct!.panoramaDevice),
  }
}


export function virtualRouterLocationTemplateToHclTerraform(struct?: VirtualRouterLocationTemplate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ngfw_device: {
      value: cdktf.stringToHclTerraform(struct!.ngfwDevice),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    panorama_device: {
      value: cdktf.stringToHclTerraform(struct!.panoramaDevice),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterLocationTemplateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterLocationTemplate | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._ngfwDevice !== undefined) {
      hasAnyValues = true;
      internalValueResult.ngfwDevice = this._ngfwDevice;
    }
    if (this._panoramaDevice !== undefined) {
      hasAnyValues = true;
      internalValueResult.panoramaDevice = this._panoramaDevice;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterLocationTemplate | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._ngfwDevice = undefined;
      this._panoramaDevice = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._ngfwDevice = value.ngfwDevice;
      this._panoramaDevice = value.panoramaDevice;
    }
  }

  // name - computed: true, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // ngfw_device - computed: true, optional: true, required: false
  private _ngfwDevice?: string; 
  public get ngfwDevice() {
    return this.getStringAttribute('ngfw_device');
  }
  public set ngfwDevice(value: string) {
    this._ngfwDevice = value;
  }
  public resetNgfwDevice() {
    this._ngfwDevice = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ngfwDeviceInput() {
    return this._ngfwDevice;
  }

  // panorama_device - computed: true, optional: true, required: false
  private _panoramaDevice?: string; 
  public get panoramaDevice() {
    return this.getStringAttribute('panorama_device');
  }
  public set panoramaDevice(value: string) {
    this._panoramaDevice = value;
  }
  public resetPanoramaDevice() {
    this._panoramaDevice = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get panoramaDeviceInput() {
    return this._panoramaDevice;
  }
}
export interface VirtualRouterLocationTemplateStack {
  /**
  * Specific Panorama template stack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#name VirtualRouter#name}
  */
  readonly name?: string;
  /**
  * The NGFW device
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#ngfw_device VirtualRouter#ngfw_device}
  */
  readonly ngfwDevice?: string;
  /**
  * Specific Panorama device
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#panorama_device VirtualRouter#panorama_device}
  */
  readonly panoramaDevice?: string;
}

export function virtualRouterLocationTemplateStackToTerraform(struct?: VirtualRouterLocationTemplateStack | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    ngfw_device: cdktf.stringToTerraform(struct!.ngfwDevice),
    panorama_device: cdktf.stringToTerraform(struct!.panoramaDevice),
  }
}


export function virtualRouterLocationTemplateStackToHclTerraform(struct?: VirtualRouterLocationTemplateStack | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ngfw_device: {
      value: cdktf.stringToHclTerraform(struct!.ngfwDevice),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    panorama_device: {
      value: cdktf.stringToHclTerraform(struct!.panoramaDevice),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterLocationTemplateStackOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterLocationTemplateStack | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._ngfwDevice !== undefined) {
      hasAnyValues = true;
      internalValueResult.ngfwDevice = this._ngfwDevice;
    }
    if (this._panoramaDevice !== undefined) {
      hasAnyValues = true;
      internalValueResult.panoramaDevice = this._panoramaDevice;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterLocationTemplateStack | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._ngfwDevice = undefined;
      this._panoramaDevice = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._ngfwDevice = value.ngfwDevice;
      this._panoramaDevice = value.panoramaDevice;
    }
  }

  // name - computed: true, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // ngfw_device - computed: true, optional: true, required: false
  private _ngfwDevice?: string; 
  public get ngfwDevice() {
    return this.getStringAttribute('ngfw_device');
  }
  public set ngfwDevice(value: string) {
    this._ngfwDevice = value;
  }
  public resetNgfwDevice() {
    this._ngfwDevice = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ngfwDeviceInput() {
    return this._ngfwDevice;
  }

  // panorama_device - computed: true, optional: true, required: false
  private _panoramaDevice?: string; 
  public get panoramaDevice() {
    return this.getStringAttribute('panorama_device');
  }
  public set panoramaDevice(value: string) {
    this._panoramaDevice = value;
  }
  public resetPanoramaDevice() {
    this._panoramaDevice = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get panoramaDeviceInput() {
    return this._panoramaDevice;
  }
}
export interface VirtualRouterLocation {
  /**
  * Located in a specific NGFW device
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#ngfw VirtualRouter#ngfw}
  */
  readonly ngfw?: VirtualRouterLocationNgfw;
  /**
  * Located in a specific template
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#template VirtualRouter#template}
  */
  readonly template?: VirtualRouterLocationTemplate;
  /**
  * Located in a specific template stack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#template_stack VirtualRouter#template_stack}
  */
  readonly templateStack?: VirtualRouterLocationTemplateStack;
}

export function virtualRouterLocationToTerraform(struct?: VirtualRouterLocation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ngfw: virtualRouterLocationNgfwToTerraform(struct!.ngfw),
    template: virtualRouterLocationTemplateToTerraform(struct!.template),
    template_stack: virtualRouterLocationTemplateStackToTerraform(struct!.templateStack),
  }
}


export function virtualRouterLocationToHclTerraform(struct?: VirtualRouterLocation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ngfw: {
      value: virtualRouterLocationNgfwToHclTerraform(struct!.ngfw),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterLocationNgfw",
    },
    template: {
      value: virtualRouterLocationTemplateToHclTerraform(struct!.template),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterLocationTemplate",
    },
    template_stack: {
      value: virtualRouterLocationTemplateStackToHclTerraform(struct!.templateStack),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterLocationTemplateStack",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterLocationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterLocation | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ngfw?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ngfw = this._ngfw?.internalValue;
    }
    if (this._template?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.template = this._template?.internalValue;
    }
    if (this._templateStack?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.templateStack = this._templateStack?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterLocation | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ngfw.internalValue = undefined;
      this._template.internalValue = undefined;
      this._templateStack.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ngfw.internalValue = value.ngfw;
      this._template.internalValue = value.template;
      this._templateStack.internalValue = value.templateStack;
    }
  }

  // ngfw - computed: false, optional: true, required: false
  private _ngfw = new VirtualRouterLocationNgfwOutputReference(this, "ngfw");
  public get ngfw() {
    return this._ngfw;
  }
  public putNgfw(value: VirtualRouterLocationNgfw) {
    this._ngfw.internalValue = value;
  }
  public resetNgfw() {
    this._ngfw.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ngfwInput() {
    return this._ngfw.internalValue;
  }

  // template - computed: false, optional: true, required: false
  private _template = new VirtualRouterLocationTemplateOutputReference(this, "template");
  public get template() {
    return this._template;
  }
  public putTemplate(value: VirtualRouterLocationTemplate) {
    this._template.internalValue = value;
  }
  public resetTemplate() {
    this._template.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get templateInput() {
    return this._template.internalValue;
  }

  // template_stack - computed: false, optional: true, required: false
  private _templateStack = new VirtualRouterLocationTemplateStackOutputReference(this, "template_stack");
  public get templateStack() {
    return this._templateStack;
  }
  public putTemplateStack(value: VirtualRouterLocationTemplateStack) {
    this._templateStack.internalValue = value;
  }
  public resetTemplateStack() {
    this._templateStack.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get templateStackInput() {
    return this._templateStack.internalValue;
  }
}
export interface VirtualRouterMulticastInterfaceGroupGroupPermissionAnySourceMulticast {
  /**
  * group-address/prefix
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#group_address VirtualRouter#group_address}
  */
  readonly groupAddress?: string;
  /**
  * included
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#included VirtualRouter#included}
  */
  readonly included?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#name VirtualRouter#name}
  */
  readonly name: string;
}

export function virtualRouterMulticastInterfaceGroupGroupPermissionAnySourceMulticastToTerraform(struct?: VirtualRouterMulticastInterfaceGroupGroupPermissionAnySourceMulticast | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    group_address: cdktf.stringToTerraform(struct!.groupAddress),
    included: cdktf.booleanToTerraform(struct!.included),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function virtualRouterMulticastInterfaceGroupGroupPermissionAnySourceMulticastToHclTerraform(struct?: VirtualRouterMulticastInterfaceGroupGroupPermissionAnySourceMulticast | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    group_address: {
      value: cdktf.stringToHclTerraform(struct!.groupAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    included: {
      value: cdktf.booleanToHclTerraform(struct!.included),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterMulticastInterfaceGroupGroupPermissionAnySourceMulticastOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): VirtualRouterMulticastInterfaceGroupGroupPermissionAnySourceMulticast | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._groupAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupAddress = this._groupAddress;
    }
    if (this._included !== undefined) {
      hasAnyValues = true;
      internalValueResult.included = this._included;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterMulticastInterfaceGroupGroupPermissionAnySourceMulticast | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._groupAddress = undefined;
      this._included = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._groupAddress = value.groupAddress;
      this._included = value.included;
      this._name = value.name;
    }
  }

  // group_address - computed: false, optional: true, required: false
  private _groupAddress?: string; 
  public get groupAddress() {
    return this.getStringAttribute('group_address');
  }
  public set groupAddress(value: string) {
    this._groupAddress = value;
  }
  public resetGroupAddress() {
    this._groupAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupAddressInput() {
    return this._groupAddress;
  }

  // included - computed: false, optional: true, required: false
  private _included?: boolean | cdktf.IResolvable; 
  public get included() {
    return this.getBooleanAttribute('included');
  }
  public set included(value: boolean | cdktf.IResolvable) {
    this._included = value;
  }
  public resetIncluded() {
    this._included = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get includedInput() {
    return this._included;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class VirtualRouterMulticastInterfaceGroupGroupPermissionAnySourceMulticastList extends cdktf.ComplexList {
  public internalValue? : VirtualRouterMulticastInterfaceGroupGroupPermissionAnySourceMulticast[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): VirtualRouterMulticastInterfaceGroupGroupPermissionAnySourceMulticastOutputReference {
    return new VirtualRouterMulticastInterfaceGroupGroupPermissionAnySourceMulticastOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface VirtualRouterMulticastInterfaceGroupGroupPermissionSourceSpecificMulticast {
  /**
  * group-address/prefix
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#group_address VirtualRouter#group_address}
  */
  readonly groupAddress?: string;
  /**
  * included
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#included VirtualRouter#included}
  */
  readonly included?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#name VirtualRouter#name}
  */
  readonly name: string;
  /**
  * source-address/prefix
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#source_address VirtualRouter#source_address}
  */
  readonly sourceAddress?: string;
}

export function virtualRouterMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastToTerraform(struct?: VirtualRouterMulticastInterfaceGroupGroupPermissionSourceSpecificMulticast | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    group_address: cdktf.stringToTerraform(struct!.groupAddress),
    included: cdktf.booleanToTerraform(struct!.included),
    name: cdktf.stringToTerraform(struct!.name),
    source_address: cdktf.stringToTerraform(struct!.sourceAddress),
  }
}


export function virtualRouterMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastToHclTerraform(struct?: VirtualRouterMulticastInterfaceGroupGroupPermissionSourceSpecificMulticast | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    group_address: {
      value: cdktf.stringToHclTerraform(struct!.groupAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    included: {
      value: cdktf.booleanToHclTerraform(struct!.included),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    source_address: {
      value: cdktf.stringToHclTerraform(struct!.sourceAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): VirtualRouterMulticastInterfaceGroupGroupPermissionSourceSpecificMulticast | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._groupAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupAddress = this._groupAddress;
    }
    if (this._included !== undefined) {
      hasAnyValues = true;
      internalValueResult.included = this._included;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._sourceAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceAddress = this._sourceAddress;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterMulticastInterfaceGroupGroupPermissionSourceSpecificMulticast | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._groupAddress = undefined;
      this._included = undefined;
      this._name = undefined;
      this._sourceAddress = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._groupAddress = value.groupAddress;
      this._included = value.included;
      this._name = value.name;
      this._sourceAddress = value.sourceAddress;
    }
  }

  // group_address - computed: false, optional: true, required: false
  private _groupAddress?: string; 
  public get groupAddress() {
    return this.getStringAttribute('group_address');
  }
  public set groupAddress(value: string) {
    this._groupAddress = value;
  }
  public resetGroupAddress() {
    this._groupAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupAddressInput() {
    return this._groupAddress;
  }

  // included - computed: false, optional: true, required: false
  private _included?: boolean | cdktf.IResolvable; 
  public get included() {
    return this.getBooleanAttribute('included');
  }
  public set included(value: boolean | cdktf.IResolvable) {
    this._included = value;
  }
  public resetIncluded() {
    this._included = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get includedInput() {
    return this._included;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // source_address - computed: false, optional: true, required: false
  private _sourceAddress?: string; 
  public get sourceAddress() {
    return this.getStringAttribute('source_address');
  }
  public set sourceAddress(value: string) {
    this._sourceAddress = value;
  }
  public resetSourceAddress() {
    this._sourceAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceAddressInput() {
    return this._sourceAddress;
  }
}

export class VirtualRouterMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastList extends cdktf.ComplexList {
  public internalValue? : VirtualRouterMulticastInterfaceGroupGroupPermissionSourceSpecificMulticast[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): VirtualRouterMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastOutputReference {
    return new VirtualRouterMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface VirtualRouterMulticastInterfaceGroupGroupPermission {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#any_source_multicast VirtualRouter#any_source_multicast}
  */
  readonly anySourceMulticast?: VirtualRouterMulticastInterfaceGroupGroupPermissionAnySourceMulticast[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#source_specific_multicast VirtualRouter#source_specific_multicast}
  */
  readonly sourceSpecificMulticast?: VirtualRouterMulticastInterfaceGroupGroupPermissionSourceSpecificMulticast[] | cdktf.IResolvable;
}

export function virtualRouterMulticastInterfaceGroupGroupPermissionToTerraform(struct?: VirtualRouterMulticastInterfaceGroupGroupPermission | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    any_source_multicast: cdktf.listMapper(virtualRouterMulticastInterfaceGroupGroupPermissionAnySourceMulticastToTerraform, false)(struct!.anySourceMulticast),
    source_specific_multicast: cdktf.listMapper(virtualRouterMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastToTerraform, false)(struct!.sourceSpecificMulticast),
  }
}


export function virtualRouterMulticastInterfaceGroupGroupPermissionToHclTerraform(struct?: VirtualRouterMulticastInterfaceGroupGroupPermission | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    any_source_multicast: {
      value: cdktf.listMapperHcl(virtualRouterMulticastInterfaceGroupGroupPermissionAnySourceMulticastToHclTerraform, false)(struct!.anySourceMulticast),
      isBlock: true,
      type: "list",
      storageClassType: "VirtualRouterMulticastInterfaceGroupGroupPermissionAnySourceMulticastList",
    },
    source_specific_multicast: {
      value: cdktf.listMapperHcl(virtualRouterMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastToHclTerraform, false)(struct!.sourceSpecificMulticast),
      isBlock: true,
      type: "list",
      storageClassType: "VirtualRouterMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterMulticastInterfaceGroupGroupPermissionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterMulticastInterfaceGroupGroupPermission | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._anySourceMulticast?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.anySourceMulticast = this._anySourceMulticast?.internalValue;
    }
    if (this._sourceSpecificMulticast?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceSpecificMulticast = this._sourceSpecificMulticast?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterMulticastInterfaceGroupGroupPermission | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._anySourceMulticast.internalValue = undefined;
      this._sourceSpecificMulticast.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._anySourceMulticast.internalValue = value.anySourceMulticast;
      this._sourceSpecificMulticast.internalValue = value.sourceSpecificMulticast;
    }
  }

  // any_source_multicast - computed: false, optional: true, required: false
  private _anySourceMulticast = new VirtualRouterMulticastInterfaceGroupGroupPermissionAnySourceMulticastList(this, "any_source_multicast", false);
  public get anySourceMulticast() {
    return this._anySourceMulticast;
  }
  public putAnySourceMulticast(value: VirtualRouterMulticastInterfaceGroupGroupPermissionAnySourceMulticast[] | cdktf.IResolvable) {
    this._anySourceMulticast.internalValue = value;
  }
  public resetAnySourceMulticast() {
    this._anySourceMulticast.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get anySourceMulticastInput() {
    return this._anySourceMulticast.internalValue;
  }

  // source_specific_multicast - computed: false, optional: true, required: false
  private _sourceSpecificMulticast = new VirtualRouterMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastList(this, "source_specific_multicast", false);
  public get sourceSpecificMulticast() {
    return this._sourceSpecificMulticast;
  }
  public putSourceSpecificMulticast(value: VirtualRouterMulticastInterfaceGroupGroupPermissionSourceSpecificMulticast[] | cdktf.IResolvable) {
    this._sourceSpecificMulticast.internalValue = value;
  }
  public resetSourceSpecificMulticast() {
    this._sourceSpecificMulticast.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceSpecificMulticastInput() {
    return this._sourceSpecificMulticast.internalValue;
  }
}
export interface VirtualRouterMulticastInterfaceGroupIgmp {
  /**
  * enable IGMP
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#enable VirtualRouter#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * leave group immediately when a leave message is received
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#immediate_leave VirtualRouter#immediate_leave}
  */
  readonly immediateLeave?: boolean | cdktf.IResolvable;
  /**
  * interval between group/source specific query messages (including those sent in response of leave group messages)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#last_member_query_interval VirtualRouter#last_member_query_interval}
  */
  readonly lastMemberQueryInterval?: number;
  /**
  * maximum number of groups allowed on this interface
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#max_groups VirtualRouter#max_groups}
  */
  readonly maxGroups?: string;
  /**
  * maximum query response time for general group membership queries in seconds
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#max_query_response_time VirtualRouter#max_query_response_time}
  */
  readonly maxQueryResponseTime?: number;
  /**
  * maximum number of source-specific memberships allowed on this interface
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#max_sources VirtualRouter#max_sources}
  */
  readonly maxSources?: string;
  /**
  * interval between group/source specific query messages
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#query_interval VirtualRouter#query_interval}
  */
  readonly queryInterval?: number;
  /**
  * robustness variable
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#robustness VirtualRouter#robustness}
  */
  readonly robustness?: string;
  /**
  * drop IGMP packets without Router Alert option
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#router_alert_policing VirtualRouter#router_alert_policing}
  */
  readonly routerAlertPolicing?: boolean | cdktf.IResolvable;
  /**
  * IGMP version number
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#version VirtualRouter#version}
  */
  readonly version?: string;
}

export function virtualRouterMulticastInterfaceGroupIgmpToTerraform(struct?: VirtualRouterMulticastInterfaceGroupIgmp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enable: cdktf.booleanToTerraform(struct!.enable),
    immediate_leave: cdktf.booleanToTerraform(struct!.immediateLeave),
    last_member_query_interval: cdktf.numberToTerraform(struct!.lastMemberQueryInterval),
    max_groups: cdktf.stringToTerraform(struct!.maxGroups),
    max_query_response_time: cdktf.numberToTerraform(struct!.maxQueryResponseTime),
    max_sources: cdktf.stringToTerraform(struct!.maxSources),
    query_interval: cdktf.numberToTerraform(struct!.queryInterval),
    robustness: cdktf.stringToTerraform(struct!.robustness),
    router_alert_policing: cdktf.booleanToTerraform(struct!.routerAlertPolicing),
    version: cdktf.stringToTerraform(struct!.version),
  }
}


export function virtualRouterMulticastInterfaceGroupIgmpToHclTerraform(struct?: VirtualRouterMulticastInterfaceGroupIgmp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    immediate_leave: {
      value: cdktf.booleanToHclTerraform(struct!.immediateLeave),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    last_member_query_interval: {
      value: cdktf.numberToHclTerraform(struct!.lastMemberQueryInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_groups: {
      value: cdktf.stringToHclTerraform(struct!.maxGroups),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_query_response_time: {
      value: cdktf.numberToHclTerraform(struct!.maxQueryResponseTime),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_sources: {
      value: cdktf.stringToHclTerraform(struct!.maxSources),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    query_interval: {
      value: cdktf.numberToHclTerraform(struct!.queryInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    robustness: {
      value: cdktf.stringToHclTerraform(struct!.robustness),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    router_alert_policing: {
      value: cdktf.booleanToHclTerraform(struct!.routerAlertPolicing),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    version: {
      value: cdktf.stringToHclTerraform(struct!.version),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterMulticastInterfaceGroupIgmpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterMulticastInterfaceGroupIgmp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._immediateLeave !== undefined) {
      hasAnyValues = true;
      internalValueResult.immediateLeave = this._immediateLeave;
    }
    if (this._lastMemberQueryInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.lastMemberQueryInterval = this._lastMemberQueryInterval;
    }
    if (this._maxGroups !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxGroups = this._maxGroups;
    }
    if (this._maxQueryResponseTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxQueryResponseTime = this._maxQueryResponseTime;
    }
    if (this._maxSources !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSources = this._maxSources;
    }
    if (this._queryInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.queryInterval = this._queryInterval;
    }
    if (this._robustness !== undefined) {
      hasAnyValues = true;
      internalValueResult.robustness = this._robustness;
    }
    if (this._routerAlertPolicing !== undefined) {
      hasAnyValues = true;
      internalValueResult.routerAlertPolicing = this._routerAlertPolicing;
    }
    if (this._version !== undefined) {
      hasAnyValues = true;
      internalValueResult.version = this._version;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterMulticastInterfaceGroupIgmp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enable = undefined;
      this._immediateLeave = undefined;
      this._lastMemberQueryInterval = undefined;
      this._maxGroups = undefined;
      this._maxQueryResponseTime = undefined;
      this._maxSources = undefined;
      this._queryInterval = undefined;
      this._robustness = undefined;
      this._routerAlertPolicing = undefined;
      this._version = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enable = value.enable;
      this._immediateLeave = value.immediateLeave;
      this._lastMemberQueryInterval = value.lastMemberQueryInterval;
      this._maxGroups = value.maxGroups;
      this._maxQueryResponseTime = value.maxQueryResponseTime;
      this._maxSources = value.maxSources;
      this._queryInterval = value.queryInterval;
      this._robustness = value.robustness;
      this._routerAlertPolicing = value.routerAlertPolicing;
      this._version = value.version;
    }
  }

  // enable - computed: false, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // immediate_leave - computed: false, optional: true, required: false
  private _immediateLeave?: boolean | cdktf.IResolvable; 
  public get immediateLeave() {
    return this.getBooleanAttribute('immediate_leave');
  }
  public set immediateLeave(value: boolean | cdktf.IResolvable) {
    this._immediateLeave = value;
  }
  public resetImmediateLeave() {
    this._immediateLeave = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get immediateLeaveInput() {
    return this._immediateLeave;
  }

  // last_member_query_interval - computed: false, optional: true, required: false
  private _lastMemberQueryInterval?: number; 
  public get lastMemberQueryInterval() {
    return this.getNumberAttribute('last_member_query_interval');
  }
  public set lastMemberQueryInterval(value: number) {
    this._lastMemberQueryInterval = value;
  }
  public resetLastMemberQueryInterval() {
    this._lastMemberQueryInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lastMemberQueryIntervalInput() {
    return this._lastMemberQueryInterval;
  }

  // max_groups - computed: true, optional: true, required: false
  private _maxGroups?: string; 
  public get maxGroups() {
    return this.getStringAttribute('max_groups');
  }
  public set maxGroups(value: string) {
    this._maxGroups = value;
  }
  public resetMaxGroups() {
    this._maxGroups = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxGroupsInput() {
    return this._maxGroups;
  }

  // max_query_response_time - computed: false, optional: true, required: false
  private _maxQueryResponseTime?: number; 
  public get maxQueryResponseTime() {
    return this.getNumberAttribute('max_query_response_time');
  }
  public set maxQueryResponseTime(value: number) {
    this._maxQueryResponseTime = value;
  }
  public resetMaxQueryResponseTime() {
    this._maxQueryResponseTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxQueryResponseTimeInput() {
    return this._maxQueryResponseTime;
  }

  // max_sources - computed: true, optional: true, required: false
  private _maxSources?: string; 
  public get maxSources() {
    return this.getStringAttribute('max_sources');
  }
  public set maxSources(value: string) {
    this._maxSources = value;
  }
  public resetMaxSources() {
    this._maxSources = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSourcesInput() {
    return this._maxSources;
  }

  // query_interval - computed: true, optional: true, required: false
  private _queryInterval?: number; 
  public get queryInterval() {
    return this.getNumberAttribute('query_interval');
  }
  public set queryInterval(value: number) {
    this._queryInterval = value;
  }
  public resetQueryInterval() {
    this._queryInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get queryIntervalInput() {
    return this._queryInterval;
  }

  // robustness - computed: true, optional: true, required: false
  private _robustness?: string; 
  public get robustness() {
    return this.getStringAttribute('robustness');
  }
  public set robustness(value: string) {
    this._robustness = value;
  }
  public resetRobustness() {
    this._robustness = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get robustnessInput() {
    return this._robustness;
  }

  // router_alert_policing - computed: false, optional: true, required: false
  private _routerAlertPolicing?: boolean | cdktf.IResolvable; 
  public get routerAlertPolicing() {
    return this.getBooleanAttribute('router_alert_policing');
  }
  public set routerAlertPolicing(value: boolean | cdktf.IResolvable) {
    this._routerAlertPolicing = value;
  }
  public resetRouterAlertPolicing() {
    this._routerAlertPolicing = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routerAlertPolicingInput() {
    return this._routerAlertPolicing;
  }

  // version - computed: true, optional: true, required: false
  private _version?: string; 
  public get version() {
    return this.getStringAttribute('version');
  }
  public set version(value: string) {
    this._version = value;
  }
  public resetVersion() {
    this._version = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get versionInput() {
    return this._version;
  }
}
export interface VirtualRouterMulticastInterfaceGroupPimAllowedNeighbors {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#name VirtualRouter#name}
  */
  readonly name: string;
}

export function virtualRouterMulticastInterfaceGroupPimAllowedNeighborsToTerraform(struct?: VirtualRouterMulticastInterfaceGroupPimAllowedNeighbors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function virtualRouterMulticastInterfaceGroupPimAllowedNeighborsToHclTerraform(struct?: VirtualRouterMulticastInterfaceGroupPimAllowedNeighbors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterMulticastInterfaceGroupPimAllowedNeighborsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): VirtualRouterMulticastInterfaceGroupPimAllowedNeighbors | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterMulticastInterfaceGroupPimAllowedNeighbors | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class VirtualRouterMulticastInterfaceGroupPimAllowedNeighborsList extends cdktf.ComplexList {
  public internalValue? : VirtualRouterMulticastInterfaceGroupPimAllowedNeighbors[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): VirtualRouterMulticastInterfaceGroupPimAllowedNeighborsOutputReference {
    return new VirtualRouterMulticastInterfaceGroupPimAllowedNeighborsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface VirtualRouterMulticastInterfaceGroupPim {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#allowed_neighbors VirtualRouter#allowed_neighbors}
  */
  readonly allowedNeighbors?: VirtualRouterMulticastInterfaceGroupPimAllowedNeighbors[] | cdktf.IResolvable;
  /**
  * interval between PIM Assert messages, in seconds
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#assert_interval VirtualRouter#assert_interval}
  */
  readonly assertInterval?: number;
  /**
  * interface is bootstrap border
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#bsr_border VirtualRouter#bsr_border}
  */
  readonly bsrBorder?: boolean | cdktf.IResolvable;
  /**
  * Designated Router priority
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#dr_priority VirtualRouter#dr_priority}
  */
  readonly drPriority?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#enable VirtualRouter#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * interval between PIM Hello messages, in seconds, a value of 0 represents an 'infinite' interval
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#hello_interval VirtualRouter#hello_interval}
  */
  readonly helloInterval?: number;
  /**
  * interval between PIM Join/Prune messages, in seconds
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#join_prune_interval VirtualRouter#join_prune_interval}
  */
  readonly joinPruneInterval?: number;
}

export function virtualRouterMulticastInterfaceGroupPimToTerraform(struct?: VirtualRouterMulticastInterfaceGroupPim | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allowed_neighbors: cdktf.listMapper(virtualRouterMulticastInterfaceGroupPimAllowedNeighborsToTerraform, false)(struct!.allowedNeighbors),
    assert_interval: cdktf.numberToTerraform(struct!.assertInterval),
    bsr_border: cdktf.booleanToTerraform(struct!.bsrBorder),
    dr_priority: cdktf.numberToTerraform(struct!.drPriority),
    enable: cdktf.booleanToTerraform(struct!.enable),
    hello_interval: cdktf.numberToTerraform(struct!.helloInterval),
    join_prune_interval: cdktf.numberToTerraform(struct!.joinPruneInterval),
  }
}


export function virtualRouterMulticastInterfaceGroupPimToHclTerraform(struct?: VirtualRouterMulticastInterfaceGroupPim | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allowed_neighbors: {
      value: cdktf.listMapperHcl(virtualRouterMulticastInterfaceGroupPimAllowedNeighborsToHclTerraform, false)(struct!.allowedNeighbors),
      isBlock: true,
      type: "list",
      storageClassType: "VirtualRouterMulticastInterfaceGroupPimAllowedNeighborsList",
    },
    assert_interval: {
      value: cdktf.numberToHclTerraform(struct!.assertInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    bsr_border: {
      value: cdktf.booleanToHclTerraform(struct!.bsrBorder),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    dr_priority: {
      value: cdktf.numberToHclTerraform(struct!.drPriority),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    hello_interval: {
      value: cdktf.numberToHclTerraform(struct!.helloInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    join_prune_interval: {
      value: cdktf.numberToHclTerraform(struct!.joinPruneInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterMulticastInterfaceGroupPimOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterMulticastInterfaceGroupPim | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowedNeighbors?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowedNeighbors = this._allowedNeighbors?.internalValue;
    }
    if (this._assertInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.assertInterval = this._assertInterval;
    }
    if (this._bsrBorder !== undefined) {
      hasAnyValues = true;
      internalValueResult.bsrBorder = this._bsrBorder;
    }
    if (this._drPriority !== undefined) {
      hasAnyValues = true;
      internalValueResult.drPriority = this._drPriority;
    }
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._helloInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.helloInterval = this._helloInterval;
    }
    if (this._joinPruneInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.joinPruneInterval = this._joinPruneInterval;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterMulticastInterfaceGroupPim | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allowedNeighbors.internalValue = undefined;
      this._assertInterval = undefined;
      this._bsrBorder = undefined;
      this._drPriority = undefined;
      this._enable = undefined;
      this._helloInterval = undefined;
      this._joinPruneInterval = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allowedNeighbors.internalValue = value.allowedNeighbors;
      this._assertInterval = value.assertInterval;
      this._bsrBorder = value.bsrBorder;
      this._drPriority = value.drPriority;
      this._enable = value.enable;
      this._helloInterval = value.helloInterval;
      this._joinPruneInterval = value.joinPruneInterval;
    }
  }

  // allowed_neighbors - computed: false, optional: true, required: false
  private _allowedNeighbors = new VirtualRouterMulticastInterfaceGroupPimAllowedNeighborsList(this, "allowed_neighbors", false);
  public get allowedNeighbors() {
    return this._allowedNeighbors;
  }
  public putAllowedNeighbors(value: VirtualRouterMulticastInterfaceGroupPimAllowedNeighbors[] | cdktf.IResolvable) {
    this._allowedNeighbors.internalValue = value;
  }
  public resetAllowedNeighbors() {
    this._allowedNeighbors.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowedNeighborsInput() {
    return this._allowedNeighbors.internalValue;
  }

  // assert_interval - computed: true, optional: true, required: false
  private _assertInterval?: number; 
  public get assertInterval() {
    return this.getNumberAttribute('assert_interval');
  }
  public set assertInterval(value: number) {
    this._assertInterval = value;
  }
  public resetAssertInterval() {
    this._assertInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assertIntervalInput() {
    return this._assertInterval;
  }

  // bsr_border - computed: false, optional: true, required: false
  private _bsrBorder?: boolean | cdktf.IResolvable; 
  public get bsrBorder() {
    return this.getBooleanAttribute('bsr_border');
  }
  public set bsrBorder(value: boolean | cdktf.IResolvable) {
    this._bsrBorder = value;
  }
  public resetBsrBorder() {
    this._bsrBorder = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bsrBorderInput() {
    return this._bsrBorder;
  }

  // dr_priority - computed: true, optional: true, required: false
  private _drPriority?: number; 
  public get drPriority() {
    return this.getNumberAttribute('dr_priority');
  }
  public set drPriority(value: number) {
    this._drPriority = value;
  }
  public resetDrPriority() {
    this._drPriority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get drPriorityInput() {
    return this._drPriority;
  }

  // enable - computed: false, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // hello_interval - computed: true, optional: true, required: false
  private _helloInterval?: number; 
  public get helloInterval() {
    return this.getNumberAttribute('hello_interval');
  }
  public set helloInterval(value: number) {
    this._helloInterval = value;
  }
  public resetHelloInterval() {
    this._helloInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get helloIntervalInput() {
    return this._helloInterval;
  }

  // join_prune_interval - computed: true, optional: true, required: false
  private _joinPruneInterval?: number; 
  public get joinPruneInterval() {
    return this.getNumberAttribute('join_prune_interval');
  }
  public set joinPruneInterval(value: number) {
    this._joinPruneInterval = value;
  }
  public resetJoinPruneInterval() {
    this._joinPruneInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get joinPruneIntervalInput() {
    return this._joinPruneInterval;
  }
}
export interface VirtualRouterMulticastInterfaceGroup {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#description VirtualRouter#description}
  */
  readonly description?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#group_permission VirtualRouter#group_permission}
  */
  readonly groupPermission?: VirtualRouterMulticastInterfaceGroupGroupPermission;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#igmp VirtualRouter#igmp}
  */
  readonly igmp?: VirtualRouterMulticastInterfaceGroupIgmp;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#interface VirtualRouter#interface}
  */
  readonly interface?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#name VirtualRouter#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#pim VirtualRouter#pim}
  */
  readonly pim?: VirtualRouterMulticastInterfaceGroupPim;
}

export function virtualRouterMulticastInterfaceGroupToTerraform(struct?: VirtualRouterMulticastInterfaceGroup | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    description: cdktf.stringToTerraform(struct!.description),
    group_permission: virtualRouterMulticastInterfaceGroupGroupPermissionToTerraform(struct!.groupPermission),
    igmp: virtualRouterMulticastInterfaceGroupIgmpToTerraform(struct!.igmp),
    interface: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.interface),
    name: cdktf.stringToTerraform(struct!.name),
    pim: virtualRouterMulticastInterfaceGroupPimToTerraform(struct!.pim),
  }
}


export function virtualRouterMulticastInterfaceGroupToHclTerraform(struct?: VirtualRouterMulticastInterfaceGroup | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    group_permission: {
      value: virtualRouterMulticastInterfaceGroupGroupPermissionToHclTerraform(struct!.groupPermission),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterMulticastInterfaceGroupGroupPermission",
    },
    igmp: {
      value: virtualRouterMulticastInterfaceGroupIgmpToHclTerraform(struct!.igmp),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterMulticastInterfaceGroupIgmp",
    },
    interface: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.interface),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pim: {
      value: virtualRouterMulticastInterfaceGroupPimToHclTerraform(struct!.pim),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterMulticastInterfaceGroupPim",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterMulticastInterfaceGroupOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): VirtualRouterMulticastInterfaceGroup | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._groupPermission?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupPermission = this._groupPermission?.internalValue;
    }
    if (this._igmp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.igmp = this._igmp?.internalValue;
    }
    if (this._interface !== undefined) {
      hasAnyValues = true;
      internalValueResult.interface = this._interface;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._pim?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pim = this._pim?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterMulticastInterfaceGroup | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._description = undefined;
      this._groupPermission.internalValue = undefined;
      this._igmp.internalValue = undefined;
      this._interface = undefined;
      this._name = undefined;
      this._pim.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._description = value.description;
      this._groupPermission.internalValue = value.groupPermission;
      this._igmp.internalValue = value.igmp;
      this._interface = value.interface;
      this._name = value.name;
      this._pim.internalValue = value.pim;
    }
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // group_permission - computed: false, optional: true, required: false
  private _groupPermission = new VirtualRouterMulticastInterfaceGroupGroupPermissionOutputReference(this, "group_permission");
  public get groupPermission() {
    return this._groupPermission;
  }
  public putGroupPermission(value: VirtualRouterMulticastInterfaceGroupGroupPermission) {
    this._groupPermission.internalValue = value;
  }
  public resetGroupPermission() {
    this._groupPermission.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupPermissionInput() {
    return this._groupPermission.internalValue;
  }

  // igmp - computed: false, optional: true, required: false
  private _igmp = new VirtualRouterMulticastInterfaceGroupIgmpOutputReference(this, "igmp");
  public get igmp() {
    return this._igmp;
  }
  public putIgmp(value: VirtualRouterMulticastInterfaceGroupIgmp) {
    this._igmp.internalValue = value;
  }
  public resetIgmp() {
    this._igmp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get igmpInput() {
    return this._igmp.internalValue;
  }

  // interface - computed: false, optional: true, required: false
  private _interface?: string[]; 
  public get interface() {
    return this.getListAttribute('interface');
  }
  public set interface(value: string[]) {
    this._interface = value;
  }
  public resetInterface() {
    this._interface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfaceInput() {
    return this._interface;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // pim - computed: false, optional: true, required: false
  private _pim = new VirtualRouterMulticastInterfaceGroupPimOutputReference(this, "pim");
  public get pim() {
    return this._pim;
  }
  public putPim(value: VirtualRouterMulticastInterfaceGroupPim) {
    this._pim.internalValue = value;
  }
  public resetPim() {
    this._pim.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pimInput() {
    return this._pim.internalValue;
  }
}

export class VirtualRouterMulticastInterfaceGroupList extends cdktf.ComplexList {
  public internalValue? : VirtualRouterMulticastInterfaceGroup[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): VirtualRouterMulticastInterfaceGroupOutputReference {
    return new VirtualRouterMulticastInterfaceGroupOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface VirtualRouterMulticastRpExternalRp {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#group_addresses VirtualRouter#group_addresses}
  */
  readonly groupAddresses?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#name VirtualRouter#name}
  */
  readonly name: string;
  /**
  * Override learned RP for the same group
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#override VirtualRouter#override}
  */
  readonly override?: boolean | cdktf.IResolvable;
}

export function virtualRouterMulticastRpExternalRpToTerraform(struct?: VirtualRouterMulticastRpExternalRp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    group_addresses: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.groupAddresses),
    name: cdktf.stringToTerraform(struct!.name),
    override: cdktf.booleanToTerraform(struct!.override),
  }
}


export function virtualRouterMulticastRpExternalRpToHclTerraform(struct?: VirtualRouterMulticastRpExternalRp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    group_addresses: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.groupAddresses),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    override: {
      value: cdktf.booleanToHclTerraform(struct!.override),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterMulticastRpExternalRpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): VirtualRouterMulticastRpExternalRp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._groupAddresses !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupAddresses = this._groupAddresses;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._override !== undefined) {
      hasAnyValues = true;
      internalValueResult.override = this._override;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterMulticastRpExternalRp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._groupAddresses = undefined;
      this._name = undefined;
      this._override = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._groupAddresses = value.groupAddresses;
      this._name = value.name;
      this._override = value.override;
    }
  }

  // group_addresses - computed: false, optional: true, required: false
  private _groupAddresses?: string[]; 
  public get groupAddresses() {
    return this.getListAttribute('group_addresses');
  }
  public set groupAddresses(value: string[]) {
    this._groupAddresses = value;
  }
  public resetGroupAddresses() {
    this._groupAddresses = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupAddressesInput() {
    return this._groupAddresses;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // override - computed: false, optional: true, required: false
  private _override?: boolean | cdktf.IResolvable; 
  public get override() {
    return this.getBooleanAttribute('override');
  }
  public set override(value: boolean | cdktf.IResolvable) {
    this._override = value;
  }
  public resetOverride() {
    this._override = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overrideInput() {
    return this._override;
  }
}

export class VirtualRouterMulticastRpExternalRpList extends cdktf.ComplexList {
  public internalValue? : VirtualRouterMulticastRpExternalRp[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): VirtualRouterMulticastRpExternalRpOutputReference {
    return new VirtualRouterMulticastRpExternalRpOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface VirtualRouterMulticastRpLocalRpCandidateRp {
  /**
  * candidate RP address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#address VirtualRouter#address}
  */
  readonly address?: string;
  /**
  * The time interval in seconds between candidate rp advertisements
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#advertisement_interval VirtualRouter#advertisement_interval}
  */
  readonly advertisementInterval?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#group_addresses VirtualRouter#group_addresses}
  */
  readonly groupAddresses?: string[];
  /**
  * candidate RP interface
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#interface VirtualRouter#interface}
  */
  readonly interface?: string;
  /**
  * The priority for this candidate rt
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#priority VirtualRouter#priority}
  */
  readonly priority?: number;
}

export function virtualRouterMulticastRpLocalRpCandidateRpToTerraform(struct?: VirtualRouterMulticastRpLocalRpCandidateRp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: cdktf.stringToTerraform(struct!.address),
    advertisement_interval: cdktf.numberToTerraform(struct!.advertisementInterval),
    group_addresses: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.groupAddresses),
    interface: cdktf.stringToTerraform(struct!.interface),
    priority: cdktf.numberToTerraform(struct!.priority),
  }
}


export function virtualRouterMulticastRpLocalRpCandidateRpToHclTerraform(struct?: VirtualRouterMulticastRpLocalRpCandidateRp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: cdktf.stringToHclTerraform(struct!.address),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    advertisement_interval: {
      value: cdktf.numberToHclTerraform(struct!.advertisementInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    group_addresses: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.groupAddresses),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    interface: {
      value: cdktf.stringToHclTerraform(struct!.interface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priority: {
      value: cdktf.numberToHclTerraform(struct!.priority),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterMulticastRpLocalRpCandidateRpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterMulticastRpLocalRpCandidateRp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address;
    }
    if (this._advertisementInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.advertisementInterval = this._advertisementInterval;
    }
    if (this._groupAddresses !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupAddresses = this._groupAddresses;
    }
    if (this._interface !== undefined) {
      hasAnyValues = true;
      internalValueResult.interface = this._interface;
    }
    if (this._priority !== undefined) {
      hasAnyValues = true;
      internalValueResult.priority = this._priority;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterMulticastRpLocalRpCandidateRp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address = undefined;
      this._advertisementInterval = undefined;
      this._groupAddresses = undefined;
      this._interface = undefined;
      this._priority = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address = value.address;
      this._advertisementInterval = value.advertisementInterval;
      this._groupAddresses = value.groupAddresses;
      this._interface = value.interface;
      this._priority = value.priority;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address?: string; 
  public get address() {
    return this.getStringAttribute('address');
  }
  public set address(value: string) {
    this._address = value;
  }
  public resetAddress() {
    this._address = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address;
  }

  // advertisement_interval - computed: true, optional: true, required: false
  private _advertisementInterval?: number; 
  public get advertisementInterval() {
    return this.getNumberAttribute('advertisement_interval');
  }
  public set advertisementInterval(value: number) {
    this._advertisementInterval = value;
  }
  public resetAdvertisementInterval() {
    this._advertisementInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get advertisementIntervalInput() {
    return this._advertisementInterval;
  }

  // group_addresses - computed: false, optional: true, required: false
  private _groupAddresses?: string[]; 
  public get groupAddresses() {
    return this.getListAttribute('group_addresses');
  }
  public set groupAddresses(value: string[]) {
    this._groupAddresses = value;
  }
  public resetGroupAddresses() {
    this._groupAddresses = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupAddressesInput() {
    return this._groupAddresses;
  }

  // interface - computed: false, optional: true, required: false
  private _interface?: string; 
  public get interface() {
    return this.getStringAttribute('interface');
  }
  public set interface(value: string) {
    this._interface = value;
  }
  public resetInterface() {
    this._interface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfaceInput() {
    return this._interface;
  }

  // priority - computed: true, optional: true, required: false
  private _priority?: number; 
  public get priority() {
    return this.getNumberAttribute('priority');
  }
  public set priority(value: number) {
    this._priority = value;
  }
  public resetPriority() {
    this._priority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get priorityInput() {
    return this._priority;
  }
}
export interface VirtualRouterMulticastRpLocalRpStaticRp {
  /**
  * local RP address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#address VirtualRouter#address}
  */
  readonly address?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#group_addresses VirtualRouter#group_addresses}
  */
  readonly groupAddresses?: string[];
  /**
  * local RP interface
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#interface VirtualRouter#interface}
  */
  readonly interface?: string;
  /**
  * Override learned RP for the same group
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#override VirtualRouter#override}
  */
  readonly override?: boolean | cdktf.IResolvable;
}

export function virtualRouterMulticastRpLocalRpStaticRpToTerraform(struct?: VirtualRouterMulticastRpLocalRpStaticRp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: cdktf.stringToTerraform(struct!.address),
    group_addresses: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.groupAddresses),
    interface: cdktf.stringToTerraform(struct!.interface),
    override: cdktf.booleanToTerraform(struct!.override),
  }
}


export function virtualRouterMulticastRpLocalRpStaticRpToHclTerraform(struct?: VirtualRouterMulticastRpLocalRpStaticRp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: cdktf.stringToHclTerraform(struct!.address),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    group_addresses: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.groupAddresses),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    interface: {
      value: cdktf.stringToHclTerraform(struct!.interface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    override: {
      value: cdktf.booleanToHclTerraform(struct!.override),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterMulticastRpLocalRpStaticRpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterMulticastRpLocalRpStaticRp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address;
    }
    if (this._groupAddresses !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupAddresses = this._groupAddresses;
    }
    if (this._interface !== undefined) {
      hasAnyValues = true;
      internalValueResult.interface = this._interface;
    }
    if (this._override !== undefined) {
      hasAnyValues = true;
      internalValueResult.override = this._override;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterMulticastRpLocalRpStaticRp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address = undefined;
      this._groupAddresses = undefined;
      this._interface = undefined;
      this._override = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address = value.address;
      this._groupAddresses = value.groupAddresses;
      this._interface = value.interface;
      this._override = value.override;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address?: string; 
  public get address() {
    return this.getStringAttribute('address');
  }
  public set address(value: string) {
    this._address = value;
  }
  public resetAddress() {
    this._address = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address;
  }

  // group_addresses - computed: false, optional: true, required: false
  private _groupAddresses?: string[]; 
  public get groupAddresses() {
    return this.getListAttribute('group_addresses');
  }
  public set groupAddresses(value: string[]) {
    this._groupAddresses = value;
  }
  public resetGroupAddresses() {
    this._groupAddresses = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupAddressesInput() {
    return this._groupAddresses;
  }

  // interface - computed: false, optional: true, required: false
  private _interface?: string; 
  public get interface() {
    return this.getStringAttribute('interface');
  }
  public set interface(value: string) {
    this._interface = value;
  }
  public resetInterface() {
    this._interface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfaceInput() {
    return this._interface;
  }

  // override - computed: false, optional: true, required: false
  private _override?: boolean | cdktf.IResolvable; 
  public get override() {
    return this.getBooleanAttribute('override');
  }
  public set override(value: boolean | cdktf.IResolvable) {
    this._override = value;
  }
  public resetOverride() {
    this._override = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overrideInput() {
    return this._override;
  }
}
export interface VirtualRouterMulticastRpLocalRp {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#candidate_rp VirtualRouter#candidate_rp}
  */
  readonly candidateRp?: VirtualRouterMulticastRpLocalRpCandidateRp;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#static_rp VirtualRouter#static_rp}
  */
  readonly staticRp?: VirtualRouterMulticastRpLocalRpStaticRp;
}

export function virtualRouterMulticastRpLocalRpToTerraform(struct?: VirtualRouterMulticastRpLocalRp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    candidate_rp: virtualRouterMulticastRpLocalRpCandidateRpToTerraform(struct!.candidateRp),
    static_rp: virtualRouterMulticastRpLocalRpStaticRpToTerraform(struct!.staticRp),
  }
}


export function virtualRouterMulticastRpLocalRpToHclTerraform(struct?: VirtualRouterMulticastRpLocalRp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    candidate_rp: {
      value: virtualRouterMulticastRpLocalRpCandidateRpToHclTerraform(struct!.candidateRp),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterMulticastRpLocalRpCandidateRp",
    },
    static_rp: {
      value: virtualRouterMulticastRpLocalRpStaticRpToHclTerraform(struct!.staticRp),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterMulticastRpLocalRpStaticRp",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterMulticastRpLocalRpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterMulticastRpLocalRp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._candidateRp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.candidateRp = this._candidateRp?.internalValue;
    }
    if (this._staticRp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.staticRp = this._staticRp?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterMulticastRpLocalRp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._candidateRp.internalValue = undefined;
      this._staticRp.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._candidateRp.internalValue = value.candidateRp;
      this._staticRp.internalValue = value.staticRp;
    }
  }

  // candidate_rp - computed: false, optional: true, required: false
  private _candidateRp = new VirtualRouterMulticastRpLocalRpCandidateRpOutputReference(this, "candidate_rp");
  public get candidateRp() {
    return this._candidateRp;
  }
  public putCandidateRp(value: VirtualRouterMulticastRpLocalRpCandidateRp) {
    this._candidateRp.internalValue = value;
  }
  public resetCandidateRp() {
    this._candidateRp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get candidateRpInput() {
    return this._candidateRp.internalValue;
  }

  // static_rp - computed: false, optional: true, required: false
  private _staticRp = new VirtualRouterMulticastRpLocalRpStaticRpOutputReference(this, "static_rp");
  public get staticRp() {
    return this._staticRp;
  }
  public putStaticRp(value: VirtualRouterMulticastRpLocalRpStaticRp) {
    this._staticRp.internalValue = value;
  }
  public resetStaticRp() {
    this._staticRp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get staticRpInput() {
    return this._staticRp.internalValue;
  }
}
export interface VirtualRouterMulticastRp {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#external_rp VirtualRouter#external_rp}
  */
  readonly externalRp?: VirtualRouterMulticastRpExternalRp[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#local_rp VirtualRouter#local_rp}
  */
  readonly localRp?: VirtualRouterMulticastRpLocalRp;
}

export function virtualRouterMulticastRpToTerraform(struct?: VirtualRouterMulticastRp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    external_rp: cdktf.listMapper(virtualRouterMulticastRpExternalRpToTerraform, false)(struct!.externalRp),
    local_rp: virtualRouterMulticastRpLocalRpToTerraform(struct!.localRp),
  }
}


export function virtualRouterMulticastRpToHclTerraform(struct?: VirtualRouterMulticastRp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    external_rp: {
      value: cdktf.listMapperHcl(virtualRouterMulticastRpExternalRpToHclTerraform, false)(struct!.externalRp),
      isBlock: true,
      type: "list",
      storageClassType: "VirtualRouterMulticastRpExternalRpList",
    },
    local_rp: {
      value: virtualRouterMulticastRpLocalRpToHclTerraform(struct!.localRp),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterMulticastRpLocalRp",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterMulticastRpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterMulticastRp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._externalRp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.externalRp = this._externalRp?.internalValue;
    }
    if (this._localRp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.localRp = this._localRp?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterMulticastRp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._externalRp.internalValue = undefined;
      this._localRp.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._externalRp.internalValue = value.externalRp;
      this._localRp.internalValue = value.localRp;
    }
  }

  // external_rp - computed: false, optional: true, required: false
  private _externalRp = new VirtualRouterMulticastRpExternalRpList(this, "external_rp", false);
  public get externalRp() {
    return this._externalRp;
  }
  public putExternalRp(value: VirtualRouterMulticastRpExternalRp[] | cdktf.IResolvable) {
    this._externalRp.internalValue = value;
  }
  public resetExternalRp() {
    this._externalRp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get externalRpInput() {
    return this._externalRp.internalValue;
  }

  // local_rp - computed: false, optional: true, required: false
  private _localRp = new VirtualRouterMulticastRpLocalRpOutputReference(this, "local_rp");
  public get localRp() {
    return this._localRp;
  }
  public putLocalRp(value: VirtualRouterMulticastRpLocalRp) {
    this._localRp.internalValue = value;
  }
  public resetLocalRp() {
    this._localRp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localRpInput() {
    return this._localRp.internalValue;
  }
}
export interface VirtualRouterMulticastSptThreshold {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#name VirtualRouter#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#threshold VirtualRouter#threshold}
  */
  readonly threshold?: string;
}

export function virtualRouterMulticastSptThresholdToTerraform(struct?: VirtualRouterMulticastSptThreshold | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    threshold: cdktf.stringToTerraform(struct!.threshold),
  }
}


export function virtualRouterMulticastSptThresholdToHclTerraform(struct?: VirtualRouterMulticastSptThreshold | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    threshold: {
      value: cdktf.stringToHclTerraform(struct!.threshold),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterMulticastSptThresholdOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): VirtualRouterMulticastSptThreshold | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._threshold !== undefined) {
      hasAnyValues = true;
      internalValueResult.threshold = this._threshold;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterMulticastSptThreshold | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._threshold = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._threshold = value.threshold;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // threshold - computed: true, optional: true, required: false
  private _threshold?: string; 
  public get threshold() {
    return this.getStringAttribute('threshold');
  }
  public set threshold(value: string) {
    this._threshold = value;
  }
  public resetThreshold() {
    this._threshold = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get thresholdInput() {
    return this._threshold;
  }
}

export class VirtualRouterMulticastSptThresholdList extends cdktf.ComplexList {
  public internalValue? : VirtualRouterMulticastSptThreshold[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): VirtualRouterMulticastSptThresholdOutputReference {
    return new VirtualRouterMulticastSptThresholdOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface VirtualRouterMulticastSsmAddressSpace {
  /**
  * group-address/prefix
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#group_address VirtualRouter#group_address}
  */
  readonly groupAddress?: string;
  /**
  * included
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#included VirtualRouter#included}
  */
  readonly included?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#name VirtualRouter#name}
  */
  readonly name: string;
}

export function virtualRouterMulticastSsmAddressSpaceToTerraform(struct?: VirtualRouterMulticastSsmAddressSpace | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    group_address: cdktf.stringToTerraform(struct!.groupAddress),
    included: cdktf.booleanToTerraform(struct!.included),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function virtualRouterMulticastSsmAddressSpaceToHclTerraform(struct?: VirtualRouterMulticastSsmAddressSpace | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    group_address: {
      value: cdktf.stringToHclTerraform(struct!.groupAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    included: {
      value: cdktf.booleanToHclTerraform(struct!.included),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterMulticastSsmAddressSpaceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): VirtualRouterMulticastSsmAddressSpace | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._groupAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupAddress = this._groupAddress;
    }
    if (this._included !== undefined) {
      hasAnyValues = true;
      internalValueResult.included = this._included;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterMulticastSsmAddressSpace | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._groupAddress = undefined;
      this._included = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._groupAddress = value.groupAddress;
      this._included = value.included;
      this._name = value.name;
    }
  }

  // group_address - computed: false, optional: true, required: false
  private _groupAddress?: string; 
  public get groupAddress() {
    return this.getStringAttribute('group_address');
  }
  public set groupAddress(value: string) {
    this._groupAddress = value;
  }
  public resetGroupAddress() {
    this._groupAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupAddressInput() {
    return this._groupAddress;
  }

  // included - computed: false, optional: true, required: false
  private _included?: boolean | cdktf.IResolvable; 
  public get included() {
    return this.getBooleanAttribute('included');
  }
  public set included(value: boolean | cdktf.IResolvable) {
    this._included = value;
  }
  public resetIncluded() {
    this._included = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get includedInput() {
    return this._included;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class VirtualRouterMulticastSsmAddressSpaceList extends cdktf.ComplexList {
  public internalValue? : VirtualRouterMulticastSsmAddressSpace[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): VirtualRouterMulticastSsmAddressSpaceOutputReference {
    return new VirtualRouterMulticastSsmAddressSpaceOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface VirtualRouterMulticast {
  /**
  * enable multicast protocol
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#enable VirtualRouter#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#interface_group VirtualRouter#interface_group}
  */
  readonly interfaceGroup?: VirtualRouterMulticastInterfaceGroup[] | cdktf.IResolvable;
  /**
  * time to wait before aging out a multicast route after data stops, in seconds
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#route_ageout_time VirtualRouter#route_ageout_time}
  */
  readonly routeAgeoutTime?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#rp VirtualRouter#rp}
  */
  readonly rp?: VirtualRouterMulticastRp;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#spt_threshold VirtualRouter#spt_threshold}
  */
  readonly sptThreshold?: VirtualRouterMulticastSptThreshold[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#ssm_address_space VirtualRouter#ssm_address_space}
  */
  readonly ssmAddressSpace?: VirtualRouterMulticastSsmAddressSpace[] | cdktf.IResolvable;
}

export function virtualRouterMulticastToTerraform(struct?: VirtualRouterMulticast | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enable: cdktf.booleanToTerraform(struct!.enable),
    interface_group: cdktf.listMapper(virtualRouterMulticastInterfaceGroupToTerraform, false)(struct!.interfaceGroup),
    route_ageout_time: cdktf.numberToTerraform(struct!.routeAgeoutTime),
    rp: virtualRouterMulticastRpToTerraform(struct!.rp),
    spt_threshold: cdktf.listMapper(virtualRouterMulticastSptThresholdToTerraform, false)(struct!.sptThreshold),
    ssm_address_space: cdktf.listMapper(virtualRouterMulticastSsmAddressSpaceToTerraform, false)(struct!.ssmAddressSpace),
  }
}


export function virtualRouterMulticastToHclTerraform(struct?: VirtualRouterMulticast | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    interface_group: {
      value: cdktf.listMapperHcl(virtualRouterMulticastInterfaceGroupToHclTerraform, false)(struct!.interfaceGroup),
      isBlock: true,
      type: "list",
      storageClassType: "VirtualRouterMulticastInterfaceGroupList",
    },
    route_ageout_time: {
      value: cdktf.numberToHclTerraform(struct!.routeAgeoutTime),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    rp: {
      value: virtualRouterMulticastRpToHclTerraform(struct!.rp),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterMulticastRp",
    },
    spt_threshold: {
      value: cdktf.listMapperHcl(virtualRouterMulticastSptThresholdToHclTerraform, false)(struct!.sptThreshold),
      isBlock: true,
      type: "list",
      storageClassType: "VirtualRouterMulticastSptThresholdList",
    },
    ssm_address_space: {
      value: cdktf.listMapperHcl(virtualRouterMulticastSsmAddressSpaceToHclTerraform, false)(struct!.ssmAddressSpace),
      isBlock: true,
      type: "list",
      storageClassType: "VirtualRouterMulticastSsmAddressSpaceList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterMulticastOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterMulticast | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._interfaceGroup?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.interfaceGroup = this._interfaceGroup?.internalValue;
    }
    if (this._routeAgeoutTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeAgeoutTime = this._routeAgeoutTime;
    }
    if (this._rp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rp = this._rp?.internalValue;
    }
    if (this._sptThreshold?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sptThreshold = this._sptThreshold?.internalValue;
    }
    if (this._ssmAddressSpace?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ssmAddressSpace = this._ssmAddressSpace?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterMulticast | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enable = undefined;
      this._interfaceGroup.internalValue = undefined;
      this._routeAgeoutTime = undefined;
      this._rp.internalValue = undefined;
      this._sptThreshold.internalValue = undefined;
      this._ssmAddressSpace.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enable = value.enable;
      this._interfaceGroup.internalValue = value.interfaceGroup;
      this._routeAgeoutTime = value.routeAgeoutTime;
      this._rp.internalValue = value.rp;
      this._sptThreshold.internalValue = value.sptThreshold;
      this._ssmAddressSpace.internalValue = value.ssmAddressSpace;
    }
  }

  // enable - computed: false, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // interface_group - computed: false, optional: true, required: false
  private _interfaceGroup = new VirtualRouterMulticastInterfaceGroupList(this, "interface_group", false);
  public get interfaceGroup() {
    return this._interfaceGroup;
  }
  public putInterfaceGroup(value: VirtualRouterMulticastInterfaceGroup[] | cdktf.IResolvable) {
    this._interfaceGroup.internalValue = value;
  }
  public resetInterfaceGroup() {
    this._interfaceGroup.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfaceGroupInput() {
    return this._interfaceGroup.internalValue;
  }

  // route_ageout_time - computed: true, optional: true, required: false
  private _routeAgeoutTime?: number; 
  public get routeAgeoutTime() {
    return this.getNumberAttribute('route_ageout_time');
  }
  public set routeAgeoutTime(value: number) {
    this._routeAgeoutTime = value;
  }
  public resetRouteAgeoutTime() {
    this._routeAgeoutTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeAgeoutTimeInput() {
    return this._routeAgeoutTime;
  }

  // rp - computed: false, optional: true, required: false
  private _rp = new VirtualRouterMulticastRpOutputReference(this, "rp");
  public get rp() {
    return this._rp;
  }
  public putRp(value: VirtualRouterMulticastRp) {
    this._rp.internalValue = value;
  }
  public resetRp() {
    this._rp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rpInput() {
    return this._rp.internalValue;
  }

  // spt_threshold - computed: false, optional: true, required: false
  private _sptThreshold = new VirtualRouterMulticastSptThresholdList(this, "spt_threshold", false);
  public get sptThreshold() {
    return this._sptThreshold;
  }
  public putSptThreshold(value: VirtualRouterMulticastSptThreshold[] | cdktf.IResolvable) {
    this._sptThreshold.internalValue = value;
  }
  public resetSptThreshold() {
    this._sptThreshold.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sptThresholdInput() {
    return this._sptThreshold.internalValue;
  }

  // ssm_address_space - computed: false, optional: true, required: false
  private _ssmAddressSpace = new VirtualRouterMulticastSsmAddressSpaceList(this, "ssm_address_space", false);
  public get ssmAddressSpace() {
    return this._ssmAddressSpace;
  }
  public putSsmAddressSpace(value: VirtualRouterMulticastSsmAddressSpace[] | cdktf.IResolvable) {
    this._ssmAddressSpace.internalValue = value;
  }
  public resetSsmAddressSpace() {
    this._ssmAddressSpace.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ssmAddressSpaceInput() {
    return this._ssmAddressSpace.internalValue;
  }
}
export interface VirtualRouterProtocolBgpAuthProfile {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#name VirtualRouter#name}
  */
  readonly name: string;
  /**
  * shared secret for the TCP MD5 authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#secret VirtualRouter#secret}
  */
  readonly secret?: string;
}

export function virtualRouterProtocolBgpAuthProfileToTerraform(struct?: VirtualRouterProtocolBgpAuthProfile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    secret: cdktf.stringToTerraform(struct!.secret),
  }
}


export function virtualRouterProtocolBgpAuthProfileToHclTerraform(struct?: VirtualRouterProtocolBgpAuthProfile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret: {
      value: cdktf.stringToHclTerraform(struct!.secret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpAuthProfileOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): VirtualRouterProtocolBgpAuthProfile | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._secret !== undefined) {
      hasAnyValues = true;
      internalValueResult.secret = this._secret;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpAuthProfile | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._secret = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._secret = value.secret;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // secret - computed: false, optional: true, required: false
  private _secret?: string; 
  public get secret() {
    return this.getStringAttribute('secret');
  }
  public set secret(value: string) {
    this._secret = value;
  }
  public resetSecret() {
    this._secret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretInput() {
    return this._secret;
  }
}

export class VirtualRouterProtocolBgpAuthProfileList extends cdktf.ComplexList {
  public internalValue? : VirtualRouterProtocolBgpAuthProfile[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): VirtualRouterProtocolBgpAuthProfileOutputReference {
    return new VirtualRouterProtocolBgpAuthProfileOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface VirtualRouterProtocolBgpDampeningProfile {
  /**
  * cutoff threshold value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#cutoff VirtualRouter#cutoff}
  */
  readonly cutoff?: number;
  /**
  * Decay half-life while reachable (in seconds)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#decay_half_life_reachable VirtualRouter#decay_half_life_reachable}
  */
  readonly decayHalfLifeReachable?: number;
  /**
  * Decay half-life while unreachable (in seconds)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#decay_half_life_unreachable VirtualRouter#decay_half_life_unreachable}
  */
  readonly decayHalfLifeUnreachable?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#enable VirtualRouter#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * maximum of hold-down time (in seconds)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#max_hold_time VirtualRouter#max_hold_time}
  */
  readonly maxHoldTime?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#name VirtualRouter#name}
  */
  readonly name: string;
  /**
  * reuse threshold value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#reuse VirtualRouter#reuse}
  */
  readonly reuse?: number;
}

export function virtualRouterProtocolBgpDampeningProfileToTerraform(struct?: VirtualRouterProtocolBgpDampeningProfile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cutoff: cdktf.numberToTerraform(struct!.cutoff),
    decay_half_life_reachable: cdktf.numberToTerraform(struct!.decayHalfLifeReachable),
    decay_half_life_unreachable: cdktf.numberToTerraform(struct!.decayHalfLifeUnreachable),
    enable: cdktf.booleanToTerraform(struct!.enable),
    max_hold_time: cdktf.numberToTerraform(struct!.maxHoldTime),
    name: cdktf.stringToTerraform(struct!.name),
    reuse: cdktf.numberToTerraform(struct!.reuse),
  }
}


export function virtualRouterProtocolBgpDampeningProfileToHclTerraform(struct?: VirtualRouterProtocolBgpDampeningProfile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cutoff: {
      value: cdktf.numberToHclTerraform(struct!.cutoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    decay_half_life_reachable: {
      value: cdktf.numberToHclTerraform(struct!.decayHalfLifeReachable),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    decay_half_life_unreachable: {
      value: cdktf.numberToHclTerraform(struct!.decayHalfLifeUnreachable),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_hold_time: {
      value: cdktf.numberToHclTerraform(struct!.maxHoldTime),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reuse: {
      value: cdktf.numberToHclTerraform(struct!.reuse),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpDampeningProfileOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): VirtualRouterProtocolBgpDampeningProfile | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cutoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.cutoff = this._cutoff;
    }
    if (this._decayHalfLifeReachable !== undefined) {
      hasAnyValues = true;
      internalValueResult.decayHalfLifeReachable = this._decayHalfLifeReachable;
    }
    if (this._decayHalfLifeUnreachable !== undefined) {
      hasAnyValues = true;
      internalValueResult.decayHalfLifeUnreachable = this._decayHalfLifeUnreachable;
    }
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._maxHoldTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxHoldTime = this._maxHoldTime;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._reuse !== undefined) {
      hasAnyValues = true;
      internalValueResult.reuse = this._reuse;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpDampeningProfile | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cutoff = undefined;
      this._decayHalfLifeReachable = undefined;
      this._decayHalfLifeUnreachable = undefined;
      this._enable = undefined;
      this._maxHoldTime = undefined;
      this._name = undefined;
      this._reuse = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cutoff = value.cutoff;
      this._decayHalfLifeReachable = value.decayHalfLifeReachable;
      this._decayHalfLifeUnreachable = value.decayHalfLifeUnreachable;
      this._enable = value.enable;
      this._maxHoldTime = value.maxHoldTime;
      this._name = value.name;
      this._reuse = value.reuse;
    }
  }

  // cutoff - computed: false, optional: true, required: false
  private _cutoff?: number; 
  public get cutoff() {
    return this.getNumberAttribute('cutoff');
  }
  public set cutoff(value: number) {
    this._cutoff = value;
  }
  public resetCutoff() {
    this._cutoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cutoffInput() {
    return this._cutoff;
  }

  // decay_half_life_reachable - computed: true, optional: true, required: false
  private _decayHalfLifeReachable?: number; 
  public get decayHalfLifeReachable() {
    return this.getNumberAttribute('decay_half_life_reachable');
  }
  public set decayHalfLifeReachable(value: number) {
    this._decayHalfLifeReachable = value;
  }
  public resetDecayHalfLifeReachable() {
    this._decayHalfLifeReachable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get decayHalfLifeReachableInput() {
    return this._decayHalfLifeReachable;
  }

  // decay_half_life_unreachable - computed: true, optional: true, required: false
  private _decayHalfLifeUnreachable?: number; 
  public get decayHalfLifeUnreachable() {
    return this.getNumberAttribute('decay_half_life_unreachable');
  }
  public set decayHalfLifeUnreachable(value: number) {
    this._decayHalfLifeUnreachable = value;
  }
  public resetDecayHalfLifeUnreachable() {
    this._decayHalfLifeUnreachable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get decayHalfLifeUnreachableInput() {
    return this._decayHalfLifeUnreachable;
  }

  // enable - computed: false, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // max_hold_time - computed: true, optional: true, required: false
  private _maxHoldTime?: number; 
  public get maxHoldTime() {
    return this.getNumberAttribute('max_hold_time');
  }
  public set maxHoldTime(value: number) {
    this._maxHoldTime = value;
  }
  public resetMaxHoldTime() {
    this._maxHoldTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxHoldTimeInput() {
    return this._maxHoldTime;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // reuse - computed: false, optional: true, required: false
  private _reuse?: number; 
  public get reuse() {
    return this.getNumberAttribute('reuse');
  }
  public set reuse(value: number) {
    this._reuse = value;
  }
  public resetReuse() {
    this._reuse = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reuseInput() {
    return this._reuse;
  }
}

export class VirtualRouterProtocolBgpDampeningProfileList extends cdktf.ComplexList {
  public internalValue? : VirtualRouterProtocolBgpDampeningProfile[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): VirtualRouterProtocolBgpDampeningProfileOutputReference {
    return new VirtualRouterProtocolBgpDampeningProfileOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface VirtualRouterProtocolBgpGlobalBfd {
  /**
  * BFD profile
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#profile VirtualRouter#profile}
  */
  readonly profile?: string;
}

export function virtualRouterProtocolBgpGlobalBfdToTerraform(struct?: VirtualRouterProtocolBgpGlobalBfd | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    profile: cdktf.stringToTerraform(struct!.profile),
  }
}


export function virtualRouterProtocolBgpGlobalBfdToHclTerraform(struct?: VirtualRouterProtocolBgpGlobalBfd | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    profile: {
      value: cdktf.stringToHclTerraform(struct!.profile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpGlobalBfdOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpGlobalBfd | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._profile !== undefined) {
      hasAnyValues = true;
      internalValueResult.profile = this._profile;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpGlobalBfd | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._profile = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._profile = value.profile;
    }
  }

  // profile - computed: true, optional: true, required: false
  private _profile?: string; 
  public get profile() {
    return this.getStringAttribute('profile');
  }
  public set profile(value: string) {
    this._profile = value;
  }
  public resetProfile() {
    this._profile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get profileInput() {
    return this._profile;
  }
}
export interface VirtualRouterProtocolBgpPeerGroupPeerBfd {
  /**
  * BFD profile
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#profile VirtualRouter#profile}
  */
  readonly profile?: string;
}

export function virtualRouterProtocolBgpPeerGroupPeerBfdToTerraform(struct?: VirtualRouterProtocolBgpPeerGroupPeerBfd | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    profile: cdktf.stringToTerraform(struct!.profile),
  }
}


export function virtualRouterProtocolBgpPeerGroupPeerBfdToHclTerraform(struct?: VirtualRouterProtocolBgpPeerGroupPeerBfd | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    profile: {
      value: cdktf.stringToHclTerraform(struct!.profile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPeerGroupPeerBfdOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPeerGroupPeerBfd | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._profile !== undefined) {
      hasAnyValues = true;
      internalValueResult.profile = this._profile;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPeerGroupPeerBfd | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._profile = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._profile = value.profile;
    }
  }

  // profile - computed: true, optional: true, required: false
  private _profile?: string; 
  public get profile() {
    return this.getStringAttribute('profile');
  }
  public set profile(value: string) {
    this._profile = value;
  }
  public resetProfile() {
    this._profile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get profileInput() {
    return this._profile;
  }
}
export interface VirtualRouterProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnection {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#allow VirtualRouter#allow}
  */
  readonly allow?: boolean | cdktf.IResolvable;
  /**
  * restrict remote port for incoming BGP connections
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#remote_port VirtualRouter#remote_port}
  */
  readonly remotePort?: number;
}

export function virtualRouterProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionToTerraform(struct?: VirtualRouterProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnection | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow: cdktf.booleanToTerraform(struct!.allow),
    remote_port: cdktf.numberToTerraform(struct!.remotePort),
  }
}


export function virtualRouterProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionToHclTerraform(struct?: VirtualRouterProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnection | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow: {
      value: cdktf.booleanToHclTerraform(struct!.allow),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    remote_port: {
      value: cdktf.numberToHclTerraform(struct!.remotePort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnection | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allow !== undefined) {
      hasAnyValues = true;
      internalValueResult.allow = this._allow;
    }
    if (this._remotePort !== undefined) {
      hasAnyValues = true;
      internalValueResult.remotePort = this._remotePort;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnection | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allow = undefined;
      this._remotePort = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allow = value.allow;
      this._remotePort = value.remotePort;
    }
  }

  // allow - computed: false, optional: true, required: false
  private _allow?: boolean | cdktf.IResolvable; 
  public get allow() {
    return this.getBooleanAttribute('allow');
  }
  public set allow(value: boolean | cdktf.IResolvable) {
    this._allow = value;
  }
  public resetAllow() {
    this._allow = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowInput() {
    return this._allow;
  }

  // remote_port - computed: true, optional: true, required: false
  private _remotePort?: number; 
  public get remotePort() {
    return this.getNumberAttribute('remote_port');
  }
  public set remotePort(value: number) {
    this._remotePort = value;
  }
  public resetRemotePort() {
    this._remotePort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get remotePortInput() {
    return this._remotePort;
  }
}
export interface VirtualRouterProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnection {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#allow VirtualRouter#allow}
  */
  readonly allow?: boolean | cdktf.IResolvable;
  /**
  * use specific local port for outgoing BGP connections
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#local_port VirtualRouter#local_port}
  */
  readonly localPort?: number;
}

export function virtualRouterProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionToTerraform(struct?: VirtualRouterProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnection | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow: cdktf.booleanToTerraform(struct!.allow),
    local_port: cdktf.numberToTerraform(struct!.localPort),
  }
}


export function virtualRouterProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionToHclTerraform(struct?: VirtualRouterProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnection | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow: {
      value: cdktf.booleanToHclTerraform(struct!.allow),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    local_port: {
      value: cdktf.numberToHclTerraform(struct!.localPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnection | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allow !== undefined) {
      hasAnyValues = true;
      internalValueResult.allow = this._allow;
    }
    if (this._localPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.localPort = this._localPort;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnection | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allow = undefined;
      this._localPort = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allow = value.allow;
      this._localPort = value.localPort;
    }
  }

  // allow - computed: false, optional: true, required: false
  private _allow?: boolean | cdktf.IResolvable; 
  public get allow() {
    return this.getBooleanAttribute('allow');
  }
  public set allow(value: boolean | cdktf.IResolvable) {
    this._allow = value;
  }
  public resetAllow() {
    this._allow = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowInput() {
    return this._allow;
  }

  // local_port - computed: true, optional: true, required: false
  private _localPort?: number; 
  public get localPort() {
    return this.getNumberAttribute('local_port');
  }
  public set localPort(value: number) {
    this._localPort = value;
  }
  public resetLocalPort() {
    this._localPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localPortInput() {
    return this._localPort;
  }
}
export interface VirtualRouterProtocolBgpPeerGroupPeerConnectionOptions {
  /**
  * Authentication options
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#authentication VirtualRouter#authentication}
  */
  readonly authentication?: string;
  /**
  * hold time (in seconds)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#hold_time VirtualRouter#hold_time}
  */
  readonly holdTime?: string;
  /**
  * idle hold time (in seconds)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#idle_hold_time VirtualRouter#idle_hold_time}
  */
  readonly idleHoldTime?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#incoming_bgp_connection VirtualRouter#incoming_bgp_connection}
  */
  readonly incomingBgpConnection?: VirtualRouterProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnection;
  /**
  * keep-alive interval (in seconds)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#keep_alive_interval VirtualRouter#keep_alive_interval}
  */
  readonly keepAliveInterval?: string;
  /**
  * Minimum Route Advertisement Interval (in seconds)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#min_route_adv_interval VirtualRouter#min_route_adv_interval}
  */
  readonly minRouteAdvInterval?: number;
  /**
  * IP TTL value used for sending BGP packet. set to 0 means eBGP use 2, iBGP use 255
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#multihop VirtualRouter#multihop}
  */
  readonly multihop?: number;
  /**
  * open delay time (in seconds)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#open_delay_time VirtualRouter#open_delay_time}
  */
  readonly openDelayTime?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#outgoing_bgp_connection VirtualRouter#outgoing_bgp_connection}
  */
  readonly outgoingBgpConnection?: VirtualRouterProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnection;
}

export function virtualRouterProtocolBgpPeerGroupPeerConnectionOptionsToTerraform(struct?: VirtualRouterProtocolBgpPeerGroupPeerConnectionOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    authentication: cdktf.stringToTerraform(struct!.authentication),
    hold_time: cdktf.stringToTerraform(struct!.holdTime),
    idle_hold_time: cdktf.numberToTerraform(struct!.idleHoldTime),
    incoming_bgp_connection: virtualRouterProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionToTerraform(struct!.incomingBgpConnection),
    keep_alive_interval: cdktf.stringToTerraform(struct!.keepAliveInterval),
    min_route_adv_interval: cdktf.numberToTerraform(struct!.minRouteAdvInterval),
    multihop: cdktf.numberToTerraform(struct!.multihop),
    open_delay_time: cdktf.numberToTerraform(struct!.openDelayTime),
    outgoing_bgp_connection: virtualRouterProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionToTerraform(struct!.outgoingBgpConnection),
  }
}


export function virtualRouterProtocolBgpPeerGroupPeerConnectionOptionsToHclTerraform(struct?: VirtualRouterProtocolBgpPeerGroupPeerConnectionOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    authentication: {
      value: cdktf.stringToHclTerraform(struct!.authentication),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hold_time: {
      value: cdktf.stringToHclTerraform(struct!.holdTime),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    idle_hold_time: {
      value: cdktf.numberToHclTerraform(struct!.idleHoldTime),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    incoming_bgp_connection: {
      value: virtualRouterProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionToHclTerraform(struct!.incomingBgpConnection),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnection",
    },
    keep_alive_interval: {
      value: cdktf.stringToHclTerraform(struct!.keepAliveInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_route_adv_interval: {
      value: cdktf.numberToHclTerraform(struct!.minRouteAdvInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    multihop: {
      value: cdktf.numberToHclTerraform(struct!.multihop),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    open_delay_time: {
      value: cdktf.numberToHclTerraform(struct!.openDelayTime),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    outgoing_bgp_connection: {
      value: virtualRouterProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionToHclTerraform(struct!.outgoingBgpConnection),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnection",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPeerGroupPeerConnectionOptionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPeerGroupPeerConnectionOptions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authentication !== undefined) {
      hasAnyValues = true;
      internalValueResult.authentication = this._authentication;
    }
    if (this._holdTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.holdTime = this._holdTime;
    }
    if (this._idleHoldTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.idleHoldTime = this._idleHoldTime;
    }
    if (this._incomingBgpConnection?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.incomingBgpConnection = this._incomingBgpConnection?.internalValue;
    }
    if (this._keepAliveInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepAliveInterval = this._keepAliveInterval;
    }
    if (this._minRouteAdvInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.minRouteAdvInterval = this._minRouteAdvInterval;
    }
    if (this._multihop !== undefined) {
      hasAnyValues = true;
      internalValueResult.multihop = this._multihop;
    }
    if (this._openDelayTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.openDelayTime = this._openDelayTime;
    }
    if (this._outgoingBgpConnection?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.outgoingBgpConnection = this._outgoingBgpConnection?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPeerGroupPeerConnectionOptions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authentication = undefined;
      this._holdTime = undefined;
      this._idleHoldTime = undefined;
      this._incomingBgpConnection.internalValue = undefined;
      this._keepAliveInterval = undefined;
      this._minRouteAdvInterval = undefined;
      this._multihop = undefined;
      this._openDelayTime = undefined;
      this._outgoingBgpConnection.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authentication = value.authentication;
      this._holdTime = value.holdTime;
      this._idleHoldTime = value.idleHoldTime;
      this._incomingBgpConnection.internalValue = value.incomingBgpConnection;
      this._keepAliveInterval = value.keepAliveInterval;
      this._minRouteAdvInterval = value.minRouteAdvInterval;
      this._multihop = value.multihop;
      this._openDelayTime = value.openDelayTime;
      this._outgoingBgpConnection.internalValue = value.outgoingBgpConnection;
    }
  }

  // authentication - computed: false, optional: true, required: false
  private _authentication?: string; 
  public get authentication() {
    return this.getStringAttribute('authentication');
  }
  public set authentication(value: string) {
    this._authentication = value;
  }
  public resetAuthentication() {
    this._authentication = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authenticationInput() {
    return this._authentication;
  }

  // hold_time - computed: true, optional: true, required: false
  private _holdTime?: string; 
  public get holdTime() {
    return this.getStringAttribute('hold_time');
  }
  public set holdTime(value: string) {
    this._holdTime = value;
  }
  public resetHoldTime() {
    this._holdTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get holdTimeInput() {
    return this._holdTime;
  }

  // idle_hold_time - computed: true, optional: true, required: false
  private _idleHoldTime?: number; 
  public get idleHoldTime() {
    return this.getNumberAttribute('idle_hold_time');
  }
  public set idleHoldTime(value: number) {
    this._idleHoldTime = value;
  }
  public resetIdleHoldTime() {
    this._idleHoldTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idleHoldTimeInput() {
    return this._idleHoldTime;
  }

  // incoming_bgp_connection - computed: false, optional: true, required: false
  private _incomingBgpConnection = new VirtualRouterProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionOutputReference(this, "incoming_bgp_connection");
  public get incomingBgpConnection() {
    return this._incomingBgpConnection;
  }
  public putIncomingBgpConnection(value: VirtualRouterProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnection) {
    this._incomingBgpConnection.internalValue = value;
  }
  public resetIncomingBgpConnection() {
    this._incomingBgpConnection.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get incomingBgpConnectionInput() {
    return this._incomingBgpConnection.internalValue;
  }

  // keep_alive_interval - computed: true, optional: true, required: false
  private _keepAliveInterval?: string; 
  public get keepAliveInterval() {
    return this.getStringAttribute('keep_alive_interval');
  }
  public set keepAliveInterval(value: string) {
    this._keepAliveInterval = value;
  }
  public resetKeepAliveInterval() {
    this._keepAliveInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepAliveIntervalInput() {
    return this._keepAliveInterval;
  }

  // min_route_adv_interval - computed: true, optional: true, required: false
  private _minRouteAdvInterval?: number; 
  public get minRouteAdvInterval() {
    return this.getNumberAttribute('min_route_adv_interval');
  }
  public set minRouteAdvInterval(value: number) {
    this._minRouteAdvInterval = value;
  }
  public resetMinRouteAdvInterval() {
    this._minRouteAdvInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minRouteAdvIntervalInput() {
    return this._minRouteAdvInterval;
  }

  // multihop - computed: true, optional: true, required: false
  private _multihop?: number; 
  public get multihop() {
    return this.getNumberAttribute('multihop');
  }
  public set multihop(value: number) {
    this._multihop = value;
  }
  public resetMultihop() {
    this._multihop = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get multihopInput() {
    return this._multihop;
  }

  // open_delay_time - computed: true, optional: true, required: false
  private _openDelayTime?: number; 
  public get openDelayTime() {
    return this.getNumberAttribute('open_delay_time');
  }
  public set openDelayTime(value: number) {
    this._openDelayTime = value;
  }
  public resetOpenDelayTime() {
    this._openDelayTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get openDelayTimeInput() {
    return this._openDelayTime;
  }

  // outgoing_bgp_connection - computed: false, optional: true, required: false
  private _outgoingBgpConnection = new VirtualRouterProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionOutputReference(this, "outgoing_bgp_connection");
  public get outgoingBgpConnection() {
    return this._outgoingBgpConnection;
  }
  public putOutgoingBgpConnection(value: VirtualRouterProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnection) {
    this._outgoingBgpConnection.internalValue = value;
  }
  public resetOutgoingBgpConnection() {
    this._outgoingBgpConnection.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get outgoingBgpConnectionInput() {
    return this._outgoingBgpConnection.internalValue;
  }
}
export interface VirtualRouterProtocolBgpPeerGroupPeerLocalAddress {
  /**
  * interface to accept BGP session
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#interface VirtualRouter#interface}
  */
  readonly interface?: string;
  /**
  * specify exact IP address if interface has multiple addresses
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#ip VirtualRouter#ip}
  */
  readonly ip?: string;
}

export function virtualRouterProtocolBgpPeerGroupPeerLocalAddressToTerraform(struct?: VirtualRouterProtocolBgpPeerGroupPeerLocalAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    interface: cdktf.stringToTerraform(struct!.interface),
    ip: cdktf.stringToTerraform(struct!.ip),
  }
}


export function virtualRouterProtocolBgpPeerGroupPeerLocalAddressToHclTerraform(struct?: VirtualRouterProtocolBgpPeerGroupPeerLocalAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    interface: {
      value: cdktf.stringToHclTerraform(struct!.interface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip: {
      value: cdktf.stringToHclTerraform(struct!.ip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPeerGroupPeerLocalAddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPeerGroupPeerLocalAddress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._interface !== undefined) {
      hasAnyValues = true;
      internalValueResult.interface = this._interface;
    }
    if (this._ip !== undefined) {
      hasAnyValues = true;
      internalValueResult.ip = this._ip;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPeerGroupPeerLocalAddress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._interface = undefined;
      this._ip = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._interface = value.interface;
      this._ip = value.ip;
    }
  }

  // interface - computed: false, optional: true, required: false
  private _interface?: string; 
  public get interface() {
    return this.getStringAttribute('interface');
  }
  public set interface(value: string) {
    this._interface = value;
  }
  public resetInterface() {
    this._interface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfaceInput() {
    return this._interface;
  }

  // ip - computed: false, optional: true, required: false
  private _ip?: string; 
  public get ip() {
    return this.getStringAttribute('ip');
  }
  public set ip(value: string) {
    this._ip = value;
  }
  public resetIp() {
    this._ip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipInput() {
    return this._ip;
  }
}
export interface VirtualRouterProtocolBgpPeerGroupPeerPeerAddress {
  /**
  * bgp peer FQDN address object configuration
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#fqdn VirtualRouter#fqdn}
  */
  readonly fqdn?: string;
  /**
  * peer address configuration
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#ip VirtualRouter#ip}
  */
  readonly ip?: string;
}

export function virtualRouterProtocolBgpPeerGroupPeerPeerAddressToTerraform(struct?: VirtualRouterProtocolBgpPeerGroupPeerPeerAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    fqdn: cdktf.stringToTerraform(struct!.fqdn),
    ip: cdktf.stringToTerraform(struct!.ip),
  }
}


export function virtualRouterProtocolBgpPeerGroupPeerPeerAddressToHclTerraform(struct?: VirtualRouterProtocolBgpPeerGroupPeerPeerAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    fqdn: {
      value: cdktf.stringToHclTerraform(struct!.fqdn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip: {
      value: cdktf.stringToHclTerraform(struct!.ip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPeerGroupPeerPeerAddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPeerGroupPeerPeerAddress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fqdn !== undefined) {
      hasAnyValues = true;
      internalValueResult.fqdn = this._fqdn;
    }
    if (this._ip !== undefined) {
      hasAnyValues = true;
      internalValueResult.ip = this._ip;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPeerGroupPeerPeerAddress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fqdn = undefined;
      this._ip = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fqdn = value.fqdn;
      this._ip = value.ip;
    }
  }

  // fqdn - computed: false, optional: true, required: false
  private _fqdn?: string; 
  public get fqdn() {
    return this.getStringAttribute('fqdn');
  }
  public set fqdn(value: string) {
    this._fqdn = value;
  }
  public resetFqdn() {
    this._fqdn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fqdnInput() {
    return this._fqdn;
  }

  // ip - computed: false, optional: true, required: false
  private _ip?: string; 
  public get ip() {
    return this.getStringAttribute('ip');
  }
  public set ip(value: string) {
    this._ip = value;
  }
  public resetIp() {
    this._ip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipInput() {
    return this._ip;
  }
}
export interface VirtualRouterProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifier {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#multicast VirtualRouter#multicast}
  */
  readonly multicast?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#unicast VirtualRouter#unicast}
  */
  readonly unicast?: boolean | cdktf.IResolvable;
}

export function virtualRouterProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifierToTerraform(struct?: VirtualRouterProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifier | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    multicast: cdktf.booleanToTerraform(struct!.multicast),
    unicast: cdktf.booleanToTerraform(struct!.unicast),
  }
}


export function virtualRouterProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifierToHclTerraform(struct?: VirtualRouterProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifier | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    multicast: {
      value: cdktf.booleanToHclTerraform(struct!.multicast),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    unicast: {
      value: cdktf.booleanToHclTerraform(struct!.unicast),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifierOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifier | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._multicast !== undefined) {
      hasAnyValues = true;
      internalValueResult.multicast = this._multicast;
    }
    if (this._unicast !== undefined) {
      hasAnyValues = true;
      internalValueResult.unicast = this._unicast;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifier | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._multicast = undefined;
      this._unicast = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._multicast = value.multicast;
      this._unicast = value.unicast;
    }
  }

  // multicast - computed: false, optional: true, required: false
  private _multicast?: boolean | cdktf.IResolvable; 
  public get multicast() {
    return this.getBooleanAttribute('multicast');
  }
  public set multicast(value: boolean | cdktf.IResolvable) {
    this._multicast = value;
  }
  public resetMulticast() {
    this._multicast = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get multicastInput() {
    return this._multicast;
  }

  // unicast - computed: false, optional: true, required: false
  private _unicast?: boolean | cdktf.IResolvable; 
  public get unicast() {
    return this.getBooleanAttribute('unicast');
  }
  public set unicast(value: boolean | cdktf.IResolvable) {
    this._unicast = value;
  }
  public resetUnicast() {
    this._unicast = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get unicastInput() {
    return this._unicast;
  }
}
export interface VirtualRouterProtocolBgpPeerGroupPeer {
  /**
  * select AFI for this peer
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#address_family_identifier VirtualRouter#address_family_identifier}
  */
  readonly addressFamilyIdentifier?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#bfd VirtualRouter#bfd}
  */
  readonly bfd?: VirtualRouterProtocolBgpPeerGroupPeerBfd;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#connection_options VirtualRouter#connection_options}
  */
  readonly connectionOptions?: VirtualRouterProtocolBgpPeerGroupPeerConnectionOptions;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#enable VirtualRouter#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#enable_mp_bgp VirtualRouter#enable_mp_bgp}
  */
  readonly enableMpBgp?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#enable_sender_side_loop_detection VirtualRouter#enable_sender_side_loop_detection}
  */
  readonly enableSenderSideLoopDetection?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#local_address VirtualRouter#local_address}
  */
  readonly localAddress?: VirtualRouterProtocolBgpPeerGroupPeerLocalAddress;
  /**
  * maximum of prefixes to receive from peer
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#max_prefixes VirtualRouter#max_prefixes}
  */
  readonly maxPrefixes?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#name VirtualRouter#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#peer_address VirtualRouter#peer_address}
  */
  readonly peerAddress?: VirtualRouterProtocolBgpPeerGroupPeerPeerAddress;
  /**
  * peer AS number
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#peer_as VirtualRouter#peer_as}
  */
  readonly peerAs?: string;
  /**
  * peering type that affects NOPEER community value handling
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#peering_type VirtualRouter#peering_type}
  */
  readonly peeringType?: string;
  /**
  * this peer is reflector client
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#reflector_client VirtualRouter#reflector_client}
  */
  readonly reflectorClient?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#subsequent_address_family_identifier VirtualRouter#subsequent_address_family_identifier}
  */
  readonly subsequentAddressFamilyIdentifier?: VirtualRouterProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifier;
}

export function virtualRouterProtocolBgpPeerGroupPeerToTerraform(struct?: VirtualRouterProtocolBgpPeerGroupPeer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address_family_identifier: cdktf.stringToTerraform(struct!.addressFamilyIdentifier),
    bfd: virtualRouterProtocolBgpPeerGroupPeerBfdToTerraform(struct!.bfd),
    connection_options: virtualRouterProtocolBgpPeerGroupPeerConnectionOptionsToTerraform(struct!.connectionOptions),
    enable: cdktf.booleanToTerraform(struct!.enable),
    enable_mp_bgp: cdktf.booleanToTerraform(struct!.enableMpBgp),
    enable_sender_side_loop_detection: cdktf.booleanToTerraform(struct!.enableSenderSideLoopDetection),
    local_address: virtualRouterProtocolBgpPeerGroupPeerLocalAddressToTerraform(struct!.localAddress),
    max_prefixes: cdktf.stringToTerraform(struct!.maxPrefixes),
    name: cdktf.stringToTerraform(struct!.name),
    peer_address: virtualRouterProtocolBgpPeerGroupPeerPeerAddressToTerraform(struct!.peerAddress),
    peer_as: cdktf.stringToTerraform(struct!.peerAs),
    peering_type: cdktf.stringToTerraform(struct!.peeringType),
    reflector_client: cdktf.stringToTerraform(struct!.reflectorClient),
    subsequent_address_family_identifier: virtualRouterProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifierToTerraform(struct!.subsequentAddressFamilyIdentifier),
  }
}


export function virtualRouterProtocolBgpPeerGroupPeerToHclTerraform(struct?: VirtualRouterProtocolBgpPeerGroupPeer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address_family_identifier: {
      value: cdktf.stringToHclTerraform(struct!.addressFamilyIdentifier),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bfd: {
      value: virtualRouterProtocolBgpPeerGroupPeerBfdToHclTerraform(struct!.bfd),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPeerGroupPeerBfd",
    },
    connection_options: {
      value: virtualRouterProtocolBgpPeerGroupPeerConnectionOptionsToHclTerraform(struct!.connectionOptions),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPeerGroupPeerConnectionOptions",
    },
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_mp_bgp: {
      value: cdktf.booleanToHclTerraform(struct!.enableMpBgp),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_sender_side_loop_detection: {
      value: cdktf.booleanToHclTerraform(struct!.enableSenderSideLoopDetection),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    local_address: {
      value: virtualRouterProtocolBgpPeerGroupPeerLocalAddressToHclTerraform(struct!.localAddress),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPeerGroupPeerLocalAddress",
    },
    max_prefixes: {
      value: cdktf.stringToHclTerraform(struct!.maxPrefixes),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    peer_address: {
      value: virtualRouterProtocolBgpPeerGroupPeerPeerAddressToHclTerraform(struct!.peerAddress),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPeerGroupPeerPeerAddress",
    },
    peer_as: {
      value: cdktf.stringToHclTerraform(struct!.peerAs),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    peering_type: {
      value: cdktf.stringToHclTerraform(struct!.peeringType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reflector_client: {
      value: cdktf.stringToHclTerraform(struct!.reflectorClient),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subsequent_address_family_identifier: {
      value: virtualRouterProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifierToHclTerraform(struct!.subsequentAddressFamilyIdentifier),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifier",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPeerGroupPeerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): VirtualRouterProtocolBgpPeerGroupPeer | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addressFamilyIdentifier !== undefined) {
      hasAnyValues = true;
      internalValueResult.addressFamilyIdentifier = this._addressFamilyIdentifier;
    }
    if (this._bfd?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.bfd = this._bfd?.internalValue;
    }
    if (this._connectionOptions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionOptions = this._connectionOptions?.internalValue;
    }
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._enableMpBgp !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableMpBgp = this._enableMpBgp;
    }
    if (this._enableSenderSideLoopDetection !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableSenderSideLoopDetection = this._enableSenderSideLoopDetection;
    }
    if (this._localAddress?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.localAddress = this._localAddress?.internalValue;
    }
    if (this._maxPrefixes !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPrefixes = this._maxPrefixes;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._peerAddress?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.peerAddress = this._peerAddress?.internalValue;
    }
    if (this._peerAs !== undefined) {
      hasAnyValues = true;
      internalValueResult.peerAs = this._peerAs;
    }
    if (this._peeringType !== undefined) {
      hasAnyValues = true;
      internalValueResult.peeringType = this._peeringType;
    }
    if (this._reflectorClient !== undefined) {
      hasAnyValues = true;
      internalValueResult.reflectorClient = this._reflectorClient;
    }
    if (this._subsequentAddressFamilyIdentifier?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.subsequentAddressFamilyIdentifier = this._subsequentAddressFamilyIdentifier?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPeerGroupPeer | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addressFamilyIdentifier = undefined;
      this._bfd.internalValue = undefined;
      this._connectionOptions.internalValue = undefined;
      this._enable = undefined;
      this._enableMpBgp = undefined;
      this._enableSenderSideLoopDetection = undefined;
      this._localAddress.internalValue = undefined;
      this._maxPrefixes = undefined;
      this._name = undefined;
      this._peerAddress.internalValue = undefined;
      this._peerAs = undefined;
      this._peeringType = undefined;
      this._reflectorClient = undefined;
      this._subsequentAddressFamilyIdentifier.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addressFamilyIdentifier = value.addressFamilyIdentifier;
      this._bfd.internalValue = value.bfd;
      this._connectionOptions.internalValue = value.connectionOptions;
      this._enable = value.enable;
      this._enableMpBgp = value.enableMpBgp;
      this._enableSenderSideLoopDetection = value.enableSenderSideLoopDetection;
      this._localAddress.internalValue = value.localAddress;
      this._maxPrefixes = value.maxPrefixes;
      this._name = value.name;
      this._peerAddress.internalValue = value.peerAddress;
      this._peerAs = value.peerAs;
      this._peeringType = value.peeringType;
      this._reflectorClient = value.reflectorClient;
      this._subsequentAddressFamilyIdentifier.internalValue = value.subsequentAddressFamilyIdentifier;
    }
  }

  // address_family_identifier - computed: true, optional: true, required: false
  private _addressFamilyIdentifier?: string; 
  public get addressFamilyIdentifier() {
    return this.getStringAttribute('address_family_identifier');
  }
  public set addressFamilyIdentifier(value: string) {
    this._addressFamilyIdentifier = value;
  }
  public resetAddressFamilyIdentifier() {
    this._addressFamilyIdentifier = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressFamilyIdentifierInput() {
    return this._addressFamilyIdentifier;
  }

  // bfd - computed: false, optional: true, required: false
  private _bfd = new VirtualRouterProtocolBgpPeerGroupPeerBfdOutputReference(this, "bfd");
  public get bfd() {
    return this._bfd;
  }
  public putBfd(value: VirtualRouterProtocolBgpPeerGroupPeerBfd) {
    this._bfd.internalValue = value;
  }
  public resetBfd() {
    this._bfd.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bfdInput() {
    return this._bfd.internalValue;
  }

  // connection_options - computed: false, optional: true, required: false
  private _connectionOptions = new VirtualRouterProtocolBgpPeerGroupPeerConnectionOptionsOutputReference(this, "connection_options");
  public get connectionOptions() {
    return this._connectionOptions;
  }
  public putConnectionOptions(value: VirtualRouterProtocolBgpPeerGroupPeerConnectionOptions) {
    this._connectionOptions.internalValue = value;
  }
  public resetConnectionOptions() {
    this._connectionOptions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionOptionsInput() {
    return this._connectionOptions.internalValue;
  }

  // enable - computed: false, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // enable_mp_bgp - computed: false, optional: true, required: false
  private _enableMpBgp?: boolean | cdktf.IResolvable; 
  public get enableMpBgp() {
    return this.getBooleanAttribute('enable_mp_bgp');
  }
  public set enableMpBgp(value: boolean | cdktf.IResolvable) {
    this._enableMpBgp = value;
  }
  public resetEnableMpBgp() {
    this._enableMpBgp = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableMpBgpInput() {
    return this._enableMpBgp;
  }

  // enable_sender_side_loop_detection - computed: false, optional: true, required: false
  private _enableSenderSideLoopDetection?: boolean | cdktf.IResolvable; 
  public get enableSenderSideLoopDetection() {
    return this.getBooleanAttribute('enable_sender_side_loop_detection');
  }
  public set enableSenderSideLoopDetection(value: boolean | cdktf.IResolvable) {
    this._enableSenderSideLoopDetection = value;
  }
  public resetEnableSenderSideLoopDetection() {
    this._enableSenderSideLoopDetection = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableSenderSideLoopDetectionInput() {
    return this._enableSenderSideLoopDetection;
  }

  // local_address - computed: false, optional: true, required: false
  private _localAddress = new VirtualRouterProtocolBgpPeerGroupPeerLocalAddressOutputReference(this, "local_address");
  public get localAddress() {
    return this._localAddress;
  }
  public putLocalAddress(value: VirtualRouterProtocolBgpPeerGroupPeerLocalAddress) {
    this._localAddress.internalValue = value;
  }
  public resetLocalAddress() {
    this._localAddress.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localAddressInput() {
    return this._localAddress.internalValue;
  }

  // max_prefixes - computed: true, optional: true, required: false
  private _maxPrefixes?: string; 
  public get maxPrefixes() {
    return this.getStringAttribute('max_prefixes');
  }
  public set maxPrefixes(value: string) {
    this._maxPrefixes = value;
  }
  public resetMaxPrefixes() {
    this._maxPrefixes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPrefixesInput() {
    return this._maxPrefixes;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // peer_address - computed: false, optional: true, required: false
  private _peerAddress = new VirtualRouterProtocolBgpPeerGroupPeerPeerAddressOutputReference(this, "peer_address");
  public get peerAddress() {
    return this._peerAddress;
  }
  public putPeerAddress(value: VirtualRouterProtocolBgpPeerGroupPeerPeerAddress) {
    this._peerAddress.internalValue = value;
  }
  public resetPeerAddress() {
    this._peerAddress.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get peerAddressInput() {
    return this._peerAddress.internalValue;
  }

  // peer_as - computed: false, optional: true, required: false
  private _peerAs?: string; 
  public get peerAs() {
    return this.getStringAttribute('peer_as');
  }
  public set peerAs(value: string) {
    this._peerAs = value;
  }
  public resetPeerAs() {
    this._peerAs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get peerAsInput() {
    return this._peerAs;
  }

  // peering_type - computed: true, optional: true, required: false
  private _peeringType?: string; 
  public get peeringType() {
    return this.getStringAttribute('peering_type');
  }
  public set peeringType(value: string) {
    this._peeringType = value;
  }
  public resetPeeringType() {
    this._peeringType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get peeringTypeInput() {
    return this._peeringType;
  }

  // reflector_client - computed: true, optional: true, required: false
  private _reflectorClient?: string; 
  public get reflectorClient() {
    return this.getStringAttribute('reflector_client');
  }
  public set reflectorClient(value: string) {
    this._reflectorClient = value;
  }
  public resetReflectorClient() {
    this._reflectorClient = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reflectorClientInput() {
    return this._reflectorClient;
  }

  // subsequent_address_family_identifier - computed: false, optional: true, required: false
  private _subsequentAddressFamilyIdentifier = new VirtualRouterProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifierOutputReference(this, "subsequent_address_family_identifier");
  public get subsequentAddressFamilyIdentifier() {
    return this._subsequentAddressFamilyIdentifier;
  }
  public putSubsequentAddressFamilyIdentifier(value: VirtualRouterProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifier) {
    this._subsequentAddressFamilyIdentifier.internalValue = value;
  }
  public resetSubsequentAddressFamilyIdentifier() {
    this._subsequentAddressFamilyIdentifier.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subsequentAddressFamilyIdentifierInput() {
    return this._subsequentAddressFamilyIdentifier.internalValue;
  }
}

export class VirtualRouterProtocolBgpPeerGroupPeerList extends cdktf.ComplexList {
  public internalValue? : VirtualRouterProtocolBgpPeerGroupPeer[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): VirtualRouterProtocolBgpPeerGroupPeerOutputReference {
    return new VirtualRouterProtocolBgpPeerGroupPeerOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface VirtualRouterProtocolBgpPeerGroupTypeEbgp {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#export_nexthop VirtualRouter#export_nexthop}
  */
  readonly exportNexthop?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#import_nexthop VirtualRouter#import_nexthop}
  */
  readonly importNexthop?: string;
  /**
  * remove private AS when exporting route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#remove_private_as VirtualRouter#remove_private_as}
  */
  readonly removePrivateAs?: boolean | cdktf.IResolvable;
}

export function virtualRouterProtocolBgpPeerGroupTypeEbgpToTerraform(struct?: VirtualRouterProtocolBgpPeerGroupTypeEbgp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    export_nexthop: cdktf.stringToTerraform(struct!.exportNexthop),
    import_nexthop: cdktf.stringToTerraform(struct!.importNexthop),
    remove_private_as: cdktf.booleanToTerraform(struct!.removePrivateAs),
  }
}


export function virtualRouterProtocolBgpPeerGroupTypeEbgpToHclTerraform(struct?: VirtualRouterProtocolBgpPeerGroupTypeEbgp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    export_nexthop: {
      value: cdktf.stringToHclTerraform(struct!.exportNexthop),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    import_nexthop: {
      value: cdktf.stringToHclTerraform(struct!.importNexthop),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    remove_private_as: {
      value: cdktf.booleanToHclTerraform(struct!.removePrivateAs),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPeerGroupTypeEbgpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPeerGroupTypeEbgp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._exportNexthop !== undefined) {
      hasAnyValues = true;
      internalValueResult.exportNexthop = this._exportNexthop;
    }
    if (this._importNexthop !== undefined) {
      hasAnyValues = true;
      internalValueResult.importNexthop = this._importNexthop;
    }
    if (this._removePrivateAs !== undefined) {
      hasAnyValues = true;
      internalValueResult.removePrivateAs = this._removePrivateAs;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPeerGroupTypeEbgp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._exportNexthop = undefined;
      this._importNexthop = undefined;
      this._removePrivateAs = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._exportNexthop = value.exportNexthop;
      this._importNexthop = value.importNexthop;
      this._removePrivateAs = value.removePrivateAs;
    }
  }

  // export_nexthop - computed: true, optional: true, required: false
  private _exportNexthop?: string; 
  public get exportNexthop() {
    return this.getStringAttribute('export_nexthop');
  }
  public set exportNexthop(value: string) {
    this._exportNexthop = value;
  }
  public resetExportNexthop() {
    this._exportNexthop = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exportNexthopInput() {
    return this._exportNexthop;
  }

  // import_nexthop - computed: true, optional: true, required: false
  private _importNexthop?: string; 
  public get importNexthop() {
    return this.getStringAttribute('import_nexthop');
  }
  public set importNexthop(value: string) {
    this._importNexthop = value;
  }
  public resetImportNexthop() {
    this._importNexthop = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get importNexthopInput() {
    return this._importNexthop;
  }

  // remove_private_as - computed: false, optional: true, required: false
  private _removePrivateAs?: boolean | cdktf.IResolvable; 
  public get removePrivateAs() {
    return this.getBooleanAttribute('remove_private_as');
  }
  public set removePrivateAs(value: boolean | cdktf.IResolvable) {
    this._removePrivateAs = value;
  }
  public resetRemovePrivateAs() {
    this._removePrivateAs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removePrivateAsInput() {
    return this._removePrivateAs;
  }
}
export interface VirtualRouterProtocolBgpPeerGroupTypeEbgpConfed {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#export_nexthop VirtualRouter#export_nexthop}
  */
  readonly exportNexthop?: string;
}

export function virtualRouterProtocolBgpPeerGroupTypeEbgpConfedToTerraform(struct?: VirtualRouterProtocolBgpPeerGroupTypeEbgpConfed | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    export_nexthop: cdktf.stringToTerraform(struct!.exportNexthop),
  }
}


export function virtualRouterProtocolBgpPeerGroupTypeEbgpConfedToHclTerraform(struct?: VirtualRouterProtocolBgpPeerGroupTypeEbgpConfed | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    export_nexthop: {
      value: cdktf.stringToHclTerraform(struct!.exportNexthop),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPeerGroupTypeEbgpConfedOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPeerGroupTypeEbgpConfed | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._exportNexthop !== undefined) {
      hasAnyValues = true;
      internalValueResult.exportNexthop = this._exportNexthop;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPeerGroupTypeEbgpConfed | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._exportNexthop = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._exportNexthop = value.exportNexthop;
    }
  }

  // export_nexthop - computed: true, optional: true, required: false
  private _exportNexthop?: string; 
  public get exportNexthop() {
    return this.getStringAttribute('export_nexthop');
  }
  public set exportNexthop(value: string) {
    this._exportNexthop = value;
  }
  public resetExportNexthop() {
    this._exportNexthop = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exportNexthopInput() {
    return this._exportNexthop;
  }
}
export interface VirtualRouterProtocolBgpPeerGroupTypeIbgp {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#export_nexthop VirtualRouter#export_nexthop}
  */
  readonly exportNexthop?: string;
}

export function virtualRouterProtocolBgpPeerGroupTypeIbgpToTerraform(struct?: VirtualRouterProtocolBgpPeerGroupTypeIbgp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    export_nexthop: cdktf.stringToTerraform(struct!.exportNexthop),
  }
}


export function virtualRouterProtocolBgpPeerGroupTypeIbgpToHclTerraform(struct?: VirtualRouterProtocolBgpPeerGroupTypeIbgp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    export_nexthop: {
      value: cdktf.stringToHclTerraform(struct!.exportNexthop),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPeerGroupTypeIbgpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPeerGroupTypeIbgp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._exportNexthop !== undefined) {
      hasAnyValues = true;
      internalValueResult.exportNexthop = this._exportNexthop;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPeerGroupTypeIbgp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._exportNexthop = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._exportNexthop = value.exportNexthop;
    }
  }

  // export_nexthop - computed: true, optional: true, required: false
  private _exportNexthop?: string; 
  public get exportNexthop() {
    return this.getStringAttribute('export_nexthop');
  }
  public set exportNexthop(value: string) {
    this._exportNexthop = value;
  }
  public resetExportNexthop() {
    this._exportNexthop = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exportNexthopInput() {
    return this._exportNexthop;
  }
}
export interface VirtualRouterProtocolBgpPeerGroupTypeIbgpConfed {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#export_nexthop VirtualRouter#export_nexthop}
  */
  readonly exportNexthop?: string;
}

export function virtualRouterProtocolBgpPeerGroupTypeIbgpConfedToTerraform(struct?: VirtualRouterProtocolBgpPeerGroupTypeIbgpConfed | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    export_nexthop: cdktf.stringToTerraform(struct!.exportNexthop),
  }
}


export function virtualRouterProtocolBgpPeerGroupTypeIbgpConfedToHclTerraform(struct?: VirtualRouterProtocolBgpPeerGroupTypeIbgpConfed | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    export_nexthop: {
      value: cdktf.stringToHclTerraform(struct!.exportNexthop),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPeerGroupTypeIbgpConfedOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPeerGroupTypeIbgpConfed | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._exportNexthop !== undefined) {
      hasAnyValues = true;
      internalValueResult.exportNexthop = this._exportNexthop;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPeerGroupTypeIbgpConfed | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._exportNexthop = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._exportNexthop = value.exportNexthop;
    }
  }

  // export_nexthop - computed: true, optional: true, required: false
  private _exportNexthop?: string; 
  public get exportNexthop() {
    return this.getStringAttribute('export_nexthop');
  }
  public set exportNexthop(value: string) {
    this._exportNexthop = value;
  }
  public resetExportNexthop() {
    this._exportNexthop = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exportNexthopInput() {
    return this._exportNexthop;
  }
}
export interface VirtualRouterProtocolBgpPeerGroupType {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#ebgp VirtualRouter#ebgp}
  */
  readonly ebgp?: VirtualRouterProtocolBgpPeerGroupTypeEbgp;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#ebgp_confed VirtualRouter#ebgp_confed}
  */
  readonly ebgpConfed?: VirtualRouterProtocolBgpPeerGroupTypeEbgpConfed;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#ibgp VirtualRouter#ibgp}
  */
  readonly ibgp?: VirtualRouterProtocolBgpPeerGroupTypeIbgp;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#ibgp_confed VirtualRouter#ibgp_confed}
  */
  readonly ibgpConfed?: VirtualRouterProtocolBgpPeerGroupTypeIbgpConfed;
}

export function virtualRouterProtocolBgpPeerGroupTypeToTerraform(struct?: VirtualRouterProtocolBgpPeerGroupType | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ebgp: virtualRouterProtocolBgpPeerGroupTypeEbgpToTerraform(struct!.ebgp),
    ebgp_confed: virtualRouterProtocolBgpPeerGroupTypeEbgpConfedToTerraform(struct!.ebgpConfed),
    ibgp: virtualRouterProtocolBgpPeerGroupTypeIbgpToTerraform(struct!.ibgp),
    ibgp_confed: virtualRouterProtocolBgpPeerGroupTypeIbgpConfedToTerraform(struct!.ibgpConfed),
  }
}


export function virtualRouterProtocolBgpPeerGroupTypeToHclTerraform(struct?: VirtualRouterProtocolBgpPeerGroupType | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ebgp: {
      value: virtualRouterProtocolBgpPeerGroupTypeEbgpToHclTerraform(struct!.ebgp),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPeerGroupTypeEbgp",
    },
    ebgp_confed: {
      value: virtualRouterProtocolBgpPeerGroupTypeEbgpConfedToHclTerraform(struct!.ebgpConfed),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPeerGroupTypeEbgpConfed",
    },
    ibgp: {
      value: virtualRouterProtocolBgpPeerGroupTypeIbgpToHclTerraform(struct!.ibgp),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPeerGroupTypeIbgp",
    },
    ibgp_confed: {
      value: virtualRouterProtocolBgpPeerGroupTypeIbgpConfedToHclTerraform(struct!.ibgpConfed),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPeerGroupTypeIbgpConfed",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPeerGroupTypeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPeerGroupType | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ebgp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ebgp = this._ebgp?.internalValue;
    }
    if (this._ebgpConfed?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ebgpConfed = this._ebgpConfed?.internalValue;
    }
    if (this._ibgp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ibgp = this._ibgp?.internalValue;
    }
    if (this._ibgpConfed?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ibgpConfed = this._ibgpConfed?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPeerGroupType | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ebgp.internalValue = undefined;
      this._ebgpConfed.internalValue = undefined;
      this._ibgp.internalValue = undefined;
      this._ibgpConfed.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ebgp.internalValue = value.ebgp;
      this._ebgpConfed.internalValue = value.ebgpConfed;
      this._ibgp.internalValue = value.ibgp;
      this._ibgpConfed.internalValue = value.ibgpConfed;
    }
  }

  // ebgp - computed: false, optional: true, required: false
  private _ebgp = new VirtualRouterProtocolBgpPeerGroupTypeEbgpOutputReference(this, "ebgp");
  public get ebgp() {
    return this._ebgp;
  }
  public putEbgp(value: VirtualRouterProtocolBgpPeerGroupTypeEbgp) {
    this._ebgp.internalValue = value;
  }
  public resetEbgp() {
    this._ebgp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ebgpInput() {
    return this._ebgp.internalValue;
  }

  // ebgp_confed - computed: false, optional: true, required: false
  private _ebgpConfed = new VirtualRouterProtocolBgpPeerGroupTypeEbgpConfedOutputReference(this, "ebgp_confed");
  public get ebgpConfed() {
    return this._ebgpConfed;
  }
  public putEbgpConfed(value: VirtualRouterProtocolBgpPeerGroupTypeEbgpConfed) {
    this._ebgpConfed.internalValue = value;
  }
  public resetEbgpConfed() {
    this._ebgpConfed.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ebgpConfedInput() {
    return this._ebgpConfed.internalValue;
  }

  // ibgp - computed: false, optional: true, required: false
  private _ibgp = new VirtualRouterProtocolBgpPeerGroupTypeIbgpOutputReference(this, "ibgp");
  public get ibgp() {
    return this._ibgp;
  }
  public putIbgp(value: VirtualRouterProtocolBgpPeerGroupTypeIbgp) {
    this._ibgp.internalValue = value;
  }
  public resetIbgp() {
    this._ibgp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ibgpInput() {
    return this._ibgp.internalValue;
  }

  // ibgp_confed - computed: false, optional: true, required: false
  private _ibgpConfed = new VirtualRouterProtocolBgpPeerGroupTypeIbgpConfedOutputReference(this, "ibgp_confed");
  public get ibgpConfed() {
    return this._ibgpConfed;
  }
  public putIbgpConfed(value: VirtualRouterProtocolBgpPeerGroupTypeIbgpConfed) {
    this._ibgpConfed.internalValue = value;
  }
  public resetIbgpConfed() {
    this._ibgpConfed.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ibgpConfedInput() {
    return this._ibgpConfed.internalValue;
  }
}
export interface VirtualRouterProtocolBgpPeerGroup {
  /**
  * the peers understand aggregated confederation AS path
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#aggregated_confed_as_path VirtualRouter#aggregated_confed_as_path}
  */
  readonly aggregatedConfedAsPath?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#enable VirtualRouter#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#name VirtualRouter#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#peer VirtualRouter#peer}
  */
  readonly peer?: VirtualRouterProtocolBgpPeerGroupPeer[] | cdktf.IResolvable;
  /**
  * soft reset with stored info
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#soft_reset_with_stored_info VirtualRouter#soft_reset_with_stored_info}
  */
  readonly softResetWithStoredInfo?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#type VirtualRouter#type}
  */
  readonly type?: VirtualRouterProtocolBgpPeerGroupType;
}

export function virtualRouterProtocolBgpPeerGroupToTerraform(struct?: VirtualRouterProtocolBgpPeerGroup | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    aggregated_confed_as_path: cdktf.booleanToTerraform(struct!.aggregatedConfedAsPath),
    enable: cdktf.booleanToTerraform(struct!.enable),
    name: cdktf.stringToTerraform(struct!.name),
    peer: cdktf.listMapper(virtualRouterProtocolBgpPeerGroupPeerToTerraform, false)(struct!.peer),
    soft_reset_with_stored_info: cdktf.booleanToTerraform(struct!.softResetWithStoredInfo),
    type: virtualRouterProtocolBgpPeerGroupTypeToTerraform(struct!.type),
  }
}


export function virtualRouterProtocolBgpPeerGroupToHclTerraform(struct?: VirtualRouterProtocolBgpPeerGroup | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    aggregated_confed_as_path: {
      value: cdktf.booleanToHclTerraform(struct!.aggregatedConfedAsPath),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    peer: {
      value: cdktf.listMapperHcl(virtualRouterProtocolBgpPeerGroupPeerToHclTerraform, false)(struct!.peer),
      isBlock: true,
      type: "list",
      storageClassType: "VirtualRouterProtocolBgpPeerGroupPeerList",
    },
    soft_reset_with_stored_info: {
      value: cdktf.booleanToHclTerraform(struct!.softResetWithStoredInfo),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    type: {
      value: virtualRouterProtocolBgpPeerGroupTypeToHclTerraform(struct!.type),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPeerGroupType",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPeerGroupOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): VirtualRouterProtocolBgpPeerGroup | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._aggregatedConfedAsPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.aggregatedConfedAsPath = this._aggregatedConfedAsPath;
    }
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._peer?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.peer = this._peer?.internalValue;
    }
    if (this._softResetWithStoredInfo !== undefined) {
      hasAnyValues = true;
      internalValueResult.softResetWithStoredInfo = this._softResetWithStoredInfo;
    }
    if (this._type?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPeerGroup | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._aggregatedConfedAsPath = undefined;
      this._enable = undefined;
      this._name = undefined;
      this._peer.internalValue = undefined;
      this._softResetWithStoredInfo = undefined;
      this._type.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._aggregatedConfedAsPath = value.aggregatedConfedAsPath;
      this._enable = value.enable;
      this._name = value.name;
      this._peer.internalValue = value.peer;
      this._softResetWithStoredInfo = value.softResetWithStoredInfo;
      this._type.internalValue = value.type;
    }
  }

  // aggregated_confed_as_path - computed: false, optional: true, required: false
  private _aggregatedConfedAsPath?: boolean | cdktf.IResolvable; 
  public get aggregatedConfedAsPath() {
    return this.getBooleanAttribute('aggregated_confed_as_path');
  }
  public set aggregatedConfedAsPath(value: boolean | cdktf.IResolvable) {
    this._aggregatedConfedAsPath = value;
  }
  public resetAggregatedConfedAsPath() {
    this._aggregatedConfedAsPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aggregatedConfedAsPathInput() {
    return this._aggregatedConfedAsPath;
  }

  // enable - computed: false, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // peer - computed: false, optional: true, required: false
  private _peer = new VirtualRouterProtocolBgpPeerGroupPeerList(this, "peer", false);
  public get peer() {
    return this._peer;
  }
  public putPeer(value: VirtualRouterProtocolBgpPeerGroupPeer[] | cdktf.IResolvable) {
    this._peer.internalValue = value;
  }
  public resetPeer() {
    this._peer.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get peerInput() {
    return this._peer.internalValue;
  }

  // soft_reset_with_stored_info - computed: false, optional: true, required: false
  private _softResetWithStoredInfo?: boolean | cdktf.IResolvable; 
  public get softResetWithStoredInfo() {
    return this.getBooleanAttribute('soft_reset_with_stored_info');
  }
  public set softResetWithStoredInfo(value: boolean | cdktf.IResolvable) {
    this._softResetWithStoredInfo = value;
  }
  public resetSoftResetWithStoredInfo() {
    this._softResetWithStoredInfo = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get softResetWithStoredInfoInput() {
    return this._softResetWithStoredInfo;
  }

  // type - computed: false, optional: true, required: false
  private _type = new VirtualRouterProtocolBgpPeerGroupTypeOutputReference(this, "type");
  public get type() {
    return this._type;
  }
  public putType(value: VirtualRouterProtocolBgpPeerGroupType) {
    this._type.internalValue = value;
  }
  public resetType() {
    this._type.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type.internalValue;
  }
}

export class VirtualRouterProtocolBgpPeerGroupList extends cdktf.ComplexList {
  public internalValue? : VirtualRouterProtocolBgpPeerGroup[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): VirtualRouterProtocolBgpPeerGroupOutputReference {
    return new VirtualRouterProtocolBgpPeerGroupOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefix {
  /**
  * match exact prefix length
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#exact VirtualRouter#exact}
  */
  readonly exact?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#name VirtualRouter#name}
  */
  readonly name: string;
}

export function virtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixToTerraform(struct?: VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    exact: cdktf.booleanToTerraform(struct!.exact),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function virtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    exact: {
      value: cdktf.booleanToHclTerraform(struct!.exact),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefix | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._exact !== undefined) {
      hasAnyValues = true;
      internalValueResult.exact = this._exact;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefix | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._exact = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._exact = value.exact;
      this._name = value.name;
    }
  }

  // exact - computed: false, optional: true, required: false
  private _exact?: boolean | cdktf.IResolvable; 
  public get exact() {
    return this.getBooleanAttribute('exact');
  }
  public set exact(value: boolean | cdktf.IResolvable) {
    this._exact = value;
  }
  public resetExact() {
    this._exact = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exactInput() {
    return this._exact;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixList extends cdktf.ComplexList {
  public internalValue? : VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefix[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixOutputReference {
    return new VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPath {
  /**
  * AS-path regular expression
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#regex VirtualRouter#regex}
  */
  readonly regex?: string;
}

export function virtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathToTerraform(struct?: VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function virtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPath | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPath | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._regex = value.regex;
    }
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunity {
  /**
  * AS-path regular expression
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#regex VirtualRouter#regex}
  */
  readonly regex?: string;
}

export function virtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunityToTerraform(struct?: VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function virtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunityToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._regex = value.regex;
    }
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunity {
  /**
  * AS-path regular expression
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#regex VirtualRouter#regex}
  */
  readonly regex?: string;
}

export function virtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunityToTerraform(struct?: VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function virtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunityToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._regex = value.regex;
    }
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatch {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#address_prefix VirtualRouter#address_prefix}
  */
  readonly addressPrefix?: VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefix[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#as_path VirtualRouter#as_path}
  */
  readonly asPath?: VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPath;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#community VirtualRouter#community}
  */
  readonly community?: VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunity;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#extended_community VirtualRouter#extended_community}
  */
  readonly extendedCommunity?: VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunity;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#from_peer VirtualRouter#from_peer}
  */
  readonly fromPeer?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#med VirtualRouter#med}
  */
  readonly med?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#nexthop VirtualRouter#nexthop}
  */
  readonly nexthop?: string[];
  /**
  * route table to match rule
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#route_table VirtualRouter#route_table}
  */
  readonly routeTable?: string;
}

export function virtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchToTerraform(struct?: VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address_prefix: cdktf.listMapper(virtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixToTerraform, false)(struct!.addressPrefix),
    as_path: virtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathToTerraform(struct!.asPath),
    community: virtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunityToTerraform(struct!.community),
    extended_community: virtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunityToTerraform(struct!.extendedCommunity),
    from_peer: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.fromPeer),
    med: cdktf.numberToTerraform(struct!.med),
    nexthop: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.nexthop),
    route_table: cdktf.stringToTerraform(struct!.routeTable),
  }
}


export function virtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address_prefix: {
      value: cdktf.listMapperHcl(virtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixToHclTerraform, false)(struct!.addressPrefix),
      isBlock: true,
      type: "list",
      storageClassType: "VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixList",
    },
    as_path: {
      value: virtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathToHclTerraform(struct!.asPath),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPath",
    },
    community: {
      value: virtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunityToHclTerraform(struct!.community),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunity",
    },
    extended_community: {
      value: virtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunityToHclTerraform(struct!.extendedCommunity),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunity",
    },
    from_peer: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.fromPeer),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    med: {
      value: cdktf.numberToHclTerraform(struct!.med),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    nexthop: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.nexthop),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    route_table: {
      value: cdktf.stringToHclTerraform(struct!.routeTable),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addressPrefix?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.addressPrefix = this._addressPrefix?.internalValue;
    }
    if (this._asPath?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.asPath = this._asPath?.internalValue;
    }
    if (this._community?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.community = this._community?.internalValue;
    }
    if (this._extendedCommunity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extendedCommunity = this._extendedCommunity?.internalValue;
    }
    if (this._fromPeer !== undefined) {
      hasAnyValues = true;
      internalValueResult.fromPeer = this._fromPeer;
    }
    if (this._med !== undefined) {
      hasAnyValues = true;
      internalValueResult.med = this._med;
    }
    if (this._nexthop !== undefined) {
      hasAnyValues = true;
      internalValueResult.nexthop = this._nexthop;
    }
    if (this._routeTable !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeTable = this._routeTable;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addressPrefix.internalValue = undefined;
      this._asPath.internalValue = undefined;
      this._community.internalValue = undefined;
      this._extendedCommunity.internalValue = undefined;
      this._fromPeer = undefined;
      this._med = undefined;
      this._nexthop = undefined;
      this._routeTable = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addressPrefix.internalValue = value.addressPrefix;
      this._asPath.internalValue = value.asPath;
      this._community.internalValue = value.community;
      this._extendedCommunity.internalValue = value.extendedCommunity;
      this._fromPeer = value.fromPeer;
      this._med = value.med;
      this._nexthop = value.nexthop;
      this._routeTable = value.routeTable;
    }
  }

  // address_prefix - computed: false, optional: true, required: false
  private _addressPrefix = new VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixList(this, "address_prefix", false);
  public get addressPrefix() {
    return this._addressPrefix;
  }
  public putAddressPrefix(value: VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefix[] | cdktf.IResolvable) {
    this._addressPrefix.internalValue = value;
  }
  public resetAddressPrefix() {
    this._addressPrefix.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressPrefixInput() {
    return this._addressPrefix.internalValue;
  }

  // as_path - computed: false, optional: true, required: false
  private _asPath = new VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathOutputReference(this, "as_path");
  public get asPath() {
    return this._asPath;
  }
  public putAsPath(value: VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPath) {
    this._asPath.internalValue = value;
  }
  public resetAsPath() {
    this._asPath.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asPathInput() {
    return this._asPath.internalValue;
  }

  // community - computed: false, optional: true, required: false
  private _community = new VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunityOutputReference(this, "community");
  public get community() {
    return this._community;
  }
  public putCommunity(value: VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunity) {
    this._community.internalValue = value;
  }
  public resetCommunity() {
    this._community.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get communityInput() {
    return this._community.internalValue;
  }

  // extended_community - computed: false, optional: true, required: false
  private _extendedCommunity = new VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunityOutputReference(this, "extended_community");
  public get extendedCommunity() {
    return this._extendedCommunity;
  }
  public putExtendedCommunity(value: VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunity) {
    this._extendedCommunity.internalValue = value;
  }
  public resetExtendedCommunity() {
    this._extendedCommunity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extendedCommunityInput() {
    return this._extendedCommunity.internalValue;
  }

  // from_peer - computed: false, optional: true, required: false
  private _fromPeer?: string[]; 
  public get fromPeer() {
    return this.getListAttribute('from_peer');
  }
  public set fromPeer(value: string[]) {
    this._fromPeer = value;
  }
  public resetFromPeer() {
    this._fromPeer = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fromPeerInput() {
    return this._fromPeer;
  }

  // med - computed: false, optional: true, required: false
  private _med?: number; 
  public get med() {
    return this.getNumberAttribute('med');
  }
  public set med(value: number) {
    this._med = value;
  }
  public resetMed() {
    this._med = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get medInput() {
    return this._med;
  }

  // nexthop - computed: false, optional: true, required: false
  private _nexthop?: string[]; 
  public get nexthop() {
    return this.getListAttribute('nexthop');
  }
  public set nexthop(value: string[]) {
    this._nexthop = value;
  }
  public resetNexthop() {
    this._nexthop = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nexthopInput() {
    return this._nexthop;
  }

  // route_table - computed: true, optional: true, required: false
  private _routeTable?: string; 
  public get routeTable() {
    return this.getStringAttribute('route_table');
  }
  public set routeTable(value: string) {
    this._routeTable = value;
  }
  public resetRouteTable() {
    this._routeTable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeTableInput() {
    return this._routeTable;
  }
}
export interface VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFilters {
  /**
  * enble this rule
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#enable VirtualRouter#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#match VirtualRouter#match}
  */
  readonly match?: VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#name VirtualRouter#name}
  */
  readonly name: string;
}

export function virtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersToTerraform(struct?: VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFilters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enable: cdktf.booleanToTerraform(struct!.enable),
    match: virtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchToTerraform(struct!.match),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function virtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFilters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    match: {
      value: virtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchToHclTerraform(struct!.match),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatch",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFilters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._match?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFilters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enable = undefined;
      this._match.internalValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enable = value.enable;
      this._match.internalValue = value.match;
      this._name = value.name;
    }
  }

  // enable - computed: false, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // match - computed: false, optional: true, required: false
  private _match = new VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchOutputReference(this, "match");
  public get match() {
    return this._match;
  }
  public putMatch(value: VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatch) {
    this._match.internalValue = value;
  }
  public resetMatch() {
    this._match.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match.internalValue;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersList extends cdktf.ComplexList {
  public internalValue? : VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFilters[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersOutputReference {
    return new VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNone {
}

export function virtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneToTerraform(struct?: VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNone | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function virtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNone | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNone | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNone | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPath {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#none VirtualRouter#none}
  */
  readonly none?: VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNone;
  /**
  * prepend local AS for specified number of times
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#prepend VirtualRouter#prepend}
  */
  readonly prepend?: number;
}

export function virtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathToTerraform(struct?: VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    none: virtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneToTerraform(struct!.none),
    prepend: cdktf.numberToTerraform(struct!.prepend),
  }
}


export function virtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    none: {
      value: virtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneToHclTerraform(struct!.none),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNone",
    },
    prepend: {
      value: cdktf.numberToHclTerraform(struct!.prepend),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPath | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._none?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.none = this._none?.internalValue;
    }
    if (this._prepend !== undefined) {
      hasAnyValues = true;
      internalValueResult.prepend = this._prepend;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPath | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._none.internalValue = undefined;
      this._prepend = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._none.internalValue = value.none;
      this._prepend = value.prepend;
    }
  }

  // none - computed: false, optional: true, required: false
  private _none = new VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneOutputReference(this, "none");
  public get none() {
    return this._none;
  }
  public putNone(value: VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNone) {
    this._none.internalValue = value;
  }
  public resetNone() {
    this._none.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get noneInput() {
    return this._none.internalValue;
  }

  // prepend - computed: true, optional: true, required: false
  private _prepend?: number; 
  public get prepend() {
    return this.getNumberAttribute('prepend');
  }
  public set prepend(value: number) {
    this._prepend = value;
  }
  public resetPrepend() {
    this._prepend = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prependInput() {
    return this._prepend;
  }
}
export interface VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNone {
}

export function virtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneToTerraform(struct?: VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNone | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function virtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNone | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNone | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNone | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAll {
}

export function virtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllToTerraform(struct?: VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAll | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function virtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAll | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAll | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAll | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunity {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#append VirtualRouter#append}
  */
  readonly append?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#none VirtualRouter#none}
  */
  readonly none?: VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNone;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#overwrite VirtualRouter#overwrite}
  */
  readonly overwrite?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#remove_all VirtualRouter#remove_all}
  */
  readonly removeAll?: VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAll;
  /**
  * remove specified coummnity match regular expression
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#remove_regex VirtualRouter#remove_regex}
  */
  readonly removeRegex?: string;
}

export function virtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityToTerraform(struct?: VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    append: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.append),
    none: virtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneToTerraform(struct!.none),
    overwrite: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.overwrite),
    remove_all: virtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllToTerraform(struct!.removeAll),
    remove_regex: cdktf.stringToTerraform(struct!.removeRegex),
  }
}


export function virtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    append: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.append),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    none: {
      value: virtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneToHclTerraform(struct!.none),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNone",
    },
    overwrite: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.overwrite),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    remove_all: {
      value: virtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllToHclTerraform(struct!.removeAll),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAll",
    },
    remove_regex: {
      value: cdktf.stringToHclTerraform(struct!.removeRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._append !== undefined) {
      hasAnyValues = true;
      internalValueResult.append = this._append;
    }
    if (this._none?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.none = this._none?.internalValue;
    }
    if (this._overwrite !== undefined) {
      hasAnyValues = true;
      internalValueResult.overwrite = this._overwrite;
    }
    if (this._removeAll?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.removeAll = this._removeAll?.internalValue;
    }
    if (this._removeRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.removeRegex = this._removeRegex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._append = undefined;
      this._none.internalValue = undefined;
      this._overwrite = undefined;
      this._removeAll.internalValue = undefined;
      this._removeRegex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._append = value.append;
      this._none.internalValue = value.none;
      this._overwrite = value.overwrite;
      this._removeAll.internalValue = value.removeAll;
      this._removeRegex = value.removeRegex;
    }
  }

  // append - computed: false, optional: true, required: false
  private _append?: string[]; 
  public get append() {
    return this.getListAttribute('append');
  }
  public set append(value: string[]) {
    this._append = value;
  }
  public resetAppend() {
    this._append = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appendInput() {
    return this._append;
  }

  // none - computed: false, optional: true, required: false
  private _none = new VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneOutputReference(this, "none");
  public get none() {
    return this._none;
  }
  public putNone(value: VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNone) {
    this._none.internalValue = value;
  }
  public resetNone() {
    this._none.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get noneInput() {
    return this._none.internalValue;
  }

  // overwrite - computed: false, optional: true, required: false
  private _overwrite?: string[]; 
  public get overwrite() {
    return this.getListAttribute('overwrite');
  }
  public set overwrite(value: string[]) {
    this._overwrite = value;
  }
  public resetOverwrite() {
    this._overwrite = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overwriteInput() {
    return this._overwrite;
  }

  // remove_all - computed: false, optional: true, required: false
  private _removeAll = new VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllOutputReference(this, "remove_all");
  public get removeAll() {
    return this._removeAll;
  }
  public putRemoveAll(value: VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAll) {
    this._removeAll.internalValue = value;
  }
  public resetRemoveAll() {
    this._removeAll.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeAllInput() {
    return this._removeAll.internalValue;
  }

  // remove_regex - computed: false, optional: true, required: false
  private _removeRegex?: string; 
  public get removeRegex() {
    return this.getStringAttribute('remove_regex');
  }
  public set removeRegex(value: string) {
    this._removeRegex = value;
  }
  public resetRemoveRegex() {
    this._removeRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeRegexInput() {
    return this._removeRegex;
  }
}
export interface VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNone {
}

export function virtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneToTerraform(struct?: VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNone | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function virtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNone | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNone | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNone | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAll {
}

export function virtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllToTerraform(struct?: VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAll | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function virtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAll | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAll | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAll | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunity {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#append VirtualRouter#append}
  */
  readonly append?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#none VirtualRouter#none}
  */
  readonly none?: VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNone;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#overwrite VirtualRouter#overwrite}
  */
  readonly overwrite?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#remove_all VirtualRouter#remove_all}
  */
  readonly removeAll?: VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAll;
  /**
  * remove specified coummnity match regular expression
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#remove_regex VirtualRouter#remove_regex}
  */
  readonly removeRegex?: string;
}

export function virtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityToTerraform(struct?: VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    append: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.append),
    none: virtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneToTerraform(struct!.none),
    overwrite: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.overwrite),
    remove_all: virtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllToTerraform(struct!.removeAll),
    remove_regex: cdktf.stringToTerraform(struct!.removeRegex),
  }
}


export function virtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    append: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.append),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    none: {
      value: virtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneToHclTerraform(struct!.none),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNone",
    },
    overwrite: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.overwrite),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    remove_all: {
      value: virtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllToHclTerraform(struct!.removeAll),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAll",
    },
    remove_regex: {
      value: cdktf.stringToHclTerraform(struct!.removeRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._append !== undefined) {
      hasAnyValues = true;
      internalValueResult.append = this._append;
    }
    if (this._none?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.none = this._none?.internalValue;
    }
    if (this._overwrite !== undefined) {
      hasAnyValues = true;
      internalValueResult.overwrite = this._overwrite;
    }
    if (this._removeAll?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.removeAll = this._removeAll?.internalValue;
    }
    if (this._removeRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.removeRegex = this._removeRegex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._append = undefined;
      this._none.internalValue = undefined;
      this._overwrite = undefined;
      this._removeAll.internalValue = undefined;
      this._removeRegex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._append = value.append;
      this._none.internalValue = value.none;
      this._overwrite = value.overwrite;
      this._removeAll.internalValue = value.removeAll;
      this._removeRegex = value.removeRegex;
    }
  }

  // append - computed: false, optional: true, required: false
  private _append?: string[]; 
  public get append() {
    return this.getListAttribute('append');
  }
  public set append(value: string[]) {
    this._append = value;
  }
  public resetAppend() {
    this._append = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appendInput() {
    return this._append;
  }

  // none - computed: false, optional: true, required: false
  private _none = new VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneOutputReference(this, "none");
  public get none() {
    return this._none;
  }
  public putNone(value: VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNone) {
    this._none.internalValue = value;
  }
  public resetNone() {
    this._none.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get noneInput() {
    return this._none.internalValue;
  }

  // overwrite - computed: false, optional: true, required: false
  private _overwrite?: string[]; 
  public get overwrite() {
    return this.getListAttribute('overwrite');
  }
  public set overwrite(value: string[]) {
    this._overwrite = value;
  }
  public resetOverwrite() {
    this._overwrite = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overwriteInput() {
    return this._overwrite;
  }

  // remove_all - computed: false, optional: true, required: false
  private _removeAll = new VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllOutputReference(this, "remove_all");
  public get removeAll() {
    return this._removeAll;
  }
  public putRemoveAll(value: VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAll) {
    this._removeAll.internalValue = value;
  }
  public resetRemoveAll() {
    this._removeAll.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeAllInput() {
    return this._removeAll.internalValue;
  }

  // remove_regex - computed: false, optional: true, required: false
  private _removeRegex?: string; 
  public get removeRegex() {
    return this.getStringAttribute('remove_regex');
  }
  public set removeRegex(value: string) {
    this._removeRegex = value;
  }
  public resetRemoveRegex() {
    this._removeRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeRegexInput() {
    return this._removeRegex;
  }
}
export interface VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributes {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#as_path VirtualRouter#as_path}
  */
  readonly asPath?: VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPath;
  /**
  * add AS path limit attribute if it does not exist 
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#as_path_limit VirtualRouter#as_path_limit}
  */
  readonly asPathLimit?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#community VirtualRouter#community}
  */
  readonly community?: VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunity;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#extended_community VirtualRouter#extended_community}
  */
  readonly extendedCommunity?: VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunity;
  /**
  * new local preference value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#local_preference VirtualRouter#local_preference}
  */
  readonly localPreference?: number;
  /**
  * new MED value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#med VirtualRouter#med}
  */
  readonly med?: number;
  /**
  * nexthop address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#nexthop VirtualRouter#nexthop}
  */
  readonly nexthop?: string;
  /**
  * new route origin
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#origin VirtualRouter#origin}
  */
  readonly origin?: string;
  /**
  * new weight value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#weight VirtualRouter#weight}
  */
  readonly weight?: number;
}

export function virtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesToTerraform(struct?: VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributes | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    as_path: virtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathToTerraform(struct!.asPath),
    as_path_limit: cdktf.numberToTerraform(struct!.asPathLimit),
    community: virtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityToTerraform(struct!.community),
    extended_community: virtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityToTerraform(struct!.extendedCommunity),
    local_preference: cdktf.numberToTerraform(struct!.localPreference),
    med: cdktf.numberToTerraform(struct!.med),
    nexthop: cdktf.stringToTerraform(struct!.nexthop),
    origin: cdktf.stringToTerraform(struct!.origin),
    weight: cdktf.numberToTerraform(struct!.weight),
  }
}


export function virtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributes | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    as_path: {
      value: virtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathToHclTerraform(struct!.asPath),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPath",
    },
    as_path_limit: {
      value: cdktf.numberToHclTerraform(struct!.asPathLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    community: {
      value: virtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityToHclTerraform(struct!.community),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunity",
    },
    extended_community: {
      value: virtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityToHclTerraform(struct!.extendedCommunity),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunity",
    },
    local_preference: {
      value: cdktf.numberToHclTerraform(struct!.localPreference),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    med: {
      value: cdktf.numberToHclTerraform(struct!.med),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    nexthop: {
      value: cdktf.stringToHclTerraform(struct!.nexthop),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    origin: {
      value: cdktf.stringToHclTerraform(struct!.origin),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    weight: {
      value: cdktf.numberToHclTerraform(struct!.weight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributes | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._asPath?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.asPath = this._asPath?.internalValue;
    }
    if (this._asPathLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.asPathLimit = this._asPathLimit;
    }
    if (this._community?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.community = this._community?.internalValue;
    }
    if (this._extendedCommunity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extendedCommunity = this._extendedCommunity?.internalValue;
    }
    if (this._localPreference !== undefined) {
      hasAnyValues = true;
      internalValueResult.localPreference = this._localPreference;
    }
    if (this._med !== undefined) {
      hasAnyValues = true;
      internalValueResult.med = this._med;
    }
    if (this._nexthop !== undefined) {
      hasAnyValues = true;
      internalValueResult.nexthop = this._nexthop;
    }
    if (this._origin !== undefined) {
      hasAnyValues = true;
      internalValueResult.origin = this._origin;
    }
    if (this._weight !== undefined) {
      hasAnyValues = true;
      internalValueResult.weight = this._weight;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributes | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._asPath.internalValue = undefined;
      this._asPathLimit = undefined;
      this._community.internalValue = undefined;
      this._extendedCommunity.internalValue = undefined;
      this._localPreference = undefined;
      this._med = undefined;
      this._nexthop = undefined;
      this._origin = undefined;
      this._weight = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._asPath.internalValue = value.asPath;
      this._asPathLimit = value.asPathLimit;
      this._community.internalValue = value.community;
      this._extendedCommunity.internalValue = value.extendedCommunity;
      this._localPreference = value.localPreference;
      this._med = value.med;
      this._nexthop = value.nexthop;
      this._origin = value.origin;
      this._weight = value.weight;
    }
  }

  // as_path - computed: false, optional: true, required: false
  private _asPath = new VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathOutputReference(this, "as_path");
  public get asPath() {
    return this._asPath;
  }
  public putAsPath(value: VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPath) {
    this._asPath.internalValue = value;
  }
  public resetAsPath() {
    this._asPath.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asPathInput() {
    return this._asPath.internalValue;
  }

  // as_path_limit - computed: false, optional: true, required: false
  private _asPathLimit?: number; 
  public get asPathLimit() {
    return this.getNumberAttribute('as_path_limit');
  }
  public set asPathLimit(value: number) {
    this._asPathLimit = value;
  }
  public resetAsPathLimit() {
    this._asPathLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asPathLimitInput() {
    return this._asPathLimit;
  }

  // community - computed: false, optional: true, required: false
  private _community = new VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityOutputReference(this, "community");
  public get community() {
    return this._community;
  }
  public putCommunity(value: VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunity) {
    this._community.internalValue = value;
  }
  public resetCommunity() {
    this._community.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get communityInput() {
    return this._community.internalValue;
  }

  // extended_community - computed: false, optional: true, required: false
  private _extendedCommunity = new VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityOutputReference(this, "extended_community");
  public get extendedCommunity() {
    return this._extendedCommunity;
  }
  public putExtendedCommunity(value: VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunity) {
    this._extendedCommunity.internalValue = value;
  }
  public resetExtendedCommunity() {
    this._extendedCommunity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extendedCommunityInput() {
    return this._extendedCommunity.internalValue;
  }

  // local_preference - computed: false, optional: true, required: false
  private _localPreference?: number; 
  public get localPreference() {
    return this.getNumberAttribute('local_preference');
  }
  public set localPreference(value: number) {
    this._localPreference = value;
  }
  public resetLocalPreference() {
    this._localPreference = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localPreferenceInput() {
    return this._localPreference;
  }

  // med - computed: false, optional: true, required: false
  private _med?: number; 
  public get med() {
    return this.getNumberAttribute('med');
  }
  public set med(value: number) {
    this._med = value;
  }
  public resetMed() {
    this._med = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get medInput() {
    return this._med;
  }

  // nexthop - computed: false, optional: true, required: false
  private _nexthop?: string; 
  public get nexthop() {
    return this.getStringAttribute('nexthop');
  }
  public set nexthop(value: string) {
    this._nexthop = value;
  }
  public resetNexthop() {
    this._nexthop = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nexthopInput() {
    return this._nexthop;
  }

  // origin - computed: false, optional: true, required: false
  private _origin?: string; 
  public get origin() {
    return this.getStringAttribute('origin');
  }
  public set origin(value: string) {
    this._origin = value;
  }
  public resetOrigin() {
    this._origin = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get originInput() {
    return this._origin;
  }

  // weight - computed: false, optional: true, required: false
  private _weight?: number; 
  public get weight() {
    return this.getNumberAttribute('weight');
  }
  public set weight(value: number) {
    this._weight = value;
  }
  public resetWeight() {
    this._weight = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get weightInput() {
    return this._weight;
  }
}
export interface VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefix {
  /**
  * match exact prefix length
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#exact VirtualRouter#exact}
  */
  readonly exact?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#name VirtualRouter#name}
  */
  readonly name: string;
}

export function virtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixToTerraform(struct?: VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    exact: cdktf.booleanToTerraform(struct!.exact),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function virtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    exact: {
      value: cdktf.booleanToHclTerraform(struct!.exact),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefix | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._exact !== undefined) {
      hasAnyValues = true;
      internalValueResult.exact = this._exact;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefix | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._exact = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._exact = value.exact;
      this._name = value.name;
    }
  }

  // exact - computed: false, optional: true, required: false
  private _exact?: boolean | cdktf.IResolvable; 
  public get exact() {
    return this.getBooleanAttribute('exact');
  }
  public set exact(value: boolean | cdktf.IResolvable) {
    this._exact = value;
  }
  public resetExact() {
    this._exact = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exactInput() {
    return this._exact;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixList extends cdktf.ComplexList {
  public internalValue? : VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefix[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixOutputReference {
    return new VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPath {
  /**
  * AS-path regular expression
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#regex VirtualRouter#regex}
  */
  readonly regex?: string;
}

export function virtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPathToTerraform(struct?: VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function virtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPathToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPathOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPath | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPath | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._regex = value.regex;
    }
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunity {
  /**
  * AS-path regular expression
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#regex VirtualRouter#regex}
  */
  readonly regex?: string;
}

export function virtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunityToTerraform(struct?: VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function virtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunityToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._regex = value.regex;
    }
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunity {
  /**
  * AS-path regular expression
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#regex VirtualRouter#regex}
  */
  readonly regex?: string;
}

export function virtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunityToTerraform(struct?: VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function virtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunityToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._regex = value.regex;
    }
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatch {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#address_prefix VirtualRouter#address_prefix}
  */
  readonly addressPrefix?: VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefix[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#as_path VirtualRouter#as_path}
  */
  readonly asPath?: VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPath;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#community VirtualRouter#community}
  */
  readonly community?: VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunity;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#extended_community VirtualRouter#extended_community}
  */
  readonly extendedCommunity?: VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunity;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#from_peer VirtualRouter#from_peer}
  */
  readonly fromPeer?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#med VirtualRouter#med}
  */
  readonly med?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#nexthop VirtualRouter#nexthop}
  */
  readonly nexthop?: string[];
  /**
  * route table to match rule
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#route_table VirtualRouter#route_table}
  */
  readonly routeTable?: string;
}

export function virtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchToTerraform(struct?: VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address_prefix: cdktf.listMapper(virtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixToTerraform, false)(struct!.addressPrefix),
    as_path: virtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPathToTerraform(struct!.asPath),
    community: virtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunityToTerraform(struct!.community),
    extended_community: virtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunityToTerraform(struct!.extendedCommunity),
    from_peer: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.fromPeer),
    med: cdktf.numberToTerraform(struct!.med),
    nexthop: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.nexthop),
    route_table: cdktf.stringToTerraform(struct!.routeTable),
  }
}


export function virtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address_prefix: {
      value: cdktf.listMapperHcl(virtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixToHclTerraform, false)(struct!.addressPrefix),
      isBlock: true,
      type: "list",
      storageClassType: "VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixList",
    },
    as_path: {
      value: virtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPathToHclTerraform(struct!.asPath),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPath",
    },
    community: {
      value: virtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunityToHclTerraform(struct!.community),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunity",
    },
    extended_community: {
      value: virtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunityToHclTerraform(struct!.extendedCommunity),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunity",
    },
    from_peer: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.fromPeer),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    med: {
      value: cdktf.numberToHclTerraform(struct!.med),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    nexthop: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.nexthop),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    route_table: {
      value: cdktf.stringToHclTerraform(struct!.routeTable),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addressPrefix?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.addressPrefix = this._addressPrefix?.internalValue;
    }
    if (this._asPath?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.asPath = this._asPath?.internalValue;
    }
    if (this._community?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.community = this._community?.internalValue;
    }
    if (this._extendedCommunity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extendedCommunity = this._extendedCommunity?.internalValue;
    }
    if (this._fromPeer !== undefined) {
      hasAnyValues = true;
      internalValueResult.fromPeer = this._fromPeer;
    }
    if (this._med !== undefined) {
      hasAnyValues = true;
      internalValueResult.med = this._med;
    }
    if (this._nexthop !== undefined) {
      hasAnyValues = true;
      internalValueResult.nexthop = this._nexthop;
    }
    if (this._routeTable !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeTable = this._routeTable;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addressPrefix.internalValue = undefined;
      this._asPath.internalValue = undefined;
      this._community.internalValue = undefined;
      this._extendedCommunity.internalValue = undefined;
      this._fromPeer = undefined;
      this._med = undefined;
      this._nexthop = undefined;
      this._routeTable = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addressPrefix.internalValue = value.addressPrefix;
      this._asPath.internalValue = value.asPath;
      this._community.internalValue = value.community;
      this._extendedCommunity.internalValue = value.extendedCommunity;
      this._fromPeer = value.fromPeer;
      this._med = value.med;
      this._nexthop = value.nexthop;
      this._routeTable = value.routeTable;
    }
  }

  // address_prefix - computed: false, optional: true, required: false
  private _addressPrefix = new VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixList(this, "address_prefix", false);
  public get addressPrefix() {
    return this._addressPrefix;
  }
  public putAddressPrefix(value: VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefix[] | cdktf.IResolvable) {
    this._addressPrefix.internalValue = value;
  }
  public resetAddressPrefix() {
    this._addressPrefix.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressPrefixInput() {
    return this._addressPrefix.internalValue;
  }

  // as_path - computed: false, optional: true, required: false
  private _asPath = new VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPathOutputReference(this, "as_path");
  public get asPath() {
    return this._asPath;
  }
  public putAsPath(value: VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPath) {
    this._asPath.internalValue = value;
  }
  public resetAsPath() {
    this._asPath.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asPathInput() {
    return this._asPath.internalValue;
  }

  // community - computed: false, optional: true, required: false
  private _community = new VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunityOutputReference(this, "community");
  public get community() {
    return this._community;
  }
  public putCommunity(value: VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunity) {
    this._community.internalValue = value;
  }
  public resetCommunity() {
    this._community.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get communityInput() {
    return this._community.internalValue;
  }

  // extended_community - computed: false, optional: true, required: false
  private _extendedCommunity = new VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunityOutputReference(this, "extended_community");
  public get extendedCommunity() {
    return this._extendedCommunity;
  }
  public putExtendedCommunity(value: VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunity) {
    this._extendedCommunity.internalValue = value;
  }
  public resetExtendedCommunity() {
    this._extendedCommunity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extendedCommunityInput() {
    return this._extendedCommunity.internalValue;
  }

  // from_peer - computed: false, optional: true, required: false
  private _fromPeer?: string[]; 
  public get fromPeer() {
    return this.getListAttribute('from_peer');
  }
  public set fromPeer(value: string[]) {
    this._fromPeer = value;
  }
  public resetFromPeer() {
    this._fromPeer = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fromPeerInput() {
    return this._fromPeer;
  }

  // med - computed: false, optional: true, required: false
  private _med?: number; 
  public get med() {
    return this.getNumberAttribute('med');
  }
  public set med(value: number) {
    this._med = value;
  }
  public resetMed() {
    this._med = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get medInput() {
    return this._med;
  }

  // nexthop - computed: false, optional: true, required: false
  private _nexthop?: string[]; 
  public get nexthop() {
    return this.getListAttribute('nexthop');
  }
  public set nexthop(value: string[]) {
    this._nexthop = value;
  }
  public resetNexthop() {
    this._nexthop = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nexthopInput() {
    return this._nexthop;
  }

  // route_table - computed: true, optional: true, required: false
  private _routeTable?: string; 
  public get routeTable() {
    return this.getStringAttribute('route_table');
  }
  public set routeTable(value: string) {
    this._routeTable = value;
  }
  public resetRouteTable() {
    this._routeTable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeTableInput() {
    return this._routeTable;
  }
}
export interface VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFilters {
  /**
  * enble this rule
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#enable VirtualRouter#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#match VirtualRouter#match}
  */
  readonly match?: VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#name VirtualRouter#name}
  */
  readonly name: string;
}

export function virtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersToTerraform(struct?: VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFilters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enable: cdktf.booleanToTerraform(struct!.enable),
    match: virtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchToTerraform(struct!.match),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function virtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFilters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    match: {
      value: virtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchToHclTerraform(struct!.match),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatch",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFilters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._match?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFilters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enable = undefined;
      this._match.internalValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enable = value.enable;
      this._match.internalValue = value.match;
      this._name = value.name;
    }
  }

  // enable - computed: false, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // match - computed: false, optional: true, required: false
  private _match = new VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatchOutputReference(this, "match");
  public get match() {
    return this._match;
  }
  public putMatch(value: VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersMatch) {
    this._match.internalValue = value;
  }
  public resetMatch() {
    this._match.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match.internalValue;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersList extends cdktf.ComplexList {
  public internalValue? : VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFilters[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersOutputReference {
    return new VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface VirtualRouterProtocolBgpPolicyAggregationAddress {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#advertise_filters VirtualRouter#advertise_filters}
  */
  readonly advertiseFilters?: VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFilters[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#aggregate_route_attributes VirtualRouter#aggregate_route_attributes}
  */
  readonly aggregateRouteAttributes?: VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributes;
  /**
  * generate AS-set attribute
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#as_set VirtualRouter#as_set}
  */
  readonly asSet?: boolean | cdktf.IResolvable;
  /**
  * enable aggregation for this prefix
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#enable VirtualRouter#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#name VirtualRouter#name}
  */
  readonly name: string;
  /**
  * aggregating address prefix
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#prefix VirtualRouter#prefix}
  */
  readonly prefix?: string;
  /**
  * summarize route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#summary VirtualRouter#summary}
  */
  readonly summary?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#suppress_filters VirtualRouter#suppress_filters}
  */
  readonly suppressFilters?: VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFilters[] | cdktf.IResolvable;
}

export function virtualRouterProtocolBgpPolicyAggregationAddressToTerraform(struct?: VirtualRouterProtocolBgpPolicyAggregationAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    advertise_filters: cdktf.listMapper(virtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersToTerraform, false)(struct!.advertiseFilters),
    aggregate_route_attributes: virtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesToTerraform(struct!.aggregateRouteAttributes),
    as_set: cdktf.booleanToTerraform(struct!.asSet),
    enable: cdktf.booleanToTerraform(struct!.enable),
    name: cdktf.stringToTerraform(struct!.name),
    prefix: cdktf.stringToTerraform(struct!.prefix),
    summary: cdktf.booleanToTerraform(struct!.summary),
    suppress_filters: cdktf.listMapper(virtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersToTerraform, false)(struct!.suppressFilters),
  }
}


export function virtualRouterProtocolBgpPolicyAggregationAddressToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyAggregationAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    advertise_filters: {
      value: cdktf.listMapperHcl(virtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersToHclTerraform, false)(struct!.advertiseFilters),
      isBlock: true,
      type: "list",
      storageClassType: "VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersList",
    },
    aggregate_route_attributes: {
      value: virtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesToHclTerraform(struct!.aggregateRouteAttributes),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributes",
    },
    as_set: {
      value: cdktf.booleanToHclTerraform(struct!.asSet),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix: {
      value: cdktf.stringToHclTerraform(struct!.prefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    summary: {
      value: cdktf.booleanToHclTerraform(struct!.summary),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    suppress_filters: {
      value: cdktf.listMapperHcl(virtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersToHclTerraform, false)(struct!.suppressFilters),
      isBlock: true,
      type: "list",
      storageClassType: "VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyAggregationAddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyAggregationAddress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._advertiseFilters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.advertiseFilters = this._advertiseFilters?.internalValue;
    }
    if (this._aggregateRouteAttributes?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.aggregateRouteAttributes = this._aggregateRouteAttributes?.internalValue;
    }
    if (this._asSet !== undefined) {
      hasAnyValues = true;
      internalValueResult.asSet = this._asSet;
    }
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._prefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefix = this._prefix;
    }
    if (this._summary !== undefined) {
      hasAnyValues = true;
      internalValueResult.summary = this._summary;
    }
    if (this._suppressFilters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.suppressFilters = this._suppressFilters?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyAggregationAddress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._advertiseFilters.internalValue = undefined;
      this._aggregateRouteAttributes.internalValue = undefined;
      this._asSet = undefined;
      this._enable = undefined;
      this._name = undefined;
      this._prefix = undefined;
      this._summary = undefined;
      this._suppressFilters.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._advertiseFilters.internalValue = value.advertiseFilters;
      this._aggregateRouteAttributes.internalValue = value.aggregateRouteAttributes;
      this._asSet = value.asSet;
      this._enable = value.enable;
      this._name = value.name;
      this._prefix = value.prefix;
      this._summary = value.summary;
      this._suppressFilters.internalValue = value.suppressFilters;
    }
  }

  // advertise_filters - computed: false, optional: true, required: false
  private _advertiseFilters = new VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFiltersList(this, "advertise_filters", false);
  public get advertiseFilters() {
    return this._advertiseFilters;
  }
  public putAdvertiseFilters(value: VirtualRouterProtocolBgpPolicyAggregationAddressAdvertiseFilters[] | cdktf.IResolvable) {
    this._advertiseFilters.internalValue = value;
  }
  public resetAdvertiseFilters() {
    this._advertiseFilters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get advertiseFiltersInput() {
    return this._advertiseFilters.internalValue;
  }

  // aggregate_route_attributes - computed: false, optional: true, required: false
  private _aggregateRouteAttributes = new VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributesOutputReference(this, "aggregate_route_attributes");
  public get aggregateRouteAttributes() {
    return this._aggregateRouteAttributes;
  }
  public putAggregateRouteAttributes(value: VirtualRouterProtocolBgpPolicyAggregationAddressAggregateRouteAttributes) {
    this._aggregateRouteAttributes.internalValue = value;
  }
  public resetAggregateRouteAttributes() {
    this._aggregateRouteAttributes.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aggregateRouteAttributesInput() {
    return this._aggregateRouteAttributes.internalValue;
  }

  // as_set - computed: false, optional: true, required: false
  private _asSet?: boolean | cdktf.IResolvable; 
  public get asSet() {
    return this.getBooleanAttribute('as_set');
  }
  public set asSet(value: boolean | cdktf.IResolvable) {
    this._asSet = value;
  }
  public resetAsSet() {
    this._asSet = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asSetInput() {
    return this._asSet;
  }

  // enable - computed: false, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // prefix - computed: false, optional: true, required: false
  private _prefix?: string; 
  public get prefix() {
    return this.getStringAttribute('prefix');
  }
  public set prefix(value: string) {
    this._prefix = value;
  }
  public resetPrefix() {
    this._prefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixInput() {
    return this._prefix;
  }

  // summary - computed: false, optional: true, required: false
  private _summary?: boolean | cdktf.IResolvable; 
  public get summary() {
    return this.getBooleanAttribute('summary');
  }
  public set summary(value: boolean | cdktf.IResolvable) {
    this._summary = value;
  }
  public resetSummary() {
    this._summary = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get summaryInput() {
    return this._summary;
  }

  // suppress_filters - computed: false, optional: true, required: false
  private _suppressFilters = new VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFiltersList(this, "suppress_filters", false);
  public get suppressFilters() {
    return this._suppressFilters;
  }
  public putSuppressFilters(value: VirtualRouterProtocolBgpPolicyAggregationAddressSuppressFilters[] | cdktf.IResolvable) {
    this._suppressFilters.internalValue = value;
  }
  public resetSuppressFilters() {
    this._suppressFilters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get suppressFiltersInput() {
    return this._suppressFilters.internalValue;
  }
}

export class VirtualRouterProtocolBgpPolicyAggregationAddressList extends cdktf.ComplexList {
  public internalValue? : VirtualRouterProtocolBgpPolicyAggregationAddress[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): VirtualRouterProtocolBgpPolicyAggregationAddressOutputReference {
    return new VirtualRouterProtocolBgpPolicyAggregationAddressOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface VirtualRouterProtocolBgpPolicyAggregation {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#address VirtualRouter#address}
  */
  readonly address?: VirtualRouterProtocolBgpPolicyAggregationAddress[] | cdktf.IResolvable;
}

export function virtualRouterProtocolBgpPolicyAggregationToTerraform(struct?: VirtualRouterProtocolBgpPolicyAggregation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: cdktf.listMapper(virtualRouterProtocolBgpPolicyAggregationAddressToTerraform, false)(struct!.address),
  }
}


export function virtualRouterProtocolBgpPolicyAggregationToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyAggregation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: cdktf.listMapperHcl(virtualRouterProtocolBgpPolicyAggregationAddressToHclTerraform, false)(struct!.address),
      isBlock: true,
      type: "list",
      storageClassType: "VirtualRouterProtocolBgpPolicyAggregationAddressList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyAggregationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyAggregation | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyAggregation | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address.internalValue = value.address;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address = new VirtualRouterProtocolBgpPolicyAggregationAddressList(this, "address", false);
  public get address() {
    return this._address;
  }
  public putAddress(value: VirtualRouterProtocolBgpPolicyAggregationAddress[] | cdktf.IResolvable) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }
}
export interface VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefix {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#name VirtualRouter#name}
  */
  readonly name: string;
}

export function virtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixToTerraform(struct?: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function virtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefix | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefix | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixList extends cdktf.ComplexList {
  public internalValue? : VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefix[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixOutputReference {
    return new VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPath {
  /**
  * AS-path regular expression
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#regex VirtualRouter#regex}
  */
  readonly regex?: string;
}

export function virtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathToTerraform(struct?: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function virtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPath | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPath | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._regex = value.regex;
    }
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunity {
  /**
  * AS-path regular expression
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#regex VirtualRouter#regex}
  */
  readonly regex?: string;
}

export function virtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunityToTerraform(struct?: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function virtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunityToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._regex = value.regex;
    }
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunity {
  /**
  * AS-path regular expression
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#regex VirtualRouter#regex}
  */
  readonly regex?: string;
}

export function virtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunityToTerraform(struct?: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function virtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunityToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._regex = value.regex;
    }
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatch {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#address_prefix VirtualRouter#address_prefix}
  */
  readonly addressPrefix?: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefix[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#as_path VirtualRouter#as_path}
  */
  readonly asPath?: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPath;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#community VirtualRouter#community}
  */
  readonly community?: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunity;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#extended_community VirtualRouter#extended_community}
  */
  readonly extendedCommunity?: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunity;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#from_peer VirtualRouter#from_peer}
  */
  readonly fromPeer?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#med VirtualRouter#med}
  */
  readonly med?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#nexthop VirtualRouter#nexthop}
  */
  readonly nexthop?: string[];
  /**
  * route table to match rule
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#route_table VirtualRouter#route_table}
  */
  readonly routeTable?: string;
}

export function virtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchToTerraform(struct?: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address_prefix: cdktf.listMapper(virtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixToTerraform, false)(struct!.addressPrefix),
    as_path: virtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathToTerraform(struct!.asPath),
    community: virtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunityToTerraform(struct!.community),
    extended_community: virtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunityToTerraform(struct!.extendedCommunity),
    from_peer: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.fromPeer),
    med: cdktf.numberToTerraform(struct!.med),
    nexthop: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.nexthop),
    route_table: cdktf.stringToTerraform(struct!.routeTable),
  }
}


export function virtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address_prefix: {
      value: cdktf.listMapperHcl(virtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixToHclTerraform, false)(struct!.addressPrefix),
      isBlock: true,
      type: "list",
      storageClassType: "VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixList",
    },
    as_path: {
      value: virtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathToHclTerraform(struct!.asPath),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPath",
    },
    community: {
      value: virtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunityToHclTerraform(struct!.community),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunity",
    },
    extended_community: {
      value: virtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunityToHclTerraform(struct!.extendedCommunity),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunity",
    },
    from_peer: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.fromPeer),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    med: {
      value: cdktf.numberToHclTerraform(struct!.med),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    nexthop: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.nexthop),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    route_table: {
      value: cdktf.stringToHclTerraform(struct!.routeTable),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addressPrefix?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.addressPrefix = this._addressPrefix?.internalValue;
    }
    if (this._asPath?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.asPath = this._asPath?.internalValue;
    }
    if (this._community?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.community = this._community?.internalValue;
    }
    if (this._extendedCommunity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extendedCommunity = this._extendedCommunity?.internalValue;
    }
    if (this._fromPeer !== undefined) {
      hasAnyValues = true;
      internalValueResult.fromPeer = this._fromPeer;
    }
    if (this._med !== undefined) {
      hasAnyValues = true;
      internalValueResult.med = this._med;
    }
    if (this._nexthop !== undefined) {
      hasAnyValues = true;
      internalValueResult.nexthop = this._nexthop;
    }
    if (this._routeTable !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeTable = this._routeTable;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addressPrefix.internalValue = undefined;
      this._asPath.internalValue = undefined;
      this._community.internalValue = undefined;
      this._extendedCommunity.internalValue = undefined;
      this._fromPeer = undefined;
      this._med = undefined;
      this._nexthop = undefined;
      this._routeTable = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addressPrefix.internalValue = value.addressPrefix;
      this._asPath.internalValue = value.asPath;
      this._community.internalValue = value.community;
      this._extendedCommunity.internalValue = value.extendedCommunity;
      this._fromPeer = value.fromPeer;
      this._med = value.med;
      this._nexthop = value.nexthop;
      this._routeTable = value.routeTable;
    }
  }

  // address_prefix - computed: false, optional: true, required: false
  private _addressPrefix = new VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixList(this, "address_prefix", false);
  public get addressPrefix() {
    return this._addressPrefix;
  }
  public putAddressPrefix(value: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefix[] | cdktf.IResolvable) {
    this._addressPrefix.internalValue = value;
  }
  public resetAddressPrefix() {
    this._addressPrefix.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressPrefixInput() {
    return this._addressPrefix.internalValue;
  }

  // as_path - computed: false, optional: true, required: false
  private _asPath = new VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathOutputReference(this, "as_path");
  public get asPath() {
    return this._asPath;
  }
  public putAsPath(value: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPath) {
    this._asPath.internalValue = value;
  }
  public resetAsPath() {
    this._asPath.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asPathInput() {
    return this._asPath.internalValue;
  }

  // community - computed: false, optional: true, required: false
  private _community = new VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunityOutputReference(this, "community");
  public get community() {
    return this._community;
  }
  public putCommunity(value: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunity) {
    this._community.internalValue = value;
  }
  public resetCommunity() {
    this._community.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get communityInput() {
    return this._community.internalValue;
  }

  // extended_community - computed: false, optional: true, required: false
  private _extendedCommunity = new VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunityOutputReference(this, "extended_community");
  public get extendedCommunity() {
    return this._extendedCommunity;
  }
  public putExtendedCommunity(value: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunity) {
    this._extendedCommunity.internalValue = value;
  }
  public resetExtendedCommunity() {
    this._extendedCommunity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extendedCommunityInput() {
    return this._extendedCommunity.internalValue;
  }

  // from_peer - computed: false, optional: true, required: false
  private _fromPeer?: string[]; 
  public get fromPeer() {
    return this.getListAttribute('from_peer');
  }
  public set fromPeer(value: string[]) {
    this._fromPeer = value;
  }
  public resetFromPeer() {
    this._fromPeer = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fromPeerInput() {
    return this._fromPeer;
  }

  // med - computed: false, optional: true, required: false
  private _med?: number; 
  public get med() {
    return this.getNumberAttribute('med');
  }
  public set med(value: number) {
    this._med = value;
  }
  public resetMed() {
    this._med = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get medInput() {
    return this._med;
  }

  // nexthop - computed: false, optional: true, required: false
  private _nexthop?: string[]; 
  public get nexthop() {
    return this.getListAttribute('nexthop');
  }
  public set nexthop(value: string[]) {
    this._nexthop = value;
  }
  public resetNexthop() {
    this._nexthop = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nexthopInput() {
    return this._nexthop;
  }

  // route_table - computed: true, optional: true, required: false
  private _routeTable?: string; 
  public get routeTable() {
    return this.getStringAttribute('route_table');
  }
  public set routeTable(value: string) {
    this._routeTable = value;
  }
  public resetRouteTable() {
    this._routeTable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeTableInput() {
    return this._routeTable;
  }
}
export interface VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFilters {
  /**
  * enble this filter
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#enable VirtualRouter#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#match VirtualRouter#match}
  */
  readonly match?: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#name VirtualRouter#name}
  */
  readonly name: string;
}

export function virtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersToTerraform(struct?: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFilters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enable: cdktf.booleanToTerraform(struct!.enable),
    match: virtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchToTerraform(struct!.match),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function virtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFilters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    match: {
      value: virtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchToHclTerraform(struct!.match),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatch",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFilters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._match?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFilters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enable = undefined;
      this._match.internalValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enable = value.enable;
      this._match.internalValue = value.match;
      this._name = value.name;
    }
  }

  // enable - computed: false, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // match - computed: false, optional: true, required: false
  private _match = new VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchOutputReference(this, "match");
  public get match() {
    return this._match;
  }
  public putMatch(value: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatch) {
    this._match.internalValue = value;
  }
  public resetMatch() {
    this._match.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match.internalValue;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersList extends cdktf.ComplexList {
  public internalValue? : VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFilters[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersOutputReference {
    return new VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefix {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#name VirtualRouter#name}
  */
  readonly name: string;
}

export function virtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixToTerraform(struct?: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function virtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefix | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefix | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixList extends cdktf.ComplexList {
  public internalValue? : VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefix[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixOutputReference {
    return new VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPath {
  /**
  * AS-path regular expression
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#regex VirtualRouter#regex}
  */
  readonly regex?: string;
}

export function virtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathToTerraform(struct?: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function virtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPath | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPath | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._regex = value.regex;
    }
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunity {
  /**
  * AS-path regular expression
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#regex VirtualRouter#regex}
  */
  readonly regex?: string;
}

export function virtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunityToTerraform(struct?: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function virtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunityToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._regex = value.regex;
    }
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunity {
  /**
  * AS-path regular expression
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#regex VirtualRouter#regex}
  */
  readonly regex?: string;
}

export function virtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunityToTerraform(struct?: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function virtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunityToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._regex = value.regex;
    }
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatch {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#address_prefix VirtualRouter#address_prefix}
  */
  readonly addressPrefix?: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefix[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#as_path VirtualRouter#as_path}
  */
  readonly asPath?: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPath;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#community VirtualRouter#community}
  */
  readonly community?: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunity;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#extended_community VirtualRouter#extended_community}
  */
  readonly extendedCommunity?: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunity;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#from_peer VirtualRouter#from_peer}
  */
  readonly fromPeer?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#med VirtualRouter#med}
  */
  readonly med?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#nexthop VirtualRouter#nexthop}
  */
  readonly nexthop?: string[];
  /**
  * route table to match rule
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#route_table VirtualRouter#route_table}
  */
  readonly routeTable?: string;
}

export function virtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchToTerraform(struct?: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address_prefix: cdktf.listMapper(virtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixToTerraform, false)(struct!.addressPrefix),
    as_path: virtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathToTerraform(struct!.asPath),
    community: virtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunityToTerraform(struct!.community),
    extended_community: virtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunityToTerraform(struct!.extendedCommunity),
    from_peer: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.fromPeer),
    med: cdktf.numberToTerraform(struct!.med),
    nexthop: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.nexthop),
    route_table: cdktf.stringToTerraform(struct!.routeTable),
  }
}


export function virtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address_prefix: {
      value: cdktf.listMapperHcl(virtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixToHclTerraform, false)(struct!.addressPrefix),
      isBlock: true,
      type: "list",
      storageClassType: "VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixList",
    },
    as_path: {
      value: virtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathToHclTerraform(struct!.asPath),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPath",
    },
    community: {
      value: virtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunityToHclTerraform(struct!.community),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunity",
    },
    extended_community: {
      value: virtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunityToHclTerraform(struct!.extendedCommunity),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunity",
    },
    from_peer: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.fromPeer),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    med: {
      value: cdktf.numberToHclTerraform(struct!.med),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    nexthop: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.nexthop),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    route_table: {
      value: cdktf.stringToHclTerraform(struct!.routeTable),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addressPrefix?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.addressPrefix = this._addressPrefix?.internalValue;
    }
    if (this._asPath?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.asPath = this._asPath?.internalValue;
    }
    if (this._community?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.community = this._community?.internalValue;
    }
    if (this._extendedCommunity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extendedCommunity = this._extendedCommunity?.internalValue;
    }
    if (this._fromPeer !== undefined) {
      hasAnyValues = true;
      internalValueResult.fromPeer = this._fromPeer;
    }
    if (this._med !== undefined) {
      hasAnyValues = true;
      internalValueResult.med = this._med;
    }
    if (this._nexthop !== undefined) {
      hasAnyValues = true;
      internalValueResult.nexthop = this._nexthop;
    }
    if (this._routeTable !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeTable = this._routeTable;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addressPrefix.internalValue = undefined;
      this._asPath.internalValue = undefined;
      this._community.internalValue = undefined;
      this._extendedCommunity.internalValue = undefined;
      this._fromPeer = undefined;
      this._med = undefined;
      this._nexthop = undefined;
      this._routeTable = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addressPrefix.internalValue = value.addressPrefix;
      this._asPath.internalValue = value.asPath;
      this._community.internalValue = value.community;
      this._extendedCommunity.internalValue = value.extendedCommunity;
      this._fromPeer = value.fromPeer;
      this._med = value.med;
      this._nexthop = value.nexthop;
      this._routeTable = value.routeTable;
    }
  }

  // address_prefix - computed: false, optional: true, required: false
  private _addressPrefix = new VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixList(this, "address_prefix", false);
  public get addressPrefix() {
    return this._addressPrefix;
  }
  public putAddressPrefix(value: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefix[] | cdktf.IResolvable) {
    this._addressPrefix.internalValue = value;
  }
  public resetAddressPrefix() {
    this._addressPrefix.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressPrefixInput() {
    return this._addressPrefix.internalValue;
  }

  // as_path - computed: false, optional: true, required: false
  private _asPath = new VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathOutputReference(this, "as_path");
  public get asPath() {
    return this._asPath;
  }
  public putAsPath(value: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPath) {
    this._asPath.internalValue = value;
  }
  public resetAsPath() {
    this._asPath.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asPathInput() {
    return this._asPath.internalValue;
  }

  // community - computed: false, optional: true, required: false
  private _community = new VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunityOutputReference(this, "community");
  public get community() {
    return this._community;
  }
  public putCommunity(value: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunity) {
    this._community.internalValue = value;
  }
  public resetCommunity() {
    this._community.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get communityInput() {
    return this._community.internalValue;
  }

  // extended_community - computed: false, optional: true, required: false
  private _extendedCommunity = new VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunityOutputReference(this, "extended_community");
  public get extendedCommunity() {
    return this._extendedCommunity;
  }
  public putExtendedCommunity(value: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunity) {
    this._extendedCommunity.internalValue = value;
  }
  public resetExtendedCommunity() {
    this._extendedCommunity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extendedCommunityInput() {
    return this._extendedCommunity.internalValue;
  }

  // from_peer - computed: false, optional: true, required: false
  private _fromPeer?: string[]; 
  public get fromPeer() {
    return this.getListAttribute('from_peer');
  }
  public set fromPeer(value: string[]) {
    this._fromPeer = value;
  }
  public resetFromPeer() {
    this._fromPeer = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fromPeerInput() {
    return this._fromPeer;
  }

  // med - computed: false, optional: true, required: false
  private _med?: number; 
  public get med() {
    return this.getNumberAttribute('med');
  }
  public set med(value: number) {
    this._med = value;
  }
  public resetMed() {
    this._med = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get medInput() {
    return this._med;
  }

  // nexthop - computed: false, optional: true, required: false
  private _nexthop?: string[]; 
  public get nexthop() {
    return this.getListAttribute('nexthop');
  }
  public set nexthop(value: string[]) {
    this._nexthop = value;
  }
  public resetNexthop() {
    this._nexthop = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nexthopInput() {
    return this._nexthop;
  }

  // route_table - computed: true, optional: true, required: false
  private _routeTable?: string; 
  public get routeTable() {
    return this.getStringAttribute('route_table');
  }
  public set routeTable(value: string) {
    this._routeTable = value;
  }
  public resetRouteTable() {
    this._routeTable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeTableInput() {
    return this._routeTable;
  }
}
export interface VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFilters {
  /**
  * enble this filter
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#enable VirtualRouter#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#match VirtualRouter#match}
  */
  readonly match?: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#name VirtualRouter#name}
  */
  readonly name: string;
}

export function virtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersToTerraform(struct?: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFilters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enable: cdktf.booleanToTerraform(struct!.enable),
    match: virtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchToTerraform(struct!.match),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function virtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFilters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    match: {
      value: virtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchToHclTerraform(struct!.match),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatch",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFilters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._match?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFilters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enable = undefined;
      this._match.internalValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enable = value.enable;
      this._match.internalValue = value.match;
      this._name = value.name;
    }
  }

  // enable - computed: false, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // match - computed: false, optional: true, required: false
  private _match = new VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchOutputReference(this, "match");
  public get match() {
    return this._match;
  }
  public putMatch(value: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatch) {
    this._match.internalValue = value;
  }
  public resetMatch() {
    this._match.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match.internalValue;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersList extends cdktf.ComplexList {
  public internalValue? : VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFilters[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersOutputReference {
    return new VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicy {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#advertise_filters VirtualRouter#advertise_filters}
  */
  readonly advertiseFilters?: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFilters[] | cdktf.IResolvable;
  /**
  * enble this policy
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#enable VirtualRouter#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#name VirtualRouter#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#non_exist_filters VirtualRouter#non_exist_filters}
  */
  readonly nonExistFilters?: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFilters[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#used_by VirtualRouter#used_by}
  */
  readonly usedBy?: string[];
}

export function virtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyToTerraform(struct?: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicy | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    advertise_filters: cdktf.listMapper(virtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersToTerraform, false)(struct!.advertiseFilters),
    enable: cdktf.booleanToTerraform(struct!.enable),
    name: cdktf.stringToTerraform(struct!.name),
    non_exist_filters: cdktf.listMapper(virtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersToTerraform, false)(struct!.nonExistFilters),
    used_by: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.usedBy),
  }
}


export function virtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicy | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    advertise_filters: {
      value: cdktf.listMapperHcl(virtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersToHclTerraform, false)(struct!.advertiseFilters),
      isBlock: true,
      type: "list",
      storageClassType: "VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersList",
    },
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    non_exist_filters: {
      value: cdktf.listMapperHcl(virtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersToHclTerraform, false)(struct!.nonExistFilters),
      isBlock: true,
      type: "list",
      storageClassType: "VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersList",
    },
    used_by: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.usedBy),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicy | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._advertiseFilters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.advertiseFilters = this._advertiseFilters?.internalValue;
    }
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._nonExistFilters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nonExistFilters = this._nonExistFilters?.internalValue;
    }
    if (this._usedBy !== undefined) {
      hasAnyValues = true;
      internalValueResult.usedBy = this._usedBy;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicy | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._advertiseFilters.internalValue = undefined;
      this._enable = undefined;
      this._name = undefined;
      this._nonExistFilters.internalValue = undefined;
      this._usedBy = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._advertiseFilters.internalValue = value.advertiseFilters;
      this._enable = value.enable;
      this._name = value.name;
      this._nonExistFilters.internalValue = value.nonExistFilters;
      this._usedBy = value.usedBy;
    }
  }

  // advertise_filters - computed: false, optional: true, required: false
  private _advertiseFilters = new VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersList(this, "advertise_filters", false);
  public get advertiseFilters() {
    return this._advertiseFilters;
  }
  public putAdvertiseFilters(value: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFilters[] | cdktf.IResolvable) {
    this._advertiseFilters.internalValue = value;
  }
  public resetAdvertiseFilters() {
    this._advertiseFilters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get advertiseFiltersInput() {
    return this._advertiseFilters.internalValue;
  }

  // enable - computed: false, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // non_exist_filters - computed: false, optional: true, required: false
  private _nonExistFilters = new VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersList(this, "non_exist_filters", false);
  public get nonExistFilters() {
    return this._nonExistFilters;
  }
  public putNonExistFilters(value: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFilters[] | cdktf.IResolvable) {
    this._nonExistFilters.internalValue = value;
  }
  public resetNonExistFilters() {
    this._nonExistFilters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nonExistFiltersInput() {
    return this._nonExistFilters.internalValue;
  }

  // used_by - computed: false, optional: true, required: false
  private _usedBy?: string[]; 
  public get usedBy() {
    return this.getListAttribute('used_by');
  }
  public set usedBy(value: string[]) {
    this._usedBy = value;
  }
  public resetUsedBy() {
    this._usedBy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usedByInput() {
    return this._usedBy;
  }
}

export class VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyList extends cdktf.ComplexList {
  public internalValue? : VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicy[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyOutputReference {
    return new VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface VirtualRouterProtocolBgpPolicyConditionalAdvertisement {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#policy VirtualRouter#policy}
  */
  readonly policy?: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicy[] | cdktf.IResolvable;
}

export function virtualRouterProtocolBgpPolicyConditionalAdvertisementToTerraform(struct?: VirtualRouterProtocolBgpPolicyConditionalAdvertisement | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    policy: cdktf.listMapper(virtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyToTerraform, false)(struct!.policy),
  }
}


export function virtualRouterProtocolBgpPolicyConditionalAdvertisementToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyConditionalAdvertisement | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    policy: {
      value: cdktf.listMapperHcl(virtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyToHclTerraform, false)(struct!.policy),
      isBlock: true,
      type: "list",
      storageClassType: "VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyConditionalAdvertisementOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyConditionalAdvertisement | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._policy?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.policy = this._policy?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyConditionalAdvertisement | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._policy.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._policy.internalValue = value.policy;
    }
  }

  // policy - computed: false, optional: true, required: false
  private _policy = new VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicyList(this, "policy", false);
  public get policy() {
    return this._policy;
  }
  public putPolicy(value: VirtualRouterProtocolBgpPolicyConditionalAdvertisementPolicy[] | cdktf.IResolvable) {
    this._policy.internalValue = value;
  }
  public resetPolicy() {
    this._policy.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get policyInput() {
    return this._policy.internalValue;
  }
}
export interface VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNone {
}

export function virtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNoneToTerraform(struct?: VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNone | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function virtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNoneToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNone | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNoneOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNone | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNone | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemove {
}

export function virtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemoveToTerraform(struct?: VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemove | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function virtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemoveToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemove | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemoveOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemove | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemove | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateAsPath {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#none VirtualRouter#none}
  */
  readonly none?: VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNone;
  /**
  * prepend local AS for specified number of times
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#prepend VirtualRouter#prepend}
  */
  readonly prepend?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#remove VirtualRouter#remove}
  */
  readonly remove?: VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemove;
  /**
  * remove matched AS path(s), and prepend local AS for specified number of times
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#remove_and_prepend VirtualRouter#remove_and_prepend}
  */
  readonly removeAndPrepend?: number;
}

export function virtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateAsPathToTerraform(struct?: VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateAsPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    none: virtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNoneToTerraform(struct!.none),
    prepend: cdktf.numberToTerraform(struct!.prepend),
    remove: virtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemoveToTerraform(struct!.remove),
    remove_and_prepend: cdktf.numberToTerraform(struct!.removeAndPrepend),
  }
}


export function virtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateAsPathToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateAsPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    none: {
      value: virtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNoneToHclTerraform(struct!.none),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNone",
    },
    prepend: {
      value: cdktf.numberToHclTerraform(struct!.prepend),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    remove: {
      value: virtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemoveToHclTerraform(struct!.remove),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemove",
    },
    remove_and_prepend: {
      value: cdktf.numberToHclTerraform(struct!.removeAndPrepend),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateAsPathOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateAsPath | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._none?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.none = this._none?.internalValue;
    }
    if (this._prepend !== undefined) {
      hasAnyValues = true;
      internalValueResult.prepend = this._prepend;
    }
    if (this._remove?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.remove = this._remove?.internalValue;
    }
    if (this._removeAndPrepend !== undefined) {
      hasAnyValues = true;
      internalValueResult.removeAndPrepend = this._removeAndPrepend;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateAsPath | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._none.internalValue = undefined;
      this._prepend = undefined;
      this._remove.internalValue = undefined;
      this._removeAndPrepend = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._none.internalValue = value.none;
      this._prepend = value.prepend;
      this._remove.internalValue = value.remove;
      this._removeAndPrepend = value.removeAndPrepend;
    }
  }

  // none - computed: false, optional: true, required: false
  private _none = new VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNoneOutputReference(this, "none");
  public get none() {
    return this._none;
  }
  public putNone(value: VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNone) {
    this._none.internalValue = value;
  }
  public resetNone() {
    this._none.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get noneInput() {
    return this._none.internalValue;
  }

  // prepend - computed: true, optional: true, required: false
  private _prepend?: number; 
  public get prepend() {
    return this.getNumberAttribute('prepend');
  }
  public set prepend(value: number) {
    this._prepend = value;
  }
  public resetPrepend() {
    this._prepend = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prependInput() {
    return this._prepend;
  }

  // remove - computed: false, optional: true, required: false
  private _remove = new VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemoveOutputReference(this, "remove");
  public get remove() {
    return this._remove;
  }
  public putRemove(value: VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemove) {
    this._remove.internalValue = value;
  }
  public resetRemove() {
    this._remove.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeInput() {
    return this._remove.internalValue;
  }

  // remove_and_prepend - computed: true, optional: true, required: false
  private _removeAndPrepend?: number; 
  public get removeAndPrepend() {
    return this.getNumberAttribute('remove_and_prepend');
  }
  public set removeAndPrepend(value: number) {
    this._removeAndPrepend = value;
  }
  public resetRemoveAndPrepend() {
    this._removeAndPrepend = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeAndPrependInput() {
    return this._removeAndPrepend;
  }
}
export interface VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNone {
}

export function virtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNoneToTerraform(struct?: VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNone | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function virtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNoneToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNone | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNoneOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNone | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNone | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAll {
}

export function virtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllToTerraform(struct?: VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAll | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function virtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAll | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAll | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAll | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateCommunity {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#append VirtualRouter#append}
  */
  readonly append?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#none VirtualRouter#none}
  */
  readonly none?: VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNone;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#overwrite VirtualRouter#overwrite}
  */
  readonly overwrite?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#remove_all VirtualRouter#remove_all}
  */
  readonly removeAll?: VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAll;
  /**
  * remove specified coummnity match regular expression
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#remove_regex VirtualRouter#remove_regex}
  */
  readonly removeRegex?: string;
}

export function virtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateCommunityToTerraform(struct?: VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    append: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.append),
    none: virtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNoneToTerraform(struct!.none),
    overwrite: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.overwrite),
    remove_all: virtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllToTerraform(struct!.removeAll),
    remove_regex: cdktf.stringToTerraform(struct!.removeRegex),
  }
}


export function virtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateCommunityToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    append: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.append),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    none: {
      value: virtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNoneToHclTerraform(struct!.none),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNone",
    },
    overwrite: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.overwrite),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    remove_all: {
      value: virtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllToHclTerraform(struct!.removeAll),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAll",
    },
    remove_regex: {
      value: cdktf.stringToHclTerraform(struct!.removeRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateCommunityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateCommunity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._append !== undefined) {
      hasAnyValues = true;
      internalValueResult.append = this._append;
    }
    if (this._none?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.none = this._none?.internalValue;
    }
    if (this._overwrite !== undefined) {
      hasAnyValues = true;
      internalValueResult.overwrite = this._overwrite;
    }
    if (this._removeAll?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.removeAll = this._removeAll?.internalValue;
    }
    if (this._removeRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.removeRegex = this._removeRegex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateCommunity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._append = undefined;
      this._none.internalValue = undefined;
      this._overwrite = undefined;
      this._removeAll.internalValue = undefined;
      this._removeRegex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._append = value.append;
      this._none.internalValue = value.none;
      this._overwrite = value.overwrite;
      this._removeAll.internalValue = value.removeAll;
      this._removeRegex = value.removeRegex;
    }
  }

  // append - computed: false, optional: true, required: false
  private _append?: string[]; 
  public get append() {
    return this.getListAttribute('append');
  }
  public set append(value: string[]) {
    this._append = value;
  }
  public resetAppend() {
    this._append = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appendInput() {
    return this._append;
  }

  // none - computed: false, optional: true, required: false
  private _none = new VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNoneOutputReference(this, "none");
  public get none() {
    return this._none;
  }
  public putNone(value: VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNone) {
    this._none.internalValue = value;
  }
  public resetNone() {
    this._none.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get noneInput() {
    return this._none.internalValue;
  }

  // overwrite - computed: false, optional: true, required: false
  private _overwrite?: string[]; 
  public get overwrite() {
    return this.getListAttribute('overwrite');
  }
  public set overwrite(value: string[]) {
    this._overwrite = value;
  }
  public resetOverwrite() {
    this._overwrite = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overwriteInput() {
    return this._overwrite;
  }

  // remove_all - computed: false, optional: true, required: false
  private _removeAll = new VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllOutputReference(this, "remove_all");
  public get removeAll() {
    return this._removeAll;
  }
  public putRemoveAll(value: VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAll) {
    this._removeAll.internalValue = value;
  }
  public resetRemoveAll() {
    this._removeAll.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeAllInput() {
    return this._removeAll.internalValue;
  }

  // remove_regex - computed: false, optional: true, required: false
  private _removeRegex?: string; 
  public get removeRegex() {
    return this.getStringAttribute('remove_regex');
  }
  public set removeRegex(value: string) {
    this._removeRegex = value;
  }
  public resetRemoveRegex() {
    this._removeRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeRegexInput() {
    return this._removeRegex;
  }
}
export interface VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNone {
}

export function virtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneToTerraform(struct?: VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNone | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function virtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNone | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNone | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNone | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAll {
}

export function virtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllToTerraform(struct?: VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAll | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function virtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAll | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAll | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAll | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunity {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#append VirtualRouter#append}
  */
  readonly append?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#none VirtualRouter#none}
  */
  readonly none?: VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNone;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#overwrite VirtualRouter#overwrite}
  */
  readonly overwrite?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#remove_all VirtualRouter#remove_all}
  */
  readonly removeAll?: VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAll;
  /**
  * remove specified coummnity match regular expression
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#remove_regex VirtualRouter#remove_regex}
  */
  readonly removeRegex?: string;
}

export function virtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityToTerraform(struct?: VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    append: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.append),
    none: virtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneToTerraform(struct!.none),
    overwrite: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.overwrite),
    remove_all: virtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllToTerraform(struct!.removeAll),
    remove_regex: cdktf.stringToTerraform(struct!.removeRegex),
  }
}


export function virtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    append: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.append),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    none: {
      value: virtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneToHclTerraform(struct!.none),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNone",
    },
    overwrite: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.overwrite),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    remove_all: {
      value: virtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllToHclTerraform(struct!.removeAll),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAll",
    },
    remove_regex: {
      value: cdktf.stringToHclTerraform(struct!.removeRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._append !== undefined) {
      hasAnyValues = true;
      internalValueResult.append = this._append;
    }
    if (this._none?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.none = this._none?.internalValue;
    }
    if (this._overwrite !== undefined) {
      hasAnyValues = true;
      internalValueResult.overwrite = this._overwrite;
    }
    if (this._removeAll?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.removeAll = this._removeAll?.internalValue;
    }
    if (this._removeRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.removeRegex = this._removeRegex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._append = undefined;
      this._none.internalValue = undefined;
      this._overwrite = undefined;
      this._removeAll.internalValue = undefined;
      this._removeRegex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._append = value.append;
      this._none.internalValue = value.none;
      this._overwrite = value.overwrite;
      this._removeAll.internalValue = value.removeAll;
      this._removeRegex = value.removeRegex;
    }
  }

  // append - computed: false, optional: true, required: false
  private _append?: string[]; 
  public get append() {
    return this.getListAttribute('append');
  }
  public set append(value: string[]) {
    this._append = value;
  }
  public resetAppend() {
    this._append = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appendInput() {
    return this._append;
  }

  // none - computed: false, optional: true, required: false
  private _none = new VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneOutputReference(this, "none");
  public get none() {
    return this._none;
  }
  public putNone(value: VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNone) {
    this._none.internalValue = value;
  }
  public resetNone() {
    this._none.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get noneInput() {
    return this._none.internalValue;
  }

  // overwrite - computed: false, optional: true, required: false
  private _overwrite?: string[]; 
  public get overwrite() {
    return this.getListAttribute('overwrite');
  }
  public set overwrite(value: string[]) {
    this._overwrite = value;
  }
  public resetOverwrite() {
    this._overwrite = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overwriteInput() {
    return this._overwrite;
  }

  // remove_all - computed: false, optional: true, required: false
  private _removeAll = new VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllOutputReference(this, "remove_all");
  public get removeAll() {
    return this._removeAll;
  }
  public putRemoveAll(value: VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAll) {
    this._removeAll.internalValue = value;
  }
  public resetRemoveAll() {
    this._removeAll.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeAllInput() {
    return this._removeAll.internalValue;
  }

  // remove_regex - computed: false, optional: true, required: false
  private _removeRegex?: string; 
  public get removeRegex() {
    return this.getStringAttribute('remove_regex');
  }
  public set removeRegex(value: string) {
    this._removeRegex = value;
  }
  public resetRemoveRegex() {
    this._removeRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeRegexInput() {
    return this._removeRegex;
  }
}
export interface VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdate {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#as_path VirtualRouter#as_path}
  */
  readonly asPath?: VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateAsPath;
  /**
  * add AS path limit attribute if it does not exist 
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#as_path_limit VirtualRouter#as_path_limit}
  */
  readonly asPathLimit?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#community VirtualRouter#community}
  */
  readonly community?: VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateCommunity;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#extended_community VirtualRouter#extended_community}
  */
  readonly extendedCommunity?: VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunity;
  /**
  * new local preference value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#local_preference VirtualRouter#local_preference}
  */
  readonly localPreference?: number;
  /**
  * new MED value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#med VirtualRouter#med}
  */
  readonly med?: number;
  /**
  * nexthop address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#nexthop VirtualRouter#nexthop}
  */
  readonly nexthop?: string;
  /**
  * new route origin
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#origin VirtualRouter#origin}
  */
  readonly origin?: string;
}

export function virtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateToTerraform(struct?: VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    as_path: virtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateAsPathToTerraform(struct!.asPath),
    as_path_limit: cdktf.numberToTerraform(struct!.asPathLimit),
    community: virtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateCommunityToTerraform(struct!.community),
    extended_community: virtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityToTerraform(struct!.extendedCommunity),
    local_preference: cdktf.numberToTerraform(struct!.localPreference),
    med: cdktf.numberToTerraform(struct!.med),
    nexthop: cdktf.stringToTerraform(struct!.nexthop),
    origin: cdktf.stringToTerraform(struct!.origin),
  }
}


export function virtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    as_path: {
      value: virtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateAsPathToHclTerraform(struct!.asPath),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateAsPath",
    },
    as_path_limit: {
      value: cdktf.numberToHclTerraform(struct!.asPathLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    community: {
      value: virtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateCommunityToHclTerraform(struct!.community),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateCommunity",
    },
    extended_community: {
      value: virtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityToHclTerraform(struct!.extendedCommunity),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunity",
    },
    local_preference: {
      value: cdktf.numberToHclTerraform(struct!.localPreference),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    med: {
      value: cdktf.numberToHclTerraform(struct!.med),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    nexthop: {
      value: cdktf.stringToHclTerraform(struct!.nexthop),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    origin: {
      value: cdktf.stringToHclTerraform(struct!.origin),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdate | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._asPath?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.asPath = this._asPath?.internalValue;
    }
    if (this._asPathLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.asPathLimit = this._asPathLimit;
    }
    if (this._community?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.community = this._community?.internalValue;
    }
    if (this._extendedCommunity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extendedCommunity = this._extendedCommunity?.internalValue;
    }
    if (this._localPreference !== undefined) {
      hasAnyValues = true;
      internalValueResult.localPreference = this._localPreference;
    }
    if (this._med !== undefined) {
      hasAnyValues = true;
      internalValueResult.med = this._med;
    }
    if (this._nexthop !== undefined) {
      hasAnyValues = true;
      internalValueResult.nexthop = this._nexthop;
    }
    if (this._origin !== undefined) {
      hasAnyValues = true;
      internalValueResult.origin = this._origin;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdate | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._asPath.internalValue = undefined;
      this._asPathLimit = undefined;
      this._community.internalValue = undefined;
      this._extendedCommunity.internalValue = undefined;
      this._localPreference = undefined;
      this._med = undefined;
      this._nexthop = undefined;
      this._origin = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._asPath.internalValue = value.asPath;
      this._asPathLimit = value.asPathLimit;
      this._community.internalValue = value.community;
      this._extendedCommunity.internalValue = value.extendedCommunity;
      this._localPreference = value.localPreference;
      this._med = value.med;
      this._nexthop = value.nexthop;
      this._origin = value.origin;
    }
  }

  // as_path - computed: false, optional: true, required: false
  private _asPath = new VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateAsPathOutputReference(this, "as_path");
  public get asPath() {
    return this._asPath;
  }
  public putAsPath(value: VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateAsPath) {
    this._asPath.internalValue = value;
  }
  public resetAsPath() {
    this._asPath.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asPathInput() {
    return this._asPath.internalValue;
  }

  // as_path_limit - computed: false, optional: true, required: false
  private _asPathLimit?: number; 
  public get asPathLimit() {
    return this.getNumberAttribute('as_path_limit');
  }
  public set asPathLimit(value: number) {
    this._asPathLimit = value;
  }
  public resetAsPathLimit() {
    this._asPathLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asPathLimitInput() {
    return this._asPathLimit;
  }

  // community - computed: false, optional: true, required: false
  private _community = new VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateCommunityOutputReference(this, "community");
  public get community() {
    return this._community;
  }
  public putCommunity(value: VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateCommunity) {
    this._community.internalValue = value;
  }
  public resetCommunity() {
    this._community.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get communityInput() {
    return this._community.internalValue;
  }

  // extended_community - computed: false, optional: true, required: false
  private _extendedCommunity = new VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityOutputReference(this, "extended_community");
  public get extendedCommunity() {
    return this._extendedCommunity;
  }
  public putExtendedCommunity(value: VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunity) {
    this._extendedCommunity.internalValue = value;
  }
  public resetExtendedCommunity() {
    this._extendedCommunity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extendedCommunityInput() {
    return this._extendedCommunity.internalValue;
  }

  // local_preference - computed: false, optional: true, required: false
  private _localPreference?: number; 
  public get localPreference() {
    return this.getNumberAttribute('local_preference');
  }
  public set localPreference(value: number) {
    this._localPreference = value;
  }
  public resetLocalPreference() {
    this._localPreference = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localPreferenceInput() {
    return this._localPreference;
  }

  // med - computed: false, optional: true, required: false
  private _med?: number; 
  public get med() {
    return this.getNumberAttribute('med');
  }
  public set med(value: number) {
    this._med = value;
  }
  public resetMed() {
    this._med = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get medInput() {
    return this._med;
  }

  // nexthop - computed: false, optional: true, required: false
  private _nexthop?: string; 
  public get nexthop() {
    return this.getStringAttribute('nexthop');
  }
  public set nexthop(value: string) {
    this._nexthop = value;
  }
  public resetNexthop() {
    this._nexthop = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nexthopInput() {
    return this._nexthop;
  }

  // origin - computed: false, optional: true, required: false
  private _origin?: string; 
  public get origin() {
    return this.getStringAttribute('origin');
  }
  public set origin(value: string) {
    this._origin = value;
  }
  public resetOrigin() {
    this._origin = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get originInput() {
    return this._origin;
  }
}
export interface VirtualRouterProtocolBgpPolicyExportRulesActionAllow {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#update VirtualRouter#update}
  */
  readonly update?: VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdate;
}

export function virtualRouterProtocolBgpPolicyExportRulesActionAllowToTerraform(struct?: VirtualRouterProtocolBgpPolicyExportRulesActionAllow | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    update: virtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateToTerraform(struct!.update),
  }
}


export function virtualRouterProtocolBgpPolicyExportRulesActionAllowToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyExportRulesActionAllow | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    update: {
      value: virtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateToHclTerraform(struct!.update),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdate",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyExportRulesActionAllowOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyExportRulesActionAllow | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._update?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.update = this._update?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyExportRulesActionAllow | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._update.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._update.internalValue = value.update;
    }
  }

  // update - computed: false, optional: true, required: false
  private _update = new VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdateOutputReference(this, "update");
  public get update() {
    return this._update;
  }
  public putUpdate(value: VirtualRouterProtocolBgpPolicyExportRulesActionAllowUpdate) {
    this._update.internalValue = value;
  }
  public resetUpdate() {
    this._update.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get updateInput() {
    return this._update.internalValue;
  }
}
export interface VirtualRouterProtocolBgpPolicyExportRulesActionDeny {
}

export function virtualRouterProtocolBgpPolicyExportRulesActionDenyToTerraform(struct?: VirtualRouterProtocolBgpPolicyExportRulesActionDeny | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function virtualRouterProtocolBgpPolicyExportRulesActionDenyToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyExportRulesActionDeny | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class VirtualRouterProtocolBgpPolicyExportRulesActionDenyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyExportRulesActionDeny | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyExportRulesActionDeny | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface VirtualRouterProtocolBgpPolicyExportRulesAction {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#allow VirtualRouter#allow}
  */
  readonly allow?: VirtualRouterProtocolBgpPolicyExportRulesActionAllow;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#deny VirtualRouter#deny}
  */
  readonly deny?: VirtualRouterProtocolBgpPolicyExportRulesActionDeny;
}

export function virtualRouterProtocolBgpPolicyExportRulesActionToTerraform(struct?: VirtualRouterProtocolBgpPolicyExportRulesAction | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow: virtualRouterProtocolBgpPolicyExportRulesActionAllowToTerraform(struct!.allow),
    deny: virtualRouterProtocolBgpPolicyExportRulesActionDenyToTerraform(struct!.deny),
  }
}


export function virtualRouterProtocolBgpPolicyExportRulesActionToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyExportRulesAction | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow: {
      value: virtualRouterProtocolBgpPolicyExportRulesActionAllowToHclTerraform(struct!.allow),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyExportRulesActionAllow",
    },
    deny: {
      value: virtualRouterProtocolBgpPolicyExportRulesActionDenyToHclTerraform(struct!.deny),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyExportRulesActionDeny",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyExportRulesActionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyExportRulesAction | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allow?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.allow = this._allow?.internalValue;
    }
    if (this._deny?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.deny = this._deny?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyExportRulesAction | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allow.internalValue = undefined;
      this._deny.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allow.internalValue = value.allow;
      this._deny.internalValue = value.deny;
    }
  }

  // allow - computed: false, optional: true, required: false
  private _allow = new VirtualRouterProtocolBgpPolicyExportRulesActionAllowOutputReference(this, "allow");
  public get allow() {
    return this._allow;
  }
  public putAllow(value: VirtualRouterProtocolBgpPolicyExportRulesActionAllow) {
    this._allow.internalValue = value;
  }
  public resetAllow() {
    this._allow.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowInput() {
    return this._allow.internalValue;
  }

  // deny - computed: false, optional: true, required: false
  private _deny = new VirtualRouterProtocolBgpPolicyExportRulesActionDenyOutputReference(this, "deny");
  public get deny() {
    return this._deny;
  }
  public putDeny(value: VirtualRouterProtocolBgpPolicyExportRulesActionDeny) {
    this._deny.internalValue = value;
  }
  public resetDeny() {
    this._deny.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get denyInput() {
    return this._deny.internalValue;
  }
}
export interface VirtualRouterProtocolBgpPolicyExportRulesMatchAddressPrefix {
  /**
  * match exact prefix length
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#exact VirtualRouter#exact}
  */
  readonly exact?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#name VirtualRouter#name}
  */
  readonly name: string;
}

export function virtualRouterProtocolBgpPolicyExportRulesMatchAddressPrefixToTerraform(struct?: VirtualRouterProtocolBgpPolicyExportRulesMatchAddressPrefix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    exact: cdktf.booleanToTerraform(struct!.exact),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function virtualRouterProtocolBgpPolicyExportRulesMatchAddressPrefixToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyExportRulesMatchAddressPrefix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    exact: {
      value: cdktf.booleanToHclTerraform(struct!.exact),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyExportRulesMatchAddressPrefixOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyExportRulesMatchAddressPrefix | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._exact !== undefined) {
      hasAnyValues = true;
      internalValueResult.exact = this._exact;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyExportRulesMatchAddressPrefix | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._exact = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._exact = value.exact;
      this._name = value.name;
    }
  }

  // exact - computed: false, optional: true, required: false
  private _exact?: boolean | cdktf.IResolvable; 
  public get exact() {
    return this.getBooleanAttribute('exact');
  }
  public set exact(value: boolean | cdktf.IResolvable) {
    this._exact = value;
  }
  public resetExact() {
    this._exact = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exactInput() {
    return this._exact;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class VirtualRouterProtocolBgpPolicyExportRulesMatchAddressPrefixList extends cdktf.ComplexList {
  public internalValue? : VirtualRouterProtocolBgpPolicyExportRulesMatchAddressPrefix[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): VirtualRouterProtocolBgpPolicyExportRulesMatchAddressPrefixOutputReference {
    return new VirtualRouterProtocolBgpPolicyExportRulesMatchAddressPrefixOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface VirtualRouterProtocolBgpPolicyExportRulesMatchAsPath {
  /**
  * AS-path regular expression
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#regex VirtualRouter#regex}
  */
  readonly regex?: string;
}

export function virtualRouterProtocolBgpPolicyExportRulesMatchAsPathToTerraform(struct?: VirtualRouterProtocolBgpPolicyExportRulesMatchAsPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function virtualRouterProtocolBgpPolicyExportRulesMatchAsPathToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyExportRulesMatchAsPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyExportRulesMatchAsPathOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyExportRulesMatchAsPath | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyExportRulesMatchAsPath | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._regex = value.regex;
    }
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface VirtualRouterProtocolBgpPolicyExportRulesMatchCommunity {
  /**
  * AS-path regular expression
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#regex VirtualRouter#regex}
  */
  readonly regex?: string;
}

export function virtualRouterProtocolBgpPolicyExportRulesMatchCommunityToTerraform(struct?: VirtualRouterProtocolBgpPolicyExportRulesMatchCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function virtualRouterProtocolBgpPolicyExportRulesMatchCommunityToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyExportRulesMatchCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyExportRulesMatchCommunityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyExportRulesMatchCommunity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyExportRulesMatchCommunity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._regex = value.regex;
    }
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface VirtualRouterProtocolBgpPolicyExportRulesMatchExtendedCommunity {
  /**
  * AS-path regular expression
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#regex VirtualRouter#regex}
  */
  readonly regex?: string;
}

export function virtualRouterProtocolBgpPolicyExportRulesMatchExtendedCommunityToTerraform(struct?: VirtualRouterProtocolBgpPolicyExportRulesMatchExtendedCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function virtualRouterProtocolBgpPolicyExportRulesMatchExtendedCommunityToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyExportRulesMatchExtendedCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyExportRulesMatchExtendedCommunityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyExportRulesMatchExtendedCommunity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyExportRulesMatchExtendedCommunity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._regex = value.regex;
    }
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface VirtualRouterProtocolBgpPolicyExportRulesMatch {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#address_prefix VirtualRouter#address_prefix}
  */
  readonly addressPrefix?: VirtualRouterProtocolBgpPolicyExportRulesMatchAddressPrefix[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#as_path VirtualRouter#as_path}
  */
  readonly asPath?: VirtualRouterProtocolBgpPolicyExportRulesMatchAsPath;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#community VirtualRouter#community}
  */
  readonly community?: VirtualRouterProtocolBgpPolicyExportRulesMatchCommunity;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#extended_community VirtualRouter#extended_community}
  */
  readonly extendedCommunity?: VirtualRouterProtocolBgpPolicyExportRulesMatchExtendedCommunity;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#from_peer VirtualRouter#from_peer}
  */
  readonly fromPeer?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#med VirtualRouter#med}
  */
  readonly med?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#nexthop VirtualRouter#nexthop}
  */
  readonly nexthop?: string[];
  /**
  * route table to match rule
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#route_table VirtualRouter#route_table}
  */
  readonly routeTable?: string;
}

export function virtualRouterProtocolBgpPolicyExportRulesMatchToTerraform(struct?: VirtualRouterProtocolBgpPolicyExportRulesMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address_prefix: cdktf.listMapper(virtualRouterProtocolBgpPolicyExportRulesMatchAddressPrefixToTerraform, false)(struct!.addressPrefix),
    as_path: virtualRouterProtocolBgpPolicyExportRulesMatchAsPathToTerraform(struct!.asPath),
    community: virtualRouterProtocolBgpPolicyExportRulesMatchCommunityToTerraform(struct!.community),
    extended_community: virtualRouterProtocolBgpPolicyExportRulesMatchExtendedCommunityToTerraform(struct!.extendedCommunity),
    from_peer: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.fromPeer),
    med: cdktf.numberToTerraform(struct!.med),
    nexthop: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.nexthop),
    route_table: cdktf.stringToTerraform(struct!.routeTable),
  }
}


export function virtualRouterProtocolBgpPolicyExportRulesMatchToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyExportRulesMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address_prefix: {
      value: cdktf.listMapperHcl(virtualRouterProtocolBgpPolicyExportRulesMatchAddressPrefixToHclTerraform, false)(struct!.addressPrefix),
      isBlock: true,
      type: "list",
      storageClassType: "VirtualRouterProtocolBgpPolicyExportRulesMatchAddressPrefixList",
    },
    as_path: {
      value: virtualRouterProtocolBgpPolicyExportRulesMatchAsPathToHclTerraform(struct!.asPath),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyExportRulesMatchAsPath",
    },
    community: {
      value: virtualRouterProtocolBgpPolicyExportRulesMatchCommunityToHclTerraform(struct!.community),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyExportRulesMatchCommunity",
    },
    extended_community: {
      value: virtualRouterProtocolBgpPolicyExportRulesMatchExtendedCommunityToHclTerraform(struct!.extendedCommunity),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyExportRulesMatchExtendedCommunity",
    },
    from_peer: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.fromPeer),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    med: {
      value: cdktf.numberToHclTerraform(struct!.med),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    nexthop: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.nexthop),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    route_table: {
      value: cdktf.stringToHclTerraform(struct!.routeTable),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyExportRulesMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyExportRulesMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addressPrefix?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.addressPrefix = this._addressPrefix?.internalValue;
    }
    if (this._asPath?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.asPath = this._asPath?.internalValue;
    }
    if (this._community?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.community = this._community?.internalValue;
    }
    if (this._extendedCommunity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extendedCommunity = this._extendedCommunity?.internalValue;
    }
    if (this._fromPeer !== undefined) {
      hasAnyValues = true;
      internalValueResult.fromPeer = this._fromPeer;
    }
    if (this._med !== undefined) {
      hasAnyValues = true;
      internalValueResult.med = this._med;
    }
    if (this._nexthop !== undefined) {
      hasAnyValues = true;
      internalValueResult.nexthop = this._nexthop;
    }
    if (this._routeTable !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeTable = this._routeTable;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyExportRulesMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addressPrefix.internalValue = undefined;
      this._asPath.internalValue = undefined;
      this._community.internalValue = undefined;
      this._extendedCommunity.internalValue = undefined;
      this._fromPeer = undefined;
      this._med = undefined;
      this._nexthop = undefined;
      this._routeTable = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addressPrefix.internalValue = value.addressPrefix;
      this._asPath.internalValue = value.asPath;
      this._community.internalValue = value.community;
      this._extendedCommunity.internalValue = value.extendedCommunity;
      this._fromPeer = value.fromPeer;
      this._med = value.med;
      this._nexthop = value.nexthop;
      this._routeTable = value.routeTable;
    }
  }

  // address_prefix - computed: false, optional: true, required: false
  private _addressPrefix = new VirtualRouterProtocolBgpPolicyExportRulesMatchAddressPrefixList(this, "address_prefix", false);
  public get addressPrefix() {
    return this._addressPrefix;
  }
  public putAddressPrefix(value: VirtualRouterProtocolBgpPolicyExportRulesMatchAddressPrefix[] | cdktf.IResolvable) {
    this._addressPrefix.internalValue = value;
  }
  public resetAddressPrefix() {
    this._addressPrefix.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressPrefixInput() {
    return this._addressPrefix.internalValue;
  }

  // as_path - computed: false, optional: true, required: false
  private _asPath = new VirtualRouterProtocolBgpPolicyExportRulesMatchAsPathOutputReference(this, "as_path");
  public get asPath() {
    return this._asPath;
  }
  public putAsPath(value: VirtualRouterProtocolBgpPolicyExportRulesMatchAsPath) {
    this._asPath.internalValue = value;
  }
  public resetAsPath() {
    this._asPath.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asPathInput() {
    return this._asPath.internalValue;
  }

  // community - computed: false, optional: true, required: false
  private _community = new VirtualRouterProtocolBgpPolicyExportRulesMatchCommunityOutputReference(this, "community");
  public get community() {
    return this._community;
  }
  public putCommunity(value: VirtualRouterProtocolBgpPolicyExportRulesMatchCommunity) {
    this._community.internalValue = value;
  }
  public resetCommunity() {
    this._community.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get communityInput() {
    return this._community.internalValue;
  }

  // extended_community - computed: false, optional: true, required: false
  private _extendedCommunity = new VirtualRouterProtocolBgpPolicyExportRulesMatchExtendedCommunityOutputReference(this, "extended_community");
  public get extendedCommunity() {
    return this._extendedCommunity;
  }
  public putExtendedCommunity(value: VirtualRouterProtocolBgpPolicyExportRulesMatchExtendedCommunity) {
    this._extendedCommunity.internalValue = value;
  }
  public resetExtendedCommunity() {
    this._extendedCommunity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extendedCommunityInput() {
    return this._extendedCommunity.internalValue;
  }

  // from_peer - computed: false, optional: true, required: false
  private _fromPeer?: string[]; 
  public get fromPeer() {
    return this.getListAttribute('from_peer');
  }
  public set fromPeer(value: string[]) {
    this._fromPeer = value;
  }
  public resetFromPeer() {
    this._fromPeer = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fromPeerInput() {
    return this._fromPeer;
  }

  // med - computed: false, optional: true, required: false
  private _med?: number; 
  public get med() {
    return this.getNumberAttribute('med');
  }
  public set med(value: number) {
    this._med = value;
  }
  public resetMed() {
    this._med = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get medInput() {
    return this._med;
  }

  // nexthop - computed: false, optional: true, required: false
  private _nexthop?: string[]; 
  public get nexthop() {
    return this.getListAttribute('nexthop');
  }
  public set nexthop(value: string[]) {
    this._nexthop = value;
  }
  public resetNexthop() {
    this._nexthop = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nexthopInput() {
    return this._nexthop;
  }

  // route_table - computed: true, optional: true, required: false
  private _routeTable?: string; 
  public get routeTable() {
    return this.getStringAttribute('route_table');
  }
  public set routeTable(value: string) {
    this._routeTable = value;
  }
  public resetRouteTable() {
    this._routeTable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeTableInput() {
    return this._routeTable;
  }
}
export interface VirtualRouterProtocolBgpPolicyExportRules {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#action VirtualRouter#action}
  */
  readonly action?: VirtualRouterProtocolBgpPolicyExportRulesAction;
  /**
  * Enable
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#enable VirtualRouter#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#match VirtualRouter#match}
  */
  readonly match?: VirtualRouterProtocolBgpPolicyExportRulesMatch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#name VirtualRouter#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#used_by VirtualRouter#used_by}
  */
  readonly usedBy?: string[];
}

export function virtualRouterProtocolBgpPolicyExportRulesToTerraform(struct?: VirtualRouterProtocolBgpPolicyExportRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: virtualRouterProtocolBgpPolicyExportRulesActionToTerraform(struct!.action),
    enable: cdktf.booleanToTerraform(struct!.enable),
    match: virtualRouterProtocolBgpPolicyExportRulesMatchToTerraform(struct!.match),
    name: cdktf.stringToTerraform(struct!.name),
    used_by: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.usedBy),
  }
}


export function virtualRouterProtocolBgpPolicyExportRulesToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyExportRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: virtualRouterProtocolBgpPolicyExportRulesActionToHclTerraform(struct!.action),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyExportRulesAction",
    },
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    match: {
      value: virtualRouterProtocolBgpPolicyExportRulesMatchToHclTerraform(struct!.match),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyExportRulesMatch",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    used_by: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.usedBy),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyExportRulesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyExportRules | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action?.internalValue;
    }
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._match?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._usedBy !== undefined) {
      hasAnyValues = true;
      internalValueResult.usedBy = this._usedBy;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyExportRules | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action.internalValue = undefined;
      this._enable = undefined;
      this._match.internalValue = undefined;
      this._name = undefined;
      this._usedBy = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action.internalValue = value.action;
      this._enable = value.enable;
      this._match.internalValue = value.match;
      this._name = value.name;
      this._usedBy = value.usedBy;
    }
  }

  // action - computed: false, optional: true, required: false
  private _action = new VirtualRouterProtocolBgpPolicyExportRulesActionOutputReference(this, "action");
  public get action() {
    return this._action;
  }
  public putAction(value: VirtualRouterProtocolBgpPolicyExportRulesAction) {
    this._action.internalValue = value;
  }
  public resetAction() {
    this._action.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action.internalValue;
  }

  // enable - computed: false, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // match - computed: false, optional: true, required: false
  private _match = new VirtualRouterProtocolBgpPolicyExportRulesMatchOutputReference(this, "match");
  public get match() {
    return this._match;
  }
  public putMatch(value: VirtualRouterProtocolBgpPolicyExportRulesMatch) {
    this._match.internalValue = value;
  }
  public resetMatch() {
    this._match.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match.internalValue;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // used_by - computed: false, optional: true, required: false
  private _usedBy?: string[]; 
  public get usedBy() {
    return this.getListAttribute('used_by');
  }
  public set usedBy(value: string[]) {
    this._usedBy = value;
  }
  public resetUsedBy() {
    this._usedBy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usedByInput() {
    return this._usedBy;
  }
}

export class VirtualRouterProtocolBgpPolicyExportRulesList extends cdktf.ComplexList {
  public internalValue? : VirtualRouterProtocolBgpPolicyExportRules[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): VirtualRouterProtocolBgpPolicyExportRulesOutputReference {
    return new VirtualRouterProtocolBgpPolicyExportRulesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface VirtualRouterProtocolBgpPolicyExport {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#rules VirtualRouter#rules}
  */
  readonly rules?: VirtualRouterProtocolBgpPolicyExportRules[] | cdktf.IResolvable;
}

export function virtualRouterProtocolBgpPolicyExportToTerraform(struct?: VirtualRouterProtocolBgpPolicyExport | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    rules: cdktf.listMapper(virtualRouterProtocolBgpPolicyExportRulesToTerraform, false)(struct!.rules),
  }
}


export function virtualRouterProtocolBgpPolicyExportToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyExport | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    rules: {
      value: cdktf.listMapperHcl(virtualRouterProtocolBgpPolicyExportRulesToHclTerraform, false)(struct!.rules),
      isBlock: true,
      type: "list",
      storageClassType: "VirtualRouterProtocolBgpPolicyExportRulesList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyExportOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyExport | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._rules?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rules = this._rules?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyExport | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._rules.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._rules.internalValue = value.rules;
    }
  }

  // rules - computed: false, optional: true, required: false
  private _rules = new VirtualRouterProtocolBgpPolicyExportRulesList(this, "rules", false);
  public get rules() {
    return this._rules;
  }
  public putRules(value: VirtualRouterProtocolBgpPolicyExportRules[] | cdktf.IResolvable) {
    this._rules.internalValue = value;
  }
  public resetRules() {
    this._rules.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rulesInput() {
    return this._rules.internalValue;
  }
}
export interface VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNone {
}

export function virtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNoneToTerraform(struct?: VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNone | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function virtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNoneToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNone | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNoneOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNone | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNone | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemove {
}

export function virtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemoveToTerraform(struct?: VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemove | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function virtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemoveToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemove | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemoveOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemove | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemove | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateAsPath {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#none VirtualRouter#none}
  */
  readonly none?: VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNone;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#remove VirtualRouter#remove}
  */
  readonly remove?: VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemove;
}

export function virtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateAsPathToTerraform(struct?: VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateAsPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    none: virtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNoneToTerraform(struct!.none),
    remove: virtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemoveToTerraform(struct!.remove),
  }
}


export function virtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateAsPathToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateAsPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    none: {
      value: virtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNoneToHclTerraform(struct!.none),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNone",
    },
    remove: {
      value: virtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemoveToHclTerraform(struct!.remove),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemove",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateAsPathOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateAsPath | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._none?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.none = this._none?.internalValue;
    }
    if (this._remove?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.remove = this._remove?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateAsPath | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._none.internalValue = undefined;
      this._remove.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._none.internalValue = value.none;
      this._remove.internalValue = value.remove;
    }
  }

  // none - computed: false, optional: true, required: false
  private _none = new VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNoneOutputReference(this, "none");
  public get none() {
    return this._none;
  }
  public putNone(value: VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNone) {
    this._none.internalValue = value;
  }
  public resetNone() {
    this._none.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get noneInput() {
    return this._none.internalValue;
  }

  // remove - computed: false, optional: true, required: false
  private _remove = new VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemoveOutputReference(this, "remove");
  public get remove() {
    return this._remove;
  }
  public putRemove(value: VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemove) {
    this._remove.internalValue = value;
  }
  public resetRemove() {
    this._remove.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeInput() {
    return this._remove.internalValue;
  }
}
export interface VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNone {
}

export function virtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNoneToTerraform(struct?: VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNone | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function virtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNoneToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNone | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNoneOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNone | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNone | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAll {
}

export function virtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllToTerraform(struct?: VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAll | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function virtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAll | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAll | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAll | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateCommunity {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#append VirtualRouter#append}
  */
  readonly append?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#none VirtualRouter#none}
  */
  readonly none?: VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNone;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#overwrite VirtualRouter#overwrite}
  */
  readonly overwrite?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#remove_all VirtualRouter#remove_all}
  */
  readonly removeAll?: VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAll;
  /**
  * remove specified coummnity match regular expression
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#remove_regex VirtualRouter#remove_regex}
  */
  readonly removeRegex?: string;
}

export function virtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateCommunityToTerraform(struct?: VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    append: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.append),
    none: virtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNoneToTerraform(struct!.none),
    overwrite: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.overwrite),
    remove_all: virtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllToTerraform(struct!.removeAll),
    remove_regex: cdktf.stringToTerraform(struct!.removeRegex),
  }
}


export function virtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateCommunityToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    append: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.append),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    none: {
      value: virtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNoneToHclTerraform(struct!.none),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNone",
    },
    overwrite: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.overwrite),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    remove_all: {
      value: virtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllToHclTerraform(struct!.removeAll),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAll",
    },
    remove_regex: {
      value: cdktf.stringToHclTerraform(struct!.removeRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateCommunityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateCommunity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._append !== undefined) {
      hasAnyValues = true;
      internalValueResult.append = this._append;
    }
    if (this._none?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.none = this._none?.internalValue;
    }
    if (this._overwrite !== undefined) {
      hasAnyValues = true;
      internalValueResult.overwrite = this._overwrite;
    }
    if (this._removeAll?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.removeAll = this._removeAll?.internalValue;
    }
    if (this._removeRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.removeRegex = this._removeRegex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateCommunity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._append = undefined;
      this._none.internalValue = undefined;
      this._overwrite = undefined;
      this._removeAll.internalValue = undefined;
      this._removeRegex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._append = value.append;
      this._none.internalValue = value.none;
      this._overwrite = value.overwrite;
      this._removeAll.internalValue = value.removeAll;
      this._removeRegex = value.removeRegex;
    }
  }

  // append - computed: false, optional: true, required: false
  private _append?: string[]; 
  public get append() {
    return this.getListAttribute('append');
  }
  public set append(value: string[]) {
    this._append = value;
  }
  public resetAppend() {
    this._append = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appendInput() {
    return this._append;
  }

  // none - computed: false, optional: true, required: false
  private _none = new VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNoneOutputReference(this, "none");
  public get none() {
    return this._none;
  }
  public putNone(value: VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNone) {
    this._none.internalValue = value;
  }
  public resetNone() {
    this._none.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get noneInput() {
    return this._none.internalValue;
  }

  // overwrite - computed: false, optional: true, required: false
  private _overwrite?: string[]; 
  public get overwrite() {
    return this.getListAttribute('overwrite');
  }
  public set overwrite(value: string[]) {
    this._overwrite = value;
  }
  public resetOverwrite() {
    this._overwrite = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overwriteInput() {
    return this._overwrite;
  }

  // remove_all - computed: false, optional: true, required: false
  private _removeAll = new VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllOutputReference(this, "remove_all");
  public get removeAll() {
    return this._removeAll;
  }
  public putRemoveAll(value: VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAll) {
    this._removeAll.internalValue = value;
  }
  public resetRemoveAll() {
    this._removeAll.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeAllInput() {
    return this._removeAll.internalValue;
  }

  // remove_regex - computed: false, optional: true, required: false
  private _removeRegex?: string; 
  public get removeRegex() {
    return this.getStringAttribute('remove_regex');
  }
  public set removeRegex(value: string) {
    this._removeRegex = value;
  }
  public resetRemoveRegex() {
    this._removeRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeRegexInput() {
    return this._removeRegex;
  }
}
export interface VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNone {
}

export function virtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneToTerraform(struct?: VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNone | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function virtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNone | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNone | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNone | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAll {
}

export function virtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllToTerraform(struct?: VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAll | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function virtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAll | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAll | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAll | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunity {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#append VirtualRouter#append}
  */
  readonly append?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#none VirtualRouter#none}
  */
  readonly none?: VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNone;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#overwrite VirtualRouter#overwrite}
  */
  readonly overwrite?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#remove_all VirtualRouter#remove_all}
  */
  readonly removeAll?: VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAll;
  /**
  * remove specified coummnity match regular expression
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#remove_regex VirtualRouter#remove_regex}
  */
  readonly removeRegex?: string;
}

export function virtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityToTerraform(struct?: VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    append: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.append),
    none: virtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneToTerraform(struct!.none),
    overwrite: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.overwrite),
    remove_all: virtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllToTerraform(struct!.removeAll),
    remove_regex: cdktf.stringToTerraform(struct!.removeRegex),
  }
}


export function virtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    append: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.append),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    none: {
      value: virtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneToHclTerraform(struct!.none),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNone",
    },
    overwrite: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.overwrite),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    remove_all: {
      value: virtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllToHclTerraform(struct!.removeAll),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAll",
    },
    remove_regex: {
      value: cdktf.stringToHclTerraform(struct!.removeRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._append !== undefined) {
      hasAnyValues = true;
      internalValueResult.append = this._append;
    }
    if (this._none?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.none = this._none?.internalValue;
    }
    if (this._overwrite !== undefined) {
      hasAnyValues = true;
      internalValueResult.overwrite = this._overwrite;
    }
    if (this._removeAll?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.removeAll = this._removeAll?.internalValue;
    }
    if (this._removeRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.removeRegex = this._removeRegex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._append = undefined;
      this._none.internalValue = undefined;
      this._overwrite = undefined;
      this._removeAll.internalValue = undefined;
      this._removeRegex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._append = value.append;
      this._none.internalValue = value.none;
      this._overwrite = value.overwrite;
      this._removeAll.internalValue = value.removeAll;
      this._removeRegex = value.removeRegex;
    }
  }

  // append - computed: false, optional: true, required: false
  private _append?: string[]; 
  public get append() {
    return this.getListAttribute('append');
  }
  public set append(value: string[]) {
    this._append = value;
  }
  public resetAppend() {
    this._append = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appendInput() {
    return this._append;
  }

  // none - computed: false, optional: true, required: false
  private _none = new VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneOutputReference(this, "none");
  public get none() {
    return this._none;
  }
  public putNone(value: VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNone) {
    this._none.internalValue = value;
  }
  public resetNone() {
    this._none.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get noneInput() {
    return this._none.internalValue;
  }

  // overwrite - computed: false, optional: true, required: false
  private _overwrite?: string[]; 
  public get overwrite() {
    return this.getListAttribute('overwrite');
  }
  public set overwrite(value: string[]) {
    this._overwrite = value;
  }
  public resetOverwrite() {
    this._overwrite = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overwriteInput() {
    return this._overwrite;
  }

  // remove_all - computed: false, optional: true, required: false
  private _removeAll = new VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllOutputReference(this, "remove_all");
  public get removeAll() {
    return this._removeAll;
  }
  public putRemoveAll(value: VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAll) {
    this._removeAll.internalValue = value;
  }
  public resetRemoveAll() {
    this._removeAll.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeAllInput() {
    return this._removeAll.internalValue;
  }

  // remove_regex - computed: false, optional: true, required: false
  private _removeRegex?: string; 
  public get removeRegex() {
    return this.getStringAttribute('remove_regex');
  }
  public set removeRegex(value: string) {
    this._removeRegex = value;
  }
  public resetRemoveRegex() {
    this._removeRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeRegexInput() {
    return this._removeRegex;
  }
}
export interface VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdate {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#as_path VirtualRouter#as_path}
  */
  readonly asPath?: VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateAsPath;
  /**
  * add AS path limit attribute if it does not exist 
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#as_path_limit VirtualRouter#as_path_limit}
  */
  readonly asPathLimit?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#community VirtualRouter#community}
  */
  readonly community?: VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateCommunity;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#extended_community VirtualRouter#extended_community}
  */
  readonly extendedCommunity?: VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunity;
  /**
  * new local preference value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#local_preference VirtualRouter#local_preference}
  */
  readonly localPreference?: number;
  /**
  * new MED value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#med VirtualRouter#med}
  */
  readonly med?: number;
  /**
  * nexthop address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#nexthop VirtualRouter#nexthop}
  */
  readonly nexthop?: string;
  /**
  * new route origin
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#origin VirtualRouter#origin}
  */
  readonly origin?: string;
  /**
  * new weight value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#weight VirtualRouter#weight}
  */
  readonly weight?: number;
}

export function virtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateToTerraform(struct?: VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    as_path: virtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateAsPathToTerraform(struct!.asPath),
    as_path_limit: cdktf.numberToTerraform(struct!.asPathLimit),
    community: virtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateCommunityToTerraform(struct!.community),
    extended_community: virtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityToTerraform(struct!.extendedCommunity),
    local_preference: cdktf.numberToTerraform(struct!.localPreference),
    med: cdktf.numberToTerraform(struct!.med),
    nexthop: cdktf.stringToTerraform(struct!.nexthop),
    origin: cdktf.stringToTerraform(struct!.origin),
    weight: cdktf.numberToTerraform(struct!.weight),
  }
}


export function virtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    as_path: {
      value: virtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateAsPathToHclTerraform(struct!.asPath),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateAsPath",
    },
    as_path_limit: {
      value: cdktf.numberToHclTerraform(struct!.asPathLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    community: {
      value: virtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateCommunityToHclTerraform(struct!.community),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateCommunity",
    },
    extended_community: {
      value: virtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityToHclTerraform(struct!.extendedCommunity),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunity",
    },
    local_preference: {
      value: cdktf.numberToHclTerraform(struct!.localPreference),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    med: {
      value: cdktf.numberToHclTerraform(struct!.med),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    nexthop: {
      value: cdktf.stringToHclTerraform(struct!.nexthop),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    origin: {
      value: cdktf.stringToHclTerraform(struct!.origin),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    weight: {
      value: cdktf.numberToHclTerraform(struct!.weight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdate | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._asPath?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.asPath = this._asPath?.internalValue;
    }
    if (this._asPathLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.asPathLimit = this._asPathLimit;
    }
    if (this._community?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.community = this._community?.internalValue;
    }
    if (this._extendedCommunity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extendedCommunity = this._extendedCommunity?.internalValue;
    }
    if (this._localPreference !== undefined) {
      hasAnyValues = true;
      internalValueResult.localPreference = this._localPreference;
    }
    if (this._med !== undefined) {
      hasAnyValues = true;
      internalValueResult.med = this._med;
    }
    if (this._nexthop !== undefined) {
      hasAnyValues = true;
      internalValueResult.nexthop = this._nexthop;
    }
    if (this._origin !== undefined) {
      hasAnyValues = true;
      internalValueResult.origin = this._origin;
    }
    if (this._weight !== undefined) {
      hasAnyValues = true;
      internalValueResult.weight = this._weight;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdate | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._asPath.internalValue = undefined;
      this._asPathLimit = undefined;
      this._community.internalValue = undefined;
      this._extendedCommunity.internalValue = undefined;
      this._localPreference = undefined;
      this._med = undefined;
      this._nexthop = undefined;
      this._origin = undefined;
      this._weight = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._asPath.internalValue = value.asPath;
      this._asPathLimit = value.asPathLimit;
      this._community.internalValue = value.community;
      this._extendedCommunity.internalValue = value.extendedCommunity;
      this._localPreference = value.localPreference;
      this._med = value.med;
      this._nexthop = value.nexthop;
      this._origin = value.origin;
      this._weight = value.weight;
    }
  }

  // as_path - computed: false, optional: true, required: false
  private _asPath = new VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateAsPathOutputReference(this, "as_path");
  public get asPath() {
    return this._asPath;
  }
  public putAsPath(value: VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateAsPath) {
    this._asPath.internalValue = value;
  }
  public resetAsPath() {
    this._asPath.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asPathInput() {
    return this._asPath.internalValue;
  }

  // as_path_limit - computed: false, optional: true, required: false
  private _asPathLimit?: number; 
  public get asPathLimit() {
    return this.getNumberAttribute('as_path_limit');
  }
  public set asPathLimit(value: number) {
    this._asPathLimit = value;
  }
  public resetAsPathLimit() {
    this._asPathLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asPathLimitInput() {
    return this._asPathLimit;
  }

  // community - computed: false, optional: true, required: false
  private _community = new VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateCommunityOutputReference(this, "community");
  public get community() {
    return this._community;
  }
  public putCommunity(value: VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateCommunity) {
    this._community.internalValue = value;
  }
  public resetCommunity() {
    this._community.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get communityInput() {
    return this._community.internalValue;
  }

  // extended_community - computed: false, optional: true, required: false
  private _extendedCommunity = new VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityOutputReference(this, "extended_community");
  public get extendedCommunity() {
    return this._extendedCommunity;
  }
  public putExtendedCommunity(value: VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunity) {
    this._extendedCommunity.internalValue = value;
  }
  public resetExtendedCommunity() {
    this._extendedCommunity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extendedCommunityInput() {
    return this._extendedCommunity.internalValue;
  }

  // local_preference - computed: false, optional: true, required: false
  private _localPreference?: number; 
  public get localPreference() {
    return this.getNumberAttribute('local_preference');
  }
  public set localPreference(value: number) {
    this._localPreference = value;
  }
  public resetLocalPreference() {
    this._localPreference = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localPreferenceInput() {
    return this._localPreference;
  }

  // med - computed: false, optional: true, required: false
  private _med?: number; 
  public get med() {
    return this.getNumberAttribute('med');
  }
  public set med(value: number) {
    this._med = value;
  }
  public resetMed() {
    this._med = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get medInput() {
    return this._med;
  }

  // nexthop - computed: false, optional: true, required: false
  private _nexthop?: string; 
  public get nexthop() {
    return this.getStringAttribute('nexthop');
  }
  public set nexthop(value: string) {
    this._nexthop = value;
  }
  public resetNexthop() {
    this._nexthop = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nexthopInput() {
    return this._nexthop;
  }

  // origin - computed: false, optional: true, required: false
  private _origin?: string; 
  public get origin() {
    return this.getStringAttribute('origin');
  }
  public set origin(value: string) {
    this._origin = value;
  }
  public resetOrigin() {
    this._origin = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get originInput() {
    return this._origin;
  }

  // weight - computed: false, optional: true, required: false
  private _weight?: number; 
  public get weight() {
    return this.getNumberAttribute('weight');
  }
  public set weight(value: number) {
    this._weight = value;
  }
  public resetWeight() {
    this._weight = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get weightInput() {
    return this._weight;
  }
}
export interface VirtualRouterProtocolBgpPolicyImportRulesActionAllow {
  /**
  * route flap dampening profile
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#dampening VirtualRouter#dampening}
  */
  readonly dampening?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#update VirtualRouter#update}
  */
  readonly update?: VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdate;
}

export function virtualRouterProtocolBgpPolicyImportRulesActionAllowToTerraform(struct?: VirtualRouterProtocolBgpPolicyImportRulesActionAllow | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dampening: cdktf.stringToTerraform(struct!.dampening),
    update: virtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateToTerraform(struct!.update),
  }
}


export function virtualRouterProtocolBgpPolicyImportRulesActionAllowToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyImportRulesActionAllow | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dampening: {
      value: cdktf.stringToHclTerraform(struct!.dampening),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    update: {
      value: virtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateToHclTerraform(struct!.update),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdate",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyImportRulesActionAllowOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyImportRulesActionAllow | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dampening !== undefined) {
      hasAnyValues = true;
      internalValueResult.dampening = this._dampening;
    }
    if (this._update?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.update = this._update?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyImportRulesActionAllow | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dampening = undefined;
      this._update.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dampening = value.dampening;
      this._update.internalValue = value.update;
    }
  }

  // dampening - computed: false, optional: true, required: false
  private _dampening?: string; 
  public get dampening() {
    return this.getStringAttribute('dampening');
  }
  public set dampening(value: string) {
    this._dampening = value;
  }
  public resetDampening() {
    this._dampening = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dampeningInput() {
    return this._dampening;
  }

  // update - computed: false, optional: true, required: false
  private _update = new VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdateOutputReference(this, "update");
  public get update() {
    return this._update;
  }
  public putUpdate(value: VirtualRouterProtocolBgpPolicyImportRulesActionAllowUpdate) {
    this._update.internalValue = value;
  }
  public resetUpdate() {
    this._update.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get updateInput() {
    return this._update.internalValue;
  }
}
export interface VirtualRouterProtocolBgpPolicyImportRulesActionDeny {
}

export function virtualRouterProtocolBgpPolicyImportRulesActionDenyToTerraform(struct?: VirtualRouterProtocolBgpPolicyImportRulesActionDeny | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function virtualRouterProtocolBgpPolicyImportRulesActionDenyToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyImportRulesActionDeny | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class VirtualRouterProtocolBgpPolicyImportRulesActionDenyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyImportRulesActionDeny | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyImportRulesActionDeny | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface VirtualRouterProtocolBgpPolicyImportRulesAction {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#allow VirtualRouter#allow}
  */
  readonly allow?: VirtualRouterProtocolBgpPolicyImportRulesActionAllow;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#deny VirtualRouter#deny}
  */
  readonly deny?: VirtualRouterProtocolBgpPolicyImportRulesActionDeny;
}

export function virtualRouterProtocolBgpPolicyImportRulesActionToTerraform(struct?: VirtualRouterProtocolBgpPolicyImportRulesAction | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow: virtualRouterProtocolBgpPolicyImportRulesActionAllowToTerraform(struct!.allow),
    deny: virtualRouterProtocolBgpPolicyImportRulesActionDenyToTerraform(struct!.deny),
  }
}


export function virtualRouterProtocolBgpPolicyImportRulesActionToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyImportRulesAction | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow: {
      value: virtualRouterProtocolBgpPolicyImportRulesActionAllowToHclTerraform(struct!.allow),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyImportRulesActionAllow",
    },
    deny: {
      value: virtualRouterProtocolBgpPolicyImportRulesActionDenyToHclTerraform(struct!.deny),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyImportRulesActionDeny",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyImportRulesActionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyImportRulesAction | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allow?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.allow = this._allow?.internalValue;
    }
    if (this._deny?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.deny = this._deny?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyImportRulesAction | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allow.internalValue = undefined;
      this._deny.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allow.internalValue = value.allow;
      this._deny.internalValue = value.deny;
    }
  }

  // allow - computed: false, optional: true, required: false
  private _allow = new VirtualRouterProtocolBgpPolicyImportRulesActionAllowOutputReference(this, "allow");
  public get allow() {
    return this._allow;
  }
  public putAllow(value: VirtualRouterProtocolBgpPolicyImportRulesActionAllow) {
    this._allow.internalValue = value;
  }
  public resetAllow() {
    this._allow.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowInput() {
    return this._allow.internalValue;
  }

  // deny - computed: false, optional: true, required: false
  private _deny = new VirtualRouterProtocolBgpPolicyImportRulesActionDenyOutputReference(this, "deny");
  public get deny() {
    return this._deny;
  }
  public putDeny(value: VirtualRouterProtocolBgpPolicyImportRulesActionDeny) {
    this._deny.internalValue = value;
  }
  public resetDeny() {
    this._deny.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get denyInput() {
    return this._deny.internalValue;
  }
}
export interface VirtualRouterProtocolBgpPolicyImportRulesMatchAddressPrefix {
  /**
  * match exact prefix length
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#exact VirtualRouter#exact}
  */
  readonly exact?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#name VirtualRouter#name}
  */
  readonly name: string;
}

export function virtualRouterProtocolBgpPolicyImportRulesMatchAddressPrefixToTerraform(struct?: VirtualRouterProtocolBgpPolicyImportRulesMatchAddressPrefix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    exact: cdktf.booleanToTerraform(struct!.exact),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function virtualRouterProtocolBgpPolicyImportRulesMatchAddressPrefixToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyImportRulesMatchAddressPrefix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    exact: {
      value: cdktf.booleanToHclTerraform(struct!.exact),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyImportRulesMatchAddressPrefixOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyImportRulesMatchAddressPrefix | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._exact !== undefined) {
      hasAnyValues = true;
      internalValueResult.exact = this._exact;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyImportRulesMatchAddressPrefix | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._exact = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._exact = value.exact;
      this._name = value.name;
    }
  }

  // exact - computed: false, optional: true, required: false
  private _exact?: boolean | cdktf.IResolvable; 
  public get exact() {
    return this.getBooleanAttribute('exact');
  }
  public set exact(value: boolean | cdktf.IResolvable) {
    this._exact = value;
  }
  public resetExact() {
    this._exact = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exactInput() {
    return this._exact;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class VirtualRouterProtocolBgpPolicyImportRulesMatchAddressPrefixList extends cdktf.ComplexList {
  public internalValue? : VirtualRouterProtocolBgpPolicyImportRulesMatchAddressPrefix[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): VirtualRouterProtocolBgpPolicyImportRulesMatchAddressPrefixOutputReference {
    return new VirtualRouterProtocolBgpPolicyImportRulesMatchAddressPrefixOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface VirtualRouterProtocolBgpPolicyImportRulesMatchAsPath {
  /**
  * AS-path regular expression
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#regex VirtualRouter#regex}
  */
  readonly regex?: string;
}

export function virtualRouterProtocolBgpPolicyImportRulesMatchAsPathToTerraform(struct?: VirtualRouterProtocolBgpPolicyImportRulesMatchAsPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function virtualRouterProtocolBgpPolicyImportRulesMatchAsPathToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyImportRulesMatchAsPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyImportRulesMatchAsPathOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyImportRulesMatchAsPath | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyImportRulesMatchAsPath | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._regex = value.regex;
    }
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface VirtualRouterProtocolBgpPolicyImportRulesMatchCommunity {
  /**
  * AS-path regular expression
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#regex VirtualRouter#regex}
  */
  readonly regex?: string;
}

export function virtualRouterProtocolBgpPolicyImportRulesMatchCommunityToTerraform(struct?: VirtualRouterProtocolBgpPolicyImportRulesMatchCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function virtualRouterProtocolBgpPolicyImportRulesMatchCommunityToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyImportRulesMatchCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyImportRulesMatchCommunityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyImportRulesMatchCommunity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyImportRulesMatchCommunity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._regex = value.regex;
    }
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface VirtualRouterProtocolBgpPolicyImportRulesMatchExtendedCommunity {
  /**
  * AS-path regular expression
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#regex VirtualRouter#regex}
  */
  readonly regex?: string;
}

export function virtualRouterProtocolBgpPolicyImportRulesMatchExtendedCommunityToTerraform(struct?: VirtualRouterProtocolBgpPolicyImportRulesMatchExtendedCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function virtualRouterProtocolBgpPolicyImportRulesMatchExtendedCommunityToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyImportRulesMatchExtendedCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyImportRulesMatchExtendedCommunityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyImportRulesMatchExtendedCommunity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyImportRulesMatchExtendedCommunity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._regex = value.regex;
    }
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface VirtualRouterProtocolBgpPolicyImportRulesMatch {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#address_prefix VirtualRouter#address_prefix}
  */
  readonly addressPrefix?: VirtualRouterProtocolBgpPolicyImportRulesMatchAddressPrefix[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#as_path VirtualRouter#as_path}
  */
  readonly asPath?: VirtualRouterProtocolBgpPolicyImportRulesMatchAsPath;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#community VirtualRouter#community}
  */
  readonly community?: VirtualRouterProtocolBgpPolicyImportRulesMatchCommunity;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#extended_community VirtualRouter#extended_community}
  */
  readonly extendedCommunity?: VirtualRouterProtocolBgpPolicyImportRulesMatchExtendedCommunity;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#from_peer VirtualRouter#from_peer}
  */
  readonly fromPeer?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#med VirtualRouter#med}
  */
  readonly med?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#nexthop VirtualRouter#nexthop}
  */
  readonly nexthop?: string[];
  /**
  * route table to match rule
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#route_table VirtualRouter#route_table}
  */
  readonly routeTable?: string;
}

export function virtualRouterProtocolBgpPolicyImportRulesMatchToTerraform(struct?: VirtualRouterProtocolBgpPolicyImportRulesMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address_prefix: cdktf.listMapper(virtualRouterProtocolBgpPolicyImportRulesMatchAddressPrefixToTerraform, false)(struct!.addressPrefix),
    as_path: virtualRouterProtocolBgpPolicyImportRulesMatchAsPathToTerraform(struct!.asPath),
    community: virtualRouterProtocolBgpPolicyImportRulesMatchCommunityToTerraform(struct!.community),
    extended_community: virtualRouterProtocolBgpPolicyImportRulesMatchExtendedCommunityToTerraform(struct!.extendedCommunity),
    from_peer: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.fromPeer),
    med: cdktf.numberToTerraform(struct!.med),
    nexthop: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.nexthop),
    route_table: cdktf.stringToTerraform(struct!.routeTable),
  }
}


export function virtualRouterProtocolBgpPolicyImportRulesMatchToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyImportRulesMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address_prefix: {
      value: cdktf.listMapperHcl(virtualRouterProtocolBgpPolicyImportRulesMatchAddressPrefixToHclTerraform, false)(struct!.addressPrefix),
      isBlock: true,
      type: "list",
      storageClassType: "VirtualRouterProtocolBgpPolicyImportRulesMatchAddressPrefixList",
    },
    as_path: {
      value: virtualRouterProtocolBgpPolicyImportRulesMatchAsPathToHclTerraform(struct!.asPath),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyImportRulesMatchAsPath",
    },
    community: {
      value: virtualRouterProtocolBgpPolicyImportRulesMatchCommunityToHclTerraform(struct!.community),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyImportRulesMatchCommunity",
    },
    extended_community: {
      value: virtualRouterProtocolBgpPolicyImportRulesMatchExtendedCommunityToHclTerraform(struct!.extendedCommunity),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyImportRulesMatchExtendedCommunity",
    },
    from_peer: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.fromPeer),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    med: {
      value: cdktf.numberToHclTerraform(struct!.med),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    nexthop: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.nexthop),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    route_table: {
      value: cdktf.stringToHclTerraform(struct!.routeTable),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyImportRulesMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyImportRulesMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addressPrefix?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.addressPrefix = this._addressPrefix?.internalValue;
    }
    if (this._asPath?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.asPath = this._asPath?.internalValue;
    }
    if (this._community?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.community = this._community?.internalValue;
    }
    if (this._extendedCommunity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extendedCommunity = this._extendedCommunity?.internalValue;
    }
    if (this._fromPeer !== undefined) {
      hasAnyValues = true;
      internalValueResult.fromPeer = this._fromPeer;
    }
    if (this._med !== undefined) {
      hasAnyValues = true;
      internalValueResult.med = this._med;
    }
    if (this._nexthop !== undefined) {
      hasAnyValues = true;
      internalValueResult.nexthop = this._nexthop;
    }
    if (this._routeTable !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeTable = this._routeTable;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyImportRulesMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addressPrefix.internalValue = undefined;
      this._asPath.internalValue = undefined;
      this._community.internalValue = undefined;
      this._extendedCommunity.internalValue = undefined;
      this._fromPeer = undefined;
      this._med = undefined;
      this._nexthop = undefined;
      this._routeTable = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addressPrefix.internalValue = value.addressPrefix;
      this._asPath.internalValue = value.asPath;
      this._community.internalValue = value.community;
      this._extendedCommunity.internalValue = value.extendedCommunity;
      this._fromPeer = value.fromPeer;
      this._med = value.med;
      this._nexthop = value.nexthop;
      this._routeTable = value.routeTable;
    }
  }

  // address_prefix - computed: false, optional: true, required: false
  private _addressPrefix = new VirtualRouterProtocolBgpPolicyImportRulesMatchAddressPrefixList(this, "address_prefix", false);
  public get addressPrefix() {
    return this._addressPrefix;
  }
  public putAddressPrefix(value: VirtualRouterProtocolBgpPolicyImportRulesMatchAddressPrefix[] | cdktf.IResolvable) {
    this._addressPrefix.internalValue = value;
  }
  public resetAddressPrefix() {
    this._addressPrefix.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressPrefixInput() {
    return this._addressPrefix.internalValue;
  }

  // as_path - computed: false, optional: true, required: false
  private _asPath = new VirtualRouterProtocolBgpPolicyImportRulesMatchAsPathOutputReference(this, "as_path");
  public get asPath() {
    return this._asPath;
  }
  public putAsPath(value: VirtualRouterProtocolBgpPolicyImportRulesMatchAsPath) {
    this._asPath.internalValue = value;
  }
  public resetAsPath() {
    this._asPath.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asPathInput() {
    return this._asPath.internalValue;
  }

  // community - computed: false, optional: true, required: false
  private _community = new VirtualRouterProtocolBgpPolicyImportRulesMatchCommunityOutputReference(this, "community");
  public get community() {
    return this._community;
  }
  public putCommunity(value: VirtualRouterProtocolBgpPolicyImportRulesMatchCommunity) {
    this._community.internalValue = value;
  }
  public resetCommunity() {
    this._community.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get communityInput() {
    return this._community.internalValue;
  }

  // extended_community - computed: false, optional: true, required: false
  private _extendedCommunity = new VirtualRouterProtocolBgpPolicyImportRulesMatchExtendedCommunityOutputReference(this, "extended_community");
  public get extendedCommunity() {
    return this._extendedCommunity;
  }
  public putExtendedCommunity(value: VirtualRouterProtocolBgpPolicyImportRulesMatchExtendedCommunity) {
    this._extendedCommunity.internalValue = value;
  }
  public resetExtendedCommunity() {
    this._extendedCommunity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extendedCommunityInput() {
    return this._extendedCommunity.internalValue;
  }

  // from_peer - computed: false, optional: true, required: false
  private _fromPeer?: string[]; 
  public get fromPeer() {
    return this.getListAttribute('from_peer');
  }
  public set fromPeer(value: string[]) {
    this._fromPeer = value;
  }
  public resetFromPeer() {
    this._fromPeer = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fromPeerInput() {
    return this._fromPeer;
  }

  // med - computed: false, optional: true, required: false
  private _med?: number; 
  public get med() {
    return this.getNumberAttribute('med');
  }
  public set med(value: number) {
    this._med = value;
  }
  public resetMed() {
    this._med = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get medInput() {
    return this._med;
  }

  // nexthop - computed: false, optional: true, required: false
  private _nexthop?: string[]; 
  public get nexthop() {
    return this.getListAttribute('nexthop');
  }
  public set nexthop(value: string[]) {
    this._nexthop = value;
  }
  public resetNexthop() {
    this._nexthop = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nexthopInput() {
    return this._nexthop;
  }

  // route_table - computed: true, optional: true, required: false
  private _routeTable?: string; 
  public get routeTable() {
    return this.getStringAttribute('route_table');
  }
  public set routeTable(value: string) {
    this._routeTable = value;
  }
  public resetRouteTable() {
    this._routeTable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeTableInput() {
    return this._routeTable;
  }
}
export interface VirtualRouterProtocolBgpPolicyImportRules {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#action VirtualRouter#action}
  */
  readonly action?: VirtualRouterProtocolBgpPolicyImportRulesAction;
  /**
  * Enable
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#enable VirtualRouter#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#match VirtualRouter#match}
  */
  readonly match?: VirtualRouterProtocolBgpPolicyImportRulesMatch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#name VirtualRouter#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#used_by VirtualRouter#used_by}
  */
  readonly usedBy?: string[];
}

export function virtualRouterProtocolBgpPolicyImportRulesToTerraform(struct?: VirtualRouterProtocolBgpPolicyImportRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: virtualRouterProtocolBgpPolicyImportRulesActionToTerraform(struct!.action),
    enable: cdktf.booleanToTerraform(struct!.enable),
    match: virtualRouterProtocolBgpPolicyImportRulesMatchToTerraform(struct!.match),
    name: cdktf.stringToTerraform(struct!.name),
    used_by: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.usedBy),
  }
}


export function virtualRouterProtocolBgpPolicyImportRulesToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyImportRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: virtualRouterProtocolBgpPolicyImportRulesActionToHclTerraform(struct!.action),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyImportRulesAction",
    },
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    match: {
      value: virtualRouterProtocolBgpPolicyImportRulesMatchToHclTerraform(struct!.match),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyImportRulesMatch",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    used_by: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.usedBy),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyImportRulesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyImportRules | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action?.internalValue;
    }
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._match?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._usedBy !== undefined) {
      hasAnyValues = true;
      internalValueResult.usedBy = this._usedBy;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyImportRules | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action.internalValue = undefined;
      this._enable = undefined;
      this._match.internalValue = undefined;
      this._name = undefined;
      this._usedBy = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action.internalValue = value.action;
      this._enable = value.enable;
      this._match.internalValue = value.match;
      this._name = value.name;
      this._usedBy = value.usedBy;
    }
  }

  // action - computed: false, optional: true, required: false
  private _action = new VirtualRouterProtocolBgpPolicyImportRulesActionOutputReference(this, "action");
  public get action() {
    return this._action;
  }
  public putAction(value: VirtualRouterProtocolBgpPolicyImportRulesAction) {
    this._action.internalValue = value;
  }
  public resetAction() {
    this._action.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action.internalValue;
  }

  // enable - computed: false, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // match - computed: false, optional: true, required: false
  private _match = new VirtualRouterProtocolBgpPolicyImportRulesMatchOutputReference(this, "match");
  public get match() {
    return this._match;
  }
  public putMatch(value: VirtualRouterProtocolBgpPolicyImportRulesMatch) {
    this._match.internalValue = value;
  }
  public resetMatch() {
    this._match.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match.internalValue;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // used_by - computed: false, optional: true, required: false
  private _usedBy?: string[]; 
  public get usedBy() {
    return this.getListAttribute('used_by');
  }
  public set usedBy(value: string[]) {
    this._usedBy = value;
  }
  public resetUsedBy() {
    this._usedBy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usedByInput() {
    return this._usedBy;
  }
}

export class VirtualRouterProtocolBgpPolicyImportRulesList extends cdktf.ComplexList {
  public internalValue? : VirtualRouterProtocolBgpPolicyImportRules[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): VirtualRouterProtocolBgpPolicyImportRulesOutputReference {
    return new VirtualRouterProtocolBgpPolicyImportRulesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface VirtualRouterProtocolBgpPolicyImport {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#rules VirtualRouter#rules}
  */
  readonly rules?: VirtualRouterProtocolBgpPolicyImportRules[] | cdktf.IResolvable;
}

export function virtualRouterProtocolBgpPolicyImportToTerraform(struct?: VirtualRouterProtocolBgpPolicyImport | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    rules: cdktf.listMapper(virtualRouterProtocolBgpPolicyImportRulesToTerraform, false)(struct!.rules),
  }
}


export function virtualRouterProtocolBgpPolicyImportToHclTerraform(struct?: VirtualRouterProtocolBgpPolicyImport | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    rules: {
      value: cdktf.listMapperHcl(virtualRouterProtocolBgpPolicyImportRulesToHclTerraform, false)(struct!.rules),
      isBlock: true,
      type: "list",
      storageClassType: "VirtualRouterProtocolBgpPolicyImportRulesList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyImportOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicyImport | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._rules?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rules = this._rules?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicyImport | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._rules.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._rules.internalValue = value.rules;
    }
  }

  // rules - computed: false, optional: true, required: false
  private _rules = new VirtualRouterProtocolBgpPolicyImportRulesList(this, "rules", false);
  public get rules() {
    return this._rules;
  }
  public putRules(value: VirtualRouterProtocolBgpPolicyImportRules[] | cdktf.IResolvable) {
    this._rules.internalValue = value;
  }
  public resetRules() {
    this._rules.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rulesInput() {
    return this._rules.internalValue;
  }
}
export interface VirtualRouterProtocolBgpPolicy {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#aggregation VirtualRouter#aggregation}
  */
  readonly aggregation?: VirtualRouterProtocolBgpPolicyAggregation;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#conditional_advertisement VirtualRouter#conditional_advertisement}
  */
  readonly conditionalAdvertisement?: VirtualRouterProtocolBgpPolicyConditionalAdvertisement;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#export VirtualRouter#export}
  */
  readonly export?: VirtualRouterProtocolBgpPolicyExport;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#import VirtualRouter#import}
  */
  readonly import?: VirtualRouterProtocolBgpPolicyImport;
}

export function virtualRouterProtocolBgpPolicyToTerraform(struct?: VirtualRouterProtocolBgpPolicy | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    aggregation: virtualRouterProtocolBgpPolicyAggregationToTerraform(struct!.aggregation),
    conditional_advertisement: virtualRouterProtocolBgpPolicyConditionalAdvertisementToTerraform(struct!.conditionalAdvertisement),
    export: virtualRouterProtocolBgpPolicyExportToTerraform(struct!.export),
    import: virtualRouterProtocolBgpPolicyImportToTerraform(struct!.import),
  }
}


export function virtualRouterProtocolBgpPolicyToHclTerraform(struct?: VirtualRouterProtocolBgpPolicy | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    aggregation: {
      value: virtualRouterProtocolBgpPolicyAggregationToHclTerraform(struct!.aggregation),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyAggregation",
    },
    conditional_advertisement: {
      value: virtualRouterProtocolBgpPolicyConditionalAdvertisementToHclTerraform(struct!.conditionalAdvertisement),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyConditionalAdvertisement",
    },
    export: {
      value: virtualRouterProtocolBgpPolicyExportToHclTerraform(struct!.export),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyExport",
    },
    import: {
      value: virtualRouterProtocolBgpPolicyImportToHclTerraform(struct!.import),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicyImport",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpPolicyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpPolicy | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._aggregation?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.aggregation = this._aggregation?.internalValue;
    }
    if (this._conditionalAdvertisement?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.conditionalAdvertisement = this._conditionalAdvertisement?.internalValue;
    }
    if (this._export?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.export = this._export?.internalValue;
    }
    if (this._import?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.import = this._import?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpPolicy | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._aggregation.internalValue = undefined;
      this._conditionalAdvertisement.internalValue = undefined;
      this._export.internalValue = undefined;
      this._import.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._aggregation.internalValue = value.aggregation;
      this._conditionalAdvertisement.internalValue = value.conditionalAdvertisement;
      this._export.internalValue = value.export;
      this._import.internalValue = value.import;
    }
  }

  // aggregation - computed: false, optional: true, required: false
  private _aggregation = new VirtualRouterProtocolBgpPolicyAggregationOutputReference(this, "aggregation");
  public get aggregation() {
    return this._aggregation;
  }
  public putAggregation(value: VirtualRouterProtocolBgpPolicyAggregation) {
    this._aggregation.internalValue = value;
  }
  public resetAggregation() {
    this._aggregation.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aggregationInput() {
    return this._aggregation.internalValue;
  }

  // conditional_advertisement - computed: false, optional: true, required: false
  private _conditionalAdvertisement = new VirtualRouterProtocolBgpPolicyConditionalAdvertisementOutputReference(this, "conditional_advertisement");
  public get conditionalAdvertisement() {
    return this._conditionalAdvertisement;
  }
  public putConditionalAdvertisement(value: VirtualRouterProtocolBgpPolicyConditionalAdvertisement) {
    this._conditionalAdvertisement.internalValue = value;
  }
  public resetConditionalAdvertisement() {
    this._conditionalAdvertisement.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get conditionalAdvertisementInput() {
    return this._conditionalAdvertisement.internalValue;
  }

  // export - computed: false, optional: true, required: false
  private _export = new VirtualRouterProtocolBgpPolicyExportOutputReference(this, "export");
  public get export() {
    return this._export;
  }
  public putExport(value: VirtualRouterProtocolBgpPolicyExport) {
    this._export.internalValue = value;
  }
  public resetExport() {
    this._export.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exportInput() {
    return this._export.internalValue;
  }

  // import - computed: false, optional: true, required: false
  private _import = new VirtualRouterProtocolBgpPolicyImportOutputReference(this, "import");
  public get import() {
    return this._import;
  }
  public putImport(value: VirtualRouterProtocolBgpPolicyImport) {
    this._import.internalValue = value;
  }
  public resetImport() {
    this._import.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get importInput() {
    return this._import.internalValue;
  }
}
export interface VirtualRouterProtocolBgpRedistRules {
  /**
  * select redistribution profile type
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#address_family_identifier VirtualRouter#address_family_identifier}
  */
  readonly addressFamilyIdentifier?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#enable VirtualRouter#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * metric value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#metric VirtualRouter#metric}
  */
  readonly metric?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#name VirtualRouter#name}
  */
  readonly name: string;
  /**
  * select destination SAFI for redistribution
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#route_table VirtualRouter#route_table}
  */
  readonly routeTable?: string;
  /**
  * add the AS_PATHLIMIT path attribute
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#set_as_path_limit VirtualRouter#set_as_path_limit}
  */
  readonly setAsPathLimit?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#set_community VirtualRouter#set_community}
  */
  readonly setCommunity?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#set_extended_community VirtualRouter#set_extended_community}
  */
  readonly setExtendedCommunity?: string[];
  /**
  * add the LOCAL_PREF path attribute
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#set_local_preference VirtualRouter#set_local_preference}
  */
  readonly setLocalPreference?: number;
  /**
  * add the MULTI_EXIT_DISC path attribute
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#set_med VirtualRouter#set_med}
  */
  readonly setMed?: number;
  /**
  * add the ORIGIN path attribute
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#set_origin VirtualRouter#set_origin}
  */
  readonly setOrigin?: string;
}

export function virtualRouterProtocolBgpRedistRulesToTerraform(struct?: VirtualRouterProtocolBgpRedistRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address_family_identifier: cdktf.stringToTerraform(struct!.addressFamilyIdentifier),
    enable: cdktf.booleanToTerraform(struct!.enable),
    metric: cdktf.numberToTerraform(struct!.metric),
    name: cdktf.stringToTerraform(struct!.name),
    route_table: cdktf.stringToTerraform(struct!.routeTable),
    set_as_path_limit: cdktf.numberToTerraform(struct!.setAsPathLimit),
    set_community: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.setCommunity),
    set_extended_community: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.setExtendedCommunity),
    set_local_preference: cdktf.numberToTerraform(struct!.setLocalPreference),
    set_med: cdktf.numberToTerraform(struct!.setMed),
    set_origin: cdktf.stringToTerraform(struct!.setOrigin),
  }
}


export function virtualRouterProtocolBgpRedistRulesToHclTerraform(struct?: VirtualRouterProtocolBgpRedistRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address_family_identifier: {
      value: cdktf.stringToHclTerraform(struct!.addressFamilyIdentifier),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    metric: {
      value: cdktf.numberToHclTerraform(struct!.metric),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    route_table: {
      value: cdktf.stringToHclTerraform(struct!.routeTable),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    set_as_path_limit: {
      value: cdktf.numberToHclTerraform(struct!.setAsPathLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    set_community: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.setCommunity),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    set_extended_community: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.setExtendedCommunity),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    set_local_preference: {
      value: cdktf.numberToHclTerraform(struct!.setLocalPreference),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    set_med: {
      value: cdktf.numberToHclTerraform(struct!.setMed),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    set_origin: {
      value: cdktf.stringToHclTerraform(struct!.setOrigin),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpRedistRulesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): VirtualRouterProtocolBgpRedistRules | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addressFamilyIdentifier !== undefined) {
      hasAnyValues = true;
      internalValueResult.addressFamilyIdentifier = this._addressFamilyIdentifier;
    }
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._metric !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._routeTable !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeTable = this._routeTable;
    }
    if (this._setAsPathLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.setAsPathLimit = this._setAsPathLimit;
    }
    if (this._setCommunity !== undefined) {
      hasAnyValues = true;
      internalValueResult.setCommunity = this._setCommunity;
    }
    if (this._setExtendedCommunity !== undefined) {
      hasAnyValues = true;
      internalValueResult.setExtendedCommunity = this._setExtendedCommunity;
    }
    if (this._setLocalPreference !== undefined) {
      hasAnyValues = true;
      internalValueResult.setLocalPreference = this._setLocalPreference;
    }
    if (this._setMed !== undefined) {
      hasAnyValues = true;
      internalValueResult.setMed = this._setMed;
    }
    if (this._setOrigin !== undefined) {
      hasAnyValues = true;
      internalValueResult.setOrigin = this._setOrigin;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpRedistRules | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addressFamilyIdentifier = undefined;
      this._enable = undefined;
      this._metric = undefined;
      this._name = undefined;
      this._routeTable = undefined;
      this._setAsPathLimit = undefined;
      this._setCommunity = undefined;
      this._setExtendedCommunity = undefined;
      this._setLocalPreference = undefined;
      this._setMed = undefined;
      this._setOrigin = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addressFamilyIdentifier = value.addressFamilyIdentifier;
      this._enable = value.enable;
      this._metric = value.metric;
      this._name = value.name;
      this._routeTable = value.routeTable;
      this._setAsPathLimit = value.setAsPathLimit;
      this._setCommunity = value.setCommunity;
      this._setExtendedCommunity = value.setExtendedCommunity;
      this._setLocalPreference = value.setLocalPreference;
      this._setMed = value.setMed;
      this._setOrigin = value.setOrigin;
    }
  }

  // address_family_identifier - computed: true, optional: true, required: false
  private _addressFamilyIdentifier?: string; 
  public get addressFamilyIdentifier() {
    return this.getStringAttribute('address_family_identifier');
  }
  public set addressFamilyIdentifier(value: string) {
    this._addressFamilyIdentifier = value;
  }
  public resetAddressFamilyIdentifier() {
    this._addressFamilyIdentifier = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressFamilyIdentifierInput() {
    return this._addressFamilyIdentifier;
  }

  // enable - computed: false, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // metric - computed: false, optional: true, required: false
  private _metric?: number; 
  public get metric() {
    return this.getNumberAttribute('metric');
  }
  public set metric(value: number) {
    this._metric = value;
  }
  public resetMetric() {
    this._metric = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // route_table - computed: true, optional: true, required: false
  private _routeTable?: string; 
  public get routeTable() {
    return this.getStringAttribute('route_table');
  }
  public set routeTable(value: string) {
    this._routeTable = value;
  }
  public resetRouteTable() {
    this._routeTable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeTableInput() {
    return this._routeTable;
  }

  // set_as_path_limit - computed: false, optional: true, required: false
  private _setAsPathLimit?: number; 
  public get setAsPathLimit() {
    return this.getNumberAttribute('set_as_path_limit');
  }
  public set setAsPathLimit(value: number) {
    this._setAsPathLimit = value;
  }
  public resetSetAsPathLimit() {
    this._setAsPathLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setAsPathLimitInput() {
    return this._setAsPathLimit;
  }

  // set_community - computed: false, optional: true, required: false
  private _setCommunity?: string[]; 
  public get setCommunity() {
    return this.getListAttribute('set_community');
  }
  public set setCommunity(value: string[]) {
    this._setCommunity = value;
  }
  public resetSetCommunity() {
    this._setCommunity = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setCommunityInput() {
    return this._setCommunity;
  }

  // set_extended_community - computed: false, optional: true, required: false
  private _setExtendedCommunity?: string[]; 
  public get setExtendedCommunity() {
    return this.getListAttribute('set_extended_community');
  }
  public set setExtendedCommunity(value: string[]) {
    this._setExtendedCommunity = value;
  }
  public resetSetExtendedCommunity() {
    this._setExtendedCommunity = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setExtendedCommunityInput() {
    return this._setExtendedCommunity;
  }

  // set_local_preference - computed: false, optional: true, required: false
  private _setLocalPreference?: number; 
  public get setLocalPreference() {
    return this.getNumberAttribute('set_local_preference');
  }
  public set setLocalPreference(value: number) {
    this._setLocalPreference = value;
  }
  public resetSetLocalPreference() {
    this._setLocalPreference = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setLocalPreferenceInput() {
    return this._setLocalPreference;
  }

  // set_med - computed: false, optional: true, required: false
  private _setMed?: number; 
  public get setMed() {
    return this.getNumberAttribute('set_med');
  }
  public set setMed(value: number) {
    this._setMed = value;
  }
  public resetSetMed() {
    this._setMed = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setMedInput() {
    return this._setMed;
  }

  // set_origin - computed: true, optional: true, required: false
  private _setOrigin?: string; 
  public get setOrigin() {
    return this.getStringAttribute('set_origin');
  }
  public set setOrigin(value: string) {
    this._setOrigin = value;
  }
  public resetSetOrigin() {
    this._setOrigin = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setOriginInput() {
    return this._setOrigin;
  }
}

export class VirtualRouterProtocolBgpRedistRulesList extends cdktf.ComplexList {
  public internalValue? : VirtualRouterProtocolBgpRedistRules[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): VirtualRouterProtocolBgpRedistRulesOutputReference {
    return new VirtualRouterProtocolBgpRedistRulesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface VirtualRouterProtocolBgpRoutingOptionsAggregate {
  /**
  * aggregate route only if they have same MED attributes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#aggregate_med VirtualRouter#aggregate_med}
  */
  readonly aggregateMed?: boolean | cdktf.IResolvable;
}

export function virtualRouterProtocolBgpRoutingOptionsAggregateToTerraform(struct?: VirtualRouterProtocolBgpRoutingOptionsAggregate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    aggregate_med: cdktf.booleanToTerraform(struct!.aggregateMed),
  }
}


export function virtualRouterProtocolBgpRoutingOptionsAggregateToHclTerraform(struct?: VirtualRouterProtocolBgpRoutingOptionsAggregate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    aggregate_med: {
      value: cdktf.booleanToHclTerraform(struct!.aggregateMed),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpRoutingOptionsAggregateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpRoutingOptionsAggregate | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._aggregateMed !== undefined) {
      hasAnyValues = true;
      internalValueResult.aggregateMed = this._aggregateMed;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpRoutingOptionsAggregate | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._aggregateMed = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._aggregateMed = value.aggregateMed;
    }
  }

  // aggregate_med - computed: false, optional: true, required: false
  private _aggregateMed?: boolean | cdktf.IResolvable; 
  public get aggregateMed() {
    return this.getBooleanAttribute('aggregate_med');
  }
  public set aggregateMed(value: boolean | cdktf.IResolvable) {
    this._aggregateMed = value;
  }
  public resetAggregateMed() {
    this._aggregateMed = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aggregateMedInput() {
    return this._aggregateMed;
  }
}
export interface VirtualRouterProtocolBgpRoutingOptionsGracefulRestart {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#enable VirtualRouter#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * local restart time to advertise to peer (in seconds)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#local_restart_time VirtualRouter#local_restart_time}
  */
  readonly localRestartTime?: number;
  /**
  * maximum of peer restart time accepted (in seconds)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#max_peer_restart_time VirtualRouter#max_peer_restart_time}
  */
  readonly maxPeerRestartTime?: number;
  /**
  * time to remove stale routes after peer restart (in seconds)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#stale_route_time VirtualRouter#stale_route_time}
  */
  readonly staleRouteTime?: number;
}

export function virtualRouterProtocolBgpRoutingOptionsGracefulRestartToTerraform(struct?: VirtualRouterProtocolBgpRoutingOptionsGracefulRestart | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enable: cdktf.booleanToTerraform(struct!.enable),
    local_restart_time: cdktf.numberToTerraform(struct!.localRestartTime),
    max_peer_restart_time: cdktf.numberToTerraform(struct!.maxPeerRestartTime),
    stale_route_time: cdktf.numberToTerraform(struct!.staleRouteTime),
  }
}


export function virtualRouterProtocolBgpRoutingOptionsGracefulRestartToHclTerraform(struct?: VirtualRouterProtocolBgpRoutingOptionsGracefulRestart | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    local_restart_time: {
      value: cdktf.numberToHclTerraform(struct!.localRestartTime),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_peer_restart_time: {
      value: cdktf.numberToHclTerraform(struct!.maxPeerRestartTime),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    stale_route_time: {
      value: cdktf.numberToHclTerraform(struct!.staleRouteTime),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpRoutingOptionsGracefulRestartOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpRoutingOptionsGracefulRestart | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._localRestartTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.localRestartTime = this._localRestartTime;
    }
    if (this._maxPeerRestartTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPeerRestartTime = this._maxPeerRestartTime;
    }
    if (this._staleRouteTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.staleRouteTime = this._staleRouteTime;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpRoutingOptionsGracefulRestart | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enable = undefined;
      this._localRestartTime = undefined;
      this._maxPeerRestartTime = undefined;
      this._staleRouteTime = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enable = value.enable;
      this._localRestartTime = value.localRestartTime;
      this._maxPeerRestartTime = value.maxPeerRestartTime;
      this._staleRouteTime = value.staleRouteTime;
    }
  }

  // enable - computed: false, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // local_restart_time - computed: true, optional: true, required: false
  private _localRestartTime?: number; 
  public get localRestartTime() {
    return this.getNumberAttribute('local_restart_time');
  }
  public set localRestartTime(value: number) {
    this._localRestartTime = value;
  }
  public resetLocalRestartTime() {
    this._localRestartTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localRestartTimeInput() {
    return this._localRestartTime;
  }

  // max_peer_restart_time - computed: true, optional: true, required: false
  private _maxPeerRestartTime?: number; 
  public get maxPeerRestartTime() {
    return this.getNumberAttribute('max_peer_restart_time');
  }
  public set maxPeerRestartTime(value: number) {
    this._maxPeerRestartTime = value;
  }
  public resetMaxPeerRestartTime() {
    this._maxPeerRestartTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPeerRestartTimeInput() {
    return this._maxPeerRestartTime;
  }

  // stale_route_time - computed: true, optional: true, required: false
  private _staleRouteTime?: number; 
  public get staleRouteTime() {
    return this.getNumberAttribute('stale_route_time');
  }
  public set staleRouteTime(value: number) {
    this._staleRouteTime = value;
  }
  public resetStaleRouteTime() {
    this._staleRouteTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get staleRouteTimeInput() {
    return this._staleRouteTime;
  }
}
export interface VirtualRouterProtocolBgpRoutingOptionsMed {
  /**
  * always compare MEDs
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#always_compare_med VirtualRouter#always_compare_med}
  */
  readonly alwaysCompareMed?: boolean | cdktf.IResolvable;
  /**
  * deterministic MEDs comparison
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#deterministic_med_comparison VirtualRouter#deterministic_med_comparison}
  */
  readonly deterministicMedComparison?: boolean | cdktf.IResolvable;
}

export function virtualRouterProtocolBgpRoutingOptionsMedToTerraform(struct?: VirtualRouterProtocolBgpRoutingOptionsMed | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    always_compare_med: cdktf.booleanToTerraform(struct!.alwaysCompareMed),
    deterministic_med_comparison: cdktf.booleanToTerraform(struct!.deterministicMedComparison),
  }
}


export function virtualRouterProtocolBgpRoutingOptionsMedToHclTerraform(struct?: VirtualRouterProtocolBgpRoutingOptionsMed | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    always_compare_med: {
      value: cdktf.booleanToHclTerraform(struct!.alwaysCompareMed),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    deterministic_med_comparison: {
      value: cdktf.booleanToHclTerraform(struct!.deterministicMedComparison),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpRoutingOptionsMedOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpRoutingOptionsMed | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._alwaysCompareMed !== undefined) {
      hasAnyValues = true;
      internalValueResult.alwaysCompareMed = this._alwaysCompareMed;
    }
    if (this._deterministicMedComparison !== undefined) {
      hasAnyValues = true;
      internalValueResult.deterministicMedComparison = this._deterministicMedComparison;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpRoutingOptionsMed | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._alwaysCompareMed = undefined;
      this._deterministicMedComparison = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._alwaysCompareMed = value.alwaysCompareMed;
      this._deterministicMedComparison = value.deterministicMedComparison;
    }
  }

  // always_compare_med - computed: false, optional: true, required: false
  private _alwaysCompareMed?: boolean | cdktf.IResolvable; 
  public get alwaysCompareMed() {
    return this.getBooleanAttribute('always_compare_med');
  }
  public set alwaysCompareMed(value: boolean | cdktf.IResolvable) {
    this._alwaysCompareMed = value;
  }
  public resetAlwaysCompareMed() {
    this._alwaysCompareMed = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get alwaysCompareMedInput() {
    return this._alwaysCompareMed;
  }

  // deterministic_med_comparison - computed: false, optional: true, required: false
  private _deterministicMedComparison?: boolean | cdktf.IResolvable; 
  public get deterministicMedComparison() {
    return this.getBooleanAttribute('deterministic_med_comparison');
  }
  public set deterministicMedComparison(value: boolean | cdktf.IResolvable) {
    this._deterministicMedComparison = value;
  }
  public resetDeterministicMedComparison() {
    this._deterministicMedComparison = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deterministicMedComparisonInput() {
    return this._deterministicMedComparison;
  }
}
export interface VirtualRouterProtocolBgpRoutingOptions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#aggregate VirtualRouter#aggregate}
  */
  readonly aggregate?: VirtualRouterProtocolBgpRoutingOptionsAggregate;
  /**
  * AS format
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#as_format VirtualRouter#as_format}
  */
  readonly asFormat?: string;
  /**
  * confederation requires member-AS number
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#confederation_member_as VirtualRouter#confederation_member_as}
  */
  readonly confederationMemberAs?: string;
  /**
  * default local preference
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#default_local_preference VirtualRouter#default_local_preference}
  */
  readonly defaultLocalPreference?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#graceful_restart VirtualRouter#graceful_restart}
  */
  readonly gracefulRestart?: VirtualRouterProtocolBgpRoutingOptionsGracefulRestart;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#med VirtualRouter#med}
  */
  readonly med?: VirtualRouterProtocolBgpRoutingOptionsMed;
  /**
  * route reflector cluster ID
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#reflector_cluster_id VirtualRouter#reflector_cluster_id}
  */
  readonly reflectorClusterId?: string;
}

export function virtualRouterProtocolBgpRoutingOptionsToTerraform(struct?: VirtualRouterProtocolBgpRoutingOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    aggregate: virtualRouterProtocolBgpRoutingOptionsAggregateToTerraform(struct!.aggregate),
    as_format: cdktf.stringToTerraform(struct!.asFormat),
    confederation_member_as: cdktf.stringToTerraform(struct!.confederationMemberAs),
    default_local_preference: cdktf.numberToTerraform(struct!.defaultLocalPreference),
    graceful_restart: virtualRouterProtocolBgpRoutingOptionsGracefulRestartToTerraform(struct!.gracefulRestart),
    med: virtualRouterProtocolBgpRoutingOptionsMedToTerraform(struct!.med),
    reflector_cluster_id: cdktf.stringToTerraform(struct!.reflectorClusterId),
  }
}


export function virtualRouterProtocolBgpRoutingOptionsToHclTerraform(struct?: VirtualRouterProtocolBgpRoutingOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    aggregate: {
      value: virtualRouterProtocolBgpRoutingOptionsAggregateToHclTerraform(struct!.aggregate),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpRoutingOptionsAggregate",
    },
    as_format: {
      value: cdktf.stringToHclTerraform(struct!.asFormat),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    confederation_member_as: {
      value: cdktf.stringToHclTerraform(struct!.confederationMemberAs),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    default_local_preference: {
      value: cdktf.numberToHclTerraform(struct!.defaultLocalPreference),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    graceful_restart: {
      value: virtualRouterProtocolBgpRoutingOptionsGracefulRestartToHclTerraform(struct!.gracefulRestart),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpRoutingOptionsGracefulRestart",
    },
    med: {
      value: virtualRouterProtocolBgpRoutingOptionsMedToHclTerraform(struct!.med),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpRoutingOptionsMed",
    },
    reflector_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.reflectorClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpRoutingOptionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgpRoutingOptions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._aggregate?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.aggregate = this._aggregate?.internalValue;
    }
    if (this._asFormat !== undefined) {
      hasAnyValues = true;
      internalValueResult.asFormat = this._asFormat;
    }
    if (this._confederationMemberAs !== undefined) {
      hasAnyValues = true;
      internalValueResult.confederationMemberAs = this._confederationMemberAs;
    }
    if (this._defaultLocalPreference !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultLocalPreference = this._defaultLocalPreference;
    }
    if (this._gracefulRestart?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.gracefulRestart = this._gracefulRestart?.internalValue;
    }
    if (this._med?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.med = this._med?.internalValue;
    }
    if (this._reflectorClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.reflectorClusterId = this._reflectorClusterId;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgpRoutingOptions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._aggregate.internalValue = undefined;
      this._asFormat = undefined;
      this._confederationMemberAs = undefined;
      this._defaultLocalPreference = undefined;
      this._gracefulRestart.internalValue = undefined;
      this._med.internalValue = undefined;
      this._reflectorClusterId = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._aggregate.internalValue = value.aggregate;
      this._asFormat = value.asFormat;
      this._confederationMemberAs = value.confederationMemberAs;
      this._defaultLocalPreference = value.defaultLocalPreference;
      this._gracefulRestart.internalValue = value.gracefulRestart;
      this._med.internalValue = value.med;
      this._reflectorClusterId = value.reflectorClusterId;
    }
  }

  // aggregate - computed: false, optional: true, required: false
  private _aggregate = new VirtualRouterProtocolBgpRoutingOptionsAggregateOutputReference(this, "aggregate");
  public get aggregate() {
    return this._aggregate;
  }
  public putAggregate(value: VirtualRouterProtocolBgpRoutingOptionsAggregate) {
    this._aggregate.internalValue = value;
  }
  public resetAggregate() {
    this._aggregate.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aggregateInput() {
    return this._aggregate.internalValue;
  }

  // as_format - computed: true, optional: true, required: false
  private _asFormat?: string; 
  public get asFormat() {
    return this.getStringAttribute('as_format');
  }
  public set asFormat(value: string) {
    this._asFormat = value;
  }
  public resetAsFormat() {
    this._asFormat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asFormatInput() {
    return this._asFormat;
  }

  // confederation_member_as - computed: false, optional: true, required: false
  private _confederationMemberAs?: string; 
  public get confederationMemberAs() {
    return this.getStringAttribute('confederation_member_as');
  }
  public set confederationMemberAs(value: string) {
    this._confederationMemberAs = value;
  }
  public resetConfederationMemberAs() {
    this._confederationMemberAs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get confederationMemberAsInput() {
    return this._confederationMemberAs;
  }

  // default_local_preference - computed: true, optional: true, required: false
  private _defaultLocalPreference?: number; 
  public get defaultLocalPreference() {
    return this.getNumberAttribute('default_local_preference');
  }
  public set defaultLocalPreference(value: number) {
    this._defaultLocalPreference = value;
  }
  public resetDefaultLocalPreference() {
    this._defaultLocalPreference = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultLocalPreferenceInput() {
    return this._defaultLocalPreference;
  }

  // graceful_restart - computed: false, optional: true, required: false
  private _gracefulRestart = new VirtualRouterProtocolBgpRoutingOptionsGracefulRestartOutputReference(this, "graceful_restart");
  public get gracefulRestart() {
    return this._gracefulRestart;
  }
  public putGracefulRestart(value: VirtualRouterProtocolBgpRoutingOptionsGracefulRestart) {
    this._gracefulRestart.internalValue = value;
  }
  public resetGracefulRestart() {
    this._gracefulRestart.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gracefulRestartInput() {
    return this._gracefulRestart.internalValue;
  }

  // med - computed: false, optional: true, required: false
  private _med = new VirtualRouterProtocolBgpRoutingOptionsMedOutputReference(this, "med");
  public get med() {
    return this._med;
  }
  public putMed(value: VirtualRouterProtocolBgpRoutingOptionsMed) {
    this._med.internalValue = value;
  }
  public resetMed() {
    this._med.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get medInput() {
    return this._med.internalValue;
  }

  // reflector_cluster_id - computed: false, optional: true, required: false
  private _reflectorClusterId?: string; 
  public get reflectorClusterId() {
    return this.getStringAttribute('reflector_cluster_id');
  }
  public set reflectorClusterId(value: string) {
    this._reflectorClusterId = value;
  }
  public resetReflectorClusterId() {
    this._reflectorClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reflectorClusterIdInput() {
    return this._reflectorClusterId;
  }
}
export interface VirtualRouterProtocolBgp {
  /**
  * allow redistribute default route to BGP
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#allow_redist_default_route VirtualRouter#allow_redist_default_route}
  */
  readonly allowRedistDefaultRoute?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#auth_profile VirtualRouter#auth_profile}
  */
  readonly authProfile?: VirtualRouterProtocolBgpAuthProfile[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#dampening_profile VirtualRouter#dampening_profile}
  */
  readonly dampeningProfile?: VirtualRouterProtocolBgpDampeningProfile[] | cdktf.IResolvable;
  /**
  * Support multiple AS in ECMP
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#ecmp_multi_as VirtualRouter#ecmp_multi_as}
  */
  readonly ecmpMultiAs?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#enable VirtualRouter#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * Enforce First AS for EBGP
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#enforce_first_as VirtualRouter#enforce_first_as}
  */
  readonly enforceFirstAs?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#global_bfd VirtualRouter#global_bfd}
  */
  readonly globalBfd?: VirtualRouterProtocolBgpGlobalBfd;
  /**
  * Populate BGP learned route to global route table
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#install_route VirtualRouter#install_route}
  */
  readonly installRoute?: boolean | cdktf.IResolvable;
  /**
  * local AS number
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#local_as VirtualRouter#local_as}
  */
  readonly localAs?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#peer_group VirtualRouter#peer_group}
  */
  readonly peerGroup?: VirtualRouterProtocolBgpPeerGroup[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#policy VirtualRouter#policy}
  */
  readonly policy?: VirtualRouterProtocolBgpPolicy;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#redist_rules VirtualRouter#redist_rules}
  */
  readonly redistRules?: VirtualRouterProtocolBgpRedistRules[] | cdktf.IResolvable;
  /**
  * do not learn default route from BGP
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#reject_default_route VirtualRouter#reject_default_route}
  */
  readonly rejectDefaultRoute?: boolean | cdktf.IResolvable;
  /**
  * router id of this BGP instance
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#router_id VirtualRouter#router_id}
  */
  readonly routerId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#routing_options VirtualRouter#routing_options}
  */
  readonly routingOptions?: VirtualRouterProtocolBgpRoutingOptions;
}

export function virtualRouterProtocolBgpToTerraform(struct?: VirtualRouterProtocolBgp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_redist_default_route: cdktf.booleanToTerraform(struct!.allowRedistDefaultRoute),
    auth_profile: cdktf.listMapper(virtualRouterProtocolBgpAuthProfileToTerraform, false)(struct!.authProfile),
    dampening_profile: cdktf.listMapper(virtualRouterProtocolBgpDampeningProfileToTerraform, false)(struct!.dampeningProfile),
    ecmp_multi_as: cdktf.booleanToTerraform(struct!.ecmpMultiAs),
    enable: cdktf.booleanToTerraform(struct!.enable),
    enforce_first_as: cdktf.booleanToTerraform(struct!.enforceFirstAs),
    global_bfd: virtualRouterProtocolBgpGlobalBfdToTerraform(struct!.globalBfd),
    install_route: cdktf.booleanToTerraform(struct!.installRoute),
    local_as: cdktf.stringToTerraform(struct!.localAs),
    peer_group: cdktf.listMapper(virtualRouterProtocolBgpPeerGroupToTerraform, false)(struct!.peerGroup),
    policy: virtualRouterProtocolBgpPolicyToTerraform(struct!.policy),
    redist_rules: cdktf.listMapper(virtualRouterProtocolBgpRedistRulesToTerraform, false)(struct!.redistRules),
    reject_default_route: cdktf.booleanToTerraform(struct!.rejectDefaultRoute),
    router_id: cdktf.stringToTerraform(struct!.routerId),
    routing_options: virtualRouterProtocolBgpRoutingOptionsToTerraform(struct!.routingOptions),
  }
}


export function virtualRouterProtocolBgpToHclTerraform(struct?: VirtualRouterProtocolBgp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_redist_default_route: {
      value: cdktf.booleanToHclTerraform(struct!.allowRedistDefaultRoute),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    auth_profile: {
      value: cdktf.listMapperHcl(virtualRouterProtocolBgpAuthProfileToHclTerraform, false)(struct!.authProfile),
      isBlock: true,
      type: "list",
      storageClassType: "VirtualRouterProtocolBgpAuthProfileList",
    },
    dampening_profile: {
      value: cdktf.listMapperHcl(virtualRouterProtocolBgpDampeningProfileToHclTerraform, false)(struct!.dampeningProfile),
      isBlock: true,
      type: "list",
      storageClassType: "VirtualRouterProtocolBgpDampeningProfileList",
    },
    ecmp_multi_as: {
      value: cdktf.booleanToHclTerraform(struct!.ecmpMultiAs),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enforce_first_as: {
      value: cdktf.booleanToHclTerraform(struct!.enforceFirstAs),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    global_bfd: {
      value: virtualRouterProtocolBgpGlobalBfdToHclTerraform(struct!.globalBfd),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpGlobalBfd",
    },
    install_route: {
      value: cdktf.booleanToHclTerraform(struct!.installRoute),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    local_as: {
      value: cdktf.stringToHclTerraform(struct!.localAs),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    peer_group: {
      value: cdktf.listMapperHcl(virtualRouterProtocolBgpPeerGroupToHclTerraform, false)(struct!.peerGroup),
      isBlock: true,
      type: "list",
      storageClassType: "VirtualRouterProtocolBgpPeerGroupList",
    },
    policy: {
      value: virtualRouterProtocolBgpPolicyToHclTerraform(struct!.policy),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpPolicy",
    },
    redist_rules: {
      value: cdktf.listMapperHcl(virtualRouterProtocolBgpRedistRulesToHclTerraform, false)(struct!.redistRules),
      isBlock: true,
      type: "list",
      storageClassType: "VirtualRouterProtocolBgpRedistRulesList",
    },
    reject_default_route: {
      value: cdktf.booleanToHclTerraform(struct!.rejectDefaultRoute),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    router_id: {
      value: cdktf.stringToHclTerraform(struct!.routerId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    routing_options: {
      value: virtualRouterProtocolBgpRoutingOptionsToHclTerraform(struct!.routingOptions),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolBgpRoutingOptions",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolBgpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolBgp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowRedistDefaultRoute !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowRedistDefaultRoute = this._allowRedistDefaultRoute;
    }
    if (this._authProfile?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authProfile = this._authProfile?.internalValue;
    }
    if (this._dampeningProfile?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dampeningProfile = this._dampeningProfile?.internalValue;
    }
    if (this._ecmpMultiAs !== undefined) {
      hasAnyValues = true;
      internalValueResult.ecmpMultiAs = this._ecmpMultiAs;
    }
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._enforceFirstAs !== undefined) {
      hasAnyValues = true;
      internalValueResult.enforceFirstAs = this._enforceFirstAs;
    }
    if (this._globalBfd?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.globalBfd = this._globalBfd?.internalValue;
    }
    if (this._installRoute !== undefined) {
      hasAnyValues = true;
      internalValueResult.installRoute = this._installRoute;
    }
    if (this._localAs !== undefined) {
      hasAnyValues = true;
      internalValueResult.localAs = this._localAs;
    }
    if (this._peerGroup?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.peerGroup = this._peerGroup?.internalValue;
    }
    if (this._policy?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.policy = this._policy?.internalValue;
    }
    if (this._redistRules?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.redistRules = this._redistRules?.internalValue;
    }
    if (this._rejectDefaultRoute !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectDefaultRoute = this._rejectDefaultRoute;
    }
    if (this._routerId !== undefined) {
      hasAnyValues = true;
      internalValueResult.routerId = this._routerId;
    }
    if (this._routingOptions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.routingOptions = this._routingOptions?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolBgp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allowRedistDefaultRoute = undefined;
      this._authProfile.internalValue = undefined;
      this._dampeningProfile.internalValue = undefined;
      this._ecmpMultiAs = undefined;
      this._enable = undefined;
      this._enforceFirstAs = undefined;
      this._globalBfd.internalValue = undefined;
      this._installRoute = undefined;
      this._localAs = undefined;
      this._peerGroup.internalValue = undefined;
      this._policy.internalValue = undefined;
      this._redistRules.internalValue = undefined;
      this._rejectDefaultRoute = undefined;
      this._routerId = undefined;
      this._routingOptions.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allowRedistDefaultRoute = value.allowRedistDefaultRoute;
      this._authProfile.internalValue = value.authProfile;
      this._dampeningProfile.internalValue = value.dampeningProfile;
      this._ecmpMultiAs = value.ecmpMultiAs;
      this._enable = value.enable;
      this._enforceFirstAs = value.enforceFirstAs;
      this._globalBfd.internalValue = value.globalBfd;
      this._installRoute = value.installRoute;
      this._localAs = value.localAs;
      this._peerGroup.internalValue = value.peerGroup;
      this._policy.internalValue = value.policy;
      this._redistRules.internalValue = value.redistRules;
      this._rejectDefaultRoute = value.rejectDefaultRoute;
      this._routerId = value.routerId;
      this._routingOptions.internalValue = value.routingOptions;
    }
  }

  // allow_redist_default_route - computed: false, optional: true, required: false
  private _allowRedistDefaultRoute?: boolean | cdktf.IResolvable; 
  public get allowRedistDefaultRoute() {
    return this.getBooleanAttribute('allow_redist_default_route');
  }
  public set allowRedistDefaultRoute(value: boolean | cdktf.IResolvable) {
    this._allowRedistDefaultRoute = value;
  }
  public resetAllowRedistDefaultRoute() {
    this._allowRedistDefaultRoute = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowRedistDefaultRouteInput() {
    return this._allowRedistDefaultRoute;
  }

  // auth_profile - computed: false, optional: true, required: false
  private _authProfile = new VirtualRouterProtocolBgpAuthProfileList(this, "auth_profile", false);
  public get authProfile() {
    return this._authProfile;
  }
  public putAuthProfile(value: VirtualRouterProtocolBgpAuthProfile[] | cdktf.IResolvable) {
    this._authProfile.internalValue = value;
  }
  public resetAuthProfile() {
    this._authProfile.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authProfileInput() {
    return this._authProfile.internalValue;
  }

  // dampening_profile - computed: false, optional: true, required: false
  private _dampeningProfile = new VirtualRouterProtocolBgpDampeningProfileList(this, "dampening_profile", false);
  public get dampeningProfile() {
    return this._dampeningProfile;
  }
  public putDampeningProfile(value: VirtualRouterProtocolBgpDampeningProfile[] | cdktf.IResolvable) {
    this._dampeningProfile.internalValue = value;
  }
  public resetDampeningProfile() {
    this._dampeningProfile.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dampeningProfileInput() {
    return this._dampeningProfile.internalValue;
  }

  // ecmp_multi_as - computed: false, optional: true, required: false
  private _ecmpMultiAs?: boolean | cdktf.IResolvable; 
  public get ecmpMultiAs() {
    return this.getBooleanAttribute('ecmp_multi_as');
  }
  public set ecmpMultiAs(value: boolean | cdktf.IResolvable) {
    this._ecmpMultiAs = value;
  }
  public resetEcmpMultiAs() {
    this._ecmpMultiAs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ecmpMultiAsInput() {
    return this._ecmpMultiAs;
  }

  // enable - computed: false, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // enforce_first_as - computed: false, optional: true, required: false
  private _enforceFirstAs?: boolean | cdktf.IResolvable; 
  public get enforceFirstAs() {
    return this.getBooleanAttribute('enforce_first_as');
  }
  public set enforceFirstAs(value: boolean | cdktf.IResolvable) {
    this._enforceFirstAs = value;
  }
  public resetEnforceFirstAs() {
    this._enforceFirstAs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enforceFirstAsInput() {
    return this._enforceFirstAs;
  }

  // global_bfd - computed: false, optional: true, required: false
  private _globalBfd = new VirtualRouterProtocolBgpGlobalBfdOutputReference(this, "global_bfd");
  public get globalBfd() {
    return this._globalBfd;
  }
  public putGlobalBfd(value: VirtualRouterProtocolBgpGlobalBfd) {
    this._globalBfd.internalValue = value;
  }
  public resetGlobalBfd() {
    this._globalBfd.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get globalBfdInput() {
    return this._globalBfd.internalValue;
  }

  // install_route - computed: false, optional: true, required: false
  private _installRoute?: boolean | cdktf.IResolvable; 
  public get installRoute() {
    return this.getBooleanAttribute('install_route');
  }
  public set installRoute(value: boolean | cdktf.IResolvable) {
    this._installRoute = value;
  }
  public resetInstallRoute() {
    this._installRoute = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get installRouteInput() {
    return this._installRoute;
  }

  // local_as - computed: false, optional: true, required: false
  private _localAs?: string; 
  public get localAs() {
    return this.getStringAttribute('local_as');
  }
  public set localAs(value: string) {
    this._localAs = value;
  }
  public resetLocalAs() {
    this._localAs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localAsInput() {
    return this._localAs;
  }

  // peer_group - computed: false, optional: true, required: false
  private _peerGroup = new VirtualRouterProtocolBgpPeerGroupList(this, "peer_group", false);
  public get peerGroup() {
    return this._peerGroup;
  }
  public putPeerGroup(value: VirtualRouterProtocolBgpPeerGroup[] | cdktf.IResolvable) {
    this._peerGroup.internalValue = value;
  }
  public resetPeerGroup() {
    this._peerGroup.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get peerGroupInput() {
    return this._peerGroup.internalValue;
  }

  // policy - computed: false, optional: true, required: false
  private _policy = new VirtualRouterProtocolBgpPolicyOutputReference(this, "policy");
  public get policy() {
    return this._policy;
  }
  public putPolicy(value: VirtualRouterProtocolBgpPolicy) {
    this._policy.internalValue = value;
  }
  public resetPolicy() {
    this._policy.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get policyInput() {
    return this._policy.internalValue;
  }

  // redist_rules - computed: false, optional: true, required: false
  private _redistRules = new VirtualRouterProtocolBgpRedistRulesList(this, "redist_rules", false);
  public get redistRules() {
    return this._redistRules;
  }
  public putRedistRules(value: VirtualRouterProtocolBgpRedistRules[] | cdktf.IResolvable) {
    this._redistRules.internalValue = value;
  }
  public resetRedistRules() {
    this._redistRules.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get redistRulesInput() {
    return this._redistRules.internalValue;
  }

  // reject_default_route - computed: false, optional: true, required: false
  private _rejectDefaultRoute?: boolean | cdktf.IResolvable; 
  public get rejectDefaultRoute() {
    return this.getBooleanAttribute('reject_default_route');
  }
  public set rejectDefaultRoute(value: boolean | cdktf.IResolvable) {
    this._rejectDefaultRoute = value;
  }
  public resetRejectDefaultRoute() {
    this._rejectDefaultRoute = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectDefaultRouteInput() {
    return this._rejectDefaultRoute;
  }

  // router_id - computed: false, optional: true, required: false
  private _routerId?: string; 
  public get routerId() {
    return this.getStringAttribute('router_id');
  }
  public set routerId(value: string) {
    this._routerId = value;
  }
  public resetRouterId() {
    this._routerId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routerIdInput() {
    return this._routerId;
  }

  // routing_options - computed: false, optional: true, required: false
  private _routingOptions = new VirtualRouterProtocolBgpRoutingOptionsOutputReference(this, "routing_options");
  public get routingOptions() {
    return this._routingOptions;
  }
  public putRoutingOptions(value: VirtualRouterProtocolBgpRoutingOptions) {
    this._routingOptions.internalValue = value;
  }
  public resetRoutingOptions() {
    this._routingOptions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routingOptionsInput() {
    return this._routingOptions.internalValue;
  }
}
export interface VirtualRouterProtocolOspfAreaInterfaceBfd {
  /**
  * BFD profile
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#profile VirtualRouter#profile}
  */
  readonly profile?: string;
}

export function virtualRouterProtocolOspfAreaInterfaceBfdToTerraform(struct?: VirtualRouterProtocolOspfAreaInterfaceBfd | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    profile: cdktf.stringToTerraform(struct!.profile),
  }
}


export function virtualRouterProtocolOspfAreaInterfaceBfdToHclTerraform(struct?: VirtualRouterProtocolOspfAreaInterfaceBfd | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    profile: {
      value: cdktf.stringToHclTerraform(struct!.profile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolOspfAreaInterfaceBfdOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolOspfAreaInterfaceBfd | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._profile !== undefined) {
      hasAnyValues = true;
      internalValueResult.profile = this._profile;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolOspfAreaInterfaceBfd | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._profile = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._profile = value.profile;
    }
  }

  // profile - computed: true, optional: true, required: false
  private _profile?: string; 
  public get profile() {
    return this.getStringAttribute('profile');
  }
  public set profile(value: string) {
    this._profile = value;
  }
  public resetProfile() {
    this._profile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get profileInput() {
    return this._profile;
  }
}
export interface VirtualRouterProtocolOspfAreaInterfaceLinkTypeBroadcast {
}

export function virtualRouterProtocolOspfAreaInterfaceLinkTypeBroadcastToTerraform(struct?: VirtualRouterProtocolOspfAreaInterfaceLinkTypeBroadcast | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function virtualRouterProtocolOspfAreaInterfaceLinkTypeBroadcastToHclTerraform(struct?: VirtualRouterProtocolOspfAreaInterfaceLinkTypeBroadcast | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class VirtualRouterProtocolOspfAreaInterfaceLinkTypeBroadcastOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolOspfAreaInterfaceLinkTypeBroadcast | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolOspfAreaInterfaceLinkTypeBroadcast | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface VirtualRouterProtocolOspfAreaInterfaceLinkTypeP2Mp {
}

export function virtualRouterProtocolOspfAreaInterfaceLinkTypeP2MpToTerraform(struct?: VirtualRouterProtocolOspfAreaInterfaceLinkTypeP2Mp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function virtualRouterProtocolOspfAreaInterfaceLinkTypeP2MpToHclTerraform(struct?: VirtualRouterProtocolOspfAreaInterfaceLinkTypeP2Mp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class VirtualRouterProtocolOspfAreaInterfaceLinkTypeP2MpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolOspfAreaInterfaceLinkTypeP2Mp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolOspfAreaInterfaceLinkTypeP2Mp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface VirtualRouterProtocolOspfAreaInterfaceLinkTypeP2P {
}

export function virtualRouterProtocolOspfAreaInterfaceLinkTypeP2PToTerraform(struct?: VirtualRouterProtocolOspfAreaInterfaceLinkTypeP2P | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function virtualRouterProtocolOspfAreaInterfaceLinkTypeP2PToHclTerraform(struct?: VirtualRouterProtocolOspfAreaInterfaceLinkTypeP2P | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class VirtualRouterProtocolOspfAreaInterfaceLinkTypeP2POutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolOspfAreaInterfaceLinkTypeP2P | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolOspfAreaInterfaceLinkTypeP2P | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface VirtualRouterProtocolOspfAreaInterfaceLinkType {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#broadcast VirtualRouter#broadcast}
  */
  readonly broadcast?: VirtualRouterProtocolOspfAreaInterfaceLinkTypeBroadcast;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#p2mp VirtualRouter#p2mp}
  */
  readonly p2Mp?: VirtualRouterProtocolOspfAreaInterfaceLinkTypeP2Mp;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#p2p VirtualRouter#p2p}
  */
  readonly p2P?: VirtualRouterProtocolOspfAreaInterfaceLinkTypeP2P;
}

export function virtualRouterProtocolOspfAreaInterfaceLinkTypeToTerraform(struct?: VirtualRouterProtocolOspfAreaInterfaceLinkType | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    broadcast: virtualRouterProtocolOspfAreaInterfaceLinkTypeBroadcastToTerraform(struct!.broadcast),
    p2mp: virtualRouterProtocolOspfAreaInterfaceLinkTypeP2MpToTerraform(struct!.p2Mp),
    p2p: virtualRouterProtocolOspfAreaInterfaceLinkTypeP2PToTerraform(struct!.p2P),
  }
}


export function virtualRouterProtocolOspfAreaInterfaceLinkTypeToHclTerraform(struct?: VirtualRouterProtocolOspfAreaInterfaceLinkType | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    broadcast: {
      value: virtualRouterProtocolOspfAreaInterfaceLinkTypeBroadcastToHclTerraform(struct!.broadcast),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolOspfAreaInterfaceLinkTypeBroadcast",
    },
    p2mp: {
      value: virtualRouterProtocolOspfAreaInterfaceLinkTypeP2MpToHclTerraform(struct!.p2Mp),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolOspfAreaInterfaceLinkTypeP2Mp",
    },
    p2p: {
      value: virtualRouterProtocolOspfAreaInterfaceLinkTypeP2PToHclTerraform(struct!.p2P),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolOspfAreaInterfaceLinkTypeP2P",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolOspfAreaInterfaceLinkTypeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolOspfAreaInterfaceLinkType | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._broadcast?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.broadcast = this._broadcast?.internalValue;
    }
    if (this._p2Mp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.p2Mp = this._p2Mp?.internalValue;
    }
    if (this._p2P?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.p2P = this._p2P?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolOspfAreaInterfaceLinkType | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._broadcast.internalValue = undefined;
      this._p2Mp.internalValue = undefined;
      this._p2P.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._broadcast.internalValue = value.broadcast;
      this._p2Mp.internalValue = value.p2Mp;
      this._p2P.internalValue = value.p2P;
    }
  }

  // broadcast - computed: false, optional: true, required: false
  private _broadcast = new VirtualRouterProtocolOspfAreaInterfaceLinkTypeBroadcastOutputReference(this, "broadcast");
  public get broadcast() {
    return this._broadcast;
  }
  public putBroadcast(value: VirtualRouterProtocolOspfAreaInterfaceLinkTypeBroadcast) {
    this._broadcast.internalValue = value;
  }
  public resetBroadcast() {
    this._broadcast.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get broadcastInput() {
    return this._broadcast.internalValue;
  }

  // p2mp - computed: false, optional: true, required: false
  private _p2Mp = new VirtualRouterProtocolOspfAreaInterfaceLinkTypeP2MpOutputReference(this, "p2mp");
  public get p2Mp() {
    return this._p2Mp;
  }
  public putP2Mp(value: VirtualRouterProtocolOspfAreaInterfaceLinkTypeP2Mp) {
    this._p2Mp.internalValue = value;
  }
  public resetP2Mp() {
    this._p2Mp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get p2MpInput() {
    return this._p2Mp.internalValue;
  }

  // p2p - computed: false, optional: true, required: false
  private _p2P = new VirtualRouterProtocolOspfAreaInterfaceLinkTypeP2POutputReference(this, "p2p");
  public get p2P() {
    return this._p2P;
  }
  public putP2P(value: VirtualRouterProtocolOspfAreaInterfaceLinkTypeP2P) {
    this._p2P.internalValue = value;
  }
  public resetP2P() {
    this._p2P.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get p2PInput() {
    return this._p2P.internalValue;
  }
}
export interface VirtualRouterProtocolOspfAreaInterfaceNeighbor {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#name VirtualRouter#name}
  */
  readonly name: string;
}

export function virtualRouterProtocolOspfAreaInterfaceNeighborToTerraform(struct?: VirtualRouterProtocolOspfAreaInterfaceNeighbor | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function virtualRouterProtocolOspfAreaInterfaceNeighborToHclTerraform(struct?: VirtualRouterProtocolOspfAreaInterfaceNeighbor | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolOspfAreaInterfaceNeighborOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): VirtualRouterProtocolOspfAreaInterfaceNeighbor | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolOspfAreaInterfaceNeighbor | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class VirtualRouterProtocolOspfAreaInterfaceNeighborList extends cdktf.ComplexList {
  public internalValue? : VirtualRouterProtocolOspfAreaInterfaceNeighbor[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): VirtualRouterProtocolOspfAreaInterfaceNeighborOutputReference {
    return new VirtualRouterProtocolOspfAreaInterfaceNeighborOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface VirtualRouterProtocolOspfAreaInterface {
  /**
  * Authentication options
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#authentication VirtualRouter#authentication}
  */
  readonly authentication?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#bfd VirtualRouter#bfd}
  */
  readonly bfd?: VirtualRouterProtocolOspfAreaInterfaceBfd;
  /**
  * number of lost hello packets to declare router down
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#dead_counts VirtualRouter#dead_counts}
  */
  readonly deadCounts?: number;
  /**
  * Enable OSPF in this interface
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#enable VirtualRouter#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * Period (in seconds) used to send grace LSAs before first hello is sent when graceful restart starts
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#gr_delay VirtualRouter#gr_delay}
  */
  readonly grDelay?: number;
  /**
  * Interval (in seconds) to send Hello packets
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#hello_interval VirtualRouter#hello_interval}
  */
  readonly helloInterval?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#link_type VirtualRouter#link_type}
  */
  readonly linkType?: VirtualRouterProtocolOspfAreaInterfaceLinkType;
  /**
  * Cost of OSPF interface
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#metric VirtualRouter#metric}
  */
  readonly metric?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#name VirtualRouter#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#neighbor VirtualRouter#neighbor}
  */
  readonly neighbor?: VirtualRouterProtocolOspfAreaInterfaceNeighbor[] | cdktf.IResolvable;
  /**
  * Suppress the sending of hello packets in this interface
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#passive VirtualRouter#passive}
  */
  readonly passive?: boolean | cdktf.IResolvable;
  /**
  * Priority for OSPF designated router selection
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#priority VirtualRouter#priority}
  */
  readonly priority?: number;
  /**
  * Interval (in seconds) to retransmit LSAs
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#retransmit_interval VirtualRouter#retransmit_interval}
  */
  readonly retransmitInterval?: number;
  /**
  * Estimated delay (in seconds) to transmit LSAs
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#transit_delay VirtualRouter#transit_delay}
  */
  readonly transitDelay?: number;
}

export function virtualRouterProtocolOspfAreaInterfaceToTerraform(struct?: VirtualRouterProtocolOspfAreaInterface | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    authentication: cdktf.stringToTerraform(struct!.authentication),
    bfd: virtualRouterProtocolOspfAreaInterfaceBfdToTerraform(struct!.bfd),
    dead_counts: cdktf.numberToTerraform(struct!.deadCounts),
    enable: cdktf.booleanToTerraform(struct!.enable),
    gr_delay: cdktf.numberToTerraform(struct!.grDelay),
    hello_interval: cdktf.numberToTerraform(struct!.helloInterval),
    link_type: virtualRouterProtocolOspfAreaInterfaceLinkTypeToTerraform(struct!.linkType),
    metric: cdktf.numberToTerraform(struct!.metric),
    name: cdktf.stringToTerraform(struct!.name),
    neighbor: cdktf.listMapper(virtualRouterProtocolOspfAreaInterfaceNeighborToTerraform, false)(struct!.neighbor),
    passive: cdktf.booleanToTerraform(struct!.passive),
    priority: cdktf.numberToTerraform(struct!.priority),
    retransmit_interval: cdktf.numberToTerraform(struct!.retransmitInterval),
    transit_delay: cdktf.numberToTerraform(struct!.transitDelay),
  }
}


export function virtualRouterProtocolOspfAreaInterfaceToHclTerraform(struct?: VirtualRouterProtocolOspfAreaInterface | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    authentication: {
      value: cdktf.stringToHclTerraform(struct!.authentication),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bfd: {
      value: virtualRouterProtocolOspfAreaInterfaceBfdToHclTerraform(struct!.bfd),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolOspfAreaInterfaceBfd",
    },
    dead_counts: {
      value: cdktf.numberToHclTerraform(struct!.deadCounts),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    gr_delay: {
      value: cdktf.numberToHclTerraform(struct!.grDelay),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    hello_interval: {
      value: cdktf.numberToHclTerraform(struct!.helloInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    link_type: {
      value: virtualRouterProtocolOspfAreaInterfaceLinkTypeToHclTerraform(struct!.linkType),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolOspfAreaInterfaceLinkType",
    },
    metric: {
      value: cdktf.numberToHclTerraform(struct!.metric),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    neighbor: {
      value: cdktf.listMapperHcl(virtualRouterProtocolOspfAreaInterfaceNeighborToHclTerraform, false)(struct!.neighbor),
      isBlock: true,
      type: "list",
      storageClassType: "VirtualRouterProtocolOspfAreaInterfaceNeighborList",
    },
    passive: {
      value: cdktf.booleanToHclTerraform(struct!.passive),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    priority: {
      value: cdktf.numberToHclTerraform(struct!.priority),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    retransmit_interval: {
      value: cdktf.numberToHclTerraform(struct!.retransmitInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    transit_delay: {
      value: cdktf.numberToHclTerraform(struct!.transitDelay),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolOspfAreaInterfaceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): VirtualRouterProtocolOspfAreaInterface | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authentication !== undefined) {
      hasAnyValues = true;
      internalValueResult.authentication = this._authentication;
    }
    if (this._bfd?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.bfd = this._bfd?.internalValue;
    }
    if (this._deadCounts !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadCounts = this._deadCounts;
    }
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._grDelay !== undefined) {
      hasAnyValues = true;
      internalValueResult.grDelay = this._grDelay;
    }
    if (this._helloInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.helloInterval = this._helloInterval;
    }
    if (this._linkType?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.linkType = this._linkType?.internalValue;
    }
    if (this._metric !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._neighbor?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.neighbor = this._neighbor?.internalValue;
    }
    if (this._passive !== undefined) {
      hasAnyValues = true;
      internalValueResult.passive = this._passive;
    }
    if (this._priority !== undefined) {
      hasAnyValues = true;
      internalValueResult.priority = this._priority;
    }
    if (this._retransmitInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.retransmitInterval = this._retransmitInterval;
    }
    if (this._transitDelay !== undefined) {
      hasAnyValues = true;
      internalValueResult.transitDelay = this._transitDelay;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolOspfAreaInterface | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authentication = undefined;
      this._bfd.internalValue = undefined;
      this._deadCounts = undefined;
      this._enable = undefined;
      this._grDelay = undefined;
      this._helloInterval = undefined;
      this._linkType.internalValue = undefined;
      this._metric = undefined;
      this._name = undefined;
      this._neighbor.internalValue = undefined;
      this._passive = undefined;
      this._priority = undefined;
      this._retransmitInterval = undefined;
      this._transitDelay = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authentication = value.authentication;
      this._bfd.internalValue = value.bfd;
      this._deadCounts = value.deadCounts;
      this._enable = value.enable;
      this._grDelay = value.grDelay;
      this._helloInterval = value.helloInterval;
      this._linkType.internalValue = value.linkType;
      this._metric = value.metric;
      this._name = value.name;
      this._neighbor.internalValue = value.neighbor;
      this._passive = value.passive;
      this._priority = value.priority;
      this._retransmitInterval = value.retransmitInterval;
      this._transitDelay = value.transitDelay;
    }
  }

  // authentication - computed: false, optional: true, required: false
  private _authentication?: string; 
  public get authentication() {
    return this.getStringAttribute('authentication');
  }
  public set authentication(value: string) {
    this._authentication = value;
  }
  public resetAuthentication() {
    this._authentication = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authenticationInput() {
    return this._authentication;
  }

  // bfd - computed: false, optional: true, required: false
  private _bfd = new VirtualRouterProtocolOspfAreaInterfaceBfdOutputReference(this, "bfd");
  public get bfd() {
    return this._bfd;
  }
  public putBfd(value: VirtualRouterProtocolOspfAreaInterfaceBfd) {
    this._bfd.internalValue = value;
  }
  public resetBfd() {
    this._bfd.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bfdInput() {
    return this._bfd.internalValue;
  }

  // dead_counts - computed: true, optional: true, required: false
  private _deadCounts?: number; 
  public get deadCounts() {
    return this.getNumberAttribute('dead_counts');
  }
  public set deadCounts(value: number) {
    this._deadCounts = value;
  }
  public resetDeadCounts() {
    this._deadCounts = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadCountsInput() {
    return this._deadCounts;
  }

  // enable - computed: false, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // gr_delay - computed: true, optional: true, required: false
  private _grDelay?: number; 
  public get grDelay() {
    return this.getNumberAttribute('gr_delay');
  }
  public set grDelay(value: number) {
    this._grDelay = value;
  }
  public resetGrDelay() {
    this._grDelay = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get grDelayInput() {
    return this._grDelay;
  }

  // hello_interval - computed: true, optional: true, required: false
  private _helloInterval?: number; 
  public get helloInterval() {
    return this.getNumberAttribute('hello_interval');
  }
  public set helloInterval(value: number) {
    this._helloInterval = value;
  }
  public resetHelloInterval() {
    this._helloInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get helloIntervalInput() {
    return this._helloInterval;
  }

  // link_type - computed: false, optional: true, required: false
  private _linkType = new VirtualRouterProtocolOspfAreaInterfaceLinkTypeOutputReference(this, "link_type");
  public get linkType() {
    return this._linkType;
  }
  public putLinkType(value: VirtualRouterProtocolOspfAreaInterfaceLinkType) {
    this._linkType.internalValue = value;
  }
  public resetLinkType() {
    this._linkType.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get linkTypeInput() {
    return this._linkType.internalValue;
  }

  // metric - computed: true, optional: true, required: false
  private _metric?: number; 
  public get metric() {
    return this.getNumberAttribute('metric');
  }
  public set metric(value: number) {
    this._metric = value;
  }
  public resetMetric() {
    this._metric = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // neighbor - computed: false, optional: true, required: false
  private _neighbor = new VirtualRouterProtocolOspfAreaInterfaceNeighborList(this, "neighbor", false);
  public get neighbor() {
    return this._neighbor;
  }
  public putNeighbor(value: VirtualRouterProtocolOspfAreaInterfaceNeighbor[] | cdktf.IResolvable) {
    this._neighbor.internalValue = value;
  }
  public resetNeighbor() {
    this._neighbor.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get neighborInput() {
    return this._neighbor.internalValue;
  }

  // passive - computed: false, optional: true, required: false
  private _passive?: boolean | cdktf.IResolvable; 
  public get passive() {
    return this.getBooleanAttribute('passive');
  }
  public set passive(value: boolean | cdktf.IResolvable) {
    this._passive = value;
  }
  public resetPassive() {
    this._passive = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passiveInput() {
    return this._passive;
  }

  // priority - computed: true, optional: true, required: false
  private _priority?: number; 
  public get priority() {
    return this.getNumberAttribute('priority');
  }
  public set priority(value: number) {
    this._priority = value;
  }
  public resetPriority() {
    this._priority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get priorityInput() {
    return this._priority;
  }

  // retransmit_interval - computed: true, optional: true, required: false
  private _retransmitInterval?: number; 
  public get retransmitInterval() {
    return this.getNumberAttribute('retransmit_interval');
  }
  public set retransmitInterval(value: number) {
    this._retransmitInterval = value;
  }
  public resetRetransmitInterval() {
    this._retransmitInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retransmitIntervalInput() {
    return this._retransmitInterval;
  }

  // transit_delay - computed: true, optional: true, required: false
  private _transitDelay?: number; 
  public get transitDelay() {
    return this.getNumberAttribute('transit_delay');
  }
  public set transitDelay(value: number) {
    this._transitDelay = value;
  }
  public resetTransitDelay() {
    this._transitDelay = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get transitDelayInput() {
    return this._transitDelay;
  }
}

export class VirtualRouterProtocolOspfAreaInterfaceList extends cdktf.ComplexList {
  public internalValue? : VirtualRouterProtocolOspfAreaInterface[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): VirtualRouterProtocolOspfAreaInterfaceOutputReference {
    return new VirtualRouterProtocolOspfAreaInterfaceOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface VirtualRouterProtocolOspfAreaRangeAdvertise {
}

export function virtualRouterProtocolOspfAreaRangeAdvertiseToTerraform(struct?: VirtualRouterProtocolOspfAreaRangeAdvertise | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function virtualRouterProtocolOspfAreaRangeAdvertiseToHclTerraform(struct?: VirtualRouterProtocolOspfAreaRangeAdvertise | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class VirtualRouterProtocolOspfAreaRangeAdvertiseOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolOspfAreaRangeAdvertise | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolOspfAreaRangeAdvertise | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface VirtualRouterProtocolOspfAreaRangeSuppress {
}

export function virtualRouterProtocolOspfAreaRangeSuppressToTerraform(struct?: VirtualRouterProtocolOspfAreaRangeSuppress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function virtualRouterProtocolOspfAreaRangeSuppressToHclTerraform(struct?: VirtualRouterProtocolOspfAreaRangeSuppress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class VirtualRouterProtocolOspfAreaRangeSuppressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolOspfAreaRangeSuppress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolOspfAreaRangeSuppress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface VirtualRouterProtocolOspfAreaRange {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#advertise VirtualRouter#advertise}
  */
  readonly advertise?: VirtualRouterProtocolOspfAreaRangeAdvertise;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#name VirtualRouter#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#suppress VirtualRouter#suppress}
  */
  readonly suppress?: VirtualRouterProtocolOspfAreaRangeSuppress;
}

export function virtualRouterProtocolOspfAreaRangeToTerraform(struct?: VirtualRouterProtocolOspfAreaRange | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    advertise: virtualRouterProtocolOspfAreaRangeAdvertiseToTerraform(struct!.advertise),
    name: cdktf.stringToTerraform(struct!.name),
    suppress: virtualRouterProtocolOspfAreaRangeSuppressToTerraform(struct!.suppress),
  }
}


export function virtualRouterProtocolOspfAreaRangeToHclTerraform(struct?: VirtualRouterProtocolOspfAreaRange | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    advertise: {
      value: virtualRouterProtocolOspfAreaRangeAdvertiseToHclTerraform(struct!.advertise),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolOspfAreaRangeAdvertise",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    suppress: {
      value: virtualRouterProtocolOspfAreaRangeSuppressToHclTerraform(struct!.suppress),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolOspfAreaRangeSuppress",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolOspfAreaRangeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): VirtualRouterProtocolOspfAreaRange | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._advertise?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.advertise = this._advertise?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._suppress?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.suppress = this._suppress?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolOspfAreaRange | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._advertise.internalValue = undefined;
      this._name = undefined;
      this._suppress.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._advertise.internalValue = value.advertise;
      this._name = value.name;
      this._suppress.internalValue = value.suppress;
    }
  }

  // advertise - computed: false, optional: true, required: false
  private _advertise = new VirtualRouterProtocolOspfAreaRangeAdvertiseOutputReference(this, "advertise");
  public get advertise() {
    return this._advertise;
  }
  public putAdvertise(value: VirtualRouterProtocolOspfAreaRangeAdvertise) {
    this._advertise.internalValue = value;
  }
  public resetAdvertise() {
    this._advertise.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get advertiseInput() {
    return this._advertise.internalValue;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // suppress - computed: false, optional: true, required: false
  private _suppress = new VirtualRouterProtocolOspfAreaRangeSuppressOutputReference(this, "suppress");
  public get suppress() {
    return this._suppress;
  }
  public putSuppress(value: VirtualRouterProtocolOspfAreaRangeSuppress) {
    this._suppress.internalValue = value;
  }
  public resetSuppress() {
    this._suppress.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get suppressInput() {
    return this._suppress.internalValue;
  }
}

export class VirtualRouterProtocolOspfAreaRangeList extends cdktf.ComplexList {
  public internalValue? : VirtualRouterProtocolOspfAreaRange[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): VirtualRouterProtocolOspfAreaRangeOutputReference {
    return new VirtualRouterProtocolOspfAreaRangeOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface VirtualRouterProtocolOspfAreaTypeNormal {
}

export function virtualRouterProtocolOspfAreaTypeNormalToTerraform(struct?: VirtualRouterProtocolOspfAreaTypeNormal | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function virtualRouterProtocolOspfAreaTypeNormalToHclTerraform(struct?: VirtualRouterProtocolOspfAreaTypeNormal | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class VirtualRouterProtocolOspfAreaTypeNormalOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolOspfAreaTypeNormal | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolOspfAreaTypeNormal | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface VirtualRouterProtocolOspfAreaTypeNssaDefaultRouteAdvertise {
  /**
  * metric to be used when advertise default route within this stub area
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#metric VirtualRouter#metric}
  */
  readonly metric?: number;
  /**
  * metric type to be used when advertise default route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#type VirtualRouter#type}
  */
  readonly type?: string;
}

export function virtualRouterProtocolOspfAreaTypeNssaDefaultRouteAdvertiseToTerraform(struct?: VirtualRouterProtocolOspfAreaTypeNssaDefaultRouteAdvertise | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    metric: cdktf.numberToTerraform(struct!.metric),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function virtualRouterProtocolOspfAreaTypeNssaDefaultRouteAdvertiseToHclTerraform(struct?: VirtualRouterProtocolOspfAreaTypeNssaDefaultRouteAdvertise | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    metric: {
      value: cdktf.numberToHclTerraform(struct!.metric),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolOspfAreaTypeNssaDefaultRouteAdvertiseOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolOspfAreaTypeNssaDefaultRouteAdvertise | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._metric !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolOspfAreaTypeNssaDefaultRouteAdvertise | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._metric = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._metric = value.metric;
      this._type = value.type;
    }
  }

  // metric - computed: true, optional: true, required: false
  private _metric?: number; 
  public get metric() {
    return this.getNumberAttribute('metric');
  }
  public set metric(value: number) {
    this._metric = value;
  }
  public resetMetric() {
    this._metric = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric;
  }

  // type - computed: true, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface VirtualRouterProtocolOspfAreaTypeNssaDefaultRouteDisable {
}

export function virtualRouterProtocolOspfAreaTypeNssaDefaultRouteDisableToTerraform(struct?: VirtualRouterProtocolOspfAreaTypeNssaDefaultRouteDisable | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function virtualRouterProtocolOspfAreaTypeNssaDefaultRouteDisableToHclTerraform(struct?: VirtualRouterProtocolOspfAreaTypeNssaDefaultRouteDisable | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class VirtualRouterProtocolOspfAreaTypeNssaDefaultRouteDisableOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolOspfAreaTypeNssaDefaultRouteDisable | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolOspfAreaTypeNssaDefaultRouteDisable | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface VirtualRouterProtocolOspfAreaTypeNssaDefaultRoute {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#advertise VirtualRouter#advertise}
  */
  readonly advertise?: VirtualRouterProtocolOspfAreaTypeNssaDefaultRouteAdvertise;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#disable VirtualRouter#disable}
  */
  readonly disable?: VirtualRouterProtocolOspfAreaTypeNssaDefaultRouteDisable;
}

export function virtualRouterProtocolOspfAreaTypeNssaDefaultRouteToTerraform(struct?: VirtualRouterProtocolOspfAreaTypeNssaDefaultRoute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    advertise: virtualRouterProtocolOspfAreaTypeNssaDefaultRouteAdvertiseToTerraform(struct!.advertise),
    disable: virtualRouterProtocolOspfAreaTypeNssaDefaultRouteDisableToTerraform(struct!.disable),
  }
}


export function virtualRouterProtocolOspfAreaTypeNssaDefaultRouteToHclTerraform(struct?: VirtualRouterProtocolOspfAreaTypeNssaDefaultRoute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    advertise: {
      value: virtualRouterProtocolOspfAreaTypeNssaDefaultRouteAdvertiseToHclTerraform(struct!.advertise),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolOspfAreaTypeNssaDefaultRouteAdvertise",
    },
    disable: {
      value: virtualRouterProtocolOspfAreaTypeNssaDefaultRouteDisableToHclTerraform(struct!.disable),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolOspfAreaTypeNssaDefaultRouteDisable",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolOspfAreaTypeNssaDefaultRouteOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolOspfAreaTypeNssaDefaultRoute | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._advertise?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.advertise = this._advertise?.internalValue;
    }
    if (this._disable?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.disable = this._disable?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolOspfAreaTypeNssaDefaultRoute | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._advertise.internalValue = undefined;
      this._disable.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._advertise.internalValue = value.advertise;
      this._disable.internalValue = value.disable;
    }
  }

  // advertise - computed: false, optional: true, required: false
  private _advertise = new VirtualRouterProtocolOspfAreaTypeNssaDefaultRouteAdvertiseOutputReference(this, "advertise");
  public get advertise() {
    return this._advertise;
  }
  public putAdvertise(value: VirtualRouterProtocolOspfAreaTypeNssaDefaultRouteAdvertise) {
    this._advertise.internalValue = value;
  }
  public resetAdvertise() {
    this._advertise.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get advertiseInput() {
    return this._advertise.internalValue;
  }

  // disable - computed: false, optional: true, required: false
  private _disable = new VirtualRouterProtocolOspfAreaTypeNssaDefaultRouteDisableOutputReference(this, "disable");
  public get disable() {
    return this._disable;
  }
  public putDisable(value: VirtualRouterProtocolOspfAreaTypeNssaDefaultRouteDisable) {
    this._disable.internalValue = value;
  }
  public resetDisable() {
    this._disable.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableInput() {
    return this._disable.internalValue;
  }
}
export interface VirtualRouterProtocolOspfAreaTypeNssaNssaExtRangeAdvertise {
}

export function virtualRouterProtocolOspfAreaTypeNssaNssaExtRangeAdvertiseToTerraform(struct?: VirtualRouterProtocolOspfAreaTypeNssaNssaExtRangeAdvertise | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function virtualRouterProtocolOspfAreaTypeNssaNssaExtRangeAdvertiseToHclTerraform(struct?: VirtualRouterProtocolOspfAreaTypeNssaNssaExtRangeAdvertise | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class VirtualRouterProtocolOspfAreaTypeNssaNssaExtRangeAdvertiseOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolOspfAreaTypeNssaNssaExtRangeAdvertise | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolOspfAreaTypeNssaNssaExtRangeAdvertise | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface VirtualRouterProtocolOspfAreaTypeNssaNssaExtRangeSuppress {
}

export function virtualRouterProtocolOspfAreaTypeNssaNssaExtRangeSuppressToTerraform(struct?: VirtualRouterProtocolOspfAreaTypeNssaNssaExtRangeSuppress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function virtualRouterProtocolOspfAreaTypeNssaNssaExtRangeSuppressToHclTerraform(struct?: VirtualRouterProtocolOspfAreaTypeNssaNssaExtRangeSuppress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class VirtualRouterProtocolOspfAreaTypeNssaNssaExtRangeSuppressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolOspfAreaTypeNssaNssaExtRangeSuppress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolOspfAreaTypeNssaNssaExtRangeSuppress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface VirtualRouterProtocolOspfAreaTypeNssaNssaExtRange {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#advertise VirtualRouter#advertise}
  */
  readonly advertise?: VirtualRouterProtocolOspfAreaTypeNssaNssaExtRangeAdvertise;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#name VirtualRouter#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#suppress VirtualRouter#suppress}
  */
  readonly suppress?: VirtualRouterProtocolOspfAreaTypeNssaNssaExtRangeSuppress;
}

export function virtualRouterProtocolOspfAreaTypeNssaNssaExtRangeToTerraform(struct?: VirtualRouterProtocolOspfAreaTypeNssaNssaExtRange | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    advertise: virtualRouterProtocolOspfAreaTypeNssaNssaExtRangeAdvertiseToTerraform(struct!.advertise),
    name: cdktf.stringToTerraform(struct!.name),
    suppress: virtualRouterProtocolOspfAreaTypeNssaNssaExtRangeSuppressToTerraform(struct!.suppress),
  }
}


export function virtualRouterProtocolOspfAreaTypeNssaNssaExtRangeToHclTerraform(struct?: VirtualRouterProtocolOspfAreaTypeNssaNssaExtRange | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    advertise: {
      value: virtualRouterProtocolOspfAreaTypeNssaNssaExtRangeAdvertiseToHclTerraform(struct!.advertise),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolOspfAreaTypeNssaNssaExtRangeAdvertise",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    suppress: {
      value: virtualRouterProtocolOspfAreaTypeNssaNssaExtRangeSuppressToHclTerraform(struct!.suppress),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolOspfAreaTypeNssaNssaExtRangeSuppress",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolOspfAreaTypeNssaNssaExtRangeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): VirtualRouterProtocolOspfAreaTypeNssaNssaExtRange | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._advertise?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.advertise = this._advertise?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._suppress?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.suppress = this._suppress?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolOspfAreaTypeNssaNssaExtRange | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._advertise.internalValue = undefined;
      this._name = undefined;
      this._suppress.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._advertise.internalValue = value.advertise;
      this._name = value.name;
      this._suppress.internalValue = value.suppress;
    }
  }

  // advertise - computed: false, optional: true, required: false
  private _advertise = new VirtualRouterProtocolOspfAreaTypeNssaNssaExtRangeAdvertiseOutputReference(this, "advertise");
  public get advertise() {
    return this._advertise;
  }
  public putAdvertise(value: VirtualRouterProtocolOspfAreaTypeNssaNssaExtRangeAdvertise) {
    this._advertise.internalValue = value;
  }
  public resetAdvertise() {
    this._advertise.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get advertiseInput() {
    return this._advertise.internalValue;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // suppress - computed: false, optional: true, required: false
  private _suppress = new VirtualRouterProtocolOspfAreaTypeNssaNssaExtRangeSuppressOutputReference(this, "suppress");
  public get suppress() {
    return this._suppress;
  }
  public putSuppress(value: VirtualRouterProtocolOspfAreaTypeNssaNssaExtRangeSuppress) {
    this._suppress.internalValue = value;
  }
  public resetSuppress() {
    this._suppress.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get suppressInput() {
    return this._suppress.internalValue;
  }
}

export class VirtualRouterProtocolOspfAreaTypeNssaNssaExtRangeList extends cdktf.ComplexList {
  public internalValue? : VirtualRouterProtocolOspfAreaTypeNssaNssaExtRange[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): VirtualRouterProtocolOspfAreaTypeNssaNssaExtRangeOutputReference {
    return new VirtualRouterProtocolOspfAreaTypeNssaNssaExtRangeOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface VirtualRouterProtocolOspfAreaTypeNssa {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#accept_summary VirtualRouter#accept_summary}
  */
  readonly acceptSummary?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#default_route VirtualRouter#default_route}
  */
  readonly defaultRoute?: VirtualRouterProtocolOspfAreaTypeNssaDefaultRoute;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#nssa_ext_range VirtualRouter#nssa_ext_range}
  */
  readonly nssaExtRange?: VirtualRouterProtocolOspfAreaTypeNssaNssaExtRange[] | cdktf.IResolvable;
}

export function virtualRouterProtocolOspfAreaTypeNssaToTerraform(struct?: VirtualRouterProtocolOspfAreaTypeNssa | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    accept_summary: cdktf.booleanToTerraform(struct!.acceptSummary),
    default_route: virtualRouterProtocolOspfAreaTypeNssaDefaultRouteToTerraform(struct!.defaultRoute),
    nssa_ext_range: cdktf.listMapper(virtualRouterProtocolOspfAreaTypeNssaNssaExtRangeToTerraform, false)(struct!.nssaExtRange),
  }
}


export function virtualRouterProtocolOspfAreaTypeNssaToHclTerraform(struct?: VirtualRouterProtocolOspfAreaTypeNssa | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    accept_summary: {
      value: cdktf.booleanToHclTerraform(struct!.acceptSummary),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    default_route: {
      value: virtualRouterProtocolOspfAreaTypeNssaDefaultRouteToHclTerraform(struct!.defaultRoute),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolOspfAreaTypeNssaDefaultRoute",
    },
    nssa_ext_range: {
      value: cdktf.listMapperHcl(virtualRouterProtocolOspfAreaTypeNssaNssaExtRangeToHclTerraform, false)(struct!.nssaExtRange),
      isBlock: true,
      type: "list",
      storageClassType: "VirtualRouterProtocolOspfAreaTypeNssaNssaExtRangeList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolOspfAreaTypeNssaOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolOspfAreaTypeNssa | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._acceptSummary !== undefined) {
      hasAnyValues = true;
      internalValueResult.acceptSummary = this._acceptSummary;
    }
    if (this._defaultRoute?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultRoute = this._defaultRoute?.internalValue;
    }
    if (this._nssaExtRange?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nssaExtRange = this._nssaExtRange?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolOspfAreaTypeNssa | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._acceptSummary = undefined;
      this._defaultRoute.internalValue = undefined;
      this._nssaExtRange.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._acceptSummary = value.acceptSummary;
      this._defaultRoute.internalValue = value.defaultRoute;
      this._nssaExtRange.internalValue = value.nssaExtRange;
    }
  }

  // accept_summary - computed: false, optional: true, required: false
  private _acceptSummary?: boolean | cdktf.IResolvable; 
  public get acceptSummary() {
    return this.getBooleanAttribute('accept_summary');
  }
  public set acceptSummary(value: boolean | cdktf.IResolvable) {
    this._acceptSummary = value;
  }
  public resetAcceptSummary() {
    this._acceptSummary = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get acceptSummaryInput() {
    return this._acceptSummary;
  }

  // default_route - computed: false, optional: true, required: false
  private _defaultRoute = new VirtualRouterProtocolOspfAreaTypeNssaDefaultRouteOutputReference(this, "default_route");
  public get defaultRoute() {
    return this._defaultRoute;
  }
  public putDefaultRoute(value: VirtualRouterProtocolOspfAreaTypeNssaDefaultRoute) {
    this._defaultRoute.internalValue = value;
  }
  public resetDefaultRoute() {
    this._defaultRoute.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultRouteInput() {
    return this._defaultRoute.internalValue;
  }

  // nssa_ext_range - computed: false, optional: true, required: false
  private _nssaExtRange = new VirtualRouterProtocolOspfAreaTypeNssaNssaExtRangeList(this, "nssa_ext_range", false);
  public get nssaExtRange() {
    return this._nssaExtRange;
  }
  public putNssaExtRange(value: VirtualRouterProtocolOspfAreaTypeNssaNssaExtRange[] | cdktf.IResolvable) {
    this._nssaExtRange.internalValue = value;
  }
  public resetNssaExtRange() {
    this._nssaExtRange.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nssaExtRangeInput() {
    return this._nssaExtRange.internalValue;
  }
}
export interface VirtualRouterProtocolOspfAreaTypeStubDefaultRouteAdvertise {
  /**
  * metric to be used when advertise default route within this stub area
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#metric VirtualRouter#metric}
  */
  readonly metric?: number;
}

export function virtualRouterProtocolOspfAreaTypeStubDefaultRouteAdvertiseToTerraform(struct?: VirtualRouterProtocolOspfAreaTypeStubDefaultRouteAdvertise | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    metric: cdktf.numberToTerraform(struct!.metric),
  }
}


export function virtualRouterProtocolOspfAreaTypeStubDefaultRouteAdvertiseToHclTerraform(struct?: VirtualRouterProtocolOspfAreaTypeStubDefaultRouteAdvertise | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    metric: {
      value: cdktf.numberToHclTerraform(struct!.metric),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolOspfAreaTypeStubDefaultRouteAdvertiseOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolOspfAreaTypeStubDefaultRouteAdvertise | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._metric !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolOspfAreaTypeStubDefaultRouteAdvertise | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._metric = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._metric = value.metric;
    }
  }

  // metric - computed: true, optional: true, required: false
  private _metric?: number; 
  public get metric() {
    return this.getNumberAttribute('metric');
  }
  public set metric(value: number) {
    this._metric = value;
  }
  public resetMetric() {
    this._metric = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric;
  }
}
export interface VirtualRouterProtocolOspfAreaTypeStubDefaultRouteDisable {
}

export function virtualRouterProtocolOspfAreaTypeStubDefaultRouteDisableToTerraform(struct?: VirtualRouterProtocolOspfAreaTypeStubDefaultRouteDisable | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function virtualRouterProtocolOspfAreaTypeStubDefaultRouteDisableToHclTerraform(struct?: VirtualRouterProtocolOspfAreaTypeStubDefaultRouteDisable | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class VirtualRouterProtocolOspfAreaTypeStubDefaultRouteDisableOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolOspfAreaTypeStubDefaultRouteDisable | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolOspfAreaTypeStubDefaultRouteDisable | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface VirtualRouterProtocolOspfAreaTypeStubDefaultRoute {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#advertise VirtualRouter#advertise}
  */
  readonly advertise?: VirtualRouterProtocolOspfAreaTypeStubDefaultRouteAdvertise;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#disable VirtualRouter#disable}
  */
  readonly disable?: VirtualRouterProtocolOspfAreaTypeStubDefaultRouteDisable;
}

export function virtualRouterProtocolOspfAreaTypeStubDefaultRouteToTerraform(struct?: VirtualRouterProtocolOspfAreaTypeStubDefaultRoute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    advertise: virtualRouterProtocolOspfAreaTypeStubDefaultRouteAdvertiseToTerraform(struct!.advertise),
    disable: virtualRouterProtocolOspfAreaTypeStubDefaultRouteDisableToTerraform(struct!.disable),
  }
}


export function virtualRouterProtocolOspfAreaTypeStubDefaultRouteToHclTerraform(struct?: VirtualRouterProtocolOspfAreaTypeStubDefaultRoute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    advertise: {
      value: virtualRouterProtocolOspfAreaTypeStubDefaultRouteAdvertiseToHclTerraform(struct!.advertise),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolOspfAreaTypeStubDefaultRouteAdvertise",
    },
    disable: {
      value: virtualRouterProtocolOspfAreaTypeStubDefaultRouteDisableToHclTerraform(struct!.disable),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolOspfAreaTypeStubDefaultRouteDisable",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolOspfAreaTypeStubDefaultRouteOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolOspfAreaTypeStubDefaultRoute | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._advertise?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.advertise = this._advertise?.internalValue;
    }
    if (this._disable?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.disable = this._disable?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolOspfAreaTypeStubDefaultRoute | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._advertise.internalValue = undefined;
      this._disable.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._advertise.internalValue = value.advertise;
      this._disable.internalValue = value.disable;
    }
  }

  // advertise - computed: false, optional: true, required: false
  private _advertise = new VirtualRouterProtocolOspfAreaTypeStubDefaultRouteAdvertiseOutputReference(this, "advertise");
  public get advertise() {
    return this._advertise;
  }
  public putAdvertise(value: VirtualRouterProtocolOspfAreaTypeStubDefaultRouteAdvertise) {
    this._advertise.internalValue = value;
  }
  public resetAdvertise() {
    this._advertise.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get advertiseInput() {
    return this._advertise.internalValue;
  }

  // disable - computed: false, optional: true, required: false
  private _disable = new VirtualRouterProtocolOspfAreaTypeStubDefaultRouteDisableOutputReference(this, "disable");
  public get disable() {
    return this._disable;
  }
  public putDisable(value: VirtualRouterProtocolOspfAreaTypeStubDefaultRouteDisable) {
    this._disable.internalValue = value;
  }
  public resetDisable() {
    this._disable.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableInput() {
    return this._disable.internalValue;
  }
}
export interface VirtualRouterProtocolOspfAreaTypeStub {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#accept_summary VirtualRouter#accept_summary}
  */
  readonly acceptSummary?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#default_route VirtualRouter#default_route}
  */
  readonly defaultRoute?: VirtualRouterProtocolOspfAreaTypeStubDefaultRoute;
}

export function virtualRouterProtocolOspfAreaTypeStubToTerraform(struct?: VirtualRouterProtocolOspfAreaTypeStub | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    accept_summary: cdktf.booleanToTerraform(struct!.acceptSummary),
    default_route: virtualRouterProtocolOspfAreaTypeStubDefaultRouteToTerraform(struct!.defaultRoute),
  }
}


export function virtualRouterProtocolOspfAreaTypeStubToHclTerraform(struct?: VirtualRouterProtocolOspfAreaTypeStub | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    accept_summary: {
      value: cdktf.booleanToHclTerraform(struct!.acceptSummary),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    default_route: {
      value: virtualRouterProtocolOspfAreaTypeStubDefaultRouteToHclTerraform(struct!.defaultRoute),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolOspfAreaTypeStubDefaultRoute",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolOspfAreaTypeStubOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolOspfAreaTypeStub | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._acceptSummary !== undefined) {
      hasAnyValues = true;
      internalValueResult.acceptSummary = this._acceptSummary;
    }
    if (this._defaultRoute?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultRoute = this._defaultRoute?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolOspfAreaTypeStub | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._acceptSummary = undefined;
      this._defaultRoute.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._acceptSummary = value.acceptSummary;
      this._defaultRoute.internalValue = value.defaultRoute;
    }
  }

  // accept_summary - computed: false, optional: true, required: false
  private _acceptSummary?: boolean | cdktf.IResolvable; 
  public get acceptSummary() {
    return this.getBooleanAttribute('accept_summary');
  }
  public set acceptSummary(value: boolean | cdktf.IResolvable) {
    this._acceptSummary = value;
  }
  public resetAcceptSummary() {
    this._acceptSummary = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get acceptSummaryInput() {
    return this._acceptSummary;
  }

  // default_route - computed: false, optional: true, required: false
  private _defaultRoute = new VirtualRouterProtocolOspfAreaTypeStubDefaultRouteOutputReference(this, "default_route");
  public get defaultRoute() {
    return this._defaultRoute;
  }
  public putDefaultRoute(value: VirtualRouterProtocolOspfAreaTypeStubDefaultRoute) {
    this._defaultRoute.internalValue = value;
  }
  public resetDefaultRoute() {
    this._defaultRoute.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultRouteInput() {
    return this._defaultRoute.internalValue;
  }
}
export interface VirtualRouterProtocolOspfAreaType {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#normal VirtualRouter#normal}
  */
  readonly normal?: VirtualRouterProtocolOspfAreaTypeNormal;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#nssa VirtualRouter#nssa}
  */
  readonly nssa?: VirtualRouterProtocolOspfAreaTypeNssa;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#stub VirtualRouter#stub}
  */
  readonly stub?: VirtualRouterProtocolOspfAreaTypeStub;
}

export function virtualRouterProtocolOspfAreaTypeToTerraform(struct?: VirtualRouterProtocolOspfAreaType | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    normal: virtualRouterProtocolOspfAreaTypeNormalToTerraform(struct!.normal),
    nssa: virtualRouterProtocolOspfAreaTypeNssaToTerraform(struct!.nssa),
    stub: virtualRouterProtocolOspfAreaTypeStubToTerraform(struct!.stub),
  }
}


export function virtualRouterProtocolOspfAreaTypeToHclTerraform(struct?: VirtualRouterProtocolOspfAreaType | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    normal: {
      value: virtualRouterProtocolOspfAreaTypeNormalToHclTerraform(struct!.normal),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolOspfAreaTypeNormal",
    },
    nssa: {
      value: virtualRouterProtocolOspfAreaTypeNssaToHclTerraform(struct!.nssa),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolOspfAreaTypeNssa",
    },
    stub: {
      value: virtualRouterProtocolOspfAreaTypeStubToHclTerraform(struct!.stub),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolOspfAreaTypeStub",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolOspfAreaTypeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolOspfAreaType | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._normal?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.normal = this._normal?.internalValue;
    }
    if (this._nssa?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nssa = this._nssa?.internalValue;
    }
    if (this._stub?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.stub = this._stub?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolOspfAreaType | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._normal.internalValue = undefined;
      this._nssa.internalValue = undefined;
      this._stub.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._normal.internalValue = value.normal;
      this._nssa.internalValue = value.nssa;
      this._stub.internalValue = value.stub;
    }
  }

  // normal - computed: false, optional: true, required: false
  private _normal = new VirtualRouterProtocolOspfAreaTypeNormalOutputReference(this, "normal");
  public get normal() {
    return this._normal;
  }
  public putNormal(value: VirtualRouterProtocolOspfAreaTypeNormal) {
    this._normal.internalValue = value;
  }
  public resetNormal() {
    this._normal.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get normalInput() {
    return this._normal.internalValue;
  }

  // nssa - computed: false, optional: true, required: false
  private _nssa = new VirtualRouterProtocolOspfAreaTypeNssaOutputReference(this, "nssa");
  public get nssa() {
    return this._nssa;
  }
  public putNssa(value: VirtualRouterProtocolOspfAreaTypeNssa) {
    this._nssa.internalValue = value;
  }
  public resetNssa() {
    this._nssa.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nssaInput() {
    return this._nssa.internalValue;
  }

  // stub - computed: false, optional: true, required: false
  private _stub = new VirtualRouterProtocolOspfAreaTypeStubOutputReference(this, "stub");
  public get stub() {
    return this._stub;
  }
  public putStub(value: VirtualRouterProtocolOspfAreaTypeStub) {
    this._stub.internalValue = value;
  }
  public resetStub() {
    this._stub.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stubInput() {
    return this._stub.internalValue;
  }
}
export interface VirtualRouterProtocolOspfAreaVirtualLinkBfd {
  /**
  * BFD profile
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#profile VirtualRouter#profile}
  */
  readonly profile?: string;
}

export function virtualRouterProtocolOspfAreaVirtualLinkBfdToTerraform(struct?: VirtualRouterProtocolOspfAreaVirtualLinkBfd | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    profile: cdktf.stringToTerraform(struct!.profile),
  }
}


export function virtualRouterProtocolOspfAreaVirtualLinkBfdToHclTerraform(struct?: VirtualRouterProtocolOspfAreaVirtualLinkBfd | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    profile: {
      value: cdktf.stringToHclTerraform(struct!.profile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolOspfAreaVirtualLinkBfdOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolOspfAreaVirtualLinkBfd | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._profile !== undefined) {
      hasAnyValues = true;
      internalValueResult.profile = this._profile;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolOspfAreaVirtualLinkBfd | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._profile = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._profile = value.profile;
    }
  }

  // profile - computed: true, optional: true, required: false
  private _profile?: string; 
  public get profile() {
    return this.getStringAttribute('profile');
  }
  public set profile(value: string) {
    this._profile = value;
  }
  public resetProfile() {
    this._profile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get profileInput() {
    return this._profile;
  }
}
export interface VirtualRouterProtocolOspfAreaVirtualLink {
  /**
  * Authentication options
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#authentication VirtualRouter#authentication}
  */
  readonly authentication?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#bfd VirtualRouter#bfd}
  */
  readonly bfd?: VirtualRouterProtocolOspfAreaVirtualLinkBfd;
  /**
  * number of lost hello packets to declare router down
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#dead_counts VirtualRouter#dead_counts}
  */
  readonly deadCounts?: number;
  /**
  * Enable this virtual link
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#enable VirtualRouter#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * Interval (in seconds) to send Hello packets
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#hello_interval VirtualRouter#hello_interval}
  */
  readonly helloInterval?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#name VirtualRouter#name}
  */
  readonly name: string;
  /**
  * neighbor router id for virtual link
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#neighbor_id VirtualRouter#neighbor_id}
  */
  readonly neighborId?: string;
  /**
  * Interval (in seconds) to retransmit LSAs
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#retransmit_interval VirtualRouter#retransmit_interval}
  */
  readonly retransmitInterval?: number;
  /**
  * id of transit area, cannot be backbone, stub or NSSA
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#transit_area_id VirtualRouter#transit_area_id}
  */
  readonly transitAreaId?: string;
  /**
  * Estimated delay (in seconds) to transmit LSAs
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#transit_delay VirtualRouter#transit_delay}
  */
  readonly transitDelay?: number;
}

export function virtualRouterProtocolOspfAreaVirtualLinkToTerraform(struct?: VirtualRouterProtocolOspfAreaVirtualLink | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    authentication: cdktf.stringToTerraform(struct!.authentication),
    bfd: virtualRouterProtocolOspfAreaVirtualLinkBfdToTerraform(struct!.bfd),
    dead_counts: cdktf.numberToTerraform(struct!.deadCounts),
    enable: cdktf.booleanToTerraform(struct!.enable),
    hello_interval: cdktf.numberToTerraform(struct!.helloInterval),
    name: cdktf.stringToTerraform(struct!.name),
    neighbor_id: cdktf.stringToTerraform(struct!.neighborId),
    retransmit_interval: cdktf.numberToTerraform(struct!.retransmitInterval),
    transit_area_id: cdktf.stringToTerraform(struct!.transitAreaId),
    transit_delay: cdktf.numberToTerraform(struct!.transitDelay),
  }
}


export function virtualRouterProtocolOspfAreaVirtualLinkToHclTerraform(struct?: VirtualRouterProtocolOspfAreaVirtualLink | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    authentication: {
      value: cdktf.stringToHclTerraform(struct!.authentication),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bfd: {
      value: virtualRouterProtocolOspfAreaVirtualLinkBfdToHclTerraform(struct!.bfd),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolOspfAreaVirtualLinkBfd",
    },
    dead_counts: {
      value: cdktf.numberToHclTerraform(struct!.deadCounts),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    hello_interval: {
      value: cdktf.numberToHclTerraform(struct!.helloInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    neighbor_id: {
      value: cdktf.stringToHclTerraform(struct!.neighborId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    retransmit_interval: {
      value: cdktf.numberToHclTerraform(struct!.retransmitInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    transit_area_id: {
      value: cdktf.stringToHclTerraform(struct!.transitAreaId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    transit_delay: {
      value: cdktf.numberToHclTerraform(struct!.transitDelay),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolOspfAreaVirtualLinkOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): VirtualRouterProtocolOspfAreaVirtualLink | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authentication !== undefined) {
      hasAnyValues = true;
      internalValueResult.authentication = this._authentication;
    }
    if (this._bfd?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.bfd = this._bfd?.internalValue;
    }
    if (this._deadCounts !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadCounts = this._deadCounts;
    }
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._helloInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.helloInterval = this._helloInterval;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._neighborId !== undefined) {
      hasAnyValues = true;
      internalValueResult.neighborId = this._neighborId;
    }
    if (this._retransmitInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.retransmitInterval = this._retransmitInterval;
    }
    if (this._transitAreaId !== undefined) {
      hasAnyValues = true;
      internalValueResult.transitAreaId = this._transitAreaId;
    }
    if (this._transitDelay !== undefined) {
      hasAnyValues = true;
      internalValueResult.transitDelay = this._transitDelay;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolOspfAreaVirtualLink | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authentication = undefined;
      this._bfd.internalValue = undefined;
      this._deadCounts = undefined;
      this._enable = undefined;
      this._helloInterval = undefined;
      this._name = undefined;
      this._neighborId = undefined;
      this._retransmitInterval = undefined;
      this._transitAreaId = undefined;
      this._transitDelay = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authentication = value.authentication;
      this._bfd.internalValue = value.bfd;
      this._deadCounts = value.deadCounts;
      this._enable = value.enable;
      this._helloInterval = value.helloInterval;
      this._name = value.name;
      this._neighborId = value.neighborId;
      this._retransmitInterval = value.retransmitInterval;
      this._transitAreaId = value.transitAreaId;
      this._transitDelay = value.transitDelay;
    }
  }

  // authentication - computed: false, optional: true, required: false
  private _authentication?: string; 
  public get authentication() {
    return this.getStringAttribute('authentication');
  }
  public set authentication(value: string) {
    this._authentication = value;
  }
  public resetAuthentication() {
    this._authentication = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authenticationInput() {
    return this._authentication;
  }

  // bfd - computed: false, optional: true, required: false
  private _bfd = new VirtualRouterProtocolOspfAreaVirtualLinkBfdOutputReference(this, "bfd");
  public get bfd() {
    return this._bfd;
  }
  public putBfd(value: VirtualRouterProtocolOspfAreaVirtualLinkBfd) {
    this._bfd.internalValue = value;
  }
  public resetBfd() {
    this._bfd.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bfdInput() {
    return this._bfd.internalValue;
  }

  // dead_counts - computed: true, optional: true, required: false
  private _deadCounts?: number; 
  public get deadCounts() {
    return this.getNumberAttribute('dead_counts');
  }
  public set deadCounts(value: number) {
    this._deadCounts = value;
  }
  public resetDeadCounts() {
    this._deadCounts = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadCountsInput() {
    return this._deadCounts;
  }

  // enable - computed: false, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // hello_interval - computed: true, optional: true, required: false
  private _helloInterval?: number; 
  public get helloInterval() {
    return this.getNumberAttribute('hello_interval');
  }
  public set helloInterval(value: number) {
    this._helloInterval = value;
  }
  public resetHelloInterval() {
    this._helloInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get helloIntervalInput() {
    return this._helloInterval;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // neighbor_id - computed: false, optional: true, required: false
  private _neighborId?: string; 
  public get neighborId() {
    return this.getStringAttribute('neighbor_id');
  }
  public set neighborId(value: string) {
    this._neighborId = value;
  }
  public resetNeighborId() {
    this._neighborId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get neighborIdInput() {
    return this._neighborId;
  }

  // retransmit_interval - computed: true, optional: true, required: false
  private _retransmitInterval?: number; 
  public get retransmitInterval() {
    return this.getNumberAttribute('retransmit_interval');
  }
  public set retransmitInterval(value: number) {
    this._retransmitInterval = value;
  }
  public resetRetransmitInterval() {
    this._retransmitInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retransmitIntervalInput() {
    return this._retransmitInterval;
  }

  // transit_area_id - computed: false, optional: true, required: false
  private _transitAreaId?: string; 
  public get transitAreaId() {
    return this.getStringAttribute('transit_area_id');
  }
  public set transitAreaId(value: string) {
    this._transitAreaId = value;
  }
  public resetTransitAreaId() {
    this._transitAreaId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get transitAreaIdInput() {
    return this._transitAreaId;
  }

  // transit_delay - computed: true, optional: true, required: false
  private _transitDelay?: number; 
  public get transitDelay() {
    return this.getNumberAttribute('transit_delay');
  }
  public set transitDelay(value: number) {
    this._transitDelay = value;
  }
  public resetTransitDelay() {
    this._transitDelay = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get transitDelayInput() {
    return this._transitDelay;
  }
}

export class VirtualRouterProtocolOspfAreaVirtualLinkList extends cdktf.ComplexList {
  public internalValue? : VirtualRouterProtocolOspfAreaVirtualLink[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): VirtualRouterProtocolOspfAreaVirtualLinkOutputReference {
    return new VirtualRouterProtocolOspfAreaVirtualLinkOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface VirtualRouterProtocolOspfArea {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#interface VirtualRouter#interface}
  */
  readonly interface?: VirtualRouterProtocolOspfAreaInterface[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#name VirtualRouter#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#range VirtualRouter#range}
  */
  readonly range?: VirtualRouterProtocolOspfAreaRange[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#type VirtualRouter#type}
  */
  readonly type?: VirtualRouterProtocolOspfAreaType;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#virtual_link VirtualRouter#virtual_link}
  */
  readonly virtualLink?: VirtualRouterProtocolOspfAreaVirtualLink[] | cdktf.IResolvable;
}

export function virtualRouterProtocolOspfAreaToTerraform(struct?: VirtualRouterProtocolOspfArea | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    interface: cdktf.listMapper(virtualRouterProtocolOspfAreaInterfaceToTerraform, false)(struct!.interface),
    name: cdktf.stringToTerraform(struct!.name),
    range: cdktf.listMapper(virtualRouterProtocolOspfAreaRangeToTerraform, false)(struct!.range),
    type: virtualRouterProtocolOspfAreaTypeToTerraform(struct!.type),
    virtual_link: cdktf.listMapper(virtualRouterProtocolOspfAreaVirtualLinkToTerraform, false)(struct!.virtualLink),
  }
}


export function virtualRouterProtocolOspfAreaToHclTerraform(struct?: VirtualRouterProtocolOspfArea | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    interface: {
      value: cdktf.listMapperHcl(virtualRouterProtocolOspfAreaInterfaceToHclTerraform, false)(struct!.interface),
      isBlock: true,
      type: "list",
      storageClassType: "VirtualRouterProtocolOspfAreaInterfaceList",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    range: {
      value: cdktf.listMapperHcl(virtualRouterProtocolOspfAreaRangeToHclTerraform, false)(struct!.range),
      isBlock: true,
      type: "list",
      storageClassType: "VirtualRouterProtocolOspfAreaRangeList",
    },
    type: {
      value: virtualRouterProtocolOspfAreaTypeToHclTerraform(struct!.type),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolOspfAreaType",
    },
    virtual_link: {
      value: cdktf.listMapperHcl(virtualRouterProtocolOspfAreaVirtualLinkToHclTerraform, false)(struct!.virtualLink),
      isBlock: true,
      type: "list",
      storageClassType: "VirtualRouterProtocolOspfAreaVirtualLinkList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolOspfAreaOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): VirtualRouterProtocolOspfArea | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._interface?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.interface = this._interface?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._range?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.range = this._range?.internalValue;
    }
    if (this._type?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type?.internalValue;
    }
    if (this._virtualLink?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.virtualLink = this._virtualLink?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolOspfArea | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._interface.internalValue = undefined;
      this._name = undefined;
      this._range.internalValue = undefined;
      this._type.internalValue = undefined;
      this._virtualLink.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._interface.internalValue = value.interface;
      this._name = value.name;
      this._range.internalValue = value.range;
      this._type.internalValue = value.type;
      this._virtualLink.internalValue = value.virtualLink;
    }
  }

  // interface - computed: false, optional: true, required: false
  private _interface = new VirtualRouterProtocolOspfAreaInterfaceList(this, "interface", false);
  public get interface() {
    return this._interface;
  }
  public putInterface(value: VirtualRouterProtocolOspfAreaInterface[] | cdktf.IResolvable) {
    this._interface.internalValue = value;
  }
  public resetInterface() {
    this._interface.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfaceInput() {
    return this._interface.internalValue;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // range - computed: false, optional: true, required: false
  private _range = new VirtualRouterProtocolOspfAreaRangeList(this, "range", false);
  public get range() {
    return this._range;
  }
  public putRange(value: VirtualRouterProtocolOspfAreaRange[] | cdktf.IResolvable) {
    this._range.internalValue = value;
  }
  public resetRange() {
    this._range.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rangeInput() {
    return this._range.internalValue;
  }

  // type - computed: false, optional: true, required: false
  private _type = new VirtualRouterProtocolOspfAreaTypeOutputReference(this, "type");
  public get type() {
    return this._type;
  }
  public putType(value: VirtualRouterProtocolOspfAreaType) {
    this._type.internalValue = value;
  }
  public resetType() {
    this._type.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type.internalValue;
  }

  // virtual_link - computed: false, optional: true, required: false
  private _virtualLink = new VirtualRouterProtocolOspfAreaVirtualLinkList(this, "virtual_link", false);
  public get virtualLink() {
    return this._virtualLink;
  }
  public putVirtualLink(value: VirtualRouterProtocolOspfAreaVirtualLink[] | cdktf.IResolvable) {
    this._virtualLink.internalValue = value;
  }
  public resetVirtualLink() {
    this._virtualLink.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get virtualLinkInput() {
    return this._virtualLink.internalValue;
  }
}

export class VirtualRouterProtocolOspfAreaList extends cdktf.ComplexList {
  public internalValue? : VirtualRouterProtocolOspfArea[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): VirtualRouterProtocolOspfAreaOutputReference {
    return new VirtualRouterProtocolOspfAreaOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface VirtualRouterProtocolOspfAuthProfileMd5 {
  /**
  * key for the authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#key VirtualRouter#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#name VirtualRouter#name}
  */
  readonly name: string;
  /**
  * use this key when sending packet
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#preferred VirtualRouter#preferred}
  */
  readonly preferred?: boolean | cdktf.IResolvable;
}

export function virtualRouterProtocolOspfAuthProfileMd5ToTerraform(struct?: VirtualRouterProtocolOspfAuthProfileMd5 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    preferred: cdktf.booleanToTerraform(struct!.preferred),
  }
}


export function virtualRouterProtocolOspfAuthProfileMd5ToHclTerraform(struct?: VirtualRouterProtocolOspfAuthProfileMd5 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    preferred: {
      value: cdktf.booleanToHclTerraform(struct!.preferred),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolOspfAuthProfileMd5OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): VirtualRouterProtocolOspfAuthProfileMd5 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._preferred !== undefined) {
      hasAnyValues = true;
      internalValueResult.preferred = this._preferred;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolOspfAuthProfileMd5 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._preferred = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._preferred = value.preferred;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // preferred - computed: false, optional: true, required: false
  private _preferred?: boolean | cdktf.IResolvable; 
  public get preferred() {
    return this.getBooleanAttribute('preferred');
  }
  public set preferred(value: boolean | cdktf.IResolvable) {
    this._preferred = value;
  }
  public resetPreferred() {
    this._preferred = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preferredInput() {
    return this._preferred;
  }
}

export class VirtualRouterProtocolOspfAuthProfileMd5List extends cdktf.ComplexList {
  public internalValue? : VirtualRouterProtocolOspfAuthProfileMd5[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): VirtualRouterProtocolOspfAuthProfileMd5OutputReference {
    return new VirtualRouterProtocolOspfAuthProfileMd5OutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface VirtualRouterProtocolOspfAuthProfile {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#md5 VirtualRouter#md5}
  */
  readonly md5?: VirtualRouterProtocolOspfAuthProfileMd5[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#name VirtualRouter#name}
  */
  readonly name: string;
  /**
  * Simple password authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#password VirtualRouter#password}
  */
  readonly password?: string;
}

export function virtualRouterProtocolOspfAuthProfileToTerraform(struct?: VirtualRouterProtocolOspfAuthProfile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    md5: cdktf.listMapper(virtualRouterProtocolOspfAuthProfileMd5ToTerraform, false)(struct!.md5),
    name: cdktf.stringToTerraform(struct!.name),
    password: cdktf.stringToTerraform(struct!.password),
  }
}


export function virtualRouterProtocolOspfAuthProfileToHclTerraform(struct?: VirtualRouterProtocolOspfAuthProfile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    md5: {
      value: cdktf.listMapperHcl(virtualRouterProtocolOspfAuthProfileMd5ToHclTerraform, false)(struct!.md5),
      isBlock: true,
      type: "list",
      storageClassType: "VirtualRouterProtocolOspfAuthProfileMd5List",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolOspfAuthProfileOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): VirtualRouterProtocolOspfAuthProfile | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._md5?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.md5 = this._md5?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolOspfAuthProfile | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._md5.internalValue = undefined;
      this._name = undefined;
      this._password = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._md5.internalValue = value.md5;
      this._name = value.name;
      this._password = value.password;
    }
  }

  // md5 - computed: false, optional: true, required: false
  private _md5 = new VirtualRouterProtocolOspfAuthProfileMd5List(this, "md5", false);
  public get md5() {
    return this._md5;
  }
  public putMd5(value: VirtualRouterProtocolOspfAuthProfileMd5[] | cdktf.IResolvable) {
    this._md5.internalValue = value;
  }
  public resetMd5() {
    this._md5.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get md5Input() {
    return this._md5.internalValue;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }
}

export class VirtualRouterProtocolOspfAuthProfileList extends cdktf.ComplexList {
  public internalValue? : VirtualRouterProtocolOspfAuthProfile[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): VirtualRouterProtocolOspfAuthProfileOutputReference {
    return new VirtualRouterProtocolOspfAuthProfileOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface VirtualRouterProtocolOspfExportRules {
  /**
  * metric value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#metric VirtualRouter#metric}
  */
  readonly metric?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#name VirtualRouter#name}
  */
  readonly name: string;
  /**
  * path type to be used for imported external routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#new_path_type VirtualRouter#new_path_type}
  */
  readonly newPathType?: string;
  /**
  * new tag value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#new_tag VirtualRouter#new_tag}
  */
  readonly newTag?: string;
}

export function virtualRouterProtocolOspfExportRulesToTerraform(struct?: VirtualRouterProtocolOspfExportRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    metric: cdktf.numberToTerraform(struct!.metric),
    name: cdktf.stringToTerraform(struct!.name),
    new_path_type: cdktf.stringToTerraform(struct!.newPathType),
    new_tag: cdktf.stringToTerraform(struct!.newTag),
  }
}


export function virtualRouterProtocolOspfExportRulesToHclTerraform(struct?: VirtualRouterProtocolOspfExportRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    metric: {
      value: cdktf.numberToHclTerraform(struct!.metric),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    new_path_type: {
      value: cdktf.stringToHclTerraform(struct!.newPathType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    new_tag: {
      value: cdktf.stringToHclTerraform(struct!.newTag),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolOspfExportRulesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): VirtualRouterProtocolOspfExportRules | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._metric !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._newPathType !== undefined) {
      hasAnyValues = true;
      internalValueResult.newPathType = this._newPathType;
    }
    if (this._newTag !== undefined) {
      hasAnyValues = true;
      internalValueResult.newTag = this._newTag;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolOspfExportRules | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._metric = undefined;
      this._name = undefined;
      this._newPathType = undefined;
      this._newTag = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._metric = value.metric;
      this._name = value.name;
      this._newPathType = value.newPathType;
      this._newTag = value.newTag;
    }
  }

  // metric - computed: false, optional: true, required: false
  private _metric?: number; 
  public get metric() {
    return this.getNumberAttribute('metric');
  }
  public set metric(value: number) {
    this._metric = value;
  }
  public resetMetric() {
    this._metric = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // new_path_type - computed: true, optional: true, required: false
  private _newPathType?: string; 
  public get newPathType() {
    return this.getStringAttribute('new_path_type');
  }
  public set newPathType(value: string) {
    this._newPathType = value;
  }
  public resetNewPathType() {
    this._newPathType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get newPathTypeInput() {
    return this._newPathType;
  }

  // new_tag - computed: false, optional: true, required: false
  private _newTag?: string; 
  public get newTag() {
    return this.getStringAttribute('new_tag');
  }
  public set newTag(value: string) {
    this._newTag = value;
  }
  public resetNewTag() {
    this._newTag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get newTagInput() {
    return this._newTag;
  }
}

export class VirtualRouterProtocolOspfExportRulesList extends cdktf.ComplexList {
  public internalValue? : VirtualRouterProtocolOspfExportRules[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): VirtualRouterProtocolOspfExportRulesOutputReference {
    return new VirtualRouterProtocolOspfExportRulesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface VirtualRouterProtocolOspfGlobalBfd {
  /**
  * BFD profile
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#profile VirtualRouter#profile}
  */
  readonly profile?: string;
}

export function virtualRouterProtocolOspfGlobalBfdToTerraform(struct?: VirtualRouterProtocolOspfGlobalBfd | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    profile: cdktf.stringToTerraform(struct!.profile),
  }
}


export function virtualRouterProtocolOspfGlobalBfdToHclTerraform(struct?: VirtualRouterProtocolOspfGlobalBfd | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    profile: {
      value: cdktf.stringToHclTerraform(struct!.profile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolOspfGlobalBfdOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolOspfGlobalBfd | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._profile !== undefined) {
      hasAnyValues = true;
      internalValueResult.profile = this._profile;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolOspfGlobalBfd | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._profile = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._profile = value.profile;
    }
  }

  // profile - computed: true, optional: true, required: false
  private _profile?: string; 
  public get profile() {
    return this.getStringAttribute('profile');
  }
  public set profile(value: string) {
    this._profile = value;
  }
  public resetProfile() {
    this._profile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get profileInput() {
    return this._profile;
  }
}
export interface VirtualRouterProtocolOspfGracefulRestart {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#enable VirtualRouter#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * maximum local restarting time (in seconds)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#grace_period VirtualRouter#grace_period}
  */
  readonly gracePeriod?: number;
  /**
  * enable/disable helping neighboring routers to graceful restart
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#helper_enable VirtualRouter#helper_enable}
  */
  readonly helperEnable?: boolean | cdktf.IResolvable;
  /**
  * maximum of neighbor restart time accepted (in seconds)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#max_neighbor_restart_time VirtualRouter#max_neighbor_restart_time}
  */
  readonly maxNeighborRestartTime?: number;
  /**
  * enable/disable strict LSA checking. Abort GR if lsa change is detected
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#strict_l_s_a_checking VirtualRouter#strict_l_s_a_checking}
  */
  readonly strictLSAChecking?: boolean | cdktf.IResolvable;
}

export function virtualRouterProtocolOspfGracefulRestartToTerraform(struct?: VirtualRouterProtocolOspfGracefulRestart | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enable: cdktf.booleanToTerraform(struct!.enable),
    grace_period: cdktf.numberToTerraform(struct!.gracePeriod),
    helper_enable: cdktf.booleanToTerraform(struct!.helperEnable),
    max_neighbor_restart_time: cdktf.numberToTerraform(struct!.maxNeighborRestartTime),
    strict_l_s_a_checking: cdktf.booleanToTerraform(struct!.strictLSAChecking),
  }
}


export function virtualRouterProtocolOspfGracefulRestartToHclTerraform(struct?: VirtualRouterProtocolOspfGracefulRestart | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    grace_period: {
      value: cdktf.numberToHclTerraform(struct!.gracePeriod),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    helper_enable: {
      value: cdktf.booleanToHclTerraform(struct!.helperEnable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_neighbor_restart_time: {
      value: cdktf.numberToHclTerraform(struct!.maxNeighborRestartTime),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    strict_l_s_a_checking: {
      value: cdktf.booleanToHclTerraform(struct!.strictLSAChecking),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolOspfGracefulRestartOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolOspfGracefulRestart | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._gracePeriod !== undefined) {
      hasAnyValues = true;
      internalValueResult.gracePeriod = this._gracePeriod;
    }
    if (this._helperEnable !== undefined) {
      hasAnyValues = true;
      internalValueResult.helperEnable = this._helperEnable;
    }
    if (this._maxNeighborRestartTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxNeighborRestartTime = this._maxNeighborRestartTime;
    }
    if (this._strictLSAChecking !== undefined) {
      hasAnyValues = true;
      internalValueResult.strictLSAChecking = this._strictLSAChecking;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolOspfGracefulRestart | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enable = undefined;
      this._gracePeriod = undefined;
      this._helperEnable = undefined;
      this._maxNeighborRestartTime = undefined;
      this._strictLSAChecking = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enable = value.enable;
      this._gracePeriod = value.gracePeriod;
      this._helperEnable = value.helperEnable;
      this._maxNeighborRestartTime = value.maxNeighborRestartTime;
      this._strictLSAChecking = value.strictLSAChecking;
    }
  }

  // enable - computed: false, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // grace_period - computed: true, optional: true, required: false
  private _gracePeriod?: number; 
  public get gracePeriod() {
    return this.getNumberAttribute('grace_period');
  }
  public set gracePeriod(value: number) {
    this._gracePeriod = value;
  }
  public resetGracePeriod() {
    this._gracePeriod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gracePeriodInput() {
    return this._gracePeriod;
  }

  // helper_enable - computed: false, optional: true, required: false
  private _helperEnable?: boolean | cdktf.IResolvable; 
  public get helperEnable() {
    return this.getBooleanAttribute('helper_enable');
  }
  public set helperEnable(value: boolean | cdktf.IResolvable) {
    this._helperEnable = value;
  }
  public resetHelperEnable() {
    this._helperEnable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get helperEnableInput() {
    return this._helperEnable;
  }

  // max_neighbor_restart_time - computed: true, optional: true, required: false
  private _maxNeighborRestartTime?: number; 
  public get maxNeighborRestartTime() {
    return this.getNumberAttribute('max_neighbor_restart_time');
  }
  public set maxNeighborRestartTime(value: number) {
    this._maxNeighborRestartTime = value;
  }
  public resetMaxNeighborRestartTime() {
    this._maxNeighborRestartTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxNeighborRestartTimeInput() {
    return this._maxNeighborRestartTime;
  }

  // strict_l_s_a_checking - computed: false, optional: true, required: false
  private _strictLSAChecking?: boolean | cdktf.IResolvable; 
  public get strictLSAChecking() {
    return this.getBooleanAttribute('strict_l_s_a_checking');
  }
  public set strictLSAChecking(value: boolean | cdktf.IResolvable) {
    this._strictLSAChecking = value;
  }
  public resetStrictLSAChecking() {
    this._strictLSAChecking = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get strictLSACheckingInput() {
    return this._strictLSAChecking;
  }
}
export interface VirtualRouterProtocolOspfTimers {
  /**
  * The minimum time in seconds between distinct originations of any particular LSA
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#lsa_interval VirtualRouter#lsa_interval}
  */
  readonly lsaInterval?: number;
  /**
  * Delay in seconds before running the SPF algorithm
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#spf_calculation_delay VirtualRouter#spf_calculation_delay}
  */
  readonly spfCalculationDelay?: number;
}

export function virtualRouterProtocolOspfTimersToTerraform(struct?: VirtualRouterProtocolOspfTimers | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    lsa_interval: cdktf.numberToTerraform(struct!.lsaInterval),
    spf_calculation_delay: cdktf.numberToTerraform(struct!.spfCalculationDelay),
  }
}


export function virtualRouterProtocolOspfTimersToHclTerraform(struct?: VirtualRouterProtocolOspfTimers | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    lsa_interval: {
      value: cdktf.numberToHclTerraform(struct!.lsaInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    spf_calculation_delay: {
      value: cdktf.numberToHclTerraform(struct!.spfCalculationDelay),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolOspfTimersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolOspfTimers | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._lsaInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.lsaInterval = this._lsaInterval;
    }
    if (this._spfCalculationDelay !== undefined) {
      hasAnyValues = true;
      internalValueResult.spfCalculationDelay = this._spfCalculationDelay;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolOspfTimers | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._lsaInterval = undefined;
      this._spfCalculationDelay = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._lsaInterval = value.lsaInterval;
      this._spfCalculationDelay = value.spfCalculationDelay;
    }
  }

  // lsa_interval - computed: false, optional: true, required: false
  private _lsaInterval?: number; 
  public get lsaInterval() {
    return this.getNumberAttribute('lsa_interval');
  }
  public set lsaInterval(value: number) {
    this._lsaInterval = value;
  }
  public resetLsaInterval() {
    this._lsaInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lsaIntervalInput() {
    return this._lsaInterval;
  }

  // spf_calculation_delay - computed: false, optional: true, required: false
  private _spfCalculationDelay?: number; 
  public get spfCalculationDelay() {
    return this.getNumberAttribute('spf_calculation_delay');
  }
  public set spfCalculationDelay(value: number) {
    this._spfCalculationDelay = value;
  }
  public resetSpfCalculationDelay() {
    this._spfCalculationDelay = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get spfCalculationDelayInput() {
    return this._spfCalculationDelay;
  }
}
export interface VirtualRouterProtocolOspf {
  /**
  * allow redistribute default route to OSPF
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#allow_redist_default_route VirtualRouter#allow_redist_default_route}
  */
  readonly allowRedistDefaultRoute?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#area VirtualRouter#area}
  */
  readonly area?: VirtualRouterProtocolOspfArea[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#auth_profile VirtualRouter#auth_profile}
  */
  readonly authProfile?: VirtualRouterProtocolOspfAuthProfile[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#enable VirtualRouter#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#export_rules VirtualRouter#export_rules}
  */
  readonly exportRules?: VirtualRouterProtocolOspfExportRules[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#global_bfd VirtualRouter#global_bfd}
  */
  readonly globalBfd?: VirtualRouterProtocolOspfGlobalBfd;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#graceful_restart VirtualRouter#graceful_restart}
  */
  readonly gracefulRestart?: VirtualRouterProtocolOspfGracefulRestart;
  /**
  * do not learn default route from OSPF
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#reject_default_route VirtualRouter#reject_default_route}
  */
  readonly rejectDefaultRoute?: boolean | cdktf.IResolvable;
  /**
  * rfc-1583 compatibility
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#rfc1583 VirtualRouter#rfc1583}
  */
  readonly rfc1583?: boolean | cdktf.IResolvable;
  /**
  * router id of this OSPF instance
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#router_id VirtualRouter#router_id}
  */
  readonly routerId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#timers VirtualRouter#timers}
  */
  readonly timers?: VirtualRouterProtocolOspfTimers;
}

export function virtualRouterProtocolOspfToTerraform(struct?: VirtualRouterProtocolOspf | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_redist_default_route: cdktf.booleanToTerraform(struct!.allowRedistDefaultRoute),
    area: cdktf.listMapper(virtualRouterProtocolOspfAreaToTerraform, false)(struct!.area),
    auth_profile: cdktf.listMapper(virtualRouterProtocolOspfAuthProfileToTerraform, false)(struct!.authProfile),
    enable: cdktf.booleanToTerraform(struct!.enable),
    export_rules: cdktf.listMapper(virtualRouterProtocolOspfExportRulesToTerraform, false)(struct!.exportRules),
    global_bfd: virtualRouterProtocolOspfGlobalBfdToTerraform(struct!.globalBfd),
    graceful_restart: virtualRouterProtocolOspfGracefulRestartToTerraform(struct!.gracefulRestart),
    reject_default_route: cdktf.booleanToTerraform(struct!.rejectDefaultRoute),
    rfc1583: cdktf.booleanToTerraform(struct!.rfc1583),
    router_id: cdktf.stringToTerraform(struct!.routerId),
    timers: virtualRouterProtocolOspfTimersToTerraform(struct!.timers),
  }
}


export function virtualRouterProtocolOspfToHclTerraform(struct?: VirtualRouterProtocolOspf | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_redist_default_route: {
      value: cdktf.booleanToHclTerraform(struct!.allowRedistDefaultRoute),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    area: {
      value: cdktf.listMapperHcl(virtualRouterProtocolOspfAreaToHclTerraform, false)(struct!.area),
      isBlock: true,
      type: "list",
      storageClassType: "VirtualRouterProtocolOspfAreaList",
    },
    auth_profile: {
      value: cdktf.listMapperHcl(virtualRouterProtocolOspfAuthProfileToHclTerraform, false)(struct!.authProfile),
      isBlock: true,
      type: "list",
      storageClassType: "VirtualRouterProtocolOspfAuthProfileList",
    },
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    export_rules: {
      value: cdktf.listMapperHcl(virtualRouterProtocolOspfExportRulesToHclTerraform, false)(struct!.exportRules),
      isBlock: true,
      type: "list",
      storageClassType: "VirtualRouterProtocolOspfExportRulesList",
    },
    global_bfd: {
      value: virtualRouterProtocolOspfGlobalBfdToHclTerraform(struct!.globalBfd),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolOspfGlobalBfd",
    },
    graceful_restart: {
      value: virtualRouterProtocolOspfGracefulRestartToHclTerraform(struct!.gracefulRestart),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolOspfGracefulRestart",
    },
    reject_default_route: {
      value: cdktf.booleanToHclTerraform(struct!.rejectDefaultRoute),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    rfc1583: {
      value: cdktf.booleanToHclTerraform(struct!.rfc1583),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    router_id: {
      value: cdktf.stringToHclTerraform(struct!.routerId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timers: {
      value: virtualRouterProtocolOspfTimersToHclTerraform(struct!.timers),
      isBlock: true,
      type: "struct",
      storageClassType: "VirtualRouterProtocolOspfTimers",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolOspfOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolOspf | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowRedistDefaultRoute !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowRedistDefaultRoute = this._allowRedistDefaultRoute;
    }
    if (this._area?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.area = this._area?.internalValue;
    }
    if (this._authProfile?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authProfile = this._authProfile?.internalValue;
    }
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._exportRules?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.exportRules = this._exportRules?.internalValue;
    }
    if (this._globalBfd?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.globalBfd = this._globalBfd?.internalValue;
    }
    if (this._gracefulRestart?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.gracefulRestart = this._gracefulRestart?.internalValue;
    }
    if (this._rejectDefaultRoute !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectDefaultRoute = this._rejectDefaultRoute;
    }
    if (this._rfc1583 !== undefined) {
      hasAnyValues = true;
      internalValueResult.rfc1583 = this._rfc1583;
    }
    if (this._routerId !== undefined) {
      hasAnyValues = true;
      internalValueResult.routerId = this._routerId;
    }
    if (this._timers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timers = this._timers?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolOspf | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allowRedistDefaultRoute = undefined;
      this._area.internalValue = undefined;
      this._authProfile.internalValue = undefined;
      this._enable = undefined;
      this._exportRules.internalValue = undefined;
      this._globalBfd.internalValue = undefined;
      this._gracefulRestart.internalValue = undefined;
      this._rejectDefaultRoute = undefined;
      this._rfc1583 = undefined;
      this._routerId = undefined;
      this._timers.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allowRedistDefaultRoute = value.allowRedistDefaultRoute;
      this._area.internalValue = value.area;
      this._authProfile.internalValue = value.authProfile;
      this._enable = value.enable;
      this._exportRules.internalValue = value.exportRules;
      this._globalBfd.internalValue = value.globalBfd;
      this._gracefulRestart.internalValue = value.gracefulRestart;
      this._rejectDefaultRoute = value.rejectDefaultRoute;
      this._rfc1583 = value.rfc1583;
      this._routerId = value.routerId;
      this._timers.internalValue = value.timers;
    }
  }

  // allow_redist_default_route - computed: false, optional: true, required: false
  private _allowRedistDefaultRoute?: boolean | cdktf.IResolvable; 
  public get allowRedistDefaultRoute() {
    return this.getBooleanAttribute('allow_redist_default_route');
  }
  public set allowRedistDefaultRoute(value: boolean | cdktf.IResolvable) {
    this._allowRedistDefaultRoute = value;
  }
  public resetAllowRedistDefaultRoute() {
    this._allowRedistDefaultRoute = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowRedistDefaultRouteInput() {
    return this._allowRedistDefaultRoute;
  }

  // area - computed: false, optional: true, required: false
  private _area = new VirtualRouterProtocolOspfAreaList(this, "area", false);
  public get area() {
    return this._area;
  }
  public putArea(value: VirtualRouterProtocolOspfArea[] | cdktf.IResolvable) {
    this._area.internalValue = value;
  }
  public resetArea() {
    this._area.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get areaInput() {
    return this._area.internalValue;
  }

  // auth_profile - computed: false, optional: true, required: false
  private _authProfile = new VirtualRouterProtocolOspfAuthProfileList(this, "auth_profile", false);
  public get authProfile() {
    return this._authProfile;
  }
  public putAuthProfile(value: VirtualRouterProtocolOspfAuthProfile[] | cdktf.IResolvable) {
    this._authProfile.internalValue = value;
  }
  public resetAuthProfile() {
    this._authProfile.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authProfileInput() {
    return this._authProfile.internalValue;
  }

  // enable - computed: false, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // export_rules - computed: false, optional: true, required: false
  private _exportRules = new VirtualRouterProtocolOspfExportRulesList(this, "export_rules", false);
  public get exportRules() {
    return this._exportRules;
  }
  public putExportRules(value: VirtualRouterProtocolOspfExportRules[] | cdktf.IResolvable) {
    this._exportRules.internalValue = value;
  }
  public resetExportRules() {
    this._exportRules.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exportRulesInput() {
    return this._exportRules.internalValue;
  }

  // global_bfd - computed: false, optional: true, required: false
  private _globalBfd = new VirtualRouterProtocolOspfGlobalBfdOutputReference(this, "global_bfd");
  public get globalBfd() {
    return this._globalBfd;
  }
  public putGlobalBfd(value: VirtualRouterProtocolOspfGlobalBfd) {
    this._globalBfd.internalValue = value;
  }
  public resetGlobalBfd() {
    this._globalBfd.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get globalBfdInput() {
    return this._globalBfd.internalValue;
  }

  // graceful_restart - computed: false, optional: true, required: false
  private _gracefulRestart = new VirtualRouterProtocolOspfGracefulRestartOutputReference(this, "graceful_restart");
  public get gracefulRestart() {
    return this._gracefulRestart;
  }
  public putGracefulRestart(value: VirtualRouterProtocolOspfGracefulRestart) {
    this._gracefulRestart.internalValue = value;
  }
  public resetGracefulRestart() {
    this._gracefulRestart.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gracefulRestartInput() {
    return this._gracefulRestart.internalValue;
  }

  // reject_default_route - computed: false, optional: true, required: false
  private _rejectDefaultRoute?: boolean | cdktf.IResolvable; 
  public get rejectDefaultRoute() {
    return this.getBooleanAttribute('reject_default_route');
  }
  public set rejectDefaultRoute(value: boolean | cdktf.IResolvable) {
    this._rejectDefaultRoute = value;
  }
  public resetRejectDefaultRoute() {
    this._rejectDefaultRoute = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectDefaultRouteInput() {
    return this._rejectDefaultRoute;
  }

  // rfc1583 - computed: false, optional: true, required: false
  private _rfc1583?: boolean | cdktf.IResolvable; 
  public get rfc1583() {
    return this.getBooleanAttribute('rfc1583');
  }
  public set rfc1583(value: boolean | cdktf.IResolvable) {
    this._rfc1583 = value;
  }
  public resetRfc1583() {
    this._rfc1583 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rfc1583Input() {
    return this._rfc1583;
  }

  // router_id - computed: false, optional: true, required: false
  private _routerId?: string; 
  public get routerId() {
    return this.getStringAttribute('router_id');
  }
  public set routerId(value: string) {
    this._routerId = value;
  }
  public resetRouterId() {
    this._routerId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routerIdInput() {
    return this._routerId;
  }

  // timers - computed: false, optional: true, required: false
  private _timers = new VirtualRouterProtocolOspfTimersOutputReference(this, "timers");
  public get timers() {
    return this._timers;
  }
  public putTimers(value: VirtualRouterProtocolOspfTimers) {
    this._timers.internalValue = value;
  }
  public resetTimers() {
    this._timers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timersInput() {
    return this._timers.internalValue;
  }
}
export interface VirtualRouterProtocolOspfv3AreaInterfaceBfd {
  /**
  * BFD profile
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/panos/2.0.5/docs/resources/virtual_router#profile VirtualRouter#profile}
  */
  readonly profile?: string;
}

export function virtualRouterProtocolOspfv3AreaInterfaceBfdToTerraform(struct?: VirtualRouterProtocolOspfv3AreaInterfaceBfd | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    profile: cdktf.stringToTerraform(struct!.profile),
  }
}


export function virtualRouterProtocolOspfv3AreaInterfaceBfdToHclTerraform(struct?: VirtualRouterProtocolOspfv3AreaInterfaceBfd | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    profile: {
      value: cdktf.stringToHclTerraform(struct!.profile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VirtualRouterProtocolOspfv3AreaInterfaceBfdOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolOspfv3AreaInterfaceBfd | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._profile !== undefined) {
      hasAnyValues = true;
      internalValueResult.profile = this._profile;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolOspfv3AreaInterfaceBfd | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._profile = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._profile = value.profile;
    }
  }

  // profile - computed: true, optional: true, required: false
  private _profile?: string; 
  public get profile() {
    return this.getStringAttribute('profile');
  }
  public set profile(value: string) {
    this._profile = value;
  }
  public resetProfile() {
    this._profile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get profileInput() {
    return this._profile;
  }
}
export interface VirtualRouterProtocolOspfv3AreaInterfaceLinkTypeBroadcast {
}

export function virtualRouterProtocolOspfv3AreaInterfaceLinkTypeBroadcastToTerraform(struct?: VirtualRouterProtocolOspfv3AreaInterfaceLinkTypeBroadcast | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function virtualRouterProtocolOspfv3AreaInterfaceLinkTypeBroadcastToHclTerraform(struct?: VirtualRouterProtocolOspfv3AreaInterfaceLinkTypeBroadcast | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class VirtualRouterProtocolOspfv3AreaInterfaceLinkTypeBroadcastOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolOspfv3AreaInterfaceLinkTypeBroadcast | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolOspfv3AreaInterfaceLinkTypeBroadcast | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface VirtualRouterProtocolOspfv3AreaInterfaceLinkTypeP2Mp {
}

export function virtualRouterProtocolOspfv3AreaInterfaceLinkTypeP2MpToTerraform(struct?: VirtualRouterProtocolOspfv3AreaInterfaceLinkTypeP2Mp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function virtualRouterProtocolOspfv3AreaInterfaceLinkTypeP2MpToHclTerraform(struct?: VirtualRouterProtocolOspfv3AreaInterfaceLinkTypeP2Mp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class VirtualRouterProtocolOspfv3AreaInterfaceLinkTypeP2MpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VirtualRouterProtocolOspfv3AreaInterfaceLinkTypeP2Mp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VirtualRouterProtocolOspfv3AreaInterfaceLinkTypeP2Mp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
