import * as cdktf from 'cdktf';
export interface LogicalRouterVrfAdminDists {
  /**
  * Bgp external
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#bgp_external LogicalRouter#bgp_external}
  */
  readonly bgpExternal?: number;
  /**
  * Bgp internal
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#bgp_internal LogicalRouter#bgp_internal}
  */
  readonly bgpInternal?: number;
  /**
  * Bgp local
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#bgp_local LogicalRouter#bgp_local}
  */
  readonly bgpLocal?: number;
  /**
  * Ospf ext
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#ospf_ext LogicalRouter#ospf_ext}
  */
  readonly ospfExt?: number;
  /**
  * Ospf inter
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#ospf_inter LogicalRouter#ospf_inter}
  */
  readonly ospfInter?: number;
  /**
  * Ospf intra
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#ospf_intra LogicalRouter#ospf_intra}
  */
  readonly ospfIntra?: number;
  /**
  * Ospfv3 ext
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#ospfv3_ext LogicalRouter#ospfv3_ext}
  */
  readonly ospfv3Ext?: number;
  /**
  * Ospfv3 inter
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#ospfv3_inter LogicalRouter#ospfv3_inter}
  */
  readonly ospfv3Inter?: number;
  /**
  * Ospfv3 intra
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#ospfv3_intra LogicalRouter#ospfv3_intra}
  */
  readonly ospfv3Intra?: number;
  /**
  * Rip
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#rip LogicalRouter#rip}
  */
  readonly rip?: number;
  /**
  * Static
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#static LogicalRouter#static}
  */
  readonly static?: number;
  /**
  * Static ipv6
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#static_ipv6 LogicalRouter#static_ipv6}
  */
  readonly staticIpv6?: number;
}

export function logicalRouterVrfAdminDistsToTerraform(struct?: LogicalRouterVrfAdminDists | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bgp_external: cdktf.numberToTerraform(struct!.bgpExternal),
    bgp_internal: cdktf.numberToTerraform(struct!.bgpInternal),
    bgp_local: cdktf.numberToTerraform(struct!.bgpLocal),
    ospf_ext: cdktf.numberToTerraform(struct!.ospfExt),
    ospf_inter: cdktf.numberToTerraform(struct!.ospfInter),
    ospf_intra: cdktf.numberToTerraform(struct!.ospfIntra),
    ospfv3_ext: cdktf.numberToTerraform(struct!.ospfv3Ext),
    ospfv3_inter: cdktf.numberToTerraform(struct!.ospfv3Inter),
    ospfv3_intra: cdktf.numberToTerraform(struct!.ospfv3Intra),
    rip: cdktf.numberToTerraform(struct!.rip),
    static: cdktf.numberToTerraform(struct!.static),
    static_ipv6: cdktf.numberToTerraform(struct!.staticIpv6),
  }
}


export function logicalRouterVrfAdminDistsToHclTerraform(struct?: LogicalRouterVrfAdminDists | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bgp_external: {
      value: cdktf.numberToHclTerraform(struct!.bgpExternal),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    bgp_internal: {
      value: cdktf.numberToHclTerraform(struct!.bgpInternal),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    bgp_local: {
      value: cdktf.numberToHclTerraform(struct!.bgpLocal),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    ospf_ext: {
      value: cdktf.numberToHclTerraform(struct!.ospfExt),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    ospf_inter: {
      value: cdktf.numberToHclTerraform(struct!.ospfInter),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    ospf_intra: {
      value: cdktf.numberToHclTerraform(struct!.ospfIntra),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    ospfv3_ext: {
      value: cdktf.numberToHclTerraform(struct!.ospfv3Ext),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    ospfv3_inter: {
      value: cdktf.numberToHclTerraform(struct!.ospfv3Inter),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    ospfv3_intra: {
      value: cdktf.numberToHclTerraform(struct!.ospfv3Intra),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    rip: {
      value: cdktf.numberToHclTerraform(struct!.rip),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    static: {
      value: cdktf.numberToHclTerraform(struct!.static),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    static_ipv6: {
      value: cdktf.numberToHclTerraform(struct!.staticIpv6),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfAdminDistsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfAdminDists | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bgpExternal !== undefined) {
      hasAnyValues = true;
      internalValueResult.bgpExternal = this._bgpExternal;
    }
    if (this._bgpInternal !== undefined) {
      hasAnyValues = true;
      internalValueResult.bgpInternal = this._bgpInternal;
    }
    if (this._bgpLocal !== undefined) {
      hasAnyValues = true;
      internalValueResult.bgpLocal = this._bgpLocal;
    }
    if (this._ospfExt !== undefined) {
      hasAnyValues = true;
      internalValueResult.ospfExt = this._ospfExt;
    }
    if (this._ospfInter !== undefined) {
      hasAnyValues = true;
      internalValueResult.ospfInter = this._ospfInter;
    }
    if (this._ospfIntra !== undefined) {
      hasAnyValues = true;
      internalValueResult.ospfIntra = this._ospfIntra;
    }
    if (this._ospfv3Ext !== undefined) {
      hasAnyValues = true;
      internalValueResult.ospfv3Ext = this._ospfv3Ext;
    }
    if (this._ospfv3Inter !== undefined) {
      hasAnyValues = true;
      internalValueResult.ospfv3Inter = this._ospfv3Inter;
    }
    if (this._ospfv3Intra !== undefined) {
      hasAnyValues = true;
      internalValueResult.ospfv3Intra = this._ospfv3Intra;
    }
    if (this._rip !== undefined) {
      hasAnyValues = true;
      internalValueResult.rip = this._rip;
    }
    if (this._static !== undefined) {
      hasAnyValues = true;
      internalValueResult.static = this._static;
    }
    if (this._staticIpv6 !== undefined) {
      hasAnyValues = true;
      internalValueResult.staticIpv6 = this._staticIpv6;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfAdminDists | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bgpExternal = undefined;
      this._bgpInternal = undefined;
      this._bgpLocal = undefined;
      this._ospfExt = undefined;
      this._ospfInter = undefined;
      this._ospfIntra = undefined;
      this._ospfv3Ext = undefined;
      this._ospfv3Inter = undefined;
      this._ospfv3Intra = undefined;
      this._rip = undefined;
      this._static = undefined;
      this._staticIpv6 = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bgpExternal = value.bgpExternal;
      this._bgpInternal = value.bgpInternal;
      this._bgpLocal = value.bgpLocal;
      this._ospfExt = value.ospfExt;
      this._ospfInter = value.ospfInter;
      this._ospfIntra = value.ospfIntra;
      this._ospfv3Ext = value.ospfv3Ext;
      this._ospfv3Inter = value.ospfv3Inter;
      this._ospfv3Intra = value.ospfv3Intra;
      this._rip = value.rip;
      this._static = value.static;
      this._staticIpv6 = value.staticIpv6;
    }
  }

  // bgp_external - computed: false, optional: true, required: false
  private _bgpExternal?: number; 
  public get bgpExternal() {
    return this.getNumberAttribute('bgp_external');
  }
  public set bgpExternal(value: number) {
    this._bgpExternal = value;
  }
  public resetBgpExternal() {
    this._bgpExternal = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bgpExternalInput() {
    return this._bgpExternal;
  }

  // bgp_internal - computed: false, optional: true, required: false
  private _bgpInternal?: number; 
  public get bgpInternal() {
    return this.getNumberAttribute('bgp_internal');
  }
  public set bgpInternal(value: number) {
    this._bgpInternal = value;
  }
  public resetBgpInternal() {
    this._bgpInternal = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bgpInternalInput() {
    return this._bgpInternal;
  }

  // bgp_local - computed: false, optional: true, required: false
  private _bgpLocal?: number; 
  public get bgpLocal() {
    return this.getNumberAttribute('bgp_local');
  }
  public set bgpLocal(value: number) {
    this._bgpLocal = value;
  }
  public resetBgpLocal() {
    this._bgpLocal = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bgpLocalInput() {
    return this._bgpLocal;
  }

  // ospf_ext - computed: false, optional: true, required: false
  private _ospfExt?: number; 
  public get ospfExt() {
    return this.getNumberAttribute('ospf_ext');
  }
  public set ospfExt(value: number) {
    this._ospfExt = value;
  }
  public resetOspfExt() {
    this._ospfExt = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ospfExtInput() {
    return this._ospfExt;
  }

  // ospf_inter - computed: false, optional: true, required: false
  private _ospfInter?: number; 
  public get ospfInter() {
    return this.getNumberAttribute('ospf_inter');
  }
  public set ospfInter(value: number) {
    this._ospfInter = value;
  }
  public resetOspfInter() {
    this._ospfInter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ospfInterInput() {
    return this._ospfInter;
  }

  // ospf_intra - computed: false, optional: true, required: false
  private _ospfIntra?: number; 
  public get ospfIntra() {
    return this.getNumberAttribute('ospf_intra');
  }
  public set ospfIntra(value: number) {
    this._ospfIntra = value;
  }
  public resetOspfIntra() {
    this._ospfIntra = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ospfIntraInput() {
    return this._ospfIntra;
  }

  // ospfv3_ext - computed: false, optional: true, required: false
  private _ospfv3Ext?: number; 
  public get ospfv3Ext() {
    return this.getNumberAttribute('ospfv3_ext');
  }
  public set ospfv3Ext(value: number) {
    this._ospfv3Ext = value;
  }
  public resetOspfv3Ext() {
    this._ospfv3Ext = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ospfv3ExtInput() {
    return this._ospfv3Ext;
  }

  // ospfv3_inter - computed: false, optional: true, required: false
  private _ospfv3Inter?: number; 
  public get ospfv3Inter() {
    return this.getNumberAttribute('ospfv3_inter');
  }
  public set ospfv3Inter(value: number) {
    this._ospfv3Inter = value;
  }
  public resetOspfv3Inter() {
    this._ospfv3Inter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ospfv3InterInput() {
    return this._ospfv3Inter;
  }

  // ospfv3_intra - computed: false, optional: true, required: false
  private _ospfv3Intra?: number; 
  public get ospfv3Intra() {
    return this.getNumberAttribute('ospfv3_intra');
  }
  public set ospfv3Intra(value: number) {
    this._ospfv3Intra = value;
  }
  public resetOspfv3Intra() {
    this._ospfv3Intra = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ospfv3IntraInput() {
    return this._ospfv3Intra;
  }

  // rip - computed: false, optional: true, required: false
  private _rip?: number; 
  public get rip() {
    return this.getNumberAttribute('rip');
  }
  public set rip(value: number) {
    this._rip = value;
  }
  public resetRip() {
    this._rip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ripInput() {
    return this._rip;
  }

  // static - computed: false, optional: true, required: false
  private _static?: number; 
  public get static() {
    return this.getNumberAttribute('static');
  }
  public set static(value: number) {
    this._static = value;
  }
  public resetStatic() {
    this._static = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get staticInput() {
    return this._static;
  }

  // static_ipv6 - computed: false, optional: true, required: false
  private _staticIpv6?: number; 
  public get staticIpv6() {
    return this.getNumberAttribute('static_ipv6');
  }
  public set staticIpv6(value: number) {
    this._staticIpv6 = value;
  }
  public resetStaticIpv6() {
    this._staticIpv6 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get staticIpv6Input() {
    return this._staticIpv6;
  }
}
export interface LogicalRouterVrfBgpAdvertiseNetworkIpv4Network {
  /**
  * Backdoor
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#backdoor LogicalRouter#backdoor}
  */
  readonly backdoor?: boolean | cdktf.IResolvable;
  /**
  * Multicast
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#multicast LogicalRouter#multicast}
  */
  readonly multicast?: boolean | cdktf.IResolvable;
  /**
  * Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#name LogicalRouter#name}
  */
  readonly name: string;
  /**
  * Unicast
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#unicast LogicalRouter#unicast}
  */
  readonly unicast?: boolean | cdktf.IResolvable;
}

export function logicalRouterVrfBgpAdvertiseNetworkIpv4NetworkToTerraform(struct?: LogicalRouterVrfBgpAdvertiseNetworkIpv4Network | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backdoor: cdktf.booleanToTerraform(struct!.backdoor),
    multicast: cdktf.booleanToTerraform(struct!.multicast),
    name: cdktf.stringToTerraform(struct!.name),
    unicast: cdktf.booleanToTerraform(struct!.unicast),
  }
}


export function logicalRouterVrfBgpAdvertiseNetworkIpv4NetworkToHclTerraform(struct?: LogicalRouterVrfBgpAdvertiseNetworkIpv4Network | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backdoor: {
      value: cdktf.booleanToHclTerraform(struct!.backdoor),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    multicast: {
      value: cdktf.booleanToHclTerraform(struct!.multicast),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    unicast: {
      value: cdktf.booleanToHclTerraform(struct!.unicast),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpAdvertiseNetworkIpv4NetworkOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): LogicalRouterVrfBgpAdvertiseNetworkIpv4Network | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backdoor !== undefined) {
      hasAnyValues = true;
      internalValueResult.backdoor = this._backdoor;
    }
    if (this._multicast !== undefined) {
      hasAnyValues = true;
      internalValueResult.multicast = this._multicast;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._unicast !== undefined) {
      hasAnyValues = true;
      internalValueResult.unicast = this._unicast;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpAdvertiseNetworkIpv4Network | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backdoor = undefined;
      this._multicast = undefined;
      this._name = undefined;
      this._unicast = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backdoor = value.backdoor;
      this._multicast = value.multicast;
      this._name = value.name;
      this._unicast = value.unicast;
    }
  }

  // backdoor - computed: false, optional: true, required: false
  private _backdoor?: boolean | cdktf.IResolvable; 
  public get backdoor() {
    return this.getBooleanAttribute('backdoor');
  }
  public set backdoor(value: boolean | cdktf.IResolvable) {
    this._backdoor = value;
  }
  public resetBackdoor() {
    this._backdoor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backdoorInput() {
    return this._backdoor;
  }

  // multicast - computed: false, optional: true, required: false
  private _multicast?: boolean | cdktf.IResolvable; 
  public get multicast() {
    return this.getBooleanAttribute('multicast');
  }
  public set multicast(value: boolean | cdktf.IResolvable) {
    this._multicast = value;
  }
  public resetMulticast() {
    this._multicast = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get multicastInput() {
    return this._multicast;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // unicast - computed: false, optional: true, required: false
  private _unicast?: boolean | cdktf.IResolvable; 
  public get unicast() {
    return this.getBooleanAttribute('unicast');
  }
  public set unicast(value: boolean | cdktf.IResolvable) {
    this._unicast = value;
  }
  public resetUnicast() {
    this._unicast = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get unicastInput() {
    return this._unicast;
  }
}

export class LogicalRouterVrfBgpAdvertiseNetworkIpv4NetworkList extends cdktf.ComplexList {
  public internalValue? : LogicalRouterVrfBgpAdvertiseNetworkIpv4Network[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): LogicalRouterVrfBgpAdvertiseNetworkIpv4NetworkOutputReference {
    return new LogicalRouterVrfBgpAdvertiseNetworkIpv4NetworkOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface LogicalRouterVrfBgpAdvertiseNetworkIpv4 {
  /**
  * Network
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#network LogicalRouter#network}
  */
  readonly network?: LogicalRouterVrfBgpAdvertiseNetworkIpv4Network[] | cdktf.IResolvable;
}

export function logicalRouterVrfBgpAdvertiseNetworkIpv4ToTerraform(struct?: LogicalRouterVrfBgpAdvertiseNetworkIpv4 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    network: cdktf.listMapper(logicalRouterVrfBgpAdvertiseNetworkIpv4NetworkToTerraform, false)(struct!.network),
  }
}


export function logicalRouterVrfBgpAdvertiseNetworkIpv4ToHclTerraform(struct?: LogicalRouterVrfBgpAdvertiseNetworkIpv4 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    network: {
      value: cdktf.listMapperHcl(logicalRouterVrfBgpAdvertiseNetworkIpv4NetworkToHclTerraform, false)(struct!.network),
      isBlock: true,
      type: "list",
      storageClassType: "LogicalRouterVrfBgpAdvertiseNetworkIpv4NetworkList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpAdvertiseNetworkIpv4OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpAdvertiseNetworkIpv4 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._network?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.network = this._network?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpAdvertiseNetworkIpv4 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._network.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._network.internalValue = value.network;
    }
  }

  // network - computed: false, optional: true, required: false
  private _network = new LogicalRouterVrfBgpAdvertiseNetworkIpv4NetworkList(this, "network", false);
  public get network() {
    return this._network;
  }
  public putNetwork(value: LogicalRouterVrfBgpAdvertiseNetworkIpv4Network[] | cdktf.IResolvable) {
    this._network.internalValue = value;
  }
  public resetNetwork() {
    this._network.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get networkInput() {
    return this._network.internalValue;
  }
}
export interface LogicalRouterVrfBgpAdvertiseNetworkIpv6Network {
  /**
  * Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#name LogicalRouter#name}
  */
  readonly name: string;
  /**
  * Unicast
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#unicast LogicalRouter#unicast}
  */
  readonly unicast?: boolean | cdktf.IResolvable;
}

export function logicalRouterVrfBgpAdvertiseNetworkIpv6NetworkToTerraform(struct?: LogicalRouterVrfBgpAdvertiseNetworkIpv6Network | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    unicast: cdktf.booleanToTerraform(struct!.unicast),
  }
}


export function logicalRouterVrfBgpAdvertiseNetworkIpv6NetworkToHclTerraform(struct?: LogicalRouterVrfBgpAdvertiseNetworkIpv6Network | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    unicast: {
      value: cdktf.booleanToHclTerraform(struct!.unicast),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpAdvertiseNetworkIpv6NetworkOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): LogicalRouterVrfBgpAdvertiseNetworkIpv6Network | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._unicast !== undefined) {
      hasAnyValues = true;
      internalValueResult.unicast = this._unicast;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpAdvertiseNetworkIpv6Network | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._unicast = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._unicast = value.unicast;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // unicast - computed: false, optional: true, required: false
  private _unicast?: boolean | cdktf.IResolvable; 
  public get unicast() {
    return this.getBooleanAttribute('unicast');
  }
  public set unicast(value: boolean | cdktf.IResolvable) {
    this._unicast = value;
  }
  public resetUnicast() {
    this._unicast = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get unicastInput() {
    return this._unicast;
  }
}

export class LogicalRouterVrfBgpAdvertiseNetworkIpv6NetworkList extends cdktf.ComplexList {
  public internalValue? : LogicalRouterVrfBgpAdvertiseNetworkIpv6Network[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): LogicalRouterVrfBgpAdvertiseNetworkIpv6NetworkOutputReference {
    return new LogicalRouterVrfBgpAdvertiseNetworkIpv6NetworkOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface LogicalRouterVrfBgpAdvertiseNetworkIpv6 {
  /**
  * Network
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#network LogicalRouter#network}
  */
  readonly network?: LogicalRouterVrfBgpAdvertiseNetworkIpv6Network[] | cdktf.IResolvable;
}

export function logicalRouterVrfBgpAdvertiseNetworkIpv6ToTerraform(struct?: LogicalRouterVrfBgpAdvertiseNetworkIpv6 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    network: cdktf.listMapper(logicalRouterVrfBgpAdvertiseNetworkIpv6NetworkToTerraform, false)(struct!.network),
  }
}


export function logicalRouterVrfBgpAdvertiseNetworkIpv6ToHclTerraform(struct?: LogicalRouterVrfBgpAdvertiseNetworkIpv6 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    network: {
      value: cdktf.listMapperHcl(logicalRouterVrfBgpAdvertiseNetworkIpv6NetworkToHclTerraform, false)(struct!.network),
      isBlock: true,
      type: "list",
      storageClassType: "LogicalRouterVrfBgpAdvertiseNetworkIpv6NetworkList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpAdvertiseNetworkIpv6OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpAdvertiseNetworkIpv6 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._network?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.network = this._network?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpAdvertiseNetworkIpv6 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._network.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._network.internalValue = value.network;
    }
  }

  // network - computed: false, optional: true, required: false
  private _network = new LogicalRouterVrfBgpAdvertiseNetworkIpv6NetworkList(this, "network", false);
  public get network() {
    return this._network;
  }
  public putNetwork(value: LogicalRouterVrfBgpAdvertiseNetworkIpv6Network[] | cdktf.IResolvable) {
    this._network.internalValue = value;
  }
  public resetNetwork() {
    this._network.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get networkInput() {
    return this._network.internalValue;
  }
}
export interface LogicalRouterVrfBgpAdvertiseNetwork {
  /**
  * Ipv4
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#ipv4 LogicalRouter#ipv4}
  */
  readonly ipv4?: LogicalRouterVrfBgpAdvertiseNetworkIpv4;
  /**
  * Ipv6
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#ipv6 LogicalRouter#ipv6}
  */
  readonly ipv6?: LogicalRouterVrfBgpAdvertiseNetworkIpv6;
}

export function logicalRouterVrfBgpAdvertiseNetworkToTerraform(struct?: LogicalRouterVrfBgpAdvertiseNetwork | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ipv4: logicalRouterVrfBgpAdvertiseNetworkIpv4ToTerraform(struct!.ipv4),
    ipv6: logicalRouterVrfBgpAdvertiseNetworkIpv6ToTerraform(struct!.ipv6),
  }
}


export function logicalRouterVrfBgpAdvertiseNetworkToHclTerraform(struct?: LogicalRouterVrfBgpAdvertiseNetwork | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ipv4: {
      value: logicalRouterVrfBgpAdvertiseNetworkIpv4ToHclTerraform(struct!.ipv4),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpAdvertiseNetworkIpv4",
    },
    ipv6: {
      value: logicalRouterVrfBgpAdvertiseNetworkIpv6ToHclTerraform(struct!.ipv6),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpAdvertiseNetworkIpv6",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpAdvertiseNetworkOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpAdvertiseNetwork | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ipv4?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipv4 = this._ipv4?.internalValue;
    }
    if (this._ipv6?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipv6 = this._ipv6?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpAdvertiseNetwork | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ipv4.internalValue = undefined;
      this._ipv6.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ipv4.internalValue = value.ipv4;
      this._ipv6.internalValue = value.ipv6;
    }
  }

  // ipv4 - computed: false, optional: true, required: false
  private _ipv4 = new LogicalRouterVrfBgpAdvertiseNetworkIpv4OutputReference(this, "ipv4");
  public get ipv4() {
    return this._ipv4;
  }
  public putIpv4(value: LogicalRouterVrfBgpAdvertiseNetworkIpv4) {
    this._ipv4.internalValue = value;
  }
  public resetIpv4() {
    this._ipv4.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipv4Input() {
    return this._ipv4.internalValue;
  }

  // ipv6 - computed: false, optional: true, required: false
  private _ipv6 = new LogicalRouterVrfBgpAdvertiseNetworkIpv6OutputReference(this, "ipv6");
  public get ipv6() {
    return this._ipv6;
  }
  public putIpv6(value: LogicalRouterVrfBgpAdvertiseNetworkIpv6) {
    this._ipv6.internalValue = value;
  }
  public resetIpv6() {
    this._ipv6.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipv6Input() {
    return this._ipv6.internalValue;
  }
}
export interface LogicalRouterVrfBgpAggregate {
  /**
  * Aggregate med
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#aggregate_med LogicalRouter#aggregate_med}
  */
  readonly aggregateMed?: boolean | cdktf.IResolvable;
}

export function logicalRouterVrfBgpAggregateToTerraform(struct?: LogicalRouterVrfBgpAggregate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    aggregate_med: cdktf.booleanToTerraform(struct!.aggregateMed),
  }
}


export function logicalRouterVrfBgpAggregateToHclTerraform(struct?: LogicalRouterVrfBgpAggregate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    aggregate_med: {
      value: cdktf.booleanToHclTerraform(struct!.aggregateMed),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpAggregateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpAggregate | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._aggregateMed !== undefined) {
      hasAnyValues = true;
      internalValueResult.aggregateMed = this._aggregateMed;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpAggregate | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._aggregateMed = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._aggregateMed = value.aggregateMed;
    }
  }

  // aggregate_med - computed: false, optional: true, required: false
  private _aggregateMed?: boolean | cdktf.IResolvable; 
  public get aggregateMed() {
    return this.getBooleanAttribute('aggregate_med');
  }
  public set aggregateMed(value: boolean | cdktf.IResolvable) {
    this._aggregateMed = value;
  }
  public resetAggregateMed() {
    this._aggregateMed = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aggregateMedInput() {
    return this._aggregateMed;
  }
}
export interface LogicalRouterVrfBgpAggregateRoutesTypeIpv4 {
  /**
  * Attribute map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#attribute_map LogicalRouter#attribute_map}
  */
  readonly attributeMap?: string;
  /**
  * Summary prefix
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#summary_prefix LogicalRouter#summary_prefix}
  */
  readonly summaryPrefix?: string;
  /**
  * Suppress map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#suppress_map LogicalRouter#suppress_map}
  */
  readonly suppressMap?: string;
}

export function logicalRouterVrfBgpAggregateRoutesTypeIpv4ToTerraform(struct?: LogicalRouterVrfBgpAggregateRoutesTypeIpv4 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    attribute_map: cdktf.stringToTerraform(struct!.attributeMap),
    summary_prefix: cdktf.stringToTerraform(struct!.summaryPrefix),
    suppress_map: cdktf.stringToTerraform(struct!.suppressMap),
  }
}


export function logicalRouterVrfBgpAggregateRoutesTypeIpv4ToHclTerraform(struct?: LogicalRouterVrfBgpAggregateRoutesTypeIpv4 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    attribute_map: {
      value: cdktf.stringToHclTerraform(struct!.attributeMap),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    summary_prefix: {
      value: cdktf.stringToHclTerraform(struct!.summaryPrefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    suppress_map: {
      value: cdktf.stringToHclTerraform(struct!.suppressMap),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpAggregateRoutesTypeIpv4OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpAggregateRoutesTypeIpv4 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._attributeMap !== undefined) {
      hasAnyValues = true;
      internalValueResult.attributeMap = this._attributeMap;
    }
    if (this._summaryPrefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.summaryPrefix = this._summaryPrefix;
    }
    if (this._suppressMap !== undefined) {
      hasAnyValues = true;
      internalValueResult.suppressMap = this._suppressMap;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpAggregateRoutesTypeIpv4 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._attributeMap = undefined;
      this._summaryPrefix = undefined;
      this._suppressMap = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._attributeMap = value.attributeMap;
      this._summaryPrefix = value.summaryPrefix;
      this._suppressMap = value.suppressMap;
    }
  }

  // attribute_map - computed: false, optional: true, required: false
  private _attributeMap?: string; 
  public get attributeMap() {
    return this.getStringAttribute('attribute_map');
  }
  public set attributeMap(value: string) {
    this._attributeMap = value;
  }
  public resetAttributeMap() {
    this._attributeMap = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get attributeMapInput() {
    return this._attributeMap;
  }

  // summary_prefix - computed: false, optional: true, required: false
  private _summaryPrefix?: string; 
  public get summaryPrefix() {
    return this.getStringAttribute('summary_prefix');
  }
  public set summaryPrefix(value: string) {
    this._summaryPrefix = value;
  }
  public resetSummaryPrefix() {
    this._summaryPrefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get summaryPrefixInput() {
    return this._summaryPrefix;
  }

  // suppress_map - computed: false, optional: true, required: false
  private _suppressMap?: string; 
  public get suppressMap() {
    return this.getStringAttribute('suppress_map');
  }
  public set suppressMap(value: string) {
    this._suppressMap = value;
  }
  public resetSuppressMap() {
    this._suppressMap = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get suppressMapInput() {
    return this._suppressMap;
  }
}
export interface LogicalRouterVrfBgpAggregateRoutesTypeIpv6 {
  /**
  * Attribute map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#attribute_map LogicalRouter#attribute_map}
  */
  readonly attributeMap?: string;
  /**
  * Summary prefix
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#summary_prefix LogicalRouter#summary_prefix}
  */
  readonly summaryPrefix?: string;
  /**
  * Suppress map
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#suppress_map LogicalRouter#suppress_map}
  */
  readonly suppressMap?: string;
}

export function logicalRouterVrfBgpAggregateRoutesTypeIpv6ToTerraform(struct?: LogicalRouterVrfBgpAggregateRoutesTypeIpv6 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    attribute_map: cdktf.stringToTerraform(struct!.attributeMap),
    summary_prefix: cdktf.stringToTerraform(struct!.summaryPrefix),
    suppress_map: cdktf.stringToTerraform(struct!.suppressMap),
  }
}


export function logicalRouterVrfBgpAggregateRoutesTypeIpv6ToHclTerraform(struct?: LogicalRouterVrfBgpAggregateRoutesTypeIpv6 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    attribute_map: {
      value: cdktf.stringToHclTerraform(struct!.attributeMap),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    summary_prefix: {
      value: cdktf.stringToHclTerraform(struct!.summaryPrefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    suppress_map: {
      value: cdktf.stringToHclTerraform(struct!.suppressMap),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpAggregateRoutesTypeIpv6OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpAggregateRoutesTypeIpv6 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._attributeMap !== undefined) {
      hasAnyValues = true;
      internalValueResult.attributeMap = this._attributeMap;
    }
    if (this._summaryPrefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.summaryPrefix = this._summaryPrefix;
    }
    if (this._suppressMap !== undefined) {
      hasAnyValues = true;
      internalValueResult.suppressMap = this._suppressMap;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpAggregateRoutesTypeIpv6 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._attributeMap = undefined;
      this._summaryPrefix = undefined;
      this._suppressMap = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._attributeMap = value.attributeMap;
      this._summaryPrefix = value.summaryPrefix;
      this._suppressMap = value.suppressMap;
    }
  }

  // attribute_map - computed: false, optional: true, required: false
  private _attributeMap?: string; 
  public get attributeMap() {
    return this.getStringAttribute('attribute_map');
  }
  public set attributeMap(value: string) {
    this._attributeMap = value;
  }
  public resetAttributeMap() {
    this._attributeMap = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get attributeMapInput() {
    return this._attributeMap;
  }

  // summary_prefix - computed: false, optional: true, required: false
  private _summaryPrefix?: string; 
  public get summaryPrefix() {
    return this.getStringAttribute('summary_prefix');
  }
  public set summaryPrefix(value: string) {
    this._summaryPrefix = value;
  }
  public resetSummaryPrefix() {
    this._summaryPrefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get summaryPrefixInput() {
    return this._summaryPrefix;
  }

  // suppress_map - computed: false, optional: true, required: false
  private _suppressMap?: string; 
  public get suppressMap() {
    return this.getStringAttribute('suppress_map');
  }
  public set suppressMap(value: string) {
    this._suppressMap = value;
  }
  public resetSuppressMap() {
    this._suppressMap = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get suppressMapInput() {
    return this._suppressMap;
  }
}
export interface LogicalRouterVrfBgpAggregateRoutesType {
  /**
  * Ipv4
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#ipv4 LogicalRouter#ipv4}
  */
  readonly ipv4?: LogicalRouterVrfBgpAggregateRoutesTypeIpv4;
  /**
  * Ipv6
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#ipv6 LogicalRouter#ipv6}
  */
  readonly ipv6?: LogicalRouterVrfBgpAggregateRoutesTypeIpv6;
}

export function logicalRouterVrfBgpAggregateRoutesTypeToTerraform(struct?: LogicalRouterVrfBgpAggregateRoutesType | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ipv4: logicalRouterVrfBgpAggregateRoutesTypeIpv4ToTerraform(struct!.ipv4),
    ipv6: logicalRouterVrfBgpAggregateRoutesTypeIpv6ToTerraform(struct!.ipv6),
  }
}


export function logicalRouterVrfBgpAggregateRoutesTypeToHclTerraform(struct?: LogicalRouterVrfBgpAggregateRoutesType | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ipv4: {
      value: logicalRouterVrfBgpAggregateRoutesTypeIpv4ToHclTerraform(struct!.ipv4),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpAggregateRoutesTypeIpv4",
    },
    ipv6: {
      value: logicalRouterVrfBgpAggregateRoutesTypeIpv6ToHclTerraform(struct!.ipv6),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpAggregateRoutesTypeIpv6",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpAggregateRoutesTypeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpAggregateRoutesType | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ipv4?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipv4 = this._ipv4?.internalValue;
    }
    if (this._ipv6?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipv6 = this._ipv6?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpAggregateRoutesType | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ipv4.internalValue = undefined;
      this._ipv6.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ipv4.internalValue = value.ipv4;
      this._ipv6.internalValue = value.ipv6;
    }
  }

  // ipv4 - computed: false, optional: true, required: false
  private _ipv4 = new LogicalRouterVrfBgpAggregateRoutesTypeIpv4OutputReference(this, "ipv4");
  public get ipv4() {
    return this._ipv4;
  }
  public putIpv4(value: LogicalRouterVrfBgpAggregateRoutesTypeIpv4) {
    this._ipv4.internalValue = value;
  }
  public resetIpv4() {
    this._ipv4.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipv4Input() {
    return this._ipv4.internalValue;
  }

  // ipv6 - computed: false, optional: true, required: false
  private _ipv6 = new LogicalRouterVrfBgpAggregateRoutesTypeIpv6OutputReference(this, "ipv6");
  public get ipv6() {
    return this._ipv6;
  }
  public putIpv6(value: LogicalRouterVrfBgpAggregateRoutesTypeIpv6) {
    this._ipv6.internalValue = value;
  }
  public resetIpv6() {
    this._ipv6.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipv6Input() {
    return this._ipv6.internalValue;
  }
}
export interface LogicalRouterVrfBgpAggregateRoutes {
  /**
  * As set
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#as_set LogicalRouter#as_set}
  */
  readonly asSet?: boolean | cdktf.IResolvable;
  /**
  * Description
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#description LogicalRouter#description}
  */
  readonly description?: string;
  /**
  * Enable
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#enable LogicalRouter#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#name LogicalRouter#name}
  */
  readonly name: string;
  /**
  * Same med
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#same_med LogicalRouter#same_med}
  */
  readonly sameMed?: boolean | cdktf.IResolvable;
  /**
  * Summary only
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#summary_only LogicalRouter#summary_only}
  */
  readonly summaryOnly?: boolean | cdktf.IResolvable;
  /**
  * Type
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#type LogicalRouter#type}
  */
  readonly type?: LogicalRouterVrfBgpAggregateRoutesType;
}

export function logicalRouterVrfBgpAggregateRoutesToTerraform(struct?: LogicalRouterVrfBgpAggregateRoutes | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    as_set: cdktf.booleanToTerraform(struct!.asSet),
    description: cdktf.stringToTerraform(struct!.description),
    enable: cdktf.booleanToTerraform(struct!.enable),
    name: cdktf.stringToTerraform(struct!.name),
    same_med: cdktf.booleanToTerraform(struct!.sameMed),
    summary_only: cdktf.booleanToTerraform(struct!.summaryOnly),
    type: logicalRouterVrfBgpAggregateRoutesTypeToTerraform(struct!.type),
  }
}


export function logicalRouterVrfBgpAggregateRoutesToHclTerraform(struct?: LogicalRouterVrfBgpAggregateRoutes | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    as_set: {
      value: cdktf.booleanToHclTerraform(struct!.asSet),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    same_med: {
      value: cdktf.booleanToHclTerraform(struct!.sameMed),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    summary_only: {
      value: cdktf.booleanToHclTerraform(struct!.summaryOnly),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    type: {
      value: logicalRouterVrfBgpAggregateRoutesTypeToHclTerraform(struct!.type),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpAggregateRoutesType",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpAggregateRoutesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): LogicalRouterVrfBgpAggregateRoutes | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._asSet !== undefined) {
      hasAnyValues = true;
      internalValueResult.asSet = this._asSet;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._sameMed !== undefined) {
      hasAnyValues = true;
      internalValueResult.sameMed = this._sameMed;
    }
    if (this._summaryOnly !== undefined) {
      hasAnyValues = true;
      internalValueResult.summaryOnly = this._summaryOnly;
    }
    if (this._type?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpAggregateRoutes | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._asSet = undefined;
      this._description = undefined;
      this._enable = undefined;
      this._name = undefined;
      this._sameMed = undefined;
      this._summaryOnly = undefined;
      this._type.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._asSet = value.asSet;
      this._description = value.description;
      this._enable = value.enable;
      this._name = value.name;
      this._sameMed = value.sameMed;
      this._summaryOnly = value.summaryOnly;
      this._type.internalValue = value.type;
    }
  }

  // as_set - computed: false, optional: true, required: false
  private _asSet?: boolean | cdktf.IResolvable; 
  public get asSet() {
    return this.getBooleanAttribute('as_set');
  }
  public set asSet(value: boolean | cdktf.IResolvable) {
    this._asSet = value;
  }
  public resetAsSet() {
    this._asSet = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asSetInput() {
    return this._asSet;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // enable - computed: false, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // same_med - computed: false, optional: true, required: false
  private _sameMed?: boolean | cdktf.IResolvable; 
  public get sameMed() {
    return this.getBooleanAttribute('same_med');
  }
  public set sameMed(value: boolean | cdktf.IResolvable) {
    this._sameMed = value;
  }
  public resetSameMed() {
    this._sameMed = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sameMedInput() {
    return this._sameMed;
  }

  // summary_only - computed: false, optional: true, required: false
  private _summaryOnly?: boolean | cdktf.IResolvable; 
  public get summaryOnly() {
    return this.getBooleanAttribute('summary_only');
  }
  public set summaryOnly(value: boolean | cdktf.IResolvable) {
    this._summaryOnly = value;
  }
  public resetSummaryOnly() {
    this._summaryOnly = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get summaryOnlyInput() {
    return this._summaryOnly;
  }

  // type - computed: false, optional: true, required: false
  private _type = new LogicalRouterVrfBgpAggregateRoutesTypeOutputReference(this, "type");
  public get type() {
    return this._type;
  }
  public putType(value: LogicalRouterVrfBgpAggregateRoutesType) {
    this._type.internalValue = value;
  }
  public resetType() {
    this._type.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type.internalValue;
  }
}

export class LogicalRouterVrfBgpAggregateRoutesList extends cdktf.ComplexList {
  public internalValue? : LogicalRouterVrfBgpAggregateRoutes[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): LogicalRouterVrfBgpAggregateRoutesOutputReference {
    return new LogicalRouterVrfBgpAggregateRoutesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface LogicalRouterVrfBgpGlobalBfd {
  /**
  * Profile
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#profile LogicalRouter#profile}
  */
  readonly profile?: string;
}

export function logicalRouterVrfBgpGlobalBfdToTerraform(struct?: LogicalRouterVrfBgpGlobalBfd | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    profile: cdktf.stringToTerraform(struct!.profile),
  }
}


export function logicalRouterVrfBgpGlobalBfdToHclTerraform(struct?: LogicalRouterVrfBgpGlobalBfd | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    profile: {
      value: cdktf.stringToHclTerraform(struct!.profile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpGlobalBfdOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpGlobalBfd | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._profile !== undefined) {
      hasAnyValues = true;
      internalValueResult.profile = this._profile;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpGlobalBfd | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._profile = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._profile = value.profile;
    }
  }

  // profile - computed: false, optional: true, required: false
  private _profile?: string; 
  public get profile() {
    return this.getStringAttribute('profile');
  }
  public set profile(value: string) {
    this._profile = value;
  }
  public resetProfile() {
    this._profile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get profileInput() {
    return this._profile;
  }
}
export interface LogicalRouterVrfBgpGracefulRestart {
  /**
  * Enable
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#enable LogicalRouter#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * Local restart time
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#local_restart_time LogicalRouter#local_restart_time}
  */
  readonly localRestartTime?: number;
  /**
  * Max peer restart time
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#max_peer_restart_time LogicalRouter#max_peer_restart_time}
  */
  readonly maxPeerRestartTime?: number;
  /**
  * Stale route time
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#stale_route_time LogicalRouter#stale_route_time}
  */
  readonly staleRouteTime?: number;
}

export function logicalRouterVrfBgpGracefulRestartToTerraform(struct?: LogicalRouterVrfBgpGracefulRestart | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enable: cdktf.booleanToTerraform(struct!.enable),
    local_restart_time: cdktf.numberToTerraform(struct!.localRestartTime),
    max_peer_restart_time: cdktf.numberToTerraform(struct!.maxPeerRestartTime),
    stale_route_time: cdktf.numberToTerraform(struct!.staleRouteTime),
  }
}


export function logicalRouterVrfBgpGracefulRestartToHclTerraform(struct?: LogicalRouterVrfBgpGracefulRestart | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    local_restart_time: {
      value: cdktf.numberToHclTerraform(struct!.localRestartTime),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_peer_restart_time: {
      value: cdktf.numberToHclTerraform(struct!.maxPeerRestartTime),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    stale_route_time: {
      value: cdktf.numberToHclTerraform(struct!.staleRouteTime),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpGracefulRestartOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpGracefulRestart | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._localRestartTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.localRestartTime = this._localRestartTime;
    }
    if (this._maxPeerRestartTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPeerRestartTime = this._maxPeerRestartTime;
    }
    if (this._staleRouteTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.staleRouteTime = this._staleRouteTime;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpGracefulRestart | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enable = undefined;
      this._localRestartTime = undefined;
      this._maxPeerRestartTime = undefined;
      this._staleRouteTime = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enable = value.enable;
      this._localRestartTime = value.localRestartTime;
      this._maxPeerRestartTime = value.maxPeerRestartTime;
      this._staleRouteTime = value.staleRouteTime;
    }
  }

  // enable - computed: false, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // local_restart_time - computed: false, optional: true, required: false
  private _localRestartTime?: number; 
  public get localRestartTime() {
    return this.getNumberAttribute('local_restart_time');
  }
  public set localRestartTime(value: number) {
    this._localRestartTime = value;
  }
  public resetLocalRestartTime() {
    this._localRestartTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localRestartTimeInput() {
    return this._localRestartTime;
  }

  // max_peer_restart_time - computed: false, optional: true, required: false
  private _maxPeerRestartTime?: number; 
  public get maxPeerRestartTime() {
    return this.getNumberAttribute('max_peer_restart_time');
  }
  public set maxPeerRestartTime(value: number) {
    this._maxPeerRestartTime = value;
  }
  public resetMaxPeerRestartTime() {
    this._maxPeerRestartTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPeerRestartTimeInput() {
    return this._maxPeerRestartTime;
  }

  // stale_route_time - computed: false, optional: true, required: false
  private _staleRouteTime?: number; 
  public get staleRouteTime() {
    return this.getNumberAttribute('stale_route_time');
  }
  public set staleRouteTime(value: number) {
    this._staleRouteTime = value;
  }
  public resetStaleRouteTime() {
    this._staleRouteTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get staleRouteTimeInput() {
    return this._staleRouteTime;
  }
}
export interface LogicalRouterVrfBgpMed {
  /**
  * Always compare med
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#always_compare_med LogicalRouter#always_compare_med}
  */
  readonly alwaysCompareMed?: boolean | cdktf.IResolvable;
  /**
  * Deterministic med comparison
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#deterministic_med_comparison LogicalRouter#deterministic_med_comparison}
  */
  readonly deterministicMedComparison?: boolean | cdktf.IResolvable;
}

export function logicalRouterVrfBgpMedToTerraform(struct?: LogicalRouterVrfBgpMed | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    always_compare_med: cdktf.booleanToTerraform(struct!.alwaysCompareMed),
    deterministic_med_comparison: cdktf.booleanToTerraform(struct!.deterministicMedComparison),
  }
}


export function logicalRouterVrfBgpMedToHclTerraform(struct?: LogicalRouterVrfBgpMed | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    always_compare_med: {
      value: cdktf.booleanToHclTerraform(struct!.alwaysCompareMed),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    deterministic_med_comparison: {
      value: cdktf.booleanToHclTerraform(struct!.deterministicMedComparison),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpMedOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpMed | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._alwaysCompareMed !== undefined) {
      hasAnyValues = true;
      internalValueResult.alwaysCompareMed = this._alwaysCompareMed;
    }
    if (this._deterministicMedComparison !== undefined) {
      hasAnyValues = true;
      internalValueResult.deterministicMedComparison = this._deterministicMedComparison;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpMed | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._alwaysCompareMed = undefined;
      this._deterministicMedComparison = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._alwaysCompareMed = value.alwaysCompareMed;
      this._deterministicMedComparison = value.deterministicMedComparison;
    }
  }

  // always_compare_med - computed: false, optional: true, required: false
  private _alwaysCompareMed?: boolean | cdktf.IResolvable; 
  public get alwaysCompareMed() {
    return this.getBooleanAttribute('always_compare_med');
  }
  public set alwaysCompareMed(value: boolean | cdktf.IResolvable) {
    this._alwaysCompareMed = value;
  }
  public resetAlwaysCompareMed() {
    this._alwaysCompareMed = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get alwaysCompareMedInput() {
    return this._alwaysCompareMed;
  }

  // deterministic_med_comparison - computed: false, optional: true, required: false
  private _deterministicMedComparison?: boolean | cdktf.IResolvable; 
  public get deterministicMedComparison() {
    return this.getBooleanAttribute('deterministic_med_comparison');
  }
  public set deterministicMedComparison(value: boolean | cdktf.IResolvable) {
    this._deterministicMedComparison = value;
  }
  public resetDeterministicMedComparison() {
    this._deterministicMedComparison = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deterministicMedComparisonInput() {
    return this._deterministicMedComparison;
  }
}
export interface LogicalRouterVrfBgpPeerGroupAddressFamily {
  /**
  * Ipv4
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#ipv4 LogicalRouter#ipv4}
  */
  readonly ipv4?: string;
  /**
  * Ipv6
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#ipv6 LogicalRouter#ipv6}
  */
  readonly ipv6?: string;
}

export function logicalRouterVrfBgpPeerGroupAddressFamilyToTerraform(struct?: LogicalRouterVrfBgpPeerGroupAddressFamily | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ipv4: cdktf.stringToTerraform(struct!.ipv4),
    ipv6: cdktf.stringToTerraform(struct!.ipv6),
  }
}


export function logicalRouterVrfBgpPeerGroupAddressFamilyToHclTerraform(struct?: LogicalRouterVrfBgpPeerGroupAddressFamily | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ipv4: {
      value: cdktf.stringToHclTerraform(struct!.ipv4),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ipv6: {
      value: cdktf.stringToHclTerraform(struct!.ipv6),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPeerGroupAddressFamilyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPeerGroupAddressFamily | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ipv4 !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipv4 = this._ipv4;
    }
    if (this._ipv6 !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipv6 = this._ipv6;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPeerGroupAddressFamily | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ipv4 = undefined;
      this._ipv6 = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ipv4 = value.ipv4;
      this._ipv6 = value.ipv6;
    }
  }

  // ipv4 - computed: false, optional: true, required: false
  private _ipv4?: string; 
  public get ipv4() {
    return this.getStringAttribute('ipv4');
  }
  public set ipv4(value: string) {
    this._ipv4 = value;
  }
  public resetIpv4() {
    this._ipv4 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipv4Input() {
    return this._ipv4;
  }

  // ipv6 - computed: false, optional: true, required: false
  private _ipv6?: string; 
  public get ipv6() {
    return this.getStringAttribute('ipv6');
  }
  public set ipv6(value: string) {
    this._ipv6 = value;
  }
  public resetIpv6() {
    this._ipv6 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipv6Input() {
    return this._ipv6;
  }
}
export interface LogicalRouterVrfBgpPeerGroupConnectionOptions {
  /**
  * Authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#authentication LogicalRouter#authentication}
  */
  readonly authentication?: string;
  /**
  * Dampening
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#dampening LogicalRouter#dampening}
  */
  readonly dampening?: string;
  /**
  * Multihop
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#multihop LogicalRouter#multihop}
  */
  readonly multihop?: number;
  /**
  * Timers
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#timers LogicalRouter#timers}
  */
  readonly timers?: string;
}

export function logicalRouterVrfBgpPeerGroupConnectionOptionsToTerraform(struct?: LogicalRouterVrfBgpPeerGroupConnectionOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    authentication: cdktf.stringToTerraform(struct!.authentication),
    dampening: cdktf.stringToTerraform(struct!.dampening),
    multihop: cdktf.numberToTerraform(struct!.multihop),
    timers: cdktf.stringToTerraform(struct!.timers),
  }
}


export function logicalRouterVrfBgpPeerGroupConnectionOptionsToHclTerraform(struct?: LogicalRouterVrfBgpPeerGroupConnectionOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    authentication: {
      value: cdktf.stringToHclTerraform(struct!.authentication),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dampening: {
      value: cdktf.stringToHclTerraform(struct!.dampening),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    multihop: {
      value: cdktf.numberToHclTerraform(struct!.multihop),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timers: {
      value: cdktf.stringToHclTerraform(struct!.timers),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPeerGroupConnectionOptionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPeerGroupConnectionOptions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authentication !== undefined) {
      hasAnyValues = true;
      internalValueResult.authentication = this._authentication;
    }
    if (this._dampening !== undefined) {
      hasAnyValues = true;
      internalValueResult.dampening = this._dampening;
    }
    if (this._multihop !== undefined) {
      hasAnyValues = true;
      internalValueResult.multihop = this._multihop;
    }
    if (this._timers !== undefined) {
      hasAnyValues = true;
      internalValueResult.timers = this._timers;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPeerGroupConnectionOptions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authentication = undefined;
      this._dampening = undefined;
      this._multihop = undefined;
      this._timers = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authentication = value.authentication;
      this._dampening = value.dampening;
      this._multihop = value.multihop;
      this._timers = value.timers;
    }
  }

  // authentication - computed: false, optional: true, required: false
  private _authentication?: string; 
  public get authentication() {
    return this.getStringAttribute('authentication');
  }
  public set authentication(value: string) {
    this._authentication = value;
  }
  public resetAuthentication() {
    this._authentication = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authenticationInput() {
    return this._authentication;
  }

  // dampening - computed: false, optional: true, required: false
  private _dampening?: string; 
  public get dampening() {
    return this.getStringAttribute('dampening');
  }
  public set dampening(value: string) {
    this._dampening = value;
  }
  public resetDampening() {
    this._dampening = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dampeningInput() {
    return this._dampening;
  }

  // multihop - computed: false, optional: true, required: false
  private _multihop?: number; 
  public get multihop() {
    return this.getNumberAttribute('multihop');
  }
  public set multihop(value: number) {
    this._multihop = value;
  }
  public resetMultihop() {
    this._multihop = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get multihopInput() {
    return this._multihop;
  }

  // timers - computed: false, optional: true, required: false
  private _timers?: string; 
  public get timers() {
    return this.getStringAttribute('timers');
  }
  public set timers(value: string) {
    this._timers = value;
  }
  public resetTimers() {
    this._timers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timersInput() {
    return this._timers;
  }
}
export interface LogicalRouterVrfBgpPeerGroupFilteringProfile {
  /**
  * Ipv4
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#ipv4 LogicalRouter#ipv4}
  */
  readonly ipv4?: string;
  /**
  * Ipv6
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#ipv6 LogicalRouter#ipv6}
  */
  readonly ipv6?: string;
}

export function logicalRouterVrfBgpPeerGroupFilteringProfileToTerraform(struct?: LogicalRouterVrfBgpPeerGroupFilteringProfile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ipv4: cdktf.stringToTerraform(struct!.ipv4),
    ipv6: cdktf.stringToTerraform(struct!.ipv6),
  }
}


export function logicalRouterVrfBgpPeerGroupFilteringProfileToHclTerraform(struct?: LogicalRouterVrfBgpPeerGroupFilteringProfile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ipv4: {
      value: cdktf.stringToHclTerraform(struct!.ipv4),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ipv6: {
      value: cdktf.stringToHclTerraform(struct!.ipv6),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPeerGroupFilteringProfileOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPeerGroupFilteringProfile | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ipv4 !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipv4 = this._ipv4;
    }
    if (this._ipv6 !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipv6 = this._ipv6;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPeerGroupFilteringProfile | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ipv4 = undefined;
      this._ipv6 = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ipv4 = value.ipv4;
      this._ipv6 = value.ipv6;
    }
  }

  // ipv4 - computed: false, optional: true, required: false
  private _ipv4?: string; 
  public get ipv4() {
    return this.getStringAttribute('ipv4');
  }
  public set ipv4(value: string) {
    this._ipv4 = value;
  }
  public resetIpv4() {
    this._ipv4 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipv4Input() {
    return this._ipv4;
  }

  // ipv6 - computed: false, optional: true, required: false
  private _ipv6?: string; 
  public get ipv6() {
    return this.getStringAttribute('ipv6');
  }
  public set ipv6(value: string) {
    this._ipv6 = value;
  }
  public resetIpv6() {
    this._ipv6 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipv6Input() {
    return this._ipv6;
  }
}
export interface LogicalRouterVrfBgpPeerGroupPeerBfdMultihop {
  /**
  * Min received ttl
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#min_received_ttl LogicalRouter#min_received_ttl}
  */
  readonly minReceivedTtl?: number;
}

export function logicalRouterVrfBgpPeerGroupPeerBfdMultihopToTerraform(struct?: LogicalRouterVrfBgpPeerGroupPeerBfdMultihop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    min_received_ttl: cdktf.numberToTerraform(struct!.minReceivedTtl),
  }
}


export function logicalRouterVrfBgpPeerGroupPeerBfdMultihopToHclTerraform(struct?: LogicalRouterVrfBgpPeerGroupPeerBfdMultihop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    min_received_ttl: {
      value: cdktf.numberToHclTerraform(struct!.minReceivedTtl),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPeerGroupPeerBfdMultihopOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPeerGroupPeerBfdMultihop | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._minReceivedTtl !== undefined) {
      hasAnyValues = true;
      internalValueResult.minReceivedTtl = this._minReceivedTtl;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPeerGroupPeerBfdMultihop | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._minReceivedTtl = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._minReceivedTtl = value.minReceivedTtl;
    }
  }

  // min_received_ttl - computed: false, optional: true, required: false
  private _minReceivedTtl?: number; 
  public get minReceivedTtl() {
    return this.getNumberAttribute('min_received_ttl');
  }
  public set minReceivedTtl(value: number) {
    this._minReceivedTtl = value;
  }
  public resetMinReceivedTtl() {
    this._minReceivedTtl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minReceivedTtlInput() {
    return this._minReceivedTtl;
  }
}
export interface LogicalRouterVrfBgpPeerGroupPeerBfd {
  /**
  * Multihop
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#multihop LogicalRouter#multihop}
  */
  readonly multihop?: LogicalRouterVrfBgpPeerGroupPeerBfdMultihop;
  /**
  * Profile
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#profile LogicalRouter#profile}
  */
  readonly profile?: string;
}

export function logicalRouterVrfBgpPeerGroupPeerBfdToTerraform(struct?: LogicalRouterVrfBgpPeerGroupPeerBfd | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    multihop: logicalRouterVrfBgpPeerGroupPeerBfdMultihopToTerraform(struct!.multihop),
    profile: cdktf.stringToTerraform(struct!.profile),
  }
}


export function logicalRouterVrfBgpPeerGroupPeerBfdToHclTerraform(struct?: LogicalRouterVrfBgpPeerGroupPeerBfd | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    multihop: {
      value: logicalRouterVrfBgpPeerGroupPeerBfdMultihopToHclTerraform(struct!.multihop),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPeerGroupPeerBfdMultihop",
    },
    profile: {
      value: cdktf.stringToHclTerraform(struct!.profile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPeerGroupPeerBfdOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPeerGroupPeerBfd | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._multihop?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.multihop = this._multihop?.internalValue;
    }
    if (this._profile !== undefined) {
      hasAnyValues = true;
      internalValueResult.profile = this._profile;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPeerGroupPeerBfd | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._multihop.internalValue = undefined;
      this._profile = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._multihop.internalValue = value.multihop;
      this._profile = value.profile;
    }
  }

  // multihop - computed: false, optional: true, required: false
  private _multihop = new LogicalRouterVrfBgpPeerGroupPeerBfdMultihopOutputReference(this, "multihop");
  public get multihop() {
    return this._multihop;
  }
  public putMultihop(value: LogicalRouterVrfBgpPeerGroupPeerBfdMultihop) {
    this._multihop.internalValue = value;
  }
  public resetMultihop() {
    this._multihop.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get multihopInput() {
    return this._multihop.internalValue;
  }

  // profile - computed: false, optional: true, required: false
  private _profile?: string; 
  public get profile() {
    return this.getStringAttribute('profile');
  }
  public set profile(value: string) {
    this._profile = value;
  }
  public resetProfile() {
    this._profile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get profileInput() {
    return this._profile;
  }
}
export interface LogicalRouterVrfBgpPeerGroupPeerConnectionOptionsIncomingBgpConnection {
  /**
  * Allow
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#allow LogicalRouter#allow}
  */
  readonly allow?: boolean | cdktf.IResolvable;
  /**
  * Remote port
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#remote_port LogicalRouter#remote_port}
  */
  readonly remotePort?: number;
}

export function logicalRouterVrfBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionToTerraform(struct?: LogicalRouterVrfBgpPeerGroupPeerConnectionOptionsIncomingBgpConnection | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow: cdktf.booleanToTerraform(struct!.allow),
    remote_port: cdktf.numberToTerraform(struct!.remotePort),
  }
}


export function logicalRouterVrfBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionToHclTerraform(struct?: LogicalRouterVrfBgpPeerGroupPeerConnectionOptionsIncomingBgpConnection | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow: {
      value: cdktf.booleanToHclTerraform(struct!.allow),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    remote_port: {
      value: cdktf.numberToHclTerraform(struct!.remotePort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPeerGroupPeerConnectionOptionsIncomingBgpConnection | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allow !== undefined) {
      hasAnyValues = true;
      internalValueResult.allow = this._allow;
    }
    if (this._remotePort !== undefined) {
      hasAnyValues = true;
      internalValueResult.remotePort = this._remotePort;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPeerGroupPeerConnectionOptionsIncomingBgpConnection | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allow = undefined;
      this._remotePort = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allow = value.allow;
      this._remotePort = value.remotePort;
    }
  }

  // allow - computed: false, optional: true, required: false
  private _allow?: boolean | cdktf.IResolvable; 
  public get allow() {
    return this.getBooleanAttribute('allow');
  }
  public set allow(value: boolean | cdktf.IResolvable) {
    this._allow = value;
  }
  public resetAllow() {
    this._allow = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowInput() {
    return this._allow;
  }

  // remote_port - computed: false, optional: true, required: false
  private _remotePort?: number; 
  public get remotePort() {
    return this.getNumberAttribute('remote_port');
  }
  public set remotePort(value: number) {
    this._remotePort = value;
  }
  public resetRemotePort() {
    this._remotePort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get remotePortInput() {
    return this._remotePort;
  }
}
export interface LogicalRouterVrfBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnection {
  /**
  * Allow
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#allow LogicalRouter#allow}
  */
  readonly allow?: boolean | cdktf.IResolvable;
  /**
  * Local port
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#local_port LogicalRouter#local_port}
  */
  readonly localPort?: number;
}

export function logicalRouterVrfBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionToTerraform(struct?: LogicalRouterVrfBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnection | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow: cdktf.booleanToTerraform(struct!.allow),
    local_port: cdktf.numberToTerraform(struct!.localPort),
  }
}


export function logicalRouterVrfBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionToHclTerraform(struct?: LogicalRouterVrfBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnection | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow: {
      value: cdktf.booleanToHclTerraform(struct!.allow),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    local_port: {
      value: cdktf.numberToHclTerraform(struct!.localPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnection | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allow !== undefined) {
      hasAnyValues = true;
      internalValueResult.allow = this._allow;
    }
    if (this._localPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.localPort = this._localPort;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnection | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allow = undefined;
      this._localPort = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allow = value.allow;
      this._localPort = value.localPort;
    }
  }

  // allow - computed: false, optional: true, required: false
  private _allow?: boolean | cdktf.IResolvable; 
  public get allow() {
    return this.getBooleanAttribute('allow');
  }
  public set allow(value: boolean | cdktf.IResolvable) {
    this._allow = value;
  }
  public resetAllow() {
    this._allow = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowInput() {
    return this._allow;
  }

  // local_port - computed: false, optional: true, required: false
  private _localPort?: number; 
  public get localPort() {
    return this.getNumberAttribute('local_port');
  }
  public set localPort(value: number) {
    this._localPort = value;
  }
  public resetLocalPort() {
    this._localPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localPortInput() {
    return this._localPort;
  }
}
export interface LogicalRouterVrfBgpPeerGroupPeerConnectionOptions {
  /**
  * Authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#authentication LogicalRouter#authentication}
  */
  readonly authentication?: string;
  /**
  * Dampening
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#dampening LogicalRouter#dampening}
  */
  readonly dampening?: string;
  /**
  * Hold time
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#hold_time LogicalRouter#hold_time}
  */
  readonly holdTime?: string;
  /**
  * Idle hold time
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#idle_hold_time LogicalRouter#idle_hold_time}
  */
  readonly idleHoldTime?: number;
  /**
  * Incoming bgp connection
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#incoming_bgp_connection LogicalRouter#incoming_bgp_connection}
  */
  readonly incomingBgpConnection?: LogicalRouterVrfBgpPeerGroupPeerConnectionOptionsIncomingBgpConnection;
  /**
  * Keep alive interval
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#keep_alive_interval LogicalRouter#keep_alive_interval}
  */
  readonly keepAliveInterval?: string;
  /**
  * Max prefixes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#max_prefixes LogicalRouter#max_prefixes}
  */
  readonly maxPrefixes?: string;
  /**
  * Min route adv interval
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#min_route_adv_interval LogicalRouter#min_route_adv_interval}
  */
  readonly minRouteAdvInterval?: number;
  /**
  * Multihop
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#multihop LogicalRouter#multihop}
  */
  readonly multihop?: string;
  /**
  * Open delay time
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#open_delay_time LogicalRouter#open_delay_time}
  */
  readonly openDelayTime?: number;
  /**
  * Outgoing bgp connection
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#outgoing_bgp_connection LogicalRouter#outgoing_bgp_connection}
  */
  readonly outgoingBgpConnection?: LogicalRouterVrfBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnection;
  /**
  * Timers
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#timers LogicalRouter#timers}
  */
  readonly timers?: string;
}

export function logicalRouterVrfBgpPeerGroupPeerConnectionOptionsToTerraform(struct?: LogicalRouterVrfBgpPeerGroupPeerConnectionOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    authentication: cdktf.stringToTerraform(struct!.authentication),
    dampening: cdktf.stringToTerraform(struct!.dampening),
    hold_time: cdktf.stringToTerraform(struct!.holdTime),
    idle_hold_time: cdktf.numberToTerraform(struct!.idleHoldTime),
    incoming_bgp_connection: logicalRouterVrfBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionToTerraform(struct!.incomingBgpConnection),
    keep_alive_interval: cdktf.stringToTerraform(struct!.keepAliveInterval),
    max_prefixes: cdktf.stringToTerraform(struct!.maxPrefixes),
    min_route_adv_interval: cdktf.numberToTerraform(struct!.minRouteAdvInterval),
    multihop: cdktf.stringToTerraform(struct!.multihop),
    open_delay_time: cdktf.numberToTerraform(struct!.openDelayTime),
    outgoing_bgp_connection: logicalRouterVrfBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionToTerraform(struct!.outgoingBgpConnection),
    timers: cdktf.stringToTerraform(struct!.timers),
  }
}


export function logicalRouterVrfBgpPeerGroupPeerConnectionOptionsToHclTerraform(struct?: LogicalRouterVrfBgpPeerGroupPeerConnectionOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    authentication: {
      value: cdktf.stringToHclTerraform(struct!.authentication),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dampening: {
      value: cdktf.stringToHclTerraform(struct!.dampening),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hold_time: {
      value: cdktf.stringToHclTerraform(struct!.holdTime),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    idle_hold_time: {
      value: cdktf.numberToHclTerraform(struct!.idleHoldTime),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    incoming_bgp_connection: {
      value: logicalRouterVrfBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionToHclTerraform(struct!.incomingBgpConnection),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPeerGroupPeerConnectionOptionsIncomingBgpConnection",
    },
    keep_alive_interval: {
      value: cdktf.stringToHclTerraform(struct!.keepAliveInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_prefixes: {
      value: cdktf.stringToHclTerraform(struct!.maxPrefixes),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_route_adv_interval: {
      value: cdktf.numberToHclTerraform(struct!.minRouteAdvInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    multihop: {
      value: cdktf.stringToHclTerraform(struct!.multihop),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    open_delay_time: {
      value: cdktf.numberToHclTerraform(struct!.openDelayTime),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    outgoing_bgp_connection: {
      value: logicalRouterVrfBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionToHclTerraform(struct!.outgoingBgpConnection),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnection",
    },
    timers: {
      value: cdktf.stringToHclTerraform(struct!.timers),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPeerGroupPeerConnectionOptionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPeerGroupPeerConnectionOptions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authentication !== undefined) {
      hasAnyValues = true;
      internalValueResult.authentication = this._authentication;
    }
    if (this._dampening !== undefined) {
      hasAnyValues = true;
      internalValueResult.dampening = this._dampening;
    }
    if (this._holdTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.holdTime = this._holdTime;
    }
    if (this._idleHoldTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.idleHoldTime = this._idleHoldTime;
    }
    if (this._incomingBgpConnection?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.incomingBgpConnection = this._incomingBgpConnection?.internalValue;
    }
    if (this._keepAliveInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepAliveInterval = this._keepAliveInterval;
    }
    if (this._maxPrefixes !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPrefixes = this._maxPrefixes;
    }
    if (this._minRouteAdvInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.minRouteAdvInterval = this._minRouteAdvInterval;
    }
    if (this._multihop !== undefined) {
      hasAnyValues = true;
      internalValueResult.multihop = this._multihop;
    }
    if (this._openDelayTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.openDelayTime = this._openDelayTime;
    }
    if (this._outgoingBgpConnection?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.outgoingBgpConnection = this._outgoingBgpConnection?.internalValue;
    }
    if (this._timers !== undefined) {
      hasAnyValues = true;
      internalValueResult.timers = this._timers;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPeerGroupPeerConnectionOptions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authentication = undefined;
      this._dampening = undefined;
      this._holdTime = undefined;
      this._idleHoldTime = undefined;
      this._incomingBgpConnection.internalValue = undefined;
      this._keepAliveInterval = undefined;
      this._maxPrefixes = undefined;
      this._minRouteAdvInterval = undefined;
      this._multihop = undefined;
      this._openDelayTime = undefined;
      this._outgoingBgpConnection.internalValue = undefined;
      this._timers = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authentication = value.authentication;
      this._dampening = value.dampening;
      this._holdTime = value.holdTime;
      this._idleHoldTime = value.idleHoldTime;
      this._incomingBgpConnection.internalValue = value.incomingBgpConnection;
      this._keepAliveInterval = value.keepAliveInterval;
      this._maxPrefixes = value.maxPrefixes;
      this._minRouteAdvInterval = value.minRouteAdvInterval;
      this._multihop = value.multihop;
      this._openDelayTime = value.openDelayTime;
      this._outgoingBgpConnection.internalValue = value.outgoingBgpConnection;
      this._timers = value.timers;
    }
  }

  // authentication - computed: false, optional: true, required: false
  private _authentication?: string; 
  public get authentication() {
    return this.getStringAttribute('authentication');
  }
  public set authentication(value: string) {
    this._authentication = value;
  }
  public resetAuthentication() {
    this._authentication = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authenticationInput() {
    return this._authentication;
  }

  // dampening - computed: false, optional: true, required: false
  private _dampening?: string; 
  public get dampening() {
    return this.getStringAttribute('dampening');
  }
  public set dampening(value: string) {
    this._dampening = value;
  }
  public resetDampening() {
    this._dampening = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dampeningInput() {
    return this._dampening;
  }

  // hold_time - computed: false, optional: true, required: false
  private _holdTime?: string; 
  public get holdTime() {
    return this.getStringAttribute('hold_time');
  }
  public set holdTime(value: string) {
    this._holdTime = value;
  }
  public resetHoldTime() {
    this._holdTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get holdTimeInput() {
    return this._holdTime;
  }

  // idle_hold_time - computed: false, optional: true, required: false
  private _idleHoldTime?: number; 
  public get idleHoldTime() {
    return this.getNumberAttribute('idle_hold_time');
  }
  public set idleHoldTime(value: number) {
    this._idleHoldTime = value;
  }
  public resetIdleHoldTime() {
    this._idleHoldTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idleHoldTimeInput() {
    return this._idleHoldTime;
  }

  // incoming_bgp_connection - computed: false, optional: true, required: false
  private _incomingBgpConnection = new LogicalRouterVrfBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionOutputReference(this, "incoming_bgp_connection");
  public get incomingBgpConnection() {
    return this._incomingBgpConnection;
  }
  public putIncomingBgpConnection(value: LogicalRouterVrfBgpPeerGroupPeerConnectionOptionsIncomingBgpConnection) {
    this._incomingBgpConnection.internalValue = value;
  }
  public resetIncomingBgpConnection() {
    this._incomingBgpConnection.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get incomingBgpConnectionInput() {
    return this._incomingBgpConnection.internalValue;
  }

  // keep_alive_interval - computed: false, optional: true, required: false
  private _keepAliveInterval?: string; 
  public get keepAliveInterval() {
    return this.getStringAttribute('keep_alive_interval');
  }
  public set keepAliveInterval(value: string) {
    this._keepAliveInterval = value;
  }
  public resetKeepAliveInterval() {
    this._keepAliveInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepAliveIntervalInput() {
    return this._keepAliveInterval;
  }

  // max_prefixes - computed: false, optional: true, required: false
  private _maxPrefixes?: string; 
  public get maxPrefixes() {
    return this.getStringAttribute('max_prefixes');
  }
  public set maxPrefixes(value: string) {
    this._maxPrefixes = value;
  }
  public resetMaxPrefixes() {
    this._maxPrefixes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPrefixesInput() {
    return this._maxPrefixes;
  }

  // min_route_adv_interval - computed: false, optional: true, required: false
  private _minRouteAdvInterval?: number; 
  public get minRouteAdvInterval() {
    return this.getNumberAttribute('min_route_adv_interval');
  }
  public set minRouteAdvInterval(value: number) {
    this._minRouteAdvInterval = value;
  }
  public resetMinRouteAdvInterval() {
    this._minRouteAdvInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minRouteAdvIntervalInput() {
    return this._minRouteAdvInterval;
  }

  // multihop - computed: false, optional: true, required: false
  private _multihop?: string; 
  public get multihop() {
    return this.getStringAttribute('multihop');
  }
  public set multihop(value: string) {
    this._multihop = value;
  }
  public resetMultihop() {
    this._multihop = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get multihopInput() {
    return this._multihop;
  }

  // open_delay_time - computed: false, optional: true, required: false
  private _openDelayTime?: number; 
  public get openDelayTime() {
    return this.getNumberAttribute('open_delay_time');
  }
  public set openDelayTime(value: number) {
    this._openDelayTime = value;
  }
  public resetOpenDelayTime() {
    this._openDelayTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get openDelayTimeInput() {
    return this._openDelayTime;
  }

  // outgoing_bgp_connection - computed: false, optional: true, required: false
  private _outgoingBgpConnection = new LogicalRouterVrfBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionOutputReference(this, "outgoing_bgp_connection");
  public get outgoingBgpConnection() {
    return this._outgoingBgpConnection;
  }
  public putOutgoingBgpConnection(value: LogicalRouterVrfBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnection) {
    this._outgoingBgpConnection.internalValue = value;
  }
  public resetOutgoingBgpConnection() {
    this._outgoingBgpConnection.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get outgoingBgpConnectionInput() {
    return this._outgoingBgpConnection.internalValue;
  }

  // timers - computed: false, optional: true, required: false
  private _timers?: string; 
  public get timers() {
    return this.getStringAttribute('timers');
  }
  public set timers(value: string) {
    this._timers = value;
  }
  public resetTimers() {
    this._timers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timersInput() {
    return this._timers;
  }
}
export interface LogicalRouterVrfBgpPeerGroupPeerInheritNoAddressFamily {
  /**
  * Ipv4
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#ipv4 LogicalRouter#ipv4}
  */
  readonly ipv4?: string;
  /**
  * Ipv6
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#ipv6 LogicalRouter#ipv6}
  */
  readonly ipv6?: string;
}

export function logicalRouterVrfBgpPeerGroupPeerInheritNoAddressFamilyToTerraform(struct?: LogicalRouterVrfBgpPeerGroupPeerInheritNoAddressFamily | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ipv4: cdktf.stringToTerraform(struct!.ipv4),
    ipv6: cdktf.stringToTerraform(struct!.ipv6),
  }
}


export function logicalRouterVrfBgpPeerGroupPeerInheritNoAddressFamilyToHclTerraform(struct?: LogicalRouterVrfBgpPeerGroupPeerInheritNoAddressFamily | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ipv4: {
      value: cdktf.stringToHclTerraform(struct!.ipv4),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ipv6: {
      value: cdktf.stringToHclTerraform(struct!.ipv6),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPeerGroupPeerInheritNoAddressFamilyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPeerGroupPeerInheritNoAddressFamily | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ipv4 !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipv4 = this._ipv4;
    }
    if (this._ipv6 !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipv6 = this._ipv6;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPeerGroupPeerInheritNoAddressFamily | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ipv4 = undefined;
      this._ipv6 = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ipv4 = value.ipv4;
      this._ipv6 = value.ipv6;
    }
  }

  // ipv4 - computed: false, optional: true, required: false
  private _ipv4?: string; 
  public get ipv4() {
    return this.getStringAttribute('ipv4');
  }
  public set ipv4(value: string) {
    this._ipv4 = value;
  }
  public resetIpv4() {
    this._ipv4 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipv4Input() {
    return this._ipv4;
  }

  // ipv6 - computed: false, optional: true, required: false
  private _ipv6?: string; 
  public get ipv6() {
    return this.getStringAttribute('ipv6');
  }
  public set ipv6(value: string) {
    this._ipv6 = value;
  }
  public resetIpv6() {
    this._ipv6 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipv6Input() {
    return this._ipv6;
  }
}
export interface LogicalRouterVrfBgpPeerGroupPeerInheritNoFilteringProfile {
  /**
  * Ipv4
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#ipv4 LogicalRouter#ipv4}
  */
  readonly ipv4?: string;
  /**
  * Ipv6
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#ipv6 LogicalRouter#ipv6}
  */
  readonly ipv6?: string;
}

export function logicalRouterVrfBgpPeerGroupPeerInheritNoFilteringProfileToTerraform(struct?: LogicalRouterVrfBgpPeerGroupPeerInheritNoFilteringProfile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ipv4: cdktf.stringToTerraform(struct!.ipv4),
    ipv6: cdktf.stringToTerraform(struct!.ipv6),
  }
}


export function logicalRouterVrfBgpPeerGroupPeerInheritNoFilteringProfileToHclTerraform(struct?: LogicalRouterVrfBgpPeerGroupPeerInheritNoFilteringProfile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ipv4: {
      value: cdktf.stringToHclTerraform(struct!.ipv4),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ipv6: {
      value: cdktf.stringToHclTerraform(struct!.ipv6),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPeerGroupPeerInheritNoFilteringProfileOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPeerGroupPeerInheritNoFilteringProfile | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ipv4 !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipv4 = this._ipv4;
    }
    if (this._ipv6 !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipv6 = this._ipv6;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPeerGroupPeerInheritNoFilteringProfile | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ipv4 = undefined;
      this._ipv6 = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ipv4 = value.ipv4;
      this._ipv6 = value.ipv6;
    }
  }

  // ipv4 - computed: false, optional: true, required: false
  private _ipv4?: string; 
  public get ipv4() {
    return this.getStringAttribute('ipv4');
  }
  public set ipv4(value: string) {
    this._ipv4 = value;
  }
  public resetIpv4() {
    this._ipv4 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipv4Input() {
    return this._ipv4;
  }

  // ipv6 - computed: false, optional: true, required: false
  private _ipv6?: string; 
  public get ipv6() {
    return this.getStringAttribute('ipv6');
  }
  public set ipv6(value: string) {
    this._ipv6 = value;
  }
  public resetIpv6() {
    this._ipv6 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipv6Input() {
    return this._ipv6;
  }
}
export interface LogicalRouterVrfBgpPeerGroupPeerInheritNo {
  /**
  * Address family
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#address_family LogicalRouter#address_family}
  */
  readonly addressFamily?: LogicalRouterVrfBgpPeerGroupPeerInheritNoAddressFamily;
  /**
  * Filtering profile
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#filtering_profile LogicalRouter#filtering_profile}
  */
  readonly filteringProfile?: LogicalRouterVrfBgpPeerGroupPeerInheritNoFilteringProfile;
}

export function logicalRouterVrfBgpPeerGroupPeerInheritNoToTerraform(struct?: LogicalRouterVrfBgpPeerGroupPeerInheritNo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address_family: logicalRouterVrfBgpPeerGroupPeerInheritNoAddressFamilyToTerraform(struct!.addressFamily),
    filtering_profile: logicalRouterVrfBgpPeerGroupPeerInheritNoFilteringProfileToTerraform(struct!.filteringProfile),
  }
}


export function logicalRouterVrfBgpPeerGroupPeerInheritNoToHclTerraform(struct?: LogicalRouterVrfBgpPeerGroupPeerInheritNo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address_family: {
      value: logicalRouterVrfBgpPeerGroupPeerInheritNoAddressFamilyToHclTerraform(struct!.addressFamily),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPeerGroupPeerInheritNoAddressFamily",
    },
    filtering_profile: {
      value: logicalRouterVrfBgpPeerGroupPeerInheritNoFilteringProfileToHclTerraform(struct!.filteringProfile),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPeerGroupPeerInheritNoFilteringProfile",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPeerGroupPeerInheritNoOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPeerGroupPeerInheritNo | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addressFamily?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.addressFamily = this._addressFamily?.internalValue;
    }
    if (this._filteringProfile?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.filteringProfile = this._filteringProfile?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPeerGroupPeerInheritNo | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addressFamily.internalValue = undefined;
      this._filteringProfile.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addressFamily.internalValue = value.addressFamily;
      this._filteringProfile.internalValue = value.filteringProfile;
    }
  }

  // address_family - computed: false, optional: true, required: false
  private _addressFamily = new LogicalRouterVrfBgpPeerGroupPeerInheritNoAddressFamilyOutputReference(this, "address_family");
  public get addressFamily() {
    return this._addressFamily;
  }
  public putAddressFamily(value: LogicalRouterVrfBgpPeerGroupPeerInheritNoAddressFamily) {
    this._addressFamily.internalValue = value;
  }
  public resetAddressFamily() {
    this._addressFamily.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressFamilyInput() {
    return this._addressFamily.internalValue;
  }

  // filtering_profile - computed: false, optional: true, required: false
  private _filteringProfile = new LogicalRouterVrfBgpPeerGroupPeerInheritNoFilteringProfileOutputReference(this, "filtering_profile");
  public get filteringProfile() {
    return this._filteringProfile;
  }
  public putFilteringProfile(value: LogicalRouterVrfBgpPeerGroupPeerInheritNoFilteringProfile) {
    this._filteringProfile.internalValue = value;
  }
  public resetFilteringProfile() {
    this._filteringProfile.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get filteringProfileInput() {
    return this._filteringProfile.internalValue;
  }
}
export interface LogicalRouterVrfBgpPeerGroupPeerInheritYes {
}

export function logicalRouterVrfBgpPeerGroupPeerInheritYesToTerraform(struct?: LogicalRouterVrfBgpPeerGroupPeerInheritYes | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function logicalRouterVrfBgpPeerGroupPeerInheritYesToHclTerraform(struct?: LogicalRouterVrfBgpPeerGroupPeerInheritYes | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class LogicalRouterVrfBgpPeerGroupPeerInheritYesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPeerGroupPeerInheritYes | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPeerGroupPeerInheritYes | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface LogicalRouterVrfBgpPeerGroupPeerInherit {
  /**
  * No
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#no LogicalRouter#no}
  */
  readonly no?: LogicalRouterVrfBgpPeerGroupPeerInheritNo;
  /**
  * Yes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#yes LogicalRouter#yes}
  */
  readonly yes?: LogicalRouterVrfBgpPeerGroupPeerInheritYes;
}

export function logicalRouterVrfBgpPeerGroupPeerInheritToTerraform(struct?: LogicalRouterVrfBgpPeerGroupPeerInherit | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    no: logicalRouterVrfBgpPeerGroupPeerInheritNoToTerraform(struct!.no),
    yes: logicalRouterVrfBgpPeerGroupPeerInheritYesToTerraform(struct!.yes),
  }
}


export function logicalRouterVrfBgpPeerGroupPeerInheritToHclTerraform(struct?: LogicalRouterVrfBgpPeerGroupPeerInherit | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    no: {
      value: logicalRouterVrfBgpPeerGroupPeerInheritNoToHclTerraform(struct!.no),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPeerGroupPeerInheritNo",
    },
    yes: {
      value: logicalRouterVrfBgpPeerGroupPeerInheritYesToHclTerraform(struct!.yes),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPeerGroupPeerInheritYes",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPeerGroupPeerInheritOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPeerGroupPeerInherit | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._no?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.no = this._no?.internalValue;
    }
    if (this._yes?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.yes = this._yes?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPeerGroupPeerInherit | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._no.internalValue = undefined;
      this._yes.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._no.internalValue = value.no;
      this._yes.internalValue = value.yes;
    }
  }

  // no - computed: false, optional: true, required: false
  private _no = new LogicalRouterVrfBgpPeerGroupPeerInheritNoOutputReference(this, "no");
  public get no() {
    return this._no;
  }
  public putNo(value: LogicalRouterVrfBgpPeerGroupPeerInheritNo) {
    this._no.internalValue = value;
  }
  public resetNo() {
    this._no.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get noInput() {
    return this._no.internalValue;
  }

  // yes - computed: false, optional: true, required: false
  private _yes = new LogicalRouterVrfBgpPeerGroupPeerInheritYesOutputReference(this, "yes");
  public get yes() {
    return this._yes;
  }
  public putYes(value: LogicalRouterVrfBgpPeerGroupPeerInheritYes) {
    this._yes.internalValue = value;
  }
  public resetYes() {
    this._yes.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get yesInput() {
    return this._yes.internalValue;
  }
}
export interface LogicalRouterVrfBgpPeerGroupPeerLocalAddress {
  /**
  * Interface
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#interface LogicalRouter#interface}
  */
  readonly interface?: string;
  /**
  * Ip
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#ip LogicalRouter#ip}
  */
  readonly ip?: string;
}

export function logicalRouterVrfBgpPeerGroupPeerLocalAddressToTerraform(struct?: LogicalRouterVrfBgpPeerGroupPeerLocalAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    interface: cdktf.stringToTerraform(struct!.interface),
    ip: cdktf.stringToTerraform(struct!.ip),
  }
}


export function logicalRouterVrfBgpPeerGroupPeerLocalAddressToHclTerraform(struct?: LogicalRouterVrfBgpPeerGroupPeerLocalAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    interface: {
      value: cdktf.stringToHclTerraform(struct!.interface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip: {
      value: cdktf.stringToHclTerraform(struct!.ip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPeerGroupPeerLocalAddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPeerGroupPeerLocalAddress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._interface !== undefined) {
      hasAnyValues = true;
      internalValueResult.interface = this._interface;
    }
    if (this._ip !== undefined) {
      hasAnyValues = true;
      internalValueResult.ip = this._ip;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPeerGroupPeerLocalAddress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._interface = undefined;
      this._ip = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._interface = value.interface;
      this._ip = value.ip;
    }
  }

  // interface - computed: false, optional: true, required: false
  private _interface?: string; 
  public get interface() {
    return this.getStringAttribute('interface');
  }
  public set interface(value: string) {
    this._interface = value;
  }
  public resetInterface() {
    this._interface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfaceInput() {
    return this._interface;
  }

  // ip - computed: false, optional: true, required: false
  private _ip?: string; 
  public get ip() {
    return this.getStringAttribute('ip');
  }
  public set ip(value: string) {
    this._ip = value;
  }
  public resetIp() {
    this._ip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipInput() {
    return this._ip;
  }
}
export interface LogicalRouterVrfBgpPeerGroupPeerPeerAddress {
  /**
  * Fqdn
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#fqdn LogicalRouter#fqdn}
  */
  readonly fqdn?: string;
  /**
  * Ip
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#ip LogicalRouter#ip}
  */
  readonly ip?: string;
}

export function logicalRouterVrfBgpPeerGroupPeerPeerAddressToTerraform(struct?: LogicalRouterVrfBgpPeerGroupPeerPeerAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    fqdn: cdktf.stringToTerraform(struct!.fqdn),
    ip: cdktf.stringToTerraform(struct!.ip),
  }
}


export function logicalRouterVrfBgpPeerGroupPeerPeerAddressToHclTerraform(struct?: LogicalRouterVrfBgpPeerGroupPeerPeerAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    fqdn: {
      value: cdktf.stringToHclTerraform(struct!.fqdn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip: {
      value: cdktf.stringToHclTerraform(struct!.ip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPeerGroupPeerPeerAddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPeerGroupPeerPeerAddress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fqdn !== undefined) {
      hasAnyValues = true;
      internalValueResult.fqdn = this._fqdn;
    }
    if (this._ip !== undefined) {
      hasAnyValues = true;
      internalValueResult.ip = this._ip;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPeerGroupPeerPeerAddress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fqdn = undefined;
      this._ip = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fqdn = value.fqdn;
      this._ip = value.ip;
    }
  }

  // fqdn - computed: false, optional: true, required: false
  private _fqdn?: string; 
  public get fqdn() {
    return this.getStringAttribute('fqdn');
  }
  public set fqdn(value: string) {
    this._fqdn = value;
  }
  public resetFqdn() {
    this._fqdn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fqdnInput() {
    return this._fqdn;
  }

  // ip - computed: false, optional: true, required: false
  private _ip?: string; 
  public get ip() {
    return this.getStringAttribute('ip');
  }
  public set ip(value: string) {
    this._ip = value;
  }
  public resetIp() {
    this._ip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipInput() {
    return this._ip;
  }
}
export interface LogicalRouterVrfBgpPeerGroupPeerSubsequentAddressFamilyIdentifier {
  /**
  * Multicast
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#multicast LogicalRouter#multicast}
  */
  readonly multicast?: boolean | cdktf.IResolvable;
  /**
  * Unicast
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#unicast LogicalRouter#unicast}
  */
  readonly unicast?: boolean | cdktf.IResolvable;
}

export function logicalRouterVrfBgpPeerGroupPeerSubsequentAddressFamilyIdentifierToTerraform(struct?: LogicalRouterVrfBgpPeerGroupPeerSubsequentAddressFamilyIdentifier | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    multicast: cdktf.booleanToTerraform(struct!.multicast),
    unicast: cdktf.booleanToTerraform(struct!.unicast),
  }
}


export function logicalRouterVrfBgpPeerGroupPeerSubsequentAddressFamilyIdentifierToHclTerraform(struct?: LogicalRouterVrfBgpPeerGroupPeerSubsequentAddressFamilyIdentifier | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    multicast: {
      value: cdktf.booleanToHclTerraform(struct!.multicast),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    unicast: {
      value: cdktf.booleanToHclTerraform(struct!.unicast),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPeerGroupPeerSubsequentAddressFamilyIdentifierOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPeerGroupPeerSubsequentAddressFamilyIdentifier | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._multicast !== undefined) {
      hasAnyValues = true;
      internalValueResult.multicast = this._multicast;
    }
    if (this._unicast !== undefined) {
      hasAnyValues = true;
      internalValueResult.unicast = this._unicast;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPeerGroupPeerSubsequentAddressFamilyIdentifier | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._multicast = undefined;
      this._unicast = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._multicast = value.multicast;
      this._unicast = value.unicast;
    }
  }

  // multicast - computed: false, optional: true, required: false
  private _multicast?: boolean | cdktf.IResolvable; 
  public get multicast() {
    return this.getBooleanAttribute('multicast');
  }
  public set multicast(value: boolean | cdktf.IResolvable) {
    this._multicast = value;
  }
  public resetMulticast() {
    this._multicast = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get multicastInput() {
    return this._multicast;
  }

  // unicast - computed: false, optional: true, required: false
  private _unicast?: boolean | cdktf.IResolvable; 
  public get unicast() {
    return this.getBooleanAttribute('unicast');
  }
  public set unicast(value: boolean | cdktf.IResolvable) {
    this._unicast = value;
  }
  public resetUnicast() {
    this._unicast = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get unicastInput() {
    return this._unicast;
  }
}
export interface LogicalRouterVrfBgpPeerGroupPeer {
  /**
  * Bfd
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#bfd LogicalRouter#bfd}
  */
  readonly bfd?: LogicalRouterVrfBgpPeerGroupPeerBfd;
  /**
  * Connection options
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#connection_options LogicalRouter#connection_options}
  */
  readonly connectionOptions?: LogicalRouterVrfBgpPeerGroupPeerConnectionOptions;
  /**
  * Enable
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#enable LogicalRouter#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * Enable mp bgp
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#enable_mp_bgp LogicalRouter#enable_mp_bgp}
  */
  readonly enableMpBgp?: boolean | cdktf.IResolvable;
  /**
  * Enable sender side loop detection
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#enable_sender_side_loop_detection LogicalRouter#enable_sender_side_loop_detection}
  */
  readonly enableSenderSideLoopDetection?: boolean | cdktf.IResolvable;
  /**
  * Inherit
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#inherit LogicalRouter#inherit}
  */
  readonly inherit?: LogicalRouterVrfBgpPeerGroupPeerInherit;
  /**
  * Local address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#local_address LogicalRouter#local_address}
  */
  readonly localAddress?: LogicalRouterVrfBgpPeerGroupPeerLocalAddress;
  /**
  * Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#name LogicalRouter#name}
  */
  readonly name: string;
  /**
  * Passive
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#passive LogicalRouter#passive}
  */
  readonly passive?: boolean | cdktf.IResolvable;
  /**
  * Peer address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#peer_address LogicalRouter#peer_address}
  */
  readonly peerAddress?: LogicalRouterVrfBgpPeerGroupPeerPeerAddress;
  /**
  * Peer as
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#peer_as LogicalRouter#peer_as}
  */
  readonly peerAs?: string;
  /**
  * Peering type
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#peering_type LogicalRouter#peering_type}
  */
  readonly peeringType?: string;
  /**
  * Reflector client
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#reflector_client LogicalRouter#reflector_client}
  */
  readonly reflectorClient?: string;
  /**
  * Subsequent address family identifier
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#subsequent_address_family_identifier LogicalRouter#subsequent_address_family_identifier}
  */
  readonly subsequentAddressFamilyIdentifier?: LogicalRouterVrfBgpPeerGroupPeerSubsequentAddressFamilyIdentifier;
}

export function logicalRouterVrfBgpPeerGroupPeerToTerraform(struct?: LogicalRouterVrfBgpPeerGroupPeer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bfd: logicalRouterVrfBgpPeerGroupPeerBfdToTerraform(struct!.bfd),
    connection_options: logicalRouterVrfBgpPeerGroupPeerConnectionOptionsToTerraform(struct!.connectionOptions),
    enable: cdktf.booleanToTerraform(struct!.enable),
    enable_mp_bgp: cdktf.booleanToTerraform(struct!.enableMpBgp),
    enable_sender_side_loop_detection: cdktf.booleanToTerraform(struct!.enableSenderSideLoopDetection),
    inherit: logicalRouterVrfBgpPeerGroupPeerInheritToTerraform(struct!.inherit),
    local_address: logicalRouterVrfBgpPeerGroupPeerLocalAddressToTerraform(struct!.localAddress),
    name: cdktf.stringToTerraform(struct!.name),
    passive: cdktf.booleanToTerraform(struct!.passive),
    peer_address: logicalRouterVrfBgpPeerGroupPeerPeerAddressToTerraform(struct!.peerAddress),
    peer_as: cdktf.stringToTerraform(struct!.peerAs),
    peering_type: cdktf.stringToTerraform(struct!.peeringType),
    reflector_client: cdktf.stringToTerraform(struct!.reflectorClient),
    subsequent_address_family_identifier: logicalRouterVrfBgpPeerGroupPeerSubsequentAddressFamilyIdentifierToTerraform(struct!.subsequentAddressFamilyIdentifier),
  }
}


export function logicalRouterVrfBgpPeerGroupPeerToHclTerraform(struct?: LogicalRouterVrfBgpPeerGroupPeer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bfd: {
      value: logicalRouterVrfBgpPeerGroupPeerBfdToHclTerraform(struct!.bfd),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPeerGroupPeerBfd",
    },
    connection_options: {
      value: logicalRouterVrfBgpPeerGroupPeerConnectionOptionsToHclTerraform(struct!.connectionOptions),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPeerGroupPeerConnectionOptions",
    },
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_mp_bgp: {
      value: cdktf.booleanToHclTerraform(struct!.enableMpBgp),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_sender_side_loop_detection: {
      value: cdktf.booleanToHclTerraform(struct!.enableSenderSideLoopDetection),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    inherit: {
      value: logicalRouterVrfBgpPeerGroupPeerInheritToHclTerraform(struct!.inherit),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPeerGroupPeerInherit",
    },
    local_address: {
      value: logicalRouterVrfBgpPeerGroupPeerLocalAddressToHclTerraform(struct!.localAddress),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPeerGroupPeerLocalAddress",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passive: {
      value: cdktf.booleanToHclTerraform(struct!.passive),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    peer_address: {
      value: logicalRouterVrfBgpPeerGroupPeerPeerAddressToHclTerraform(struct!.peerAddress),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPeerGroupPeerPeerAddress",
    },
    peer_as: {
      value: cdktf.stringToHclTerraform(struct!.peerAs),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    peering_type: {
      value: cdktf.stringToHclTerraform(struct!.peeringType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reflector_client: {
      value: cdktf.stringToHclTerraform(struct!.reflectorClient),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subsequent_address_family_identifier: {
      value: logicalRouterVrfBgpPeerGroupPeerSubsequentAddressFamilyIdentifierToHclTerraform(struct!.subsequentAddressFamilyIdentifier),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPeerGroupPeerSubsequentAddressFamilyIdentifier",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPeerGroupPeerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): LogicalRouterVrfBgpPeerGroupPeer | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bfd?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.bfd = this._bfd?.internalValue;
    }
    if (this._connectionOptions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionOptions = this._connectionOptions?.internalValue;
    }
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._enableMpBgp !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableMpBgp = this._enableMpBgp;
    }
    if (this._enableSenderSideLoopDetection !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableSenderSideLoopDetection = this._enableSenderSideLoopDetection;
    }
    if (this._inherit?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.inherit = this._inherit?.internalValue;
    }
    if (this._localAddress?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.localAddress = this._localAddress?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._passive !== undefined) {
      hasAnyValues = true;
      internalValueResult.passive = this._passive;
    }
    if (this._peerAddress?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.peerAddress = this._peerAddress?.internalValue;
    }
    if (this._peerAs !== undefined) {
      hasAnyValues = true;
      internalValueResult.peerAs = this._peerAs;
    }
    if (this._peeringType !== undefined) {
      hasAnyValues = true;
      internalValueResult.peeringType = this._peeringType;
    }
    if (this._reflectorClient !== undefined) {
      hasAnyValues = true;
      internalValueResult.reflectorClient = this._reflectorClient;
    }
    if (this._subsequentAddressFamilyIdentifier?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.subsequentAddressFamilyIdentifier = this._subsequentAddressFamilyIdentifier?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPeerGroupPeer | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bfd.internalValue = undefined;
      this._connectionOptions.internalValue = undefined;
      this._enable = undefined;
      this._enableMpBgp = undefined;
      this._enableSenderSideLoopDetection = undefined;
      this._inherit.internalValue = undefined;
      this._localAddress.internalValue = undefined;
      this._name = undefined;
      this._passive = undefined;
      this._peerAddress.internalValue = undefined;
      this._peerAs = undefined;
      this._peeringType = undefined;
      this._reflectorClient = undefined;
      this._subsequentAddressFamilyIdentifier.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bfd.internalValue = value.bfd;
      this._connectionOptions.internalValue = value.connectionOptions;
      this._enable = value.enable;
      this._enableMpBgp = value.enableMpBgp;
      this._enableSenderSideLoopDetection = value.enableSenderSideLoopDetection;
      this._inherit.internalValue = value.inherit;
      this._localAddress.internalValue = value.localAddress;
      this._name = value.name;
      this._passive = value.passive;
      this._peerAddress.internalValue = value.peerAddress;
      this._peerAs = value.peerAs;
      this._peeringType = value.peeringType;
      this._reflectorClient = value.reflectorClient;
      this._subsequentAddressFamilyIdentifier.internalValue = value.subsequentAddressFamilyIdentifier;
    }
  }

  // bfd - computed: false, optional: true, required: false
  private _bfd = new LogicalRouterVrfBgpPeerGroupPeerBfdOutputReference(this, "bfd");
  public get bfd() {
    return this._bfd;
  }
  public putBfd(value: LogicalRouterVrfBgpPeerGroupPeerBfd) {
    this._bfd.internalValue = value;
  }
  public resetBfd() {
    this._bfd.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bfdInput() {
    return this._bfd.internalValue;
  }

  // connection_options - computed: false, optional: true, required: false
  private _connectionOptions = new LogicalRouterVrfBgpPeerGroupPeerConnectionOptionsOutputReference(this, "connection_options");
  public get connectionOptions() {
    return this._connectionOptions;
  }
  public putConnectionOptions(value: LogicalRouterVrfBgpPeerGroupPeerConnectionOptions) {
    this._connectionOptions.internalValue = value;
  }
  public resetConnectionOptions() {
    this._connectionOptions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionOptionsInput() {
    return this._connectionOptions.internalValue;
  }

  // enable - computed: false, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // enable_mp_bgp - computed: false, optional: true, required: false
  private _enableMpBgp?: boolean | cdktf.IResolvable; 
  public get enableMpBgp() {
    return this.getBooleanAttribute('enable_mp_bgp');
  }
  public set enableMpBgp(value: boolean | cdktf.IResolvable) {
    this._enableMpBgp = value;
  }
  public resetEnableMpBgp() {
    this._enableMpBgp = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableMpBgpInput() {
    return this._enableMpBgp;
  }

  // enable_sender_side_loop_detection - computed: false, optional: true, required: false
  private _enableSenderSideLoopDetection?: boolean | cdktf.IResolvable; 
  public get enableSenderSideLoopDetection() {
    return this.getBooleanAttribute('enable_sender_side_loop_detection');
  }
  public set enableSenderSideLoopDetection(value: boolean | cdktf.IResolvable) {
    this._enableSenderSideLoopDetection = value;
  }
  public resetEnableSenderSideLoopDetection() {
    this._enableSenderSideLoopDetection = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableSenderSideLoopDetectionInput() {
    return this._enableSenderSideLoopDetection;
  }

  // inherit - computed: false, optional: true, required: false
  private _inherit = new LogicalRouterVrfBgpPeerGroupPeerInheritOutputReference(this, "inherit");
  public get inherit() {
    return this._inherit;
  }
  public putInherit(value: LogicalRouterVrfBgpPeerGroupPeerInherit) {
    this._inherit.internalValue = value;
  }
  public resetInherit() {
    this._inherit.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inheritInput() {
    return this._inherit.internalValue;
  }

  // local_address - computed: false, optional: true, required: false
  private _localAddress = new LogicalRouterVrfBgpPeerGroupPeerLocalAddressOutputReference(this, "local_address");
  public get localAddress() {
    return this._localAddress;
  }
  public putLocalAddress(value: LogicalRouterVrfBgpPeerGroupPeerLocalAddress) {
    this._localAddress.internalValue = value;
  }
  public resetLocalAddress() {
    this._localAddress.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localAddressInput() {
    return this._localAddress.internalValue;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // passive - computed: false, optional: true, required: false
  private _passive?: boolean | cdktf.IResolvable; 
  public get passive() {
    return this.getBooleanAttribute('passive');
  }
  public set passive(value: boolean | cdktf.IResolvable) {
    this._passive = value;
  }
  public resetPassive() {
    this._passive = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passiveInput() {
    return this._passive;
  }

  // peer_address - computed: false, optional: true, required: false
  private _peerAddress = new LogicalRouterVrfBgpPeerGroupPeerPeerAddressOutputReference(this, "peer_address");
  public get peerAddress() {
    return this._peerAddress;
  }
  public putPeerAddress(value: LogicalRouterVrfBgpPeerGroupPeerPeerAddress) {
    this._peerAddress.internalValue = value;
  }
  public resetPeerAddress() {
    this._peerAddress.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get peerAddressInput() {
    return this._peerAddress.internalValue;
  }

  // peer_as - computed: false, optional: true, required: false
  private _peerAs?: string; 
  public get peerAs() {
    return this.getStringAttribute('peer_as');
  }
  public set peerAs(value: string) {
    this._peerAs = value;
  }
  public resetPeerAs() {
    this._peerAs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get peerAsInput() {
    return this._peerAs;
  }

  // peering_type - computed: false, optional: true, required: false
  private _peeringType?: string; 
  public get peeringType() {
    return this.getStringAttribute('peering_type');
  }
  public set peeringType(value: string) {
    this._peeringType = value;
  }
  public resetPeeringType() {
    this._peeringType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get peeringTypeInput() {
    return this._peeringType;
  }

  // reflector_client - computed: false, optional: true, required: false
  private _reflectorClient?: string; 
  public get reflectorClient() {
    return this.getStringAttribute('reflector_client');
  }
  public set reflectorClient(value: string) {
    this._reflectorClient = value;
  }
  public resetReflectorClient() {
    this._reflectorClient = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reflectorClientInput() {
    return this._reflectorClient;
  }

  // subsequent_address_family_identifier - computed: false, optional: true, required: false
  private _subsequentAddressFamilyIdentifier = new LogicalRouterVrfBgpPeerGroupPeerSubsequentAddressFamilyIdentifierOutputReference(this, "subsequent_address_family_identifier");
  public get subsequentAddressFamilyIdentifier() {
    return this._subsequentAddressFamilyIdentifier;
  }
  public putSubsequentAddressFamilyIdentifier(value: LogicalRouterVrfBgpPeerGroupPeerSubsequentAddressFamilyIdentifier) {
    this._subsequentAddressFamilyIdentifier.internalValue = value;
  }
  public resetSubsequentAddressFamilyIdentifier() {
    this._subsequentAddressFamilyIdentifier.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subsequentAddressFamilyIdentifierInput() {
    return this._subsequentAddressFamilyIdentifier.internalValue;
  }
}

export class LogicalRouterVrfBgpPeerGroupPeerList extends cdktf.ComplexList {
  public internalValue? : LogicalRouterVrfBgpPeerGroupPeer[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): LogicalRouterVrfBgpPeerGroupPeerOutputReference {
    return new LogicalRouterVrfBgpPeerGroupPeerOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface LogicalRouterVrfBgpPeerGroupTypeEbgp {
  /**
  * Export nexthop
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#export_nexthop LogicalRouter#export_nexthop}
  */
  readonly exportNexthop?: string;
  /**
  * Import nexthop
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#import_nexthop LogicalRouter#import_nexthop}
  */
  readonly importNexthop?: string;
  /**
  * Remove private as
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#remove_private_as LogicalRouter#remove_private_as}
  */
  readonly removePrivateAs?: boolean | cdktf.IResolvable;
}

export function logicalRouterVrfBgpPeerGroupTypeEbgpToTerraform(struct?: LogicalRouterVrfBgpPeerGroupTypeEbgp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    export_nexthop: cdktf.stringToTerraform(struct!.exportNexthop),
    import_nexthop: cdktf.stringToTerraform(struct!.importNexthop),
    remove_private_as: cdktf.booleanToTerraform(struct!.removePrivateAs),
  }
}


export function logicalRouterVrfBgpPeerGroupTypeEbgpToHclTerraform(struct?: LogicalRouterVrfBgpPeerGroupTypeEbgp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    export_nexthop: {
      value: cdktf.stringToHclTerraform(struct!.exportNexthop),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    import_nexthop: {
      value: cdktf.stringToHclTerraform(struct!.importNexthop),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    remove_private_as: {
      value: cdktf.booleanToHclTerraform(struct!.removePrivateAs),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPeerGroupTypeEbgpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPeerGroupTypeEbgp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._exportNexthop !== undefined) {
      hasAnyValues = true;
      internalValueResult.exportNexthop = this._exportNexthop;
    }
    if (this._importNexthop !== undefined) {
      hasAnyValues = true;
      internalValueResult.importNexthop = this._importNexthop;
    }
    if (this._removePrivateAs !== undefined) {
      hasAnyValues = true;
      internalValueResult.removePrivateAs = this._removePrivateAs;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPeerGroupTypeEbgp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._exportNexthop = undefined;
      this._importNexthop = undefined;
      this._removePrivateAs = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._exportNexthop = value.exportNexthop;
      this._importNexthop = value.importNexthop;
      this._removePrivateAs = value.removePrivateAs;
    }
  }

  // export_nexthop - computed: false, optional: true, required: false
  private _exportNexthop?: string; 
  public get exportNexthop() {
    return this.getStringAttribute('export_nexthop');
  }
  public set exportNexthop(value: string) {
    this._exportNexthop = value;
  }
  public resetExportNexthop() {
    this._exportNexthop = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exportNexthopInput() {
    return this._exportNexthop;
  }

  // import_nexthop - computed: false, optional: true, required: false
  private _importNexthop?: string; 
  public get importNexthop() {
    return this.getStringAttribute('import_nexthop');
  }
  public set importNexthop(value: string) {
    this._importNexthop = value;
  }
  public resetImportNexthop() {
    this._importNexthop = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get importNexthopInput() {
    return this._importNexthop;
  }

  // remove_private_as - computed: false, optional: true, required: false
  private _removePrivateAs?: boolean | cdktf.IResolvable; 
  public get removePrivateAs() {
    return this.getBooleanAttribute('remove_private_as');
  }
  public set removePrivateAs(value: boolean | cdktf.IResolvable) {
    this._removePrivateAs = value;
  }
  public resetRemovePrivateAs() {
    this._removePrivateAs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removePrivateAsInput() {
    return this._removePrivateAs;
  }
}
export interface LogicalRouterVrfBgpPeerGroupTypeEbgpConfed {
  /**
  * Export nexthop
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#export_nexthop LogicalRouter#export_nexthop}
  */
  readonly exportNexthop?: string;
}

export function logicalRouterVrfBgpPeerGroupTypeEbgpConfedToTerraform(struct?: LogicalRouterVrfBgpPeerGroupTypeEbgpConfed | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    export_nexthop: cdktf.stringToTerraform(struct!.exportNexthop),
  }
}


export function logicalRouterVrfBgpPeerGroupTypeEbgpConfedToHclTerraform(struct?: LogicalRouterVrfBgpPeerGroupTypeEbgpConfed | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    export_nexthop: {
      value: cdktf.stringToHclTerraform(struct!.exportNexthop),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPeerGroupTypeEbgpConfedOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPeerGroupTypeEbgpConfed | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._exportNexthop !== undefined) {
      hasAnyValues = true;
      internalValueResult.exportNexthop = this._exportNexthop;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPeerGroupTypeEbgpConfed | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._exportNexthop = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._exportNexthop = value.exportNexthop;
    }
  }

  // export_nexthop - computed: false, optional: true, required: false
  private _exportNexthop?: string; 
  public get exportNexthop() {
    return this.getStringAttribute('export_nexthop');
  }
  public set exportNexthop(value: string) {
    this._exportNexthop = value;
  }
  public resetExportNexthop() {
    this._exportNexthop = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exportNexthopInput() {
    return this._exportNexthop;
  }
}
export interface LogicalRouterVrfBgpPeerGroupTypeIbgp {
  /**
  * Export nexthop
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#export_nexthop LogicalRouter#export_nexthop}
  */
  readonly exportNexthop?: string;
}

export function logicalRouterVrfBgpPeerGroupTypeIbgpToTerraform(struct?: LogicalRouterVrfBgpPeerGroupTypeIbgp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    export_nexthop: cdktf.stringToTerraform(struct!.exportNexthop),
  }
}


export function logicalRouterVrfBgpPeerGroupTypeIbgpToHclTerraform(struct?: LogicalRouterVrfBgpPeerGroupTypeIbgp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    export_nexthop: {
      value: cdktf.stringToHclTerraform(struct!.exportNexthop),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPeerGroupTypeIbgpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPeerGroupTypeIbgp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._exportNexthop !== undefined) {
      hasAnyValues = true;
      internalValueResult.exportNexthop = this._exportNexthop;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPeerGroupTypeIbgp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._exportNexthop = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._exportNexthop = value.exportNexthop;
    }
  }

  // export_nexthop - computed: false, optional: true, required: false
  private _exportNexthop?: string; 
  public get exportNexthop() {
    return this.getStringAttribute('export_nexthop');
  }
  public set exportNexthop(value: string) {
    this._exportNexthop = value;
  }
  public resetExportNexthop() {
    this._exportNexthop = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exportNexthopInput() {
    return this._exportNexthop;
  }
}
export interface LogicalRouterVrfBgpPeerGroupTypeIbgpConfed {
  /**
  * Export nexthop
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#export_nexthop LogicalRouter#export_nexthop}
  */
  readonly exportNexthop?: string;
}

export function logicalRouterVrfBgpPeerGroupTypeIbgpConfedToTerraform(struct?: LogicalRouterVrfBgpPeerGroupTypeIbgpConfed | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    export_nexthop: cdktf.stringToTerraform(struct!.exportNexthop),
  }
}


export function logicalRouterVrfBgpPeerGroupTypeIbgpConfedToHclTerraform(struct?: LogicalRouterVrfBgpPeerGroupTypeIbgpConfed | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    export_nexthop: {
      value: cdktf.stringToHclTerraform(struct!.exportNexthop),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPeerGroupTypeIbgpConfedOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPeerGroupTypeIbgpConfed | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._exportNexthop !== undefined) {
      hasAnyValues = true;
      internalValueResult.exportNexthop = this._exportNexthop;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPeerGroupTypeIbgpConfed | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._exportNexthop = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._exportNexthop = value.exportNexthop;
    }
  }

  // export_nexthop - computed: false, optional: true, required: false
  private _exportNexthop?: string; 
  public get exportNexthop() {
    return this.getStringAttribute('export_nexthop');
  }
  public set exportNexthop(value: string) {
    this._exportNexthop = value;
  }
  public resetExportNexthop() {
    this._exportNexthop = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exportNexthopInput() {
    return this._exportNexthop;
  }
}
export interface LogicalRouterVrfBgpPeerGroupType {
  /**
  * Ebgp
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#ebgp LogicalRouter#ebgp}
  */
  readonly ebgp?: LogicalRouterVrfBgpPeerGroupTypeEbgp;
  /**
  * Ebgp confed
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#ebgp_confed LogicalRouter#ebgp_confed}
  */
  readonly ebgpConfed?: LogicalRouterVrfBgpPeerGroupTypeEbgpConfed;
  /**
  * Ibgp
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#ibgp LogicalRouter#ibgp}
  */
  readonly ibgp?: LogicalRouterVrfBgpPeerGroupTypeIbgp;
  /**
  * Ibgp confed
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#ibgp_confed LogicalRouter#ibgp_confed}
  */
  readonly ibgpConfed?: LogicalRouterVrfBgpPeerGroupTypeIbgpConfed;
}

export function logicalRouterVrfBgpPeerGroupTypeToTerraform(struct?: LogicalRouterVrfBgpPeerGroupType | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ebgp: logicalRouterVrfBgpPeerGroupTypeEbgpToTerraform(struct!.ebgp),
    ebgp_confed: logicalRouterVrfBgpPeerGroupTypeEbgpConfedToTerraform(struct!.ebgpConfed),
    ibgp: logicalRouterVrfBgpPeerGroupTypeIbgpToTerraform(struct!.ibgp),
    ibgp_confed: logicalRouterVrfBgpPeerGroupTypeIbgpConfedToTerraform(struct!.ibgpConfed),
  }
}


export function logicalRouterVrfBgpPeerGroupTypeToHclTerraform(struct?: LogicalRouterVrfBgpPeerGroupType | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ebgp: {
      value: logicalRouterVrfBgpPeerGroupTypeEbgpToHclTerraform(struct!.ebgp),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPeerGroupTypeEbgp",
    },
    ebgp_confed: {
      value: logicalRouterVrfBgpPeerGroupTypeEbgpConfedToHclTerraform(struct!.ebgpConfed),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPeerGroupTypeEbgpConfed",
    },
    ibgp: {
      value: logicalRouterVrfBgpPeerGroupTypeIbgpToHclTerraform(struct!.ibgp),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPeerGroupTypeIbgp",
    },
    ibgp_confed: {
      value: logicalRouterVrfBgpPeerGroupTypeIbgpConfedToHclTerraform(struct!.ibgpConfed),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPeerGroupTypeIbgpConfed",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPeerGroupTypeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPeerGroupType | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ebgp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ebgp = this._ebgp?.internalValue;
    }
    if (this._ebgpConfed?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ebgpConfed = this._ebgpConfed?.internalValue;
    }
    if (this._ibgp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ibgp = this._ibgp?.internalValue;
    }
    if (this._ibgpConfed?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ibgpConfed = this._ibgpConfed?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPeerGroupType | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ebgp.internalValue = undefined;
      this._ebgpConfed.internalValue = undefined;
      this._ibgp.internalValue = undefined;
      this._ibgpConfed.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ebgp.internalValue = value.ebgp;
      this._ebgpConfed.internalValue = value.ebgpConfed;
      this._ibgp.internalValue = value.ibgp;
      this._ibgpConfed.internalValue = value.ibgpConfed;
    }
  }

  // ebgp - computed: false, optional: true, required: false
  private _ebgp = new LogicalRouterVrfBgpPeerGroupTypeEbgpOutputReference(this, "ebgp");
  public get ebgp() {
    return this._ebgp;
  }
  public putEbgp(value: LogicalRouterVrfBgpPeerGroupTypeEbgp) {
    this._ebgp.internalValue = value;
  }
  public resetEbgp() {
    this._ebgp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ebgpInput() {
    return this._ebgp.internalValue;
  }

  // ebgp_confed - computed: false, optional: true, required: false
  private _ebgpConfed = new LogicalRouterVrfBgpPeerGroupTypeEbgpConfedOutputReference(this, "ebgp_confed");
  public get ebgpConfed() {
    return this._ebgpConfed;
  }
  public putEbgpConfed(value: LogicalRouterVrfBgpPeerGroupTypeEbgpConfed) {
    this._ebgpConfed.internalValue = value;
  }
  public resetEbgpConfed() {
    this._ebgpConfed.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ebgpConfedInput() {
    return this._ebgpConfed.internalValue;
  }

  // ibgp - computed: false, optional: true, required: false
  private _ibgp = new LogicalRouterVrfBgpPeerGroupTypeIbgpOutputReference(this, "ibgp");
  public get ibgp() {
    return this._ibgp;
  }
  public putIbgp(value: LogicalRouterVrfBgpPeerGroupTypeIbgp) {
    this._ibgp.internalValue = value;
  }
  public resetIbgp() {
    this._ibgp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ibgpInput() {
    return this._ibgp.internalValue;
  }

  // ibgp_confed - computed: false, optional: true, required: false
  private _ibgpConfed = new LogicalRouterVrfBgpPeerGroupTypeIbgpConfedOutputReference(this, "ibgp_confed");
  public get ibgpConfed() {
    return this._ibgpConfed;
  }
  public putIbgpConfed(value: LogicalRouterVrfBgpPeerGroupTypeIbgpConfed) {
    this._ibgpConfed.internalValue = value;
  }
  public resetIbgpConfed() {
    this._ibgpConfed.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ibgpConfedInput() {
    return this._ibgpConfed.internalValue;
  }
}
export interface LogicalRouterVrfBgpPeerGroup {
  /**
  * Address family
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#address_family LogicalRouter#address_family}
  */
  readonly addressFamily?: LogicalRouterVrfBgpPeerGroupAddressFamily;
  /**
  * Aggregated confed as path
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#aggregated_confed_as_path LogicalRouter#aggregated_confed_as_path}
  */
  readonly aggregatedConfedAsPath?: boolean | cdktf.IResolvable;
  /**
  * Connection options
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#connection_options LogicalRouter#connection_options}
  */
  readonly connectionOptions?: LogicalRouterVrfBgpPeerGroupConnectionOptions;
  /**
  * Enable
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#enable LogicalRouter#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * Filtering profile
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#filtering_profile LogicalRouter#filtering_profile}
  */
  readonly filteringProfile?: LogicalRouterVrfBgpPeerGroupFilteringProfile;
  /**
  * Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#name LogicalRouter#name}
  */
  readonly name: string;
  /**
  * Peer
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#peer LogicalRouter#peer}
  */
  readonly peer?: LogicalRouterVrfBgpPeerGroupPeer[] | cdktf.IResolvable;
  /**
  * Soft reset with stored info
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#soft_reset_with_stored_info LogicalRouter#soft_reset_with_stored_info}
  */
  readonly softResetWithStoredInfo?: boolean | cdktf.IResolvable;
  /**
  * Type
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#type LogicalRouter#type}
  */
  readonly type?: LogicalRouterVrfBgpPeerGroupType;
}

export function logicalRouterVrfBgpPeerGroupToTerraform(struct?: LogicalRouterVrfBgpPeerGroup | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address_family: logicalRouterVrfBgpPeerGroupAddressFamilyToTerraform(struct!.addressFamily),
    aggregated_confed_as_path: cdktf.booleanToTerraform(struct!.aggregatedConfedAsPath),
    connection_options: logicalRouterVrfBgpPeerGroupConnectionOptionsToTerraform(struct!.connectionOptions),
    enable: cdktf.booleanToTerraform(struct!.enable),
    filtering_profile: logicalRouterVrfBgpPeerGroupFilteringProfileToTerraform(struct!.filteringProfile),
    name: cdktf.stringToTerraform(struct!.name),
    peer: cdktf.listMapper(logicalRouterVrfBgpPeerGroupPeerToTerraform, false)(struct!.peer),
    soft_reset_with_stored_info: cdktf.booleanToTerraform(struct!.softResetWithStoredInfo),
    type: logicalRouterVrfBgpPeerGroupTypeToTerraform(struct!.type),
  }
}


export function logicalRouterVrfBgpPeerGroupToHclTerraform(struct?: LogicalRouterVrfBgpPeerGroup | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address_family: {
      value: logicalRouterVrfBgpPeerGroupAddressFamilyToHclTerraform(struct!.addressFamily),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPeerGroupAddressFamily",
    },
    aggregated_confed_as_path: {
      value: cdktf.booleanToHclTerraform(struct!.aggregatedConfedAsPath),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    connection_options: {
      value: logicalRouterVrfBgpPeerGroupConnectionOptionsToHclTerraform(struct!.connectionOptions),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPeerGroupConnectionOptions",
    },
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    filtering_profile: {
      value: logicalRouterVrfBgpPeerGroupFilteringProfileToHclTerraform(struct!.filteringProfile),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPeerGroupFilteringProfile",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    peer: {
      value: cdktf.listMapperHcl(logicalRouterVrfBgpPeerGroupPeerToHclTerraform, false)(struct!.peer),
      isBlock: true,
      type: "list",
      storageClassType: "LogicalRouterVrfBgpPeerGroupPeerList",
    },
    soft_reset_with_stored_info: {
      value: cdktf.booleanToHclTerraform(struct!.softResetWithStoredInfo),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    type: {
      value: logicalRouterVrfBgpPeerGroupTypeToHclTerraform(struct!.type),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPeerGroupType",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPeerGroupOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): LogicalRouterVrfBgpPeerGroup | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addressFamily?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.addressFamily = this._addressFamily?.internalValue;
    }
    if (this._aggregatedConfedAsPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.aggregatedConfedAsPath = this._aggregatedConfedAsPath;
    }
    if (this._connectionOptions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionOptions = this._connectionOptions?.internalValue;
    }
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._filteringProfile?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.filteringProfile = this._filteringProfile?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._peer?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.peer = this._peer?.internalValue;
    }
    if (this._softResetWithStoredInfo !== undefined) {
      hasAnyValues = true;
      internalValueResult.softResetWithStoredInfo = this._softResetWithStoredInfo;
    }
    if (this._type?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPeerGroup | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addressFamily.internalValue = undefined;
      this._aggregatedConfedAsPath = undefined;
      this._connectionOptions.internalValue = undefined;
      this._enable = undefined;
      this._filteringProfile.internalValue = undefined;
      this._name = undefined;
      this._peer.internalValue = undefined;
      this._softResetWithStoredInfo = undefined;
      this._type.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addressFamily.internalValue = value.addressFamily;
      this._aggregatedConfedAsPath = value.aggregatedConfedAsPath;
      this._connectionOptions.internalValue = value.connectionOptions;
      this._enable = value.enable;
      this._filteringProfile.internalValue = value.filteringProfile;
      this._name = value.name;
      this._peer.internalValue = value.peer;
      this._softResetWithStoredInfo = value.softResetWithStoredInfo;
      this._type.internalValue = value.type;
    }
  }

  // address_family - computed: false, optional: true, required: false
  private _addressFamily = new LogicalRouterVrfBgpPeerGroupAddressFamilyOutputReference(this, "address_family");
  public get addressFamily() {
    return this._addressFamily;
  }
  public putAddressFamily(value: LogicalRouterVrfBgpPeerGroupAddressFamily) {
    this._addressFamily.internalValue = value;
  }
  public resetAddressFamily() {
    this._addressFamily.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressFamilyInput() {
    return this._addressFamily.internalValue;
  }

  // aggregated_confed_as_path - computed: false, optional: true, required: false
  private _aggregatedConfedAsPath?: boolean | cdktf.IResolvable; 
  public get aggregatedConfedAsPath() {
    return this.getBooleanAttribute('aggregated_confed_as_path');
  }
  public set aggregatedConfedAsPath(value: boolean | cdktf.IResolvable) {
    this._aggregatedConfedAsPath = value;
  }
  public resetAggregatedConfedAsPath() {
    this._aggregatedConfedAsPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aggregatedConfedAsPathInput() {
    return this._aggregatedConfedAsPath;
  }

  // connection_options - computed: false, optional: true, required: false
  private _connectionOptions = new LogicalRouterVrfBgpPeerGroupConnectionOptionsOutputReference(this, "connection_options");
  public get connectionOptions() {
    return this._connectionOptions;
  }
  public putConnectionOptions(value: LogicalRouterVrfBgpPeerGroupConnectionOptions) {
    this._connectionOptions.internalValue = value;
  }
  public resetConnectionOptions() {
    this._connectionOptions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionOptionsInput() {
    return this._connectionOptions.internalValue;
  }

  // enable - computed: false, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // filtering_profile - computed: false, optional: true, required: false
  private _filteringProfile = new LogicalRouterVrfBgpPeerGroupFilteringProfileOutputReference(this, "filtering_profile");
  public get filteringProfile() {
    return this._filteringProfile;
  }
  public putFilteringProfile(value: LogicalRouterVrfBgpPeerGroupFilteringProfile) {
    this._filteringProfile.internalValue = value;
  }
  public resetFilteringProfile() {
    this._filteringProfile.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get filteringProfileInput() {
    return this._filteringProfile.internalValue;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // peer - computed: false, optional: true, required: false
  private _peer = new LogicalRouterVrfBgpPeerGroupPeerList(this, "peer", false);
  public get peer() {
    return this._peer;
  }
  public putPeer(value: LogicalRouterVrfBgpPeerGroupPeer[] | cdktf.IResolvable) {
    this._peer.internalValue = value;
  }
  public resetPeer() {
    this._peer.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get peerInput() {
    return this._peer.internalValue;
  }

  // soft_reset_with_stored_info - computed: false, optional: true, required: false
  private _softResetWithStoredInfo?: boolean | cdktf.IResolvable; 
  public get softResetWithStoredInfo() {
    return this.getBooleanAttribute('soft_reset_with_stored_info');
  }
  public set softResetWithStoredInfo(value: boolean | cdktf.IResolvable) {
    this._softResetWithStoredInfo = value;
  }
  public resetSoftResetWithStoredInfo() {
    this._softResetWithStoredInfo = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get softResetWithStoredInfoInput() {
    return this._softResetWithStoredInfo;
  }

  // type - computed: false, optional: true, required: false
  private _type = new LogicalRouterVrfBgpPeerGroupTypeOutputReference(this, "type");
  public get type() {
    return this._type;
  }
  public putType(value: LogicalRouterVrfBgpPeerGroupType) {
    this._type.internalValue = value;
  }
  public resetType() {
    this._type.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type.internalValue;
  }
}

export class LogicalRouterVrfBgpPeerGroupList extends cdktf.ComplexList {
  public internalValue? : LogicalRouterVrfBgpPeerGroup[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): LogicalRouterVrfBgpPeerGroupOutputReference {
    return new LogicalRouterVrfBgpPeerGroupOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefix {
  /**
  * Exact
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#exact LogicalRouter#exact}
  */
  readonly exact?: boolean | cdktf.IResolvable;
  /**
  * Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#name LogicalRouter#name}
  */
  readonly name: string;
}

export function logicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixToTerraform(struct?: LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    exact: cdktf.booleanToTerraform(struct!.exact),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function logicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixToHclTerraform(struct?: LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    exact: {
      value: cdktf.booleanToHclTerraform(struct!.exact),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefix | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._exact !== undefined) {
      hasAnyValues = true;
      internalValueResult.exact = this._exact;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefix | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._exact = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._exact = value.exact;
      this._name = value.name;
    }
  }

  // exact - computed: false, optional: true, required: false
  private _exact?: boolean | cdktf.IResolvable; 
  public get exact() {
    return this.getBooleanAttribute('exact');
  }
  public set exact(value: boolean | cdktf.IResolvable) {
    this._exact = value;
  }
  public resetExact() {
    this._exact = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exactInput() {
    return this._exact;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixList extends cdktf.ComplexList {
  public internalValue? : LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefix[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixOutputReference {
    return new LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPath {
  /**
  * Regex
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#regex LogicalRouter#regex}
  */
  readonly regex?: string;
}

export function logicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathToTerraform(struct?: LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function logicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathToHclTerraform(struct?: LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPath | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPath | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._regex = value.regex;
    }
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunity {
  /**
  * Regex
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#regex LogicalRouter#regex}
  */
  readonly regex?: string;
}

export function logicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunityToTerraform(struct?: LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function logicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunityToHclTerraform(struct?: LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._regex = value.regex;
    }
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunity {
  /**
  * Regex
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#regex LogicalRouter#regex}
  */
  readonly regex?: string;
}

export function logicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunityToTerraform(struct?: LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function logicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunityToHclTerraform(struct?: LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._regex = value.regex;
    }
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatch {
  /**
  * Address prefix
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#address_prefix LogicalRouter#address_prefix}
  */
  readonly addressPrefix?: LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefix[] | cdktf.IResolvable;
  /**
  * Afi
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#afi LogicalRouter#afi}
  */
  readonly afi?: string;
  /**
  * As path
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#as_path LogicalRouter#as_path}
  */
  readonly asPath?: LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPath;
  /**
  * Community
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#community LogicalRouter#community}
  */
  readonly community?: LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunity;
  /**
  * Extended community
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#extended_community LogicalRouter#extended_community}
  */
  readonly extendedCommunity?: LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunity;
  /**
  * From peer
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#from_peer LogicalRouter#from_peer}
  */
  readonly fromPeer?: string[];
  /**
  * Med
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#med LogicalRouter#med}
  */
  readonly med?: number;
  /**
  * Nexthop
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#nexthop LogicalRouter#nexthop}
  */
  readonly nexthop?: string[];
  /**
  * Route table
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#route_table LogicalRouter#route_table}
  */
  readonly routeTable?: string;
  /**
  * Safi
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#safi LogicalRouter#safi}
  */
  readonly safi?: string;
}

export function logicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchToTerraform(struct?: LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address_prefix: cdktf.listMapper(logicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixToTerraform, false)(struct!.addressPrefix),
    afi: cdktf.stringToTerraform(struct!.afi),
    as_path: logicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathToTerraform(struct!.asPath),
    community: logicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunityToTerraform(struct!.community),
    extended_community: logicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunityToTerraform(struct!.extendedCommunity),
    from_peer: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.fromPeer),
    med: cdktf.numberToTerraform(struct!.med),
    nexthop: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.nexthop),
    route_table: cdktf.stringToTerraform(struct!.routeTable),
    safi: cdktf.stringToTerraform(struct!.safi),
  }
}


export function logicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchToHclTerraform(struct?: LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address_prefix: {
      value: cdktf.listMapperHcl(logicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixToHclTerraform, false)(struct!.addressPrefix),
      isBlock: true,
      type: "list",
      storageClassType: "LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixList",
    },
    afi: {
      value: cdktf.stringToHclTerraform(struct!.afi),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    as_path: {
      value: logicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathToHclTerraform(struct!.asPath),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPath",
    },
    community: {
      value: logicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunityToHclTerraform(struct!.community),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunity",
    },
    extended_community: {
      value: logicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunityToHclTerraform(struct!.extendedCommunity),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunity",
    },
    from_peer: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.fromPeer),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    med: {
      value: cdktf.numberToHclTerraform(struct!.med),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    nexthop: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.nexthop),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    route_table: {
      value: cdktf.stringToHclTerraform(struct!.routeTable),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    safi: {
      value: cdktf.stringToHclTerraform(struct!.safi),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addressPrefix?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.addressPrefix = this._addressPrefix?.internalValue;
    }
    if (this._afi !== undefined) {
      hasAnyValues = true;
      internalValueResult.afi = this._afi;
    }
    if (this._asPath?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.asPath = this._asPath?.internalValue;
    }
    if (this._community?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.community = this._community?.internalValue;
    }
    if (this._extendedCommunity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extendedCommunity = this._extendedCommunity?.internalValue;
    }
    if (this._fromPeer !== undefined) {
      hasAnyValues = true;
      internalValueResult.fromPeer = this._fromPeer;
    }
    if (this._med !== undefined) {
      hasAnyValues = true;
      internalValueResult.med = this._med;
    }
    if (this._nexthop !== undefined) {
      hasAnyValues = true;
      internalValueResult.nexthop = this._nexthop;
    }
    if (this._routeTable !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeTable = this._routeTable;
    }
    if (this._safi !== undefined) {
      hasAnyValues = true;
      internalValueResult.safi = this._safi;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addressPrefix.internalValue = undefined;
      this._afi = undefined;
      this._asPath.internalValue = undefined;
      this._community.internalValue = undefined;
      this._extendedCommunity.internalValue = undefined;
      this._fromPeer = undefined;
      this._med = undefined;
      this._nexthop = undefined;
      this._routeTable = undefined;
      this._safi = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addressPrefix.internalValue = value.addressPrefix;
      this._afi = value.afi;
      this._asPath.internalValue = value.asPath;
      this._community.internalValue = value.community;
      this._extendedCommunity.internalValue = value.extendedCommunity;
      this._fromPeer = value.fromPeer;
      this._med = value.med;
      this._nexthop = value.nexthop;
      this._routeTable = value.routeTable;
      this._safi = value.safi;
    }
  }

  // address_prefix - computed: false, optional: true, required: false
  private _addressPrefix = new LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixList(this, "address_prefix", false);
  public get addressPrefix() {
    return this._addressPrefix;
  }
  public putAddressPrefix(value: LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefix[] | cdktf.IResolvable) {
    this._addressPrefix.internalValue = value;
  }
  public resetAddressPrefix() {
    this._addressPrefix.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressPrefixInput() {
    return this._addressPrefix.internalValue;
  }

  // afi - computed: false, optional: true, required: false
  private _afi?: string; 
  public get afi() {
    return this.getStringAttribute('afi');
  }
  public set afi(value: string) {
    this._afi = value;
  }
  public resetAfi() {
    this._afi = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get afiInput() {
    return this._afi;
  }

  // as_path - computed: false, optional: true, required: false
  private _asPath = new LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathOutputReference(this, "as_path");
  public get asPath() {
    return this._asPath;
  }
  public putAsPath(value: LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPath) {
    this._asPath.internalValue = value;
  }
  public resetAsPath() {
    this._asPath.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asPathInput() {
    return this._asPath.internalValue;
  }

  // community - computed: false, optional: true, required: false
  private _community = new LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunityOutputReference(this, "community");
  public get community() {
    return this._community;
  }
  public putCommunity(value: LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunity) {
    this._community.internalValue = value;
  }
  public resetCommunity() {
    this._community.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get communityInput() {
    return this._community.internalValue;
  }

  // extended_community - computed: false, optional: true, required: false
  private _extendedCommunity = new LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunityOutputReference(this, "extended_community");
  public get extendedCommunity() {
    return this._extendedCommunity;
  }
  public putExtendedCommunity(value: LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunity) {
    this._extendedCommunity.internalValue = value;
  }
  public resetExtendedCommunity() {
    this._extendedCommunity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extendedCommunityInput() {
    return this._extendedCommunity.internalValue;
  }

  // from_peer - computed: false, optional: true, required: false
  private _fromPeer?: string[]; 
  public get fromPeer() {
    return this.getListAttribute('from_peer');
  }
  public set fromPeer(value: string[]) {
    this._fromPeer = value;
  }
  public resetFromPeer() {
    this._fromPeer = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fromPeerInput() {
    return this._fromPeer;
  }

  // med - computed: false, optional: true, required: false
  private _med?: number; 
  public get med() {
    return this.getNumberAttribute('med');
  }
  public set med(value: number) {
    this._med = value;
  }
  public resetMed() {
    this._med = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get medInput() {
    return this._med;
  }

  // nexthop - computed: false, optional: true, required: false
  private _nexthop?: string[]; 
  public get nexthop() {
    return this.getListAttribute('nexthop');
  }
  public set nexthop(value: string[]) {
    this._nexthop = value;
  }
  public resetNexthop() {
    this._nexthop = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nexthopInput() {
    return this._nexthop;
  }

  // route_table - computed: false, optional: true, required: false
  private _routeTable?: string; 
  public get routeTable() {
    return this.getStringAttribute('route_table');
  }
  public set routeTable(value: string) {
    this._routeTable = value;
  }
  public resetRouteTable() {
    this._routeTable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeTableInput() {
    return this._routeTable;
  }

  // safi - computed: false, optional: true, required: false
  private _safi?: string; 
  public get safi() {
    return this.getStringAttribute('safi');
  }
  public set safi(value: string) {
    this._safi = value;
  }
  public resetSafi() {
    this._safi = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safiInput() {
    return this._safi;
  }
}
export interface LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilters {
  /**
  * Enable
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#enable LogicalRouter#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * Match
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#match LogicalRouter#match}
  */
  readonly match?: LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatch;
  /**
  * Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#name LogicalRouter#name}
  */
  readonly name: string;
}

export function logicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersToTerraform(struct?: LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enable: cdktf.booleanToTerraform(struct!.enable),
    match: logicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchToTerraform(struct!.match),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function logicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersToHclTerraform(struct?: LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    match: {
      value: logicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchToHclTerraform(struct!.match),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatch",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._match?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enable = undefined;
      this._match.internalValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enable = value.enable;
      this._match.internalValue = value.match;
      this._name = value.name;
    }
  }

  // enable - computed: false, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // match - computed: false, optional: true, required: false
  private _match = new LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatchOutputReference(this, "match");
  public get match() {
    return this._match;
  }
  public putMatch(value: LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersMatch) {
    this._match.internalValue = value;
  }
  public resetMatch() {
    this._match.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match.internalValue;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersList extends cdktf.ComplexList {
  public internalValue? : LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilters[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersOutputReference {
    return new LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNone {
}

export function logicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneToTerraform(struct?: LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNone | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function logicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneToHclTerraform(struct?: LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNone | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNone | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNone | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemove {
}

export function logicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemoveToTerraform(struct?: LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemove | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function logicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemoveToHclTerraform(struct?: LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemove | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemoveOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemove | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemove | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPath {
  /**
  * None
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#none LogicalRouter#none}
  */
  readonly none?: LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNone;
  /**
  * Prepend
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#prepend LogicalRouter#prepend}
  */
  readonly prepend?: number;
  /**
  * Remove
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#remove LogicalRouter#remove}
  */
  readonly remove?: LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemove;
  /**
  * Remove and prepend
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#remove_and_prepend LogicalRouter#remove_and_prepend}
  */
  readonly removeAndPrepend?: number;
}

export function logicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathToTerraform(struct?: LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    none: logicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneToTerraform(struct!.none),
    prepend: cdktf.numberToTerraform(struct!.prepend),
    remove: logicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemoveToTerraform(struct!.remove),
    remove_and_prepend: cdktf.numberToTerraform(struct!.removeAndPrepend),
  }
}


export function logicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathToHclTerraform(struct?: LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    none: {
      value: logicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneToHclTerraform(struct!.none),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNone",
    },
    prepend: {
      value: cdktf.numberToHclTerraform(struct!.prepend),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    remove: {
      value: logicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemoveToHclTerraform(struct!.remove),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemove",
    },
    remove_and_prepend: {
      value: cdktf.numberToHclTerraform(struct!.removeAndPrepend),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPath | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._none?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.none = this._none?.internalValue;
    }
    if (this._prepend !== undefined) {
      hasAnyValues = true;
      internalValueResult.prepend = this._prepend;
    }
    if (this._remove?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.remove = this._remove?.internalValue;
    }
    if (this._removeAndPrepend !== undefined) {
      hasAnyValues = true;
      internalValueResult.removeAndPrepend = this._removeAndPrepend;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPath | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._none.internalValue = undefined;
      this._prepend = undefined;
      this._remove.internalValue = undefined;
      this._removeAndPrepend = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._none.internalValue = value.none;
      this._prepend = value.prepend;
      this._remove.internalValue = value.remove;
      this._removeAndPrepend = value.removeAndPrepend;
    }
  }

  // none - computed: false, optional: true, required: false
  private _none = new LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneOutputReference(this, "none");
  public get none() {
    return this._none;
  }
  public putNone(value: LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNone) {
    this._none.internalValue = value;
  }
  public resetNone() {
    this._none.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get noneInput() {
    return this._none.internalValue;
  }

  // prepend - computed: false, optional: true, required: false
  private _prepend?: number; 
  public get prepend() {
    return this.getNumberAttribute('prepend');
  }
  public set prepend(value: number) {
    this._prepend = value;
  }
  public resetPrepend() {
    this._prepend = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prependInput() {
    return this._prepend;
  }

  // remove - computed: false, optional: true, required: false
  private _remove = new LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemoveOutputReference(this, "remove");
  public get remove() {
    return this._remove;
  }
  public putRemove(value: LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemove) {
    this._remove.internalValue = value;
  }
  public resetRemove() {
    this._remove.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeInput() {
    return this._remove.internalValue;
  }

  // remove_and_prepend - computed: false, optional: true, required: false
  private _removeAndPrepend?: number; 
  public get removeAndPrepend() {
    return this.getNumberAttribute('remove_and_prepend');
  }
  public set removeAndPrepend(value: number) {
    this._removeAndPrepend = value;
  }
  public resetRemoveAndPrepend() {
    this._removeAndPrepend = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeAndPrependInput() {
    return this._removeAndPrepend;
  }
}
export interface LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNone {
}

export function logicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneToTerraform(struct?: LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNone | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function logicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneToHclTerraform(struct?: LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNone | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNone | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNone | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAll {
}

export function logicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllToTerraform(struct?: LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAll | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function logicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllToHclTerraform(struct?: LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAll | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAll | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAll | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunity {
  /**
  * Append
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#append LogicalRouter#append}
  */
  readonly append?: string[];
  /**
  * None
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#none LogicalRouter#none}
  */
  readonly none?: LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNone;
  /**
  * Overwrite
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#overwrite LogicalRouter#overwrite}
  */
  readonly overwrite?: string[];
  /**
  * Remove all
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#remove_all LogicalRouter#remove_all}
  */
  readonly removeAll?: LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAll;
  /**
  * Remove regex
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#remove_regex LogicalRouter#remove_regex}
  */
  readonly removeRegex?: string;
}

export function logicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityToTerraform(struct?: LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    append: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.append),
    none: logicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneToTerraform(struct!.none),
    overwrite: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.overwrite),
    remove_all: logicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllToTerraform(struct!.removeAll),
    remove_regex: cdktf.stringToTerraform(struct!.removeRegex),
  }
}


export function logicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityToHclTerraform(struct?: LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    append: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.append),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    none: {
      value: logicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneToHclTerraform(struct!.none),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNone",
    },
    overwrite: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.overwrite),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    remove_all: {
      value: logicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllToHclTerraform(struct!.removeAll),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAll",
    },
    remove_regex: {
      value: cdktf.stringToHclTerraform(struct!.removeRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._append !== undefined) {
      hasAnyValues = true;
      internalValueResult.append = this._append;
    }
    if (this._none?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.none = this._none?.internalValue;
    }
    if (this._overwrite !== undefined) {
      hasAnyValues = true;
      internalValueResult.overwrite = this._overwrite;
    }
    if (this._removeAll?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.removeAll = this._removeAll?.internalValue;
    }
    if (this._removeRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.removeRegex = this._removeRegex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._append = undefined;
      this._none.internalValue = undefined;
      this._overwrite = undefined;
      this._removeAll.internalValue = undefined;
      this._removeRegex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._append = value.append;
      this._none.internalValue = value.none;
      this._overwrite = value.overwrite;
      this._removeAll.internalValue = value.removeAll;
      this._removeRegex = value.removeRegex;
    }
  }

  // append - computed: false, optional: true, required: false
  private _append?: string[]; 
  public get append() {
    return this.getListAttribute('append');
  }
  public set append(value: string[]) {
    this._append = value;
  }
  public resetAppend() {
    this._append = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appendInput() {
    return this._append;
  }

  // none - computed: false, optional: true, required: false
  private _none = new LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneOutputReference(this, "none");
  public get none() {
    return this._none;
  }
  public putNone(value: LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNone) {
    this._none.internalValue = value;
  }
  public resetNone() {
    this._none.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get noneInput() {
    return this._none.internalValue;
  }

  // overwrite - computed: false, optional: true, required: false
  private _overwrite?: string[]; 
  public get overwrite() {
    return this.getListAttribute('overwrite');
  }
  public set overwrite(value: string[]) {
    this._overwrite = value;
  }
  public resetOverwrite() {
    this._overwrite = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overwriteInput() {
    return this._overwrite;
  }

  // remove_all - computed: false, optional: true, required: false
  private _removeAll = new LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllOutputReference(this, "remove_all");
  public get removeAll() {
    return this._removeAll;
  }
  public putRemoveAll(value: LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAll) {
    this._removeAll.internalValue = value;
  }
  public resetRemoveAll() {
    this._removeAll.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeAllInput() {
    return this._removeAll.internalValue;
  }

  // remove_regex - computed: false, optional: true, required: false
  private _removeRegex?: string; 
  public get removeRegex() {
    return this.getStringAttribute('remove_regex');
  }
  public set removeRegex(value: string) {
    this._removeRegex = value;
  }
  public resetRemoveRegex() {
    this._removeRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeRegexInput() {
    return this._removeRegex;
  }
}
export interface LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNone {
}

export function logicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneToTerraform(struct?: LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNone | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function logicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneToHclTerraform(struct?: LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNone | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNone | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNone | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAll {
}

export function logicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllToTerraform(struct?: LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAll | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function logicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllToHclTerraform(struct?: LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAll | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAll | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAll | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunity {
  /**
  * Append
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#append LogicalRouter#append}
  */
  readonly append?: string[];
  /**
  * None
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#none LogicalRouter#none}
  */
  readonly none?: LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNone;
  /**
  * Overwrite
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#overwrite LogicalRouter#overwrite}
  */
  readonly overwrite?: string[];
  /**
  * Remove all
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#remove_all LogicalRouter#remove_all}
  */
  readonly removeAll?: LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAll;
  /**
  * Remove regex
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#remove_regex LogicalRouter#remove_regex}
  */
  readonly removeRegex?: string;
}

export function logicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityToTerraform(struct?: LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    append: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.append),
    none: logicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneToTerraform(struct!.none),
    overwrite: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.overwrite),
    remove_all: logicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllToTerraform(struct!.removeAll),
    remove_regex: cdktf.stringToTerraform(struct!.removeRegex),
  }
}


export function logicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityToHclTerraform(struct?: LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    append: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.append),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    none: {
      value: logicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneToHclTerraform(struct!.none),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNone",
    },
    overwrite: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.overwrite),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    remove_all: {
      value: logicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllToHclTerraform(struct!.removeAll),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAll",
    },
    remove_regex: {
      value: cdktf.stringToHclTerraform(struct!.removeRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._append !== undefined) {
      hasAnyValues = true;
      internalValueResult.append = this._append;
    }
    if (this._none?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.none = this._none?.internalValue;
    }
    if (this._overwrite !== undefined) {
      hasAnyValues = true;
      internalValueResult.overwrite = this._overwrite;
    }
    if (this._removeAll?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.removeAll = this._removeAll?.internalValue;
    }
    if (this._removeRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.removeRegex = this._removeRegex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._append = undefined;
      this._none.internalValue = undefined;
      this._overwrite = undefined;
      this._removeAll.internalValue = undefined;
      this._removeRegex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._append = value.append;
      this._none.internalValue = value.none;
      this._overwrite = value.overwrite;
      this._removeAll.internalValue = value.removeAll;
      this._removeRegex = value.removeRegex;
    }
  }

  // append - computed: false, optional: true, required: false
  private _append?: string[]; 
  public get append() {
    return this.getListAttribute('append');
  }
  public set append(value: string[]) {
    this._append = value;
  }
  public resetAppend() {
    this._append = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appendInput() {
    return this._append;
  }

  // none - computed: false, optional: true, required: false
  private _none = new LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneOutputReference(this, "none");
  public get none() {
    return this._none;
  }
  public putNone(value: LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNone) {
    this._none.internalValue = value;
  }
  public resetNone() {
    this._none.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get noneInput() {
    return this._none.internalValue;
  }

  // overwrite - computed: false, optional: true, required: false
  private _overwrite?: string[]; 
  public get overwrite() {
    return this.getListAttribute('overwrite');
  }
  public set overwrite(value: string[]) {
    this._overwrite = value;
  }
  public resetOverwrite() {
    this._overwrite = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overwriteInput() {
    return this._overwrite;
  }

  // remove_all - computed: false, optional: true, required: false
  private _removeAll = new LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllOutputReference(this, "remove_all");
  public get removeAll() {
    return this._removeAll;
  }
  public putRemoveAll(value: LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAll) {
    this._removeAll.internalValue = value;
  }
  public resetRemoveAll() {
    this._removeAll.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeAllInput() {
    return this._removeAll.internalValue;
  }

  // remove_regex - computed: false, optional: true, required: false
  private _removeRegex?: string; 
  public get removeRegex() {
    return this.getStringAttribute('remove_regex');
  }
  public set removeRegex(value: string) {
    this._removeRegex = value;
  }
  public resetRemoveRegex() {
    this._removeRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeRegexInput() {
    return this._removeRegex;
  }
}
export interface LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributes {
  /**
  * As path
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#as_path LogicalRouter#as_path}
  */
  readonly asPath?: LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPath;
  /**
  * As path limit
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#as_path_limit LogicalRouter#as_path_limit}
  */
  readonly asPathLimit?: number;
  /**
  * Community
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#community LogicalRouter#community}
  */
  readonly community?: LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunity;
  /**
  * Extended community
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#extended_community LogicalRouter#extended_community}
  */
  readonly extendedCommunity?: LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunity;
  /**
  * Local preference
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#local_preference LogicalRouter#local_preference}
  */
  readonly localPreference?: number;
  /**
  * Med
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#med LogicalRouter#med}
  */
  readonly med?: number;
  /**
  * Nexthop
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#nexthop LogicalRouter#nexthop}
  */
  readonly nexthop?: string;
  /**
  * Origin
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#origin LogicalRouter#origin}
  */
  readonly origin?: string;
  /**
  * Weight
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#weight LogicalRouter#weight}
  */
  readonly weight?: number;
}

export function logicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesToTerraform(struct?: LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributes | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    as_path: logicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathToTerraform(struct!.asPath),
    as_path_limit: cdktf.numberToTerraform(struct!.asPathLimit),
    community: logicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityToTerraform(struct!.community),
    extended_community: logicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityToTerraform(struct!.extendedCommunity),
    local_preference: cdktf.numberToTerraform(struct!.localPreference),
    med: cdktf.numberToTerraform(struct!.med),
    nexthop: cdktf.stringToTerraform(struct!.nexthop),
    origin: cdktf.stringToTerraform(struct!.origin),
    weight: cdktf.numberToTerraform(struct!.weight),
  }
}


export function logicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesToHclTerraform(struct?: LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributes | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    as_path: {
      value: logicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathToHclTerraform(struct!.asPath),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPath",
    },
    as_path_limit: {
      value: cdktf.numberToHclTerraform(struct!.asPathLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    community: {
      value: logicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityToHclTerraform(struct!.community),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunity",
    },
    extended_community: {
      value: logicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityToHclTerraform(struct!.extendedCommunity),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunity",
    },
    local_preference: {
      value: cdktf.numberToHclTerraform(struct!.localPreference),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    med: {
      value: cdktf.numberToHclTerraform(struct!.med),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    nexthop: {
      value: cdktf.stringToHclTerraform(struct!.nexthop),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    origin: {
      value: cdktf.stringToHclTerraform(struct!.origin),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    weight: {
      value: cdktf.numberToHclTerraform(struct!.weight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributes | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._asPath?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.asPath = this._asPath?.internalValue;
    }
    if (this._asPathLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.asPathLimit = this._asPathLimit;
    }
    if (this._community?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.community = this._community?.internalValue;
    }
    if (this._extendedCommunity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extendedCommunity = this._extendedCommunity?.internalValue;
    }
    if (this._localPreference !== undefined) {
      hasAnyValues = true;
      internalValueResult.localPreference = this._localPreference;
    }
    if (this._med !== undefined) {
      hasAnyValues = true;
      internalValueResult.med = this._med;
    }
    if (this._nexthop !== undefined) {
      hasAnyValues = true;
      internalValueResult.nexthop = this._nexthop;
    }
    if (this._origin !== undefined) {
      hasAnyValues = true;
      internalValueResult.origin = this._origin;
    }
    if (this._weight !== undefined) {
      hasAnyValues = true;
      internalValueResult.weight = this._weight;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributes | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._asPath.internalValue = undefined;
      this._asPathLimit = undefined;
      this._community.internalValue = undefined;
      this._extendedCommunity.internalValue = undefined;
      this._localPreference = undefined;
      this._med = undefined;
      this._nexthop = undefined;
      this._origin = undefined;
      this._weight = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._asPath.internalValue = value.asPath;
      this._asPathLimit = value.asPathLimit;
      this._community.internalValue = value.community;
      this._extendedCommunity.internalValue = value.extendedCommunity;
      this._localPreference = value.localPreference;
      this._med = value.med;
      this._nexthop = value.nexthop;
      this._origin = value.origin;
      this._weight = value.weight;
    }
  }

  // as_path - computed: false, optional: true, required: false
  private _asPath = new LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPathOutputReference(this, "as_path");
  public get asPath() {
    return this._asPath;
  }
  public putAsPath(value: LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesAsPath) {
    this._asPath.internalValue = value;
  }
  public resetAsPath() {
    this._asPath.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asPathInput() {
    return this._asPath.internalValue;
  }

  // as_path_limit - computed: false, optional: true, required: false
  private _asPathLimit?: number; 
  public get asPathLimit() {
    return this.getNumberAttribute('as_path_limit');
  }
  public set asPathLimit(value: number) {
    this._asPathLimit = value;
  }
  public resetAsPathLimit() {
    this._asPathLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asPathLimitInput() {
    return this._asPathLimit;
  }

  // community - computed: false, optional: true, required: false
  private _community = new LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunityOutputReference(this, "community");
  public get community() {
    return this._community;
  }
  public putCommunity(value: LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesCommunity) {
    this._community.internalValue = value;
  }
  public resetCommunity() {
    this._community.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get communityInput() {
    return this._community.internalValue;
  }

  // extended_community - computed: false, optional: true, required: false
  private _extendedCommunity = new LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityOutputReference(this, "extended_community");
  public get extendedCommunity() {
    return this._extendedCommunity;
  }
  public putExtendedCommunity(value: LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunity) {
    this._extendedCommunity.internalValue = value;
  }
  public resetExtendedCommunity() {
    this._extendedCommunity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extendedCommunityInput() {
    return this._extendedCommunity.internalValue;
  }

  // local_preference - computed: false, optional: true, required: false
  private _localPreference?: number; 
  public get localPreference() {
    return this.getNumberAttribute('local_preference');
  }
  public set localPreference(value: number) {
    this._localPreference = value;
  }
  public resetLocalPreference() {
    this._localPreference = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localPreferenceInput() {
    return this._localPreference;
  }

  // med - computed: false, optional: true, required: false
  private _med?: number; 
  public get med() {
    return this.getNumberAttribute('med');
  }
  public set med(value: number) {
    this._med = value;
  }
  public resetMed() {
    this._med = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get medInput() {
    return this._med;
  }

  // nexthop - computed: false, optional: true, required: false
  private _nexthop?: string; 
  public get nexthop() {
    return this.getStringAttribute('nexthop');
  }
  public set nexthop(value: string) {
    this._nexthop = value;
  }
  public resetNexthop() {
    this._nexthop = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nexthopInput() {
    return this._nexthop;
  }

  // origin - computed: false, optional: true, required: false
  private _origin?: string; 
  public get origin() {
    return this.getStringAttribute('origin');
  }
  public set origin(value: string) {
    this._origin = value;
  }
  public resetOrigin() {
    this._origin = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get originInput() {
    return this._origin;
  }

  // weight - computed: false, optional: true, required: false
  private _weight?: number; 
  public get weight() {
    return this.getNumberAttribute('weight');
  }
  public set weight(value: number) {
    this._weight = value;
  }
  public resetWeight() {
    this._weight = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get weightInput() {
    return this._weight;
  }
}
export interface LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefix {
  /**
  * Exact
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#exact LogicalRouter#exact}
  */
  readonly exact?: boolean | cdktf.IResolvable;
  /**
  * Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#name LogicalRouter#name}
  */
  readonly name: string;
}

export function logicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixToTerraform(struct?: LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    exact: cdktf.booleanToTerraform(struct!.exact),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function logicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixToHclTerraform(struct?: LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    exact: {
      value: cdktf.booleanToHclTerraform(struct!.exact),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefix | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._exact !== undefined) {
      hasAnyValues = true;
      internalValueResult.exact = this._exact;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefix | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._exact = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._exact = value.exact;
      this._name = value.name;
    }
  }

  // exact - computed: false, optional: true, required: false
  private _exact?: boolean | cdktf.IResolvable; 
  public get exact() {
    return this.getBooleanAttribute('exact');
  }
  public set exact(value: boolean | cdktf.IResolvable) {
    this._exact = value;
  }
  public resetExact() {
    this._exact = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exactInput() {
    return this._exact;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixList extends cdktf.ComplexList {
  public internalValue? : LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefix[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixOutputReference {
    return new LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchAsPath {
  /**
  * Regex
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#regex LogicalRouter#regex}
  */
  readonly regex?: string;
}

export function logicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchAsPathToTerraform(struct?: LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchAsPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function logicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchAsPathToHclTerraform(struct?: LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchAsPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchAsPathOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchAsPath | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchAsPath | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._regex = value.regex;
    }
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchCommunity {
  /**
  * Regex
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#regex LogicalRouter#regex}
  */
  readonly regex?: string;
}

export function logicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchCommunityToTerraform(struct?: LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function logicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchCommunityToHclTerraform(struct?: LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchCommunityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchCommunity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchCommunity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._regex = value.regex;
    }
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunity {
  /**
  * Regex
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#regex LogicalRouter#regex}
  */
  readonly regex?: string;
}

export function logicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunityToTerraform(struct?: LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function logicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunityToHclTerraform(struct?: LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._regex = value.regex;
    }
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatch {
  /**
  * Address prefix
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#address_prefix LogicalRouter#address_prefix}
  */
  readonly addressPrefix?: LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefix[] | cdktf.IResolvable;
  /**
  * Afi
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#afi LogicalRouter#afi}
  */
  readonly afi?: string;
  /**
  * As path
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#as_path LogicalRouter#as_path}
  */
  readonly asPath?: LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchAsPath;
  /**
  * Community
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#community LogicalRouter#community}
  */
  readonly community?: LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchCommunity;
  /**
  * Extended community
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#extended_community LogicalRouter#extended_community}
  */
  readonly extendedCommunity?: LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunity;
  /**
  * From peer
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#from_peer LogicalRouter#from_peer}
  */
  readonly fromPeer?: string[];
  /**
  * Med
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#med LogicalRouter#med}
  */
  readonly med?: number;
  /**
  * Nexthop
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#nexthop LogicalRouter#nexthop}
  */
  readonly nexthop?: string[];
  /**
  * Route table
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#route_table LogicalRouter#route_table}
  */
  readonly routeTable?: string;
  /**
  * Safi
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#safi LogicalRouter#safi}
  */
  readonly safi?: string;
}

export function logicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchToTerraform(struct?: LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address_prefix: cdktf.listMapper(logicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixToTerraform, false)(struct!.addressPrefix),
    afi: cdktf.stringToTerraform(struct!.afi),
    as_path: logicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchAsPathToTerraform(struct!.asPath),
    community: logicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchCommunityToTerraform(struct!.community),
    extended_community: logicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunityToTerraform(struct!.extendedCommunity),
    from_peer: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.fromPeer),
    med: cdktf.numberToTerraform(struct!.med),
    nexthop: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.nexthop),
    route_table: cdktf.stringToTerraform(struct!.routeTable),
    safi: cdktf.stringToTerraform(struct!.safi),
  }
}


export function logicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchToHclTerraform(struct?: LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address_prefix: {
      value: cdktf.listMapperHcl(logicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixToHclTerraform, false)(struct!.addressPrefix),
      isBlock: true,
      type: "list",
      storageClassType: "LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixList",
    },
    afi: {
      value: cdktf.stringToHclTerraform(struct!.afi),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    as_path: {
      value: logicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchAsPathToHclTerraform(struct!.asPath),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchAsPath",
    },
    community: {
      value: logicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchCommunityToHclTerraform(struct!.community),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchCommunity",
    },
    extended_community: {
      value: logicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunityToHclTerraform(struct!.extendedCommunity),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunity",
    },
    from_peer: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.fromPeer),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    med: {
      value: cdktf.numberToHclTerraform(struct!.med),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    nexthop: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.nexthop),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    route_table: {
      value: cdktf.stringToHclTerraform(struct!.routeTable),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    safi: {
      value: cdktf.stringToHclTerraform(struct!.safi),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addressPrefix?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.addressPrefix = this._addressPrefix?.internalValue;
    }
    if (this._afi !== undefined) {
      hasAnyValues = true;
      internalValueResult.afi = this._afi;
    }
    if (this._asPath?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.asPath = this._asPath?.internalValue;
    }
    if (this._community?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.community = this._community?.internalValue;
    }
    if (this._extendedCommunity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extendedCommunity = this._extendedCommunity?.internalValue;
    }
    if (this._fromPeer !== undefined) {
      hasAnyValues = true;
      internalValueResult.fromPeer = this._fromPeer;
    }
    if (this._med !== undefined) {
      hasAnyValues = true;
      internalValueResult.med = this._med;
    }
    if (this._nexthop !== undefined) {
      hasAnyValues = true;
      internalValueResult.nexthop = this._nexthop;
    }
    if (this._routeTable !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeTable = this._routeTable;
    }
    if (this._safi !== undefined) {
      hasAnyValues = true;
      internalValueResult.safi = this._safi;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addressPrefix.internalValue = undefined;
      this._afi = undefined;
      this._asPath.internalValue = undefined;
      this._community.internalValue = undefined;
      this._extendedCommunity.internalValue = undefined;
      this._fromPeer = undefined;
      this._med = undefined;
      this._nexthop = undefined;
      this._routeTable = undefined;
      this._safi = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addressPrefix.internalValue = value.addressPrefix;
      this._afi = value.afi;
      this._asPath.internalValue = value.asPath;
      this._community.internalValue = value.community;
      this._extendedCommunity.internalValue = value.extendedCommunity;
      this._fromPeer = value.fromPeer;
      this._med = value.med;
      this._nexthop = value.nexthop;
      this._routeTable = value.routeTable;
      this._safi = value.safi;
    }
  }

  // address_prefix - computed: false, optional: true, required: false
  private _addressPrefix = new LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixList(this, "address_prefix", false);
  public get addressPrefix() {
    return this._addressPrefix;
  }
  public putAddressPrefix(value: LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefix[] | cdktf.IResolvable) {
    this._addressPrefix.internalValue = value;
  }
  public resetAddressPrefix() {
    this._addressPrefix.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressPrefixInput() {
    return this._addressPrefix.internalValue;
  }

  // afi - computed: false, optional: true, required: false
  private _afi?: string; 
  public get afi() {
    return this.getStringAttribute('afi');
  }
  public set afi(value: string) {
    this._afi = value;
  }
  public resetAfi() {
    this._afi = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get afiInput() {
    return this._afi;
  }

  // as_path - computed: false, optional: true, required: false
  private _asPath = new LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchAsPathOutputReference(this, "as_path");
  public get asPath() {
    return this._asPath;
  }
  public putAsPath(value: LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchAsPath) {
    this._asPath.internalValue = value;
  }
  public resetAsPath() {
    this._asPath.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asPathInput() {
    return this._asPath.internalValue;
  }

  // community - computed: false, optional: true, required: false
  private _community = new LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchCommunityOutputReference(this, "community");
  public get community() {
    return this._community;
  }
  public putCommunity(value: LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchCommunity) {
    this._community.internalValue = value;
  }
  public resetCommunity() {
    this._community.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get communityInput() {
    return this._community.internalValue;
  }

  // extended_community - computed: false, optional: true, required: false
  private _extendedCommunity = new LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunityOutputReference(this, "extended_community");
  public get extendedCommunity() {
    return this._extendedCommunity;
  }
  public putExtendedCommunity(value: LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunity) {
    this._extendedCommunity.internalValue = value;
  }
  public resetExtendedCommunity() {
    this._extendedCommunity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extendedCommunityInput() {
    return this._extendedCommunity.internalValue;
  }

  // from_peer - computed: false, optional: true, required: false
  private _fromPeer?: string[]; 
  public get fromPeer() {
    return this.getListAttribute('from_peer');
  }
  public set fromPeer(value: string[]) {
    this._fromPeer = value;
  }
  public resetFromPeer() {
    this._fromPeer = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fromPeerInput() {
    return this._fromPeer;
  }

  // med - computed: false, optional: true, required: false
  private _med?: number; 
  public get med() {
    return this.getNumberAttribute('med');
  }
  public set med(value: number) {
    this._med = value;
  }
  public resetMed() {
    this._med = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get medInput() {
    return this._med;
  }

  // nexthop - computed: false, optional: true, required: false
  private _nexthop?: string[]; 
  public get nexthop() {
    return this.getListAttribute('nexthop');
  }
  public set nexthop(value: string[]) {
    this._nexthop = value;
  }
  public resetNexthop() {
    this._nexthop = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nexthopInput() {
    return this._nexthop;
  }

  // route_table - computed: false, optional: true, required: false
  private _routeTable?: string; 
  public get routeTable() {
    return this.getStringAttribute('route_table');
  }
  public set routeTable(value: string) {
    this._routeTable = value;
  }
  public resetRouteTable() {
    this._routeTable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeTableInput() {
    return this._routeTable;
  }

  // safi - computed: false, optional: true, required: false
  private _safi?: string; 
  public get safi() {
    return this.getStringAttribute('safi');
  }
  public set safi(value: string) {
    this._safi = value;
  }
  public resetSafi() {
    this._safi = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safiInput() {
    return this._safi;
  }
}
export interface LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilters {
  /**
  * Enable
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#enable LogicalRouter#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * Match
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#match LogicalRouter#match}
  */
  readonly match?: LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatch;
  /**
  * Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#name LogicalRouter#name}
  */
  readonly name: string;
}

export function logicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersToTerraform(struct?: LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enable: cdktf.booleanToTerraform(struct!.enable),
    match: logicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchToTerraform(struct!.match),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function logicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersToHclTerraform(struct?: LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    match: {
      value: logicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchToHclTerraform(struct!.match),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatch",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._match?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enable = undefined;
      this._match.internalValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enable = value.enable;
      this._match.internalValue = value.match;
      this._name = value.name;
    }
  }

  // enable - computed: false, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // match - computed: false, optional: true, required: false
  private _match = new LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatchOutputReference(this, "match");
  public get match() {
    return this._match;
  }
  public putMatch(value: LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersMatch) {
    this._match.internalValue = value;
  }
  public resetMatch() {
    this._match.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match.internalValue;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersList extends cdktf.ComplexList {
  public internalValue? : LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilters[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersOutputReference {
    return new LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface LogicalRouterVrfBgpPolicyAggregationAddress {
  /**
  * Advertise filters
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#advertise_filters LogicalRouter#advertise_filters}
  */
  readonly advertiseFilters?: LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilters[] | cdktf.IResolvable;
  /**
  * Aggregate route attributes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#aggregate_route_attributes LogicalRouter#aggregate_route_attributes}
  */
  readonly aggregateRouteAttributes?: LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributes;
  /**
  * As set
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#as_set LogicalRouter#as_set}
  */
  readonly asSet?: boolean | cdktf.IResolvable;
  /**
  * Enable
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#enable LogicalRouter#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#name LogicalRouter#name}
  */
  readonly name: string;
  /**
  * Prefix
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#prefix LogicalRouter#prefix}
  */
  readonly prefix?: string;
  /**
  * Summary
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#summary LogicalRouter#summary}
  */
  readonly summary?: boolean | cdktf.IResolvable;
  /**
  * Suppress filters
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#suppress_filters LogicalRouter#suppress_filters}
  */
  readonly suppressFilters?: LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilters[] | cdktf.IResolvable;
}

export function logicalRouterVrfBgpPolicyAggregationAddressToTerraform(struct?: LogicalRouterVrfBgpPolicyAggregationAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    advertise_filters: cdktf.listMapper(logicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersToTerraform, false)(struct!.advertiseFilters),
    aggregate_route_attributes: logicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesToTerraform(struct!.aggregateRouteAttributes),
    as_set: cdktf.booleanToTerraform(struct!.asSet),
    enable: cdktf.booleanToTerraform(struct!.enable),
    name: cdktf.stringToTerraform(struct!.name),
    prefix: cdktf.stringToTerraform(struct!.prefix),
    summary: cdktf.booleanToTerraform(struct!.summary),
    suppress_filters: cdktf.listMapper(logicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersToTerraform, false)(struct!.suppressFilters),
  }
}


export function logicalRouterVrfBgpPolicyAggregationAddressToHclTerraform(struct?: LogicalRouterVrfBgpPolicyAggregationAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    advertise_filters: {
      value: cdktf.listMapperHcl(logicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersToHclTerraform, false)(struct!.advertiseFilters),
      isBlock: true,
      type: "list",
      storageClassType: "LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersList",
    },
    aggregate_route_attributes: {
      value: logicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesToHclTerraform(struct!.aggregateRouteAttributes),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributes",
    },
    as_set: {
      value: cdktf.booleanToHclTerraform(struct!.asSet),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix: {
      value: cdktf.stringToHclTerraform(struct!.prefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    summary: {
      value: cdktf.booleanToHclTerraform(struct!.summary),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    suppress_filters: {
      value: cdktf.listMapperHcl(logicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersToHclTerraform, false)(struct!.suppressFilters),
      isBlock: true,
      type: "list",
      storageClassType: "LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyAggregationAddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyAggregationAddress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._advertiseFilters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.advertiseFilters = this._advertiseFilters?.internalValue;
    }
    if (this._aggregateRouteAttributes?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.aggregateRouteAttributes = this._aggregateRouteAttributes?.internalValue;
    }
    if (this._asSet !== undefined) {
      hasAnyValues = true;
      internalValueResult.asSet = this._asSet;
    }
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._prefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefix = this._prefix;
    }
    if (this._summary !== undefined) {
      hasAnyValues = true;
      internalValueResult.summary = this._summary;
    }
    if (this._suppressFilters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.suppressFilters = this._suppressFilters?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyAggregationAddress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._advertiseFilters.internalValue = undefined;
      this._aggregateRouteAttributes.internalValue = undefined;
      this._asSet = undefined;
      this._enable = undefined;
      this._name = undefined;
      this._prefix = undefined;
      this._summary = undefined;
      this._suppressFilters.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._advertiseFilters.internalValue = value.advertiseFilters;
      this._aggregateRouteAttributes.internalValue = value.aggregateRouteAttributes;
      this._asSet = value.asSet;
      this._enable = value.enable;
      this._name = value.name;
      this._prefix = value.prefix;
      this._summary = value.summary;
      this._suppressFilters.internalValue = value.suppressFilters;
    }
  }

  // advertise_filters - computed: false, optional: true, required: false
  private _advertiseFilters = new LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFiltersList(this, "advertise_filters", false);
  public get advertiseFilters() {
    return this._advertiseFilters;
  }
  public putAdvertiseFilters(value: LogicalRouterVrfBgpPolicyAggregationAddressAdvertiseFilters[] | cdktf.IResolvable) {
    this._advertiseFilters.internalValue = value;
  }
  public resetAdvertiseFilters() {
    this._advertiseFilters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get advertiseFiltersInput() {
    return this._advertiseFilters.internalValue;
  }

  // aggregate_route_attributes - computed: false, optional: true, required: false
  private _aggregateRouteAttributes = new LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributesOutputReference(this, "aggregate_route_attributes");
  public get aggregateRouteAttributes() {
    return this._aggregateRouteAttributes;
  }
  public putAggregateRouteAttributes(value: LogicalRouterVrfBgpPolicyAggregationAddressAggregateRouteAttributes) {
    this._aggregateRouteAttributes.internalValue = value;
  }
  public resetAggregateRouteAttributes() {
    this._aggregateRouteAttributes.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aggregateRouteAttributesInput() {
    return this._aggregateRouteAttributes.internalValue;
  }

  // as_set - computed: false, optional: true, required: false
  private _asSet?: boolean | cdktf.IResolvable; 
  public get asSet() {
    return this.getBooleanAttribute('as_set');
  }
  public set asSet(value: boolean | cdktf.IResolvable) {
    this._asSet = value;
  }
  public resetAsSet() {
    this._asSet = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asSetInput() {
    return this._asSet;
  }

  // enable - computed: false, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // prefix - computed: false, optional: true, required: false
  private _prefix?: string; 
  public get prefix() {
    return this.getStringAttribute('prefix');
  }
  public set prefix(value: string) {
    this._prefix = value;
  }
  public resetPrefix() {
    this._prefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixInput() {
    return this._prefix;
  }

  // summary - computed: false, optional: true, required: false
  private _summary?: boolean | cdktf.IResolvable; 
  public get summary() {
    return this.getBooleanAttribute('summary');
  }
  public set summary(value: boolean | cdktf.IResolvable) {
    this._summary = value;
  }
  public resetSummary() {
    this._summary = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get summaryInput() {
    return this._summary;
  }

  // suppress_filters - computed: false, optional: true, required: false
  private _suppressFilters = new LogicalRouterVrfBgpPolicyAggregationAddressSuppressFiltersList(this, "suppress_filters", false);
  public get suppressFilters() {
    return this._suppressFilters;
  }
  public putSuppressFilters(value: LogicalRouterVrfBgpPolicyAggregationAddressSuppressFilters[] | cdktf.IResolvable) {
    this._suppressFilters.internalValue = value;
  }
  public resetSuppressFilters() {
    this._suppressFilters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get suppressFiltersInput() {
    return this._suppressFilters.internalValue;
  }
}

export class LogicalRouterVrfBgpPolicyAggregationAddressList extends cdktf.ComplexList {
  public internalValue? : LogicalRouterVrfBgpPolicyAggregationAddress[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): LogicalRouterVrfBgpPolicyAggregationAddressOutputReference {
    return new LogicalRouterVrfBgpPolicyAggregationAddressOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface LogicalRouterVrfBgpPolicyAggregation {
  /**
  * Address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#address LogicalRouter#address}
  */
  readonly address?: LogicalRouterVrfBgpPolicyAggregationAddress[] | cdktf.IResolvable;
}

export function logicalRouterVrfBgpPolicyAggregationToTerraform(struct?: LogicalRouterVrfBgpPolicyAggregation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: cdktf.listMapper(logicalRouterVrfBgpPolicyAggregationAddressToTerraform, false)(struct!.address),
  }
}


export function logicalRouterVrfBgpPolicyAggregationToHclTerraform(struct?: LogicalRouterVrfBgpPolicyAggregation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: cdktf.listMapperHcl(logicalRouterVrfBgpPolicyAggregationAddressToHclTerraform, false)(struct!.address),
      isBlock: true,
      type: "list",
      storageClassType: "LogicalRouterVrfBgpPolicyAggregationAddressList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyAggregationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyAggregation | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyAggregation | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address.internalValue = value.address;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address = new LogicalRouterVrfBgpPolicyAggregationAddressList(this, "address", false);
  public get address() {
    return this._address;
  }
  public putAddress(value: LogicalRouterVrfBgpPolicyAggregationAddress[] | cdktf.IResolvable) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }
}
export interface LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefix {
  /**
  * Exact
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#exact LogicalRouter#exact}
  */
  readonly exact?: boolean | cdktf.IResolvable;
  /**
  * Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#name LogicalRouter#name}
  */
  readonly name: string;
}

export function logicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixToTerraform(struct?: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    exact: cdktf.booleanToTerraform(struct!.exact),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function logicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixToHclTerraform(struct?: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    exact: {
      value: cdktf.booleanToHclTerraform(struct!.exact),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefix | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._exact !== undefined) {
      hasAnyValues = true;
      internalValueResult.exact = this._exact;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefix | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._exact = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._exact = value.exact;
      this._name = value.name;
    }
  }

  // exact - computed: false, optional: true, required: false
  private _exact?: boolean | cdktf.IResolvable; 
  public get exact() {
    return this.getBooleanAttribute('exact');
  }
  public set exact(value: boolean | cdktf.IResolvable) {
    this._exact = value;
  }
  public resetExact() {
    this._exact = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exactInput() {
    return this._exact;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixList extends cdktf.ComplexList {
  public internalValue? : LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefix[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixOutputReference {
    return new LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPath {
  /**
  * Regex
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#regex LogicalRouter#regex}
  */
  readonly regex?: string;
}

export function logicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathToTerraform(struct?: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function logicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathToHclTerraform(struct?: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPath | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPath | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._regex = value.regex;
    }
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunity {
  /**
  * Regex
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#regex LogicalRouter#regex}
  */
  readonly regex?: string;
}

export function logicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunityToTerraform(struct?: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function logicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunityToHclTerraform(struct?: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._regex = value.regex;
    }
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunity {
  /**
  * Regex
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#regex LogicalRouter#regex}
  */
  readonly regex?: string;
}

export function logicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunityToTerraform(struct?: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function logicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunityToHclTerraform(struct?: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._regex = value.regex;
    }
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatch {
  /**
  * Address prefix
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#address_prefix LogicalRouter#address_prefix}
  */
  readonly addressPrefix?: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefix[] | cdktf.IResolvable;
  /**
  * Afi
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#afi LogicalRouter#afi}
  */
  readonly afi?: string;
  /**
  * As path
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#as_path LogicalRouter#as_path}
  */
  readonly asPath?: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPath;
  /**
  * Community
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#community LogicalRouter#community}
  */
  readonly community?: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunity;
  /**
  * Extended community
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#extended_community LogicalRouter#extended_community}
  */
  readonly extendedCommunity?: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunity;
  /**
  * From peer
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#from_peer LogicalRouter#from_peer}
  */
  readonly fromPeer?: string[];
  /**
  * Med
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#med LogicalRouter#med}
  */
  readonly med?: number;
  /**
  * Nexthop
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#nexthop LogicalRouter#nexthop}
  */
  readonly nexthop?: string[];
  /**
  * Route table
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#route_table LogicalRouter#route_table}
  */
  readonly routeTable?: string;
  /**
  * Safi
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#safi LogicalRouter#safi}
  */
  readonly safi?: string;
}

export function logicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchToTerraform(struct?: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address_prefix: cdktf.listMapper(logicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixToTerraform, false)(struct!.addressPrefix),
    afi: cdktf.stringToTerraform(struct!.afi),
    as_path: logicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathToTerraform(struct!.asPath),
    community: logicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunityToTerraform(struct!.community),
    extended_community: logicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunityToTerraform(struct!.extendedCommunity),
    from_peer: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.fromPeer),
    med: cdktf.numberToTerraform(struct!.med),
    nexthop: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.nexthop),
    route_table: cdktf.stringToTerraform(struct!.routeTable),
    safi: cdktf.stringToTerraform(struct!.safi),
  }
}


export function logicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchToHclTerraform(struct?: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address_prefix: {
      value: cdktf.listMapperHcl(logicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixToHclTerraform, false)(struct!.addressPrefix),
      isBlock: true,
      type: "list",
      storageClassType: "LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixList",
    },
    afi: {
      value: cdktf.stringToHclTerraform(struct!.afi),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    as_path: {
      value: logicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathToHclTerraform(struct!.asPath),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPath",
    },
    community: {
      value: logicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunityToHclTerraform(struct!.community),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunity",
    },
    extended_community: {
      value: logicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunityToHclTerraform(struct!.extendedCommunity),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunity",
    },
    from_peer: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.fromPeer),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    med: {
      value: cdktf.numberToHclTerraform(struct!.med),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    nexthop: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.nexthop),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    route_table: {
      value: cdktf.stringToHclTerraform(struct!.routeTable),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    safi: {
      value: cdktf.stringToHclTerraform(struct!.safi),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addressPrefix?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.addressPrefix = this._addressPrefix?.internalValue;
    }
    if (this._afi !== undefined) {
      hasAnyValues = true;
      internalValueResult.afi = this._afi;
    }
    if (this._asPath?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.asPath = this._asPath?.internalValue;
    }
    if (this._community?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.community = this._community?.internalValue;
    }
    if (this._extendedCommunity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extendedCommunity = this._extendedCommunity?.internalValue;
    }
    if (this._fromPeer !== undefined) {
      hasAnyValues = true;
      internalValueResult.fromPeer = this._fromPeer;
    }
    if (this._med !== undefined) {
      hasAnyValues = true;
      internalValueResult.med = this._med;
    }
    if (this._nexthop !== undefined) {
      hasAnyValues = true;
      internalValueResult.nexthop = this._nexthop;
    }
    if (this._routeTable !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeTable = this._routeTable;
    }
    if (this._safi !== undefined) {
      hasAnyValues = true;
      internalValueResult.safi = this._safi;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addressPrefix.internalValue = undefined;
      this._afi = undefined;
      this._asPath.internalValue = undefined;
      this._community.internalValue = undefined;
      this._extendedCommunity.internalValue = undefined;
      this._fromPeer = undefined;
      this._med = undefined;
      this._nexthop = undefined;
      this._routeTable = undefined;
      this._safi = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addressPrefix.internalValue = value.addressPrefix;
      this._afi = value.afi;
      this._asPath.internalValue = value.asPath;
      this._community.internalValue = value.community;
      this._extendedCommunity.internalValue = value.extendedCommunity;
      this._fromPeer = value.fromPeer;
      this._med = value.med;
      this._nexthop = value.nexthop;
      this._routeTable = value.routeTable;
      this._safi = value.safi;
    }
  }

  // address_prefix - computed: false, optional: true, required: false
  private _addressPrefix = new LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixList(this, "address_prefix", false);
  public get addressPrefix() {
    return this._addressPrefix;
  }
  public putAddressPrefix(value: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefix[] | cdktf.IResolvable) {
    this._addressPrefix.internalValue = value;
  }
  public resetAddressPrefix() {
    this._addressPrefix.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressPrefixInput() {
    return this._addressPrefix.internalValue;
  }

  // afi - computed: false, optional: true, required: false
  private _afi?: string; 
  public get afi() {
    return this.getStringAttribute('afi');
  }
  public set afi(value: string) {
    this._afi = value;
  }
  public resetAfi() {
    this._afi = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get afiInput() {
    return this._afi;
  }

  // as_path - computed: false, optional: true, required: false
  private _asPath = new LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathOutputReference(this, "as_path");
  public get asPath() {
    return this._asPath;
  }
  public putAsPath(value: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPath) {
    this._asPath.internalValue = value;
  }
  public resetAsPath() {
    this._asPath.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asPathInput() {
    return this._asPath.internalValue;
  }

  // community - computed: false, optional: true, required: false
  private _community = new LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunityOutputReference(this, "community");
  public get community() {
    return this._community;
  }
  public putCommunity(value: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunity) {
    this._community.internalValue = value;
  }
  public resetCommunity() {
    this._community.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get communityInput() {
    return this._community.internalValue;
  }

  // extended_community - computed: false, optional: true, required: false
  private _extendedCommunity = new LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunityOutputReference(this, "extended_community");
  public get extendedCommunity() {
    return this._extendedCommunity;
  }
  public putExtendedCommunity(value: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunity) {
    this._extendedCommunity.internalValue = value;
  }
  public resetExtendedCommunity() {
    this._extendedCommunity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extendedCommunityInput() {
    return this._extendedCommunity.internalValue;
  }

  // from_peer - computed: false, optional: true, required: false
  private _fromPeer?: string[]; 
  public get fromPeer() {
    return this.getListAttribute('from_peer');
  }
  public set fromPeer(value: string[]) {
    this._fromPeer = value;
  }
  public resetFromPeer() {
    this._fromPeer = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fromPeerInput() {
    return this._fromPeer;
  }

  // med - computed: false, optional: true, required: false
  private _med?: number; 
  public get med() {
    return this.getNumberAttribute('med');
  }
  public set med(value: number) {
    this._med = value;
  }
  public resetMed() {
    this._med = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get medInput() {
    return this._med;
  }

  // nexthop - computed: false, optional: true, required: false
  private _nexthop?: string[]; 
  public get nexthop() {
    return this.getListAttribute('nexthop');
  }
  public set nexthop(value: string[]) {
    this._nexthop = value;
  }
  public resetNexthop() {
    this._nexthop = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nexthopInput() {
    return this._nexthop;
  }

  // route_table - computed: false, optional: true, required: false
  private _routeTable?: string; 
  public get routeTable() {
    return this.getStringAttribute('route_table');
  }
  public set routeTable(value: string) {
    this._routeTable = value;
  }
  public resetRouteTable() {
    this._routeTable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeTableInput() {
    return this._routeTable;
  }

  // safi - computed: false, optional: true, required: false
  private _safi?: string; 
  public get safi() {
    return this.getStringAttribute('safi');
  }
  public set safi(value: string) {
    this._safi = value;
  }
  public resetSafi() {
    this._safi = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safiInput() {
    return this._safi;
  }
}
export interface LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilters {
  /**
  * Enable
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#enable LogicalRouter#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * Match
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#match LogicalRouter#match}
  */
  readonly match?: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatch;
  /**
  * Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#name LogicalRouter#name}
  */
  readonly name: string;
}

export function logicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersToTerraform(struct?: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enable: cdktf.booleanToTerraform(struct!.enable),
    match: logicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchToTerraform(struct!.match),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function logicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersToHclTerraform(struct?: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    match: {
      value: logicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchToHclTerraform(struct!.match),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatch",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._match?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enable = undefined;
      this._match.internalValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enable = value.enable;
      this._match.internalValue = value.match;
      this._name = value.name;
    }
  }

  // enable - computed: false, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // match - computed: false, optional: true, required: false
  private _match = new LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchOutputReference(this, "match");
  public get match() {
    return this._match;
  }
  public putMatch(value: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatch) {
    this._match.internalValue = value;
  }
  public resetMatch() {
    this._match.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match.internalValue;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersList extends cdktf.ComplexList {
  public internalValue? : LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilters[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersOutputReference {
    return new LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefix {
  /**
  * Exact
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#exact LogicalRouter#exact}
  */
  readonly exact?: boolean | cdktf.IResolvable;
  /**
  * Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#name LogicalRouter#name}
  */
  readonly name: string;
}

export function logicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixToTerraform(struct?: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    exact: cdktf.booleanToTerraform(struct!.exact),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function logicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixToHclTerraform(struct?: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    exact: {
      value: cdktf.booleanToHclTerraform(struct!.exact),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefix | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._exact !== undefined) {
      hasAnyValues = true;
      internalValueResult.exact = this._exact;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefix | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._exact = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._exact = value.exact;
      this._name = value.name;
    }
  }

  // exact - computed: false, optional: true, required: false
  private _exact?: boolean | cdktf.IResolvable; 
  public get exact() {
    return this.getBooleanAttribute('exact');
  }
  public set exact(value: boolean | cdktf.IResolvable) {
    this._exact = value;
  }
  public resetExact() {
    this._exact = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exactInput() {
    return this._exact;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixList extends cdktf.ComplexList {
  public internalValue? : LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefix[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixOutputReference {
    return new LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPath {
  /**
  * Regex
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#regex LogicalRouter#regex}
  */
  readonly regex?: string;
}

export function logicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathToTerraform(struct?: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function logicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathToHclTerraform(struct?: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPath | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPath | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._regex = value.regex;
    }
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunity {
  /**
  * Regex
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#regex LogicalRouter#regex}
  */
  readonly regex?: string;
}

export function logicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunityToTerraform(struct?: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function logicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunityToHclTerraform(struct?: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._regex = value.regex;
    }
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunity {
  /**
  * Regex
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#regex LogicalRouter#regex}
  */
  readonly regex?: string;
}

export function logicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunityToTerraform(struct?: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function logicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunityToHclTerraform(struct?: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._regex = value.regex;
    }
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatch {
  /**
  * Address prefix
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#address_prefix LogicalRouter#address_prefix}
  */
  readonly addressPrefix?: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefix[] | cdktf.IResolvable;
  /**
  * Afi
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#afi LogicalRouter#afi}
  */
  readonly afi?: string;
  /**
  * As path
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#as_path LogicalRouter#as_path}
  */
  readonly asPath?: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPath;
  /**
  * Community
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#community LogicalRouter#community}
  */
  readonly community?: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunity;
  /**
  * Extended community
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#extended_community LogicalRouter#extended_community}
  */
  readonly extendedCommunity?: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunity;
  /**
  * From peer
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#from_peer LogicalRouter#from_peer}
  */
  readonly fromPeer?: string[];
  /**
  * Med
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#med LogicalRouter#med}
  */
  readonly med?: number;
  /**
  * Nexthop
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#nexthop LogicalRouter#nexthop}
  */
  readonly nexthop?: string[];
  /**
  * Route table
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#route_table LogicalRouter#route_table}
  */
  readonly routeTable?: string;
  /**
  * Safi
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#safi LogicalRouter#safi}
  */
  readonly safi?: string;
}

export function logicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchToTerraform(struct?: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address_prefix: cdktf.listMapper(logicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixToTerraform, false)(struct!.addressPrefix),
    afi: cdktf.stringToTerraform(struct!.afi),
    as_path: logicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathToTerraform(struct!.asPath),
    community: logicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunityToTerraform(struct!.community),
    extended_community: logicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunityToTerraform(struct!.extendedCommunity),
    from_peer: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.fromPeer),
    med: cdktf.numberToTerraform(struct!.med),
    nexthop: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.nexthop),
    route_table: cdktf.stringToTerraform(struct!.routeTable),
    safi: cdktf.stringToTerraform(struct!.safi),
  }
}


export function logicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchToHclTerraform(struct?: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address_prefix: {
      value: cdktf.listMapperHcl(logicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixToHclTerraform, false)(struct!.addressPrefix),
      isBlock: true,
      type: "list",
      storageClassType: "LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixList",
    },
    afi: {
      value: cdktf.stringToHclTerraform(struct!.afi),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    as_path: {
      value: logicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathToHclTerraform(struct!.asPath),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPath",
    },
    community: {
      value: logicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunityToHclTerraform(struct!.community),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunity",
    },
    extended_community: {
      value: logicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunityToHclTerraform(struct!.extendedCommunity),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunity",
    },
    from_peer: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.fromPeer),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    med: {
      value: cdktf.numberToHclTerraform(struct!.med),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    nexthop: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.nexthop),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    route_table: {
      value: cdktf.stringToHclTerraform(struct!.routeTable),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    safi: {
      value: cdktf.stringToHclTerraform(struct!.safi),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addressPrefix?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.addressPrefix = this._addressPrefix?.internalValue;
    }
    if (this._afi !== undefined) {
      hasAnyValues = true;
      internalValueResult.afi = this._afi;
    }
    if (this._asPath?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.asPath = this._asPath?.internalValue;
    }
    if (this._community?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.community = this._community?.internalValue;
    }
    if (this._extendedCommunity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extendedCommunity = this._extendedCommunity?.internalValue;
    }
    if (this._fromPeer !== undefined) {
      hasAnyValues = true;
      internalValueResult.fromPeer = this._fromPeer;
    }
    if (this._med !== undefined) {
      hasAnyValues = true;
      internalValueResult.med = this._med;
    }
    if (this._nexthop !== undefined) {
      hasAnyValues = true;
      internalValueResult.nexthop = this._nexthop;
    }
    if (this._routeTable !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeTable = this._routeTable;
    }
    if (this._safi !== undefined) {
      hasAnyValues = true;
      internalValueResult.safi = this._safi;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addressPrefix.internalValue = undefined;
      this._afi = undefined;
      this._asPath.internalValue = undefined;
      this._community.internalValue = undefined;
      this._extendedCommunity.internalValue = undefined;
      this._fromPeer = undefined;
      this._med = undefined;
      this._nexthop = undefined;
      this._routeTable = undefined;
      this._safi = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addressPrefix.internalValue = value.addressPrefix;
      this._afi = value.afi;
      this._asPath.internalValue = value.asPath;
      this._community.internalValue = value.community;
      this._extendedCommunity.internalValue = value.extendedCommunity;
      this._fromPeer = value.fromPeer;
      this._med = value.med;
      this._nexthop = value.nexthop;
      this._routeTable = value.routeTable;
      this._safi = value.safi;
    }
  }

  // address_prefix - computed: false, optional: true, required: false
  private _addressPrefix = new LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixList(this, "address_prefix", false);
  public get addressPrefix() {
    return this._addressPrefix;
  }
  public putAddressPrefix(value: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefix[] | cdktf.IResolvable) {
    this._addressPrefix.internalValue = value;
  }
  public resetAddressPrefix() {
    this._addressPrefix.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressPrefixInput() {
    return this._addressPrefix.internalValue;
  }

  // afi - computed: false, optional: true, required: false
  private _afi?: string; 
  public get afi() {
    return this.getStringAttribute('afi');
  }
  public set afi(value: string) {
    this._afi = value;
  }
  public resetAfi() {
    this._afi = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get afiInput() {
    return this._afi;
  }

  // as_path - computed: false, optional: true, required: false
  private _asPath = new LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathOutputReference(this, "as_path");
  public get asPath() {
    return this._asPath;
  }
  public putAsPath(value: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPath) {
    this._asPath.internalValue = value;
  }
  public resetAsPath() {
    this._asPath.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asPathInput() {
    return this._asPath.internalValue;
  }

  // community - computed: false, optional: true, required: false
  private _community = new LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunityOutputReference(this, "community");
  public get community() {
    return this._community;
  }
  public putCommunity(value: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunity) {
    this._community.internalValue = value;
  }
  public resetCommunity() {
    this._community.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get communityInput() {
    return this._community.internalValue;
  }

  // extended_community - computed: false, optional: true, required: false
  private _extendedCommunity = new LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunityOutputReference(this, "extended_community");
  public get extendedCommunity() {
    return this._extendedCommunity;
  }
  public putExtendedCommunity(value: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunity) {
    this._extendedCommunity.internalValue = value;
  }
  public resetExtendedCommunity() {
    this._extendedCommunity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extendedCommunityInput() {
    return this._extendedCommunity.internalValue;
  }

  // from_peer - computed: false, optional: true, required: false
  private _fromPeer?: string[]; 
  public get fromPeer() {
    return this.getListAttribute('from_peer');
  }
  public set fromPeer(value: string[]) {
    this._fromPeer = value;
  }
  public resetFromPeer() {
    this._fromPeer = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fromPeerInput() {
    return this._fromPeer;
  }

  // med - computed: false, optional: true, required: false
  private _med?: number; 
  public get med() {
    return this.getNumberAttribute('med');
  }
  public set med(value: number) {
    this._med = value;
  }
  public resetMed() {
    this._med = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get medInput() {
    return this._med;
  }

  // nexthop - computed: false, optional: true, required: false
  private _nexthop?: string[]; 
  public get nexthop() {
    return this.getListAttribute('nexthop');
  }
  public set nexthop(value: string[]) {
    this._nexthop = value;
  }
  public resetNexthop() {
    this._nexthop = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nexthopInput() {
    return this._nexthop;
  }

  // route_table - computed: false, optional: true, required: false
  private _routeTable?: string; 
  public get routeTable() {
    return this.getStringAttribute('route_table');
  }
  public set routeTable(value: string) {
    this._routeTable = value;
  }
  public resetRouteTable() {
    this._routeTable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeTableInput() {
    return this._routeTable;
  }

  // safi - computed: false, optional: true, required: false
  private _safi?: string; 
  public get safi() {
    return this.getStringAttribute('safi');
  }
  public set safi(value: string) {
    this._safi = value;
  }
  public resetSafi() {
    this._safi = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safiInput() {
    return this._safi;
  }
}
export interface LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilters {
  /**
  * Enable
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#enable LogicalRouter#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * Match
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#match LogicalRouter#match}
  */
  readonly match?: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatch;
  /**
  * Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#name LogicalRouter#name}
  */
  readonly name: string;
}

export function logicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersToTerraform(struct?: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enable: cdktf.booleanToTerraform(struct!.enable),
    match: logicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchToTerraform(struct!.match),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function logicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersToHclTerraform(struct?: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    match: {
      value: logicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchToHclTerraform(struct!.match),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatch",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._match?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enable = undefined;
      this._match.internalValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enable = value.enable;
      this._match.internalValue = value.match;
      this._name = value.name;
    }
  }

  // enable - computed: false, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // match - computed: false, optional: true, required: false
  private _match = new LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchOutputReference(this, "match");
  public get match() {
    return this._match;
  }
  public putMatch(value: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatch) {
    this._match.internalValue = value;
  }
  public resetMatch() {
    this._match.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match.internalValue;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersList extends cdktf.ComplexList {
  public internalValue? : LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilters[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersOutputReference {
    return new LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicy {
  /**
  * Advertise filters
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#advertise_filters LogicalRouter#advertise_filters}
  */
  readonly advertiseFilters?: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilters[] | cdktf.IResolvable;
  /**
  * Enable
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#enable LogicalRouter#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#name LogicalRouter#name}
  */
  readonly name: string;
  /**
  * Non exist filters
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#non_exist_filters LogicalRouter#non_exist_filters}
  */
  readonly nonExistFilters?: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilters[] | cdktf.IResolvable;
  /**
  * Used by
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#used_by LogicalRouter#used_by}
  */
  readonly usedBy?: string[];
}

export function logicalRouterVrfBgpPolicyConditionalAdvertisementPolicyToTerraform(struct?: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicy | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    advertise_filters: cdktf.listMapper(logicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersToTerraform, false)(struct!.advertiseFilters),
    enable: cdktf.booleanToTerraform(struct!.enable),
    name: cdktf.stringToTerraform(struct!.name),
    non_exist_filters: cdktf.listMapper(logicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersToTerraform, false)(struct!.nonExistFilters),
    used_by: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.usedBy),
  }
}


export function logicalRouterVrfBgpPolicyConditionalAdvertisementPolicyToHclTerraform(struct?: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicy | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    advertise_filters: {
      value: cdktf.listMapperHcl(logicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersToHclTerraform, false)(struct!.advertiseFilters),
      isBlock: true,
      type: "list",
      storageClassType: "LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersList",
    },
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    non_exist_filters: {
      value: cdktf.listMapperHcl(logicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersToHclTerraform, false)(struct!.nonExistFilters),
      isBlock: true,
      type: "list",
      storageClassType: "LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersList",
    },
    used_by: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.usedBy),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicy | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._advertiseFilters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.advertiseFilters = this._advertiseFilters?.internalValue;
    }
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._nonExistFilters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nonExistFilters = this._nonExistFilters?.internalValue;
    }
    if (this._usedBy !== undefined) {
      hasAnyValues = true;
      internalValueResult.usedBy = this._usedBy;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicy | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._advertiseFilters.internalValue = undefined;
      this._enable = undefined;
      this._name = undefined;
      this._nonExistFilters.internalValue = undefined;
      this._usedBy = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._advertiseFilters.internalValue = value.advertiseFilters;
      this._enable = value.enable;
      this._name = value.name;
      this._nonExistFilters.internalValue = value.nonExistFilters;
      this._usedBy = value.usedBy;
    }
  }

  // advertise_filters - computed: false, optional: true, required: false
  private _advertiseFilters = new LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersList(this, "advertise_filters", false);
  public get advertiseFilters() {
    return this._advertiseFilters;
  }
  public putAdvertiseFilters(value: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyAdvertiseFilters[] | cdktf.IResolvable) {
    this._advertiseFilters.internalValue = value;
  }
  public resetAdvertiseFilters() {
    this._advertiseFilters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get advertiseFiltersInput() {
    return this._advertiseFilters.internalValue;
  }

  // enable - computed: false, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // non_exist_filters - computed: false, optional: true, required: false
  private _nonExistFilters = new LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFiltersList(this, "non_exist_filters", false);
  public get nonExistFilters() {
    return this._nonExistFilters;
  }
  public putNonExistFilters(value: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyNonExistFilters[] | cdktf.IResolvable) {
    this._nonExistFilters.internalValue = value;
  }
  public resetNonExistFilters() {
    this._nonExistFilters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nonExistFiltersInput() {
    return this._nonExistFilters.internalValue;
  }

  // used_by - computed: false, optional: true, required: false
  private _usedBy?: string[]; 
  public get usedBy() {
    return this.getListAttribute('used_by');
  }
  public set usedBy(value: string[]) {
    this._usedBy = value;
  }
  public resetUsedBy() {
    this._usedBy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usedByInput() {
    return this._usedBy;
  }
}

export class LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyList extends cdktf.ComplexList {
  public internalValue? : LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicy[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyOutputReference {
    return new LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface LogicalRouterVrfBgpPolicyConditionalAdvertisement {
  /**
  * Policy
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#policy LogicalRouter#policy}
  */
  readonly policy?: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicy[] | cdktf.IResolvable;
}

export function logicalRouterVrfBgpPolicyConditionalAdvertisementToTerraform(struct?: LogicalRouterVrfBgpPolicyConditionalAdvertisement | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    policy: cdktf.listMapper(logicalRouterVrfBgpPolicyConditionalAdvertisementPolicyToTerraform, false)(struct!.policy),
  }
}


export function logicalRouterVrfBgpPolicyConditionalAdvertisementToHclTerraform(struct?: LogicalRouterVrfBgpPolicyConditionalAdvertisement | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    policy: {
      value: cdktf.listMapperHcl(logicalRouterVrfBgpPolicyConditionalAdvertisementPolicyToHclTerraform, false)(struct!.policy),
      isBlock: true,
      type: "list",
      storageClassType: "LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyConditionalAdvertisementOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyConditionalAdvertisement | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._policy?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.policy = this._policy?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyConditionalAdvertisement | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._policy.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._policy.internalValue = value.policy;
    }
  }

  // policy - computed: false, optional: true, required: false
  private _policy = new LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicyList(this, "policy", false);
  public get policy() {
    return this._policy;
  }
  public putPolicy(value: LogicalRouterVrfBgpPolicyConditionalAdvertisementPolicy[] | cdktf.IResolvable) {
    this._policy.internalValue = value;
  }
  public resetPolicy() {
    this._policy.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get policyInput() {
    return this._policy.internalValue;
  }
}
export interface LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateAsPathNone {
}

export function logicalRouterVrfBgpPolicyExportRulesActionAllowUpdateAsPathNoneToTerraform(struct?: LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateAsPathNone | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function logicalRouterVrfBgpPolicyExportRulesActionAllowUpdateAsPathNoneToHclTerraform(struct?: LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateAsPathNone | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateAsPathNoneOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateAsPathNone | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateAsPathNone | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateAsPathRemove {
}

export function logicalRouterVrfBgpPolicyExportRulesActionAllowUpdateAsPathRemoveToTerraform(struct?: LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateAsPathRemove | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function logicalRouterVrfBgpPolicyExportRulesActionAllowUpdateAsPathRemoveToHclTerraform(struct?: LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateAsPathRemove | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateAsPathRemoveOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateAsPathRemove | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateAsPathRemove | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateAsPath {
  /**
  * None
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#none LogicalRouter#none}
  */
  readonly none?: LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateAsPathNone;
  /**
  * Prepend
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#prepend LogicalRouter#prepend}
  */
  readonly prepend?: number;
  /**
  * Remove
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#remove LogicalRouter#remove}
  */
  readonly remove?: LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateAsPathRemove;
  /**
  * Remove and prepend
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#remove_and_prepend LogicalRouter#remove_and_prepend}
  */
  readonly removeAndPrepend?: number;
}

export function logicalRouterVrfBgpPolicyExportRulesActionAllowUpdateAsPathToTerraform(struct?: LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateAsPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    none: logicalRouterVrfBgpPolicyExportRulesActionAllowUpdateAsPathNoneToTerraform(struct!.none),
    prepend: cdktf.numberToTerraform(struct!.prepend),
    remove: logicalRouterVrfBgpPolicyExportRulesActionAllowUpdateAsPathRemoveToTerraform(struct!.remove),
    remove_and_prepend: cdktf.numberToTerraform(struct!.removeAndPrepend),
  }
}


export function logicalRouterVrfBgpPolicyExportRulesActionAllowUpdateAsPathToHclTerraform(struct?: LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateAsPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    none: {
      value: logicalRouterVrfBgpPolicyExportRulesActionAllowUpdateAsPathNoneToHclTerraform(struct!.none),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateAsPathNone",
    },
    prepend: {
      value: cdktf.numberToHclTerraform(struct!.prepend),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    remove: {
      value: logicalRouterVrfBgpPolicyExportRulesActionAllowUpdateAsPathRemoveToHclTerraform(struct!.remove),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateAsPathRemove",
    },
    remove_and_prepend: {
      value: cdktf.numberToHclTerraform(struct!.removeAndPrepend),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateAsPathOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateAsPath | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._none?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.none = this._none?.internalValue;
    }
    if (this._prepend !== undefined) {
      hasAnyValues = true;
      internalValueResult.prepend = this._prepend;
    }
    if (this._remove?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.remove = this._remove?.internalValue;
    }
    if (this._removeAndPrepend !== undefined) {
      hasAnyValues = true;
      internalValueResult.removeAndPrepend = this._removeAndPrepend;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateAsPath | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._none.internalValue = undefined;
      this._prepend = undefined;
      this._remove.internalValue = undefined;
      this._removeAndPrepend = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._none.internalValue = value.none;
      this._prepend = value.prepend;
      this._remove.internalValue = value.remove;
      this._removeAndPrepend = value.removeAndPrepend;
    }
  }

  // none - computed: false, optional: true, required: false
  private _none = new LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateAsPathNoneOutputReference(this, "none");
  public get none() {
    return this._none;
  }
  public putNone(value: LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateAsPathNone) {
    this._none.internalValue = value;
  }
  public resetNone() {
    this._none.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get noneInput() {
    return this._none.internalValue;
  }

  // prepend - computed: false, optional: true, required: false
  private _prepend?: number; 
  public get prepend() {
    return this.getNumberAttribute('prepend');
  }
  public set prepend(value: number) {
    this._prepend = value;
  }
  public resetPrepend() {
    this._prepend = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prependInput() {
    return this._prepend;
  }

  // remove - computed: false, optional: true, required: false
  private _remove = new LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateAsPathRemoveOutputReference(this, "remove");
  public get remove() {
    return this._remove;
  }
  public putRemove(value: LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateAsPathRemove) {
    this._remove.internalValue = value;
  }
  public resetRemove() {
    this._remove.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeInput() {
    return this._remove.internalValue;
  }

  // remove_and_prepend - computed: false, optional: true, required: false
  private _removeAndPrepend?: number; 
  public get removeAndPrepend() {
    return this.getNumberAttribute('remove_and_prepend');
  }
  public set removeAndPrepend(value: number) {
    this._removeAndPrepend = value;
  }
  public resetRemoveAndPrepend() {
    this._removeAndPrepend = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeAndPrependInput() {
    return this._removeAndPrepend;
  }
}
export interface LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateCommunityNone {
}

export function logicalRouterVrfBgpPolicyExportRulesActionAllowUpdateCommunityNoneToTerraform(struct?: LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateCommunityNone | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function logicalRouterVrfBgpPolicyExportRulesActionAllowUpdateCommunityNoneToHclTerraform(struct?: LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateCommunityNone | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateCommunityNoneOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateCommunityNone | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateCommunityNone | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAll {
}

export function logicalRouterVrfBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllToTerraform(struct?: LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAll | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function logicalRouterVrfBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllToHclTerraform(struct?: LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAll | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAll | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAll | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateCommunity {
  /**
  * Append
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#append LogicalRouter#append}
  */
  readonly append?: string[];
  /**
  * None
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#none LogicalRouter#none}
  */
  readonly none?: LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateCommunityNone;
  /**
  * Overwrite
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#overwrite LogicalRouter#overwrite}
  */
  readonly overwrite?: string[];
  /**
  * Remove all
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#remove_all LogicalRouter#remove_all}
  */
  readonly removeAll?: LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAll;
  /**
  * Remove regex
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#remove_regex LogicalRouter#remove_regex}
  */
  readonly removeRegex?: string;
}

export function logicalRouterVrfBgpPolicyExportRulesActionAllowUpdateCommunityToTerraform(struct?: LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    append: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.append),
    none: logicalRouterVrfBgpPolicyExportRulesActionAllowUpdateCommunityNoneToTerraform(struct!.none),
    overwrite: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.overwrite),
    remove_all: logicalRouterVrfBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllToTerraform(struct!.removeAll),
    remove_regex: cdktf.stringToTerraform(struct!.removeRegex),
  }
}


export function logicalRouterVrfBgpPolicyExportRulesActionAllowUpdateCommunityToHclTerraform(struct?: LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    append: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.append),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    none: {
      value: logicalRouterVrfBgpPolicyExportRulesActionAllowUpdateCommunityNoneToHclTerraform(struct!.none),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateCommunityNone",
    },
    overwrite: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.overwrite),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    remove_all: {
      value: logicalRouterVrfBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllToHclTerraform(struct!.removeAll),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAll",
    },
    remove_regex: {
      value: cdktf.stringToHclTerraform(struct!.removeRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateCommunityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateCommunity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._append !== undefined) {
      hasAnyValues = true;
      internalValueResult.append = this._append;
    }
    if (this._none?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.none = this._none?.internalValue;
    }
    if (this._overwrite !== undefined) {
      hasAnyValues = true;
      internalValueResult.overwrite = this._overwrite;
    }
    if (this._removeAll?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.removeAll = this._removeAll?.internalValue;
    }
    if (this._removeRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.removeRegex = this._removeRegex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateCommunity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._append = undefined;
      this._none.internalValue = undefined;
      this._overwrite = undefined;
      this._removeAll.internalValue = undefined;
      this._removeRegex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._append = value.append;
      this._none.internalValue = value.none;
      this._overwrite = value.overwrite;
      this._removeAll.internalValue = value.removeAll;
      this._removeRegex = value.removeRegex;
    }
  }

  // append - computed: false, optional: true, required: false
  private _append?: string[]; 
  public get append() {
    return this.getListAttribute('append');
  }
  public set append(value: string[]) {
    this._append = value;
  }
  public resetAppend() {
    this._append = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appendInput() {
    return this._append;
  }

  // none - computed: false, optional: true, required: false
  private _none = new LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateCommunityNoneOutputReference(this, "none");
  public get none() {
    return this._none;
  }
  public putNone(value: LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateCommunityNone) {
    this._none.internalValue = value;
  }
  public resetNone() {
    this._none.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get noneInput() {
    return this._none.internalValue;
  }

  // overwrite - computed: false, optional: true, required: false
  private _overwrite?: string[]; 
  public get overwrite() {
    return this.getListAttribute('overwrite');
  }
  public set overwrite(value: string[]) {
    this._overwrite = value;
  }
  public resetOverwrite() {
    this._overwrite = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overwriteInput() {
    return this._overwrite;
  }

  // remove_all - computed: false, optional: true, required: false
  private _removeAll = new LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllOutputReference(this, "remove_all");
  public get removeAll() {
    return this._removeAll;
  }
  public putRemoveAll(value: LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAll) {
    this._removeAll.internalValue = value;
  }
  public resetRemoveAll() {
    this._removeAll.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeAllInput() {
    return this._removeAll.internalValue;
  }

  // remove_regex - computed: false, optional: true, required: false
  private _removeRegex?: string; 
  public get removeRegex() {
    return this.getStringAttribute('remove_regex');
  }
  public set removeRegex(value: string) {
    this._removeRegex = value;
  }
  public resetRemoveRegex() {
    this._removeRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeRegexInput() {
    return this._removeRegex;
  }
}
export interface LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNone {
}

export function logicalRouterVrfBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneToTerraform(struct?: LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNone | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function logicalRouterVrfBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneToHclTerraform(struct?: LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNone | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNone | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNone | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAll {
}

export function logicalRouterVrfBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllToTerraform(struct?: LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAll | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function logicalRouterVrfBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllToHclTerraform(struct?: LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAll | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAll | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAll | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateExtendedCommunity {
  /**
  * Append
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#append LogicalRouter#append}
  */
  readonly append?: string[];
  /**
  * None
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#none LogicalRouter#none}
  */
  readonly none?: LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNone;
  /**
  * Overwrite
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#overwrite LogicalRouter#overwrite}
  */
  readonly overwrite?: string[];
  /**
  * Remove all
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#remove_all LogicalRouter#remove_all}
  */
  readonly removeAll?: LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAll;
  /**
  * Remove regex
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#remove_regex LogicalRouter#remove_regex}
  */
  readonly removeRegex?: string;
}

export function logicalRouterVrfBgpPolicyExportRulesActionAllowUpdateExtendedCommunityToTerraform(struct?: LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateExtendedCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    append: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.append),
    none: logicalRouterVrfBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneToTerraform(struct!.none),
    overwrite: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.overwrite),
    remove_all: logicalRouterVrfBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllToTerraform(struct!.removeAll),
    remove_regex: cdktf.stringToTerraform(struct!.removeRegex),
  }
}


export function logicalRouterVrfBgpPolicyExportRulesActionAllowUpdateExtendedCommunityToHclTerraform(struct?: LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateExtendedCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    append: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.append),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    none: {
      value: logicalRouterVrfBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneToHclTerraform(struct!.none),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNone",
    },
    overwrite: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.overwrite),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    remove_all: {
      value: logicalRouterVrfBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllToHclTerraform(struct!.removeAll),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAll",
    },
    remove_regex: {
      value: cdktf.stringToHclTerraform(struct!.removeRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateExtendedCommunityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateExtendedCommunity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._append !== undefined) {
      hasAnyValues = true;
      internalValueResult.append = this._append;
    }
    if (this._none?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.none = this._none?.internalValue;
    }
    if (this._overwrite !== undefined) {
      hasAnyValues = true;
      internalValueResult.overwrite = this._overwrite;
    }
    if (this._removeAll?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.removeAll = this._removeAll?.internalValue;
    }
    if (this._removeRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.removeRegex = this._removeRegex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateExtendedCommunity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._append = undefined;
      this._none.internalValue = undefined;
      this._overwrite = undefined;
      this._removeAll.internalValue = undefined;
      this._removeRegex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._append = value.append;
      this._none.internalValue = value.none;
      this._overwrite = value.overwrite;
      this._removeAll.internalValue = value.removeAll;
      this._removeRegex = value.removeRegex;
    }
  }

  // append - computed: false, optional: true, required: false
  private _append?: string[]; 
  public get append() {
    return this.getListAttribute('append');
  }
  public set append(value: string[]) {
    this._append = value;
  }
  public resetAppend() {
    this._append = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appendInput() {
    return this._append;
  }

  // none - computed: false, optional: true, required: false
  private _none = new LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneOutputReference(this, "none");
  public get none() {
    return this._none;
  }
  public putNone(value: LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNone) {
    this._none.internalValue = value;
  }
  public resetNone() {
    this._none.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get noneInput() {
    return this._none.internalValue;
  }

  // overwrite - computed: false, optional: true, required: false
  private _overwrite?: string[]; 
  public get overwrite() {
    return this.getListAttribute('overwrite');
  }
  public set overwrite(value: string[]) {
    this._overwrite = value;
  }
  public resetOverwrite() {
    this._overwrite = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overwriteInput() {
    return this._overwrite;
  }

  // remove_all - computed: false, optional: true, required: false
  private _removeAll = new LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllOutputReference(this, "remove_all");
  public get removeAll() {
    return this._removeAll;
  }
  public putRemoveAll(value: LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAll) {
    this._removeAll.internalValue = value;
  }
  public resetRemoveAll() {
    this._removeAll.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeAllInput() {
    return this._removeAll.internalValue;
  }

  // remove_regex - computed: false, optional: true, required: false
  private _removeRegex?: string; 
  public get removeRegex() {
    return this.getStringAttribute('remove_regex');
  }
  public set removeRegex(value: string) {
    this._removeRegex = value;
  }
  public resetRemoveRegex() {
    this._removeRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeRegexInput() {
    return this._removeRegex;
  }
}
export interface LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdate {
  /**
  * As path
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#as_path LogicalRouter#as_path}
  */
  readonly asPath?: LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateAsPath;
  /**
  * As path limit
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#as_path_limit LogicalRouter#as_path_limit}
  */
  readonly asPathLimit?: number;
  /**
  * Community
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#community LogicalRouter#community}
  */
  readonly community?: LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateCommunity;
  /**
  * Extended community
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#extended_community LogicalRouter#extended_community}
  */
  readonly extendedCommunity?: LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateExtendedCommunity;
  /**
  * Local preference
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#local_preference LogicalRouter#local_preference}
  */
  readonly localPreference?: number;
  /**
  * Med
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#med LogicalRouter#med}
  */
  readonly med?: number;
  /**
  * Nexthop
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#nexthop LogicalRouter#nexthop}
  */
  readonly nexthop?: string;
  /**
  * Origin
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#origin LogicalRouter#origin}
  */
  readonly origin?: string;
}

export function logicalRouterVrfBgpPolicyExportRulesActionAllowUpdateToTerraform(struct?: LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    as_path: logicalRouterVrfBgpPolicyExportRulesActionAllowUpdateAsPathToTerraform(struct!.asPath),
    as_path_limit: cdktf.numberToTerraform(struct!.asPathLimit),
    community: logicalRouterVrfBgpPolicyExportRulesActionAllowUpdateCommunityToTerraform(struct!.community),
    extended_community: logicalRouterVrfBgpPolicyExportRulesActionAllowUpdateExtendedCommunityToTerraform(struct!.extendedCommunity),
    local_preference: cdktf.numberToTerraform(struct!.localPreference),
    med: cdktf.numberToTerraform(struct!.med),
    nexthop: cdktf.stringToTerraform(struct!.nexthop),
    origin: cdktf.stringToTerraform(struct!.origin),
  }
}


export function logicalRouterVrfBgpPolicyExportRulesActionAllowUpdateToHclTerraform(struct?: LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    as_path: {
      value: logicalRouterVrfBgpPolicyExportRulesActionAllowUpdateAsPathToHclTerraform(struct!.asPath),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateAsPath",
    },
    as_path_limit: {
      value: cdktf.numberToHclTerraform(struct!.asPathLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    community: {
      value: logicalRouterVrfBgpPolicyExportRulesActionAllowUpdateCommunityToHclTerraform(struct!.community),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateCommunity",
    },
    extended_community: {
      value: logicalRouterVrfBgpPolicyExportRulesActionAllowUpdateExtendedCommunityToHclTerraform(struct!.extendedCommunity),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateExtendedCommunity",
    },
    local_preference: {
      value: cdktf.numberToHclTerraform(struct!.localPreference),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    med: {
      value: cdktf.numberToHclTerraform(struct!.med),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    nexthop: {
      value: cdktf.stringToHclTerraform(struct!.nexthop),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    origin: {
      value: cdktf.stringToHclTerraform(struct!.origin),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdate | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._asPath?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.asPath = this._asPath?.internalValue;
    }
    if (this._asPathLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.asPathLimit = this._asPathLimit;
    }
    if (this._community?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.community = this._community?.internalValue;
    }
    if (this._extendedCommunity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extendedCommunity = this._extendedCommunity?.internalValue;
    }
    if (this._localPreference !== undefined) {
      hasAnyValues = true;
      internalValueResult.localPreference = this._localPreference;
    }
    if (this._med !== undefined) {
      hasAnyValues = true;
      internalValueResult.med = this._med;
    }
    if (this._nexthop !== undefined) {
      hasAnyValues = true;
      internalValueResult.nexthop = this._nexthop;
    }
    if (this._origin !== undefined) {
      hasAnyValues = true;
      internalValueResult.origin = this._origin;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdate | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._asPath.internalValue = undefined;
      this._asPathLimit = undefined;
      this._community.internalValue = undefined;
      this._extendedCommunity.internalValue = undefined;
      this._localPreference = undefined;
      this._med = undefined;
      this._nexthop = undefined;
      this._origin = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._asPath.internalValue = value.asPath;
      this._asPathLimit = value.asPathLimit;
      this._community.internalValue = value.community;
      this._extendedCommunity.internalValue = value.extendedCommunity;
      this._localPreference = value.localPreference;
      this._med = value.med;
      this._nexthop = value.nexthop;
      this._origin = value.origin;
    }
  }

  // as_path - computed: false, optional: true, required: false
  private _asPath = new LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateAsPathOutputReference(this, "as_path");
  public get asPath() {
    return this._asPath;
  }
  public putAsPath(value: LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateAsPath) {
    this._asPath.internalValue = value;
  }
  public resetAsPath() {
    this._asPath.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asPathInput() {
    return this._asPath.internalValue;
  }

  // as_path_limit - computed: false, optional: true, required: false
  private _asPathLimit?: number; 
  public get asPathLimit() {
    return this.getNumberAttribute('as_path_limit');
  }
  public set asPathLimit(value: number) {
    this._asPathLimit = value;
  }
  public resetAsPathLimit() {
    this._asPathLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asPathLimitInput() {
    return this._asPathLimit;
  }

  // community - computed: false, optional: true, required: false
  private _community = new LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateCommunityOutputReference(this, "community");
  public get community() {
    return this._community;
  }
  public putCommunity(value: LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateCommunity) {
    this._community.internalValue = value;
  }
  public resetCommunity() {
    this._community.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get communityInput() {
    return this._community.internalValue;
  }

  // extended_community - computed: false, optional: true, required: false
  private _extendedCommunity = new LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateExtendedCommunityOutputReference(this, "extended_community");
  public get extendedCommunity() {
    return this._extendedCommunity;
  }
  public putExtendedCommunity(value: LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateExtendedCommunity) {
    this._extendedCommunity.internalValue = value;
  }
  public resetExtendedCommunity() {
    this._extendedCommunity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extendedCommunityInput() {
    return this._extendedCommunity.internalValue;
  }

  // local_preference - computed: false, optional: true, required: false
  private _localPreference?: number; 
  public get localPreference() {
    return this.getNumberAttribute('local_preference');
  }
  public set localPreference(value: number) {
    this._localPreference = value;
  }
  public resetLocalPreference() {
    this._localPreference = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localPreferenceInput() {
    return this._localPreference;
  }

  // med - computed: false, optional: true, required: false
  private _med?: number; 
  public get med() {
    return this.getNumberAttribute('med');
  }
  public set med(value: number) {
    this._med = value;
  }
  public resetMed() {
    this._med = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get medInput() {
    return this._med;
  }

  // nexthop - computed: false, optional: true, required: false
  private _nexthop?: string; 
  public get nexthop() {
    return this.getStringAttribute('nexthop');
  }
  public set nexthop(value: string) {
    this._nexthop = value;
  }
  public resetNexthop() {
    this._nexthop = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nexthopInput() {
    return this._nexthop;
  }

  // origin - computed: false, optional: true, required: false
  private _origin?: string; 
  public get origin() {
    return this.getStringAttribute('origin');
  }
  public set origin(value: string) {
    this._origin = value;
  }
  public resetOrigin() {
    this._origin = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get originInput() {
    return this._origin;
  }
}
export interface LogicalRouterVrfBgpPolicyExportRulesActionAllow {
  /**
  * Update
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#update LogicalRouter#update}
  */
  readonly update?: LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdate;
}

export function logicalRouterVrfBgpPolicyExportRulesActionAllowToTerraform(struct?: LogicalRouterVrfBgpPolicyExportRulesActionAllow | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    update: logicalRouterVrfBgpPolicyExportRulesActionAllowUpdateToTerraform(struct!.update),
  }
}


export function logicalRouterVrfBgpPolicyExportRulesActionAllowToHclTerraform(struct?: LogicalRouterVrfBgpPolicyExportRulesActionAllow | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    update: {
      value: logicalRouterVrfBgpPolicyExportRulesActionAllowUpdateToHclTerraform(struct!.update),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdate",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyExportRulesActionAllowOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyExportRulesActionAllow | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._update?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.update = this._update?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyExportRulesActionAllow | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._update.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._update.internalValue = value.update;
    }
  }

  // update - computed: false, optional: true, required: false
  private _update = new LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdateOutputReference(this, "update");
  public get update() {
    return this._update;
  }
  public putUpdate(value: LogicalRouterVrfBgpPolicyExportRulesActionAllowUpdate) {
    this._update.internalValue = value;
  }
  public resetUpdate() {
    this._update.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get updateInput() {
    return this._update.internalValue;
  }
}
export interface LogicalRouterVrfBgpPolicyExportRulesActionDeny {
}

export function logicalRouterVrfBgpPolicyExportRulesActionDenyToTerraform(struct?: LogicalRouterVrfBgpPolicyExportRulesActionDeny | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function logicalRouterVrfBgpPolicyExportRulesActionDenyToHclTerraform(struct?: LogicalRouterVrfBgpPolicyExportRulesActionDeny | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class LogicalRouterVrfBgpPolicyExportRulesActionDenyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyExportRulesActionDeny | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyExportRulesActionDeny | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface LogicalRouterVrfBgpPolicyExportRulesAction {
  /**
  * Allow
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#allow LogicalRouter#allow}
  */
  readonly allow?: LogicalRouterVrfBgpPolicyExportRulesActionAllow;
  /**
  * Deny
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#deny LogicalRouter#deny}
  */
  readonly deny?: LogicalRouterVrfBgpPolicyExportRulesActionDeny;
}

export function logicalRouterVrfBgpPolicyExportRulesActionToTerraform(struct?: LogicalRouterVrfBgpPolicyExportRulesAction | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow: logicalRouterVrfBgpPolicyExportRulesActionAllowToTerraform(struct!.allow),
    deny: logicalRouterVrfBgpPolicyExportRulesActionDenyToTerraform(struct!.deny),
  }
}


export function logicalRouterVrfBgpPolicyExportRulesActionToHclTerraform(struct?: LogicalRouterVrfBgpPolicyExportRulesAction | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow: {
      value: logicalRouterVrfBgpPolicyExportRulesActionAllowToHclTerraform(struct!.allow),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyExportRulesActionAllow",
    },
    deny: {
      value: logicalRouterVrfBgpPolicyExportRulesActionDenyToHclTerraform(struct!.deny),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyExportRulesActionDeny",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyExportRulesActionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyExportRulesAction | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allow?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.allow = this._allow?.internalValue;
    }
    if (this._deny?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.deny = this._deny?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyExportRulesAction | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allow.internalValue = undefined;
      this._deny.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allow.internalValue = value.allow;
      this._deny.internalValue = value.deny;
    }
  }

  // allow - computed: false, optional: true, required: false
  private _allow = new LogicalRouterVrfBgpPolicyExportRulesActionAllowOutputReference(this, "allow");
  public get allow() {
    return this._allow;
  }
  public putAllow(value: LogicalRouterVrfBgpPolicyExportRulesActionAllow) {
    this._allow.internalValue = value;
  }
  public resetAllow() {
    this._allow.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowInput() {
    return this._allow.internalValue;
  }

  // deny - computed: false, optional: true, required: false
  private _deny = new LogicalRouterVrfBgpPolicyExportRulesActionDenyOutputReference(this, "deny");
  public get deny() {
    return this._deny;
  }
  public putDeny(value: LogicalRouterVrfBgpPolicyExportRulesActionDeny) {
    this._deny.internalValue = value;
  }
  public resetDeny() {
    this._deny.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get denyInput() {
    return this._deny.internalValue;
  }
}
export interface LogicalRouterVrfBgpPolicyExportRulesMatchAddressPrefix {
  /**
  * Exact
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#exact LogicalRouter#exact}
  */
  readonly exact?: boolean | cdktf.IResolvable;
  /**
  * Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#name LogicalRouter#name}
  */
  readonly name?: string;
}

export function logicalRouterVrfBgpPolicyExportRulesMatchAddressPrefixToTerraform(struct?: LogicalRouterVrfBgpPolicyExportRulesMatchAddressPrefix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    exact: cdktf.booleanToTerraform(struct!.exact),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function logicalRouterVrfBgpPolicyExportRulesMatchAddressPrefixToHclTerraform(struct?: LogicalRouterVrfBgpPolicyExportRulesMatchAddressPrefix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    exact: {
      value: cdktf.booleanToHclTerraform(struct!.exact),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyExportRulesMatchAddressPrefixOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyExportRulesMatchAddressPrefix | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._exact !== undefined) {
      hasAnyValues = true;
      internalValueResult.exact = this._exact;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyExportRulesMatchAddressPrefix | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._exact = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._exact = value.exact;
      this._name = value.name;
    }
  }

  // exact - computed: false, optional: true, required: false
  private _exact?: boolean | cdktf.IResolvable; 
  public get exact() {
    return this.getBooleanAttribute('exact');
  }
  public set exact(value: boolean | cdktf.IResolvable) {
    this._exact = value;
  }
  public resetExact() {
    this._exact = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exactInput() {
    return this._exact;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class LogicalRouterVrfBgpPolicyExportRulesMatchAddressPrefixList extends cdktf.ComplexList {
  public internalValue? : LogicalRouterVrfBgpPolicyExportRulesMatchAddressPrefix[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): LogicalRouterVrfBgpPolicyExportRulesMatchAddressPrefixOutputReference {
    return new LogicalRouterVrfBgpPolicyExportRulesMatchAddressPrefixOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface LogicalRouterVrfBgpPolicyExportRulesMatchAsPath {
  /**
  * Regex
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#regex LogicalRouter#regex}
  */
  readonly regex?: string;
}

export function logicalRouterVrfBgpPolicyExportRulesMatchAsPathToTerraform(struct?: LogicalRouterVrfBgpPolicyExportRulesMatchAsPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function logicalRouterVrfBgpPolicyExportRulesMatchAsPathToHclTerraform(struct?: LogicalRouterVrfBgpPolicyExportRulesMatchAsPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyExportRulesMatchAsPathOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyExportRulesMatchAsPath | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyExportRulesMatchAsPath | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._regex = value.regex;
    }
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface LogicalRouterVrfBgpPolicyExportRulesMatchCommunity {
  /**
  * Regex
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#regex LogicalRouter#regex}
  */
  readonly regex?: string;
}

export function logicalRouterVrfBgpPolicyExportRulesMatchCommunityToTerraform(struct?: LogicalRouterVrfBgpPolicyExportRulesMatchCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function logicalRouterVrfBgpPolicyExportRulesMatchCommunityToHclTerraform(struct?: LogicalRouterVrfBgpPolicyExportRulesMatchCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyExportRulesMatchCommunityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyExportRulesMatchCommunity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyExportRulesMatchCommunity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._regex = value.regex;
    }
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface LogicalRouterVrfBgpPolicyExportRulesMatchExtendedCommunity {
  /**
  * Regex
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#regex LogicalRouter#regex}
  */
  readonly regex?: string;
}

export function logicalRouterVrfBgpPolicyExportRulesMatchExtendedCommunityToTerraform(struct?: LogicalRouterVrfBgpPolicyExportRulesMatchExtendedCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function logicalRouterVrfBgpPolicyExportRulesMatchExtendedCommunityToHclTerraform(struct?: LogicalRouterVrfBgpPolicyExportRulesMatchExtendedCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyExportRulesMatchExtendedCommunityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyExportRulesMatchExtendedCommunity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyExportRulesMatchExtendedCommunity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._regex = value.regex;
    }
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface LogicalRouterVrfBgpPolicyExportRulesMatch {
  /**
  * Address prefix
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#address_prefix LogicalRouter#address_prefix}
  */
  readonly addressPrefix?: LogicalRouterVrfBgpPolicyExportRulesMatchAddressPrefix[] | cdktf.IResolvable;
  /**
  * Afi
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#afi LogicalRouter#afi}
  */
  readonly afi?: string;
  /**
  * As path
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#as_path LogicalRouter#as_path}
  */
  readonly asPath?: LogicalRouterVrfBgpPolicyExportRulesMatchAsPath;
  /**
  * Community
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#community LogicalRouter#community}
  */
  readonly community?: LogicalRouterVrfBgpPolicyExportRulesMatchCommunity;
  /**
  * Extended community
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#extended_community LogicalRouter#extended_community}
  */
  readonly extendedCommunity?: LogicalRouterVrfBgpPolicyExportRulesMatchExtendedCommunity;
  /**
  * From peer
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#from_peer LogicalRouter#from_peer}
  */
  readonly fromPeer?: string[];
  /**
  * Med
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#med LogicalRouter#med}
  */
  readonly med?: number;
  /**
  * Nexthop
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#nexthop LogicalRouter#nexthop}
  */
  readonly nexthop?: string[];
  /**
  * Route table
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#route_table LogicalRouter#route_table}
  */
  readonly routeTable?: string;
  /**
  * Safi
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#safi LogicalRouter#safi}
  */
  readonly safi?: string;
}

export function logicalRouterVrfBgpPolicyExportRulesMatchToTerraform(struct?: LogicalRouterVrfBgpPolicyExportRulesMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address_prefix: cdktf.listMapper(logicalRouterVrfBgpPolicyExportRulesMatchAddressPrefixToTerraform, false)(struct!.addressPrefix),
    afi: cdktf.stringToTerraform(struct!.afi),
    as_path: logicalRouterVrfBgpPolicyExportRulesMatchAsPathToTerraform(struct!.asPath),
    community: logicalRouterVrfBgpPolicyExportRulesMatchCommunityToTerraform(struct!.community),
    extended_community: logicalRouterVrfBgpPolicyExportRulesMatchExtendedCommunityToTerraform(struct!.extendedCommunity),
    from_peer: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.fromPeer),
    med: cdktf.numberToTerraform(struct!.med),
    nexthop: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.nexthop),
    route_table: cdktf.stringToTerraform(struct!.routeTable),
    safi: cdktf.stringToTerraform(struct!.safi),
  }
}


export function logicalRouterVrfBgpPolicyExportRulesMatchToHclTerraform(struct?: LogicalRouterVrfBgpPolicyExportRulesMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address_prefix: {
      value: cdktf.listMapperHcl(logicalRouterVrfBgpPolicyExportRulesMatchAddressPrefixToHclTerraform, false)(struct!.addressPrefix),
      isBlock: true,
      type: "list",
      storageClassType: "LogicalRouterVrfBgpPolicyExportRulesMatchAddressPrefixList",
    },
    afi: {
      value: cdktf.stringToHclTerraform(struct!.afi),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    as_path: {
      value: logicalRouterVrfBgpPolicyExportRulesMatchAsPathToHclTerraform(struct!.asPath),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyExportRulesMatchAsPath",
    },
    community: {
      value: logicalRouterVrfBgpPolicyExportRulesMatchCommunityToHclTerraform(struct!.community),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyExportRulesMatchCommunity",
    },
    extended_community: {
      value: logicalRouterVrfBgpPolicyExportRulesMatchExtendedCommunityToHclTerraform(struct!.extendedCommunity),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyExportRulesMatchExtendedCommunity",
    },
    from_peer: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.fromPeer),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    med: {
      value: cdktf.numberToHclTerraform(struct!.med),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    nexthop: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.nexthop),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    route_table: {
      value: cdktf.stringToHclTerraform(struct!.routeTable),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    safi: {
      value: cdktf.stringToHclTerraform(struct!.safi),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyExportRulesMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyExportRulesMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addressPrefix?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.addressPrefix = this._addressPrefix?.internalValue;
    }
    if (this._afi !== undefined) {
      hasAnyValues = true;
      internalValueResult.afi = this._afi;
    }
    if (this._asPath?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.asPath = this._asPath?.internalValue;
    }
    if (this._community?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.community = this._community?.internalValue;
    }
    if (this._extendedCommunity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extendedCommunity = this._extendedCommunity?.internalValue;
    }
    if (this._fromPeer !== undefined) {
      hasAnyValues = true;
      internalValueResult.fromPeer = this._fromPeer;
    }
    if (this._med !== undefined) {
      hasAnyValues = true;
      internalValueResult.med = this._med;
    }
    if (this._nexthop !== undefined) {
      hasAnyValues = true;
      internalValueResult.nexthop = this._nexthop;
    }
    if (this._routeTable !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeTable = this._routeTable;
    }
    if (this._safi !== undefined) {
      hasAnyValues = true;
      internalValueResult.safi = this._safi;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyExportRulesMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addressPrefix.internalValue = undefined;
      this._afi = undefined;
      this._asPath.internalValue = undefined;
      this._community.internalValue = undefined;
      this._extendedCommunity.internalValue = undefined;
      this._fromPeer = undefined;
      this._med = undefined;
      this._nexthop = undefined;
      this._routeTable = undefined;
      this._safi = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addressPrefix.internalValue = value.addressPrefix;
      this._afi = value.afi;
      this._asPath.internalValue = value.asPath;
      this._community.internalValue = value.community;
      this._extendedCommunity.internalValue = value.extendedCommunity;
      this._fromPeer = value.fromPeer;
      this._med = value.med;
      this._nexthop = value.nexthop;
      this._routeTable = value.routeTable;
      this._safi = value.safi;
    }
  }

  // address_prefix - computed: false, optional: true, required: false
  private _addressPrefix = new LogicalRouterVrfBgpPolicyExportRulesMatchAddressPrefixList(this, "address_prefix", false);
  public get addressPrefix() {
    return this._addressPrefix;
  }
  public putAddressPrefix(value: LogicalRouterVrfBgpPolicyExportRulesMatchAddressPrefix[] | cdktf.IResolvable) {
    this._addressPrefix.internalValue = value;
  }
  public resetAddressPrefix() {
    this._addressPrefix.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressPrefixInput() {
    return this._addressPrefix.internalValue;
  }

  // afi - computed: false, optional: true, required: false
  private _afi?: string; 
  public get afi() {
    return this.getStringAttribute('afi');
  }
  public set afi(value: string) {
    this._afi = value;
  }
  public resetAfi() {
    this._afi = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get afiInput() {
    return this._afi;
  }

  // as_path - computed: false, optional: true, required: false
  private _asPath = new LogicalRouterVrfBgpPolicyExportRulesMatchAsPathOutputReference(this, "as_path");
  public get asPath() {
    return this._asPath;
  }
  public putAsPath(value: LogicalRouterVrfBgpPolicyExportRulesMatchAsPath) {
    this._asPath.internalValue = value;
  }
  public resetAsPath() {
    this._asPath.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asPathInput() {
    return this._asPath.internalValue;
  }

  // community - computed: false, optional: true, required: false
  private _community = new LogicalRouterVrfBgpPolicyExportRulesMatchCommunityOutputReference(this, "community");
  public get community() {
    return this._community;
  }
  public putCommunity(value: LogicalRouterVrfBgpPolicyExportRulesMatchCommunity) {
    this._community.internalValue = value;
  }
  public resetCommunity() {
    this._community.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get communityInput() {
    return this._community.internalValue;
  }

  // extended_community - computed: false, optional: true, required: false
  private _extendedCommunity = new LogicalRouterVrfBgpPolicyExportRulesMatchExtendedCommunityOutputReference(this, "extended_community");
  public get extendedCommunity() {
    return this._extendedCommunity;
  }
  public putExtendedCommunity(value: LogicalRouterVrfBgpPolicyExportRulesMatchExtendedCommunity) {
    this._extendedCommunity.internalValue = value;
  }
  public resetExtendedCommunity() {
    this._extendedCommunity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extendedCommunityInput() {
    return this._extendedCommunity.internalValue;
  }

  // from_peer - computed: false, optional: true, required: false
  private _fromPeer?: string[]; 
  public get fromPeer() {
    return this.getListAttribute('from_peer');
  }
  public set fromPeer(value: string[]) {
    this._fromPeer = value;
  }
  public resetFromPeer() {
    this._fromPeer = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fromPeerInput() {
    return this._fromPeer;
  }

  // med - computed: false, optional: true, required: false
  private _med?: number; 
  public get med() {
    return this.getNumberAttribute('med');
  }
  public set med(value: number) {
    this._med = value;
  }
  public resetMed() {
    this._med = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get medInput() {
    return this._med;
  }

  // nexthop - computed: false, optional: true, required: false
  private _nexthop?: string[]; 
  public get nexthop() {
    return this.getListAttribute('nexthop');
  }
  public set nexthop(value: string[]) {
    this._nexthop = value;
  }
  public resetNexthop() {
    this._nexthop = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nexthopInput() {
    return this._nexthop;
  }

  // route_table - computed: false, optional: true, required: false
  private _routeTable?: string; 
  public get routeTable() {
    return this.getStringAttribute('route_table');
  }
  public set routeTable(value: string) {
    this._routeTable = value;
  }
  public resetRouteTable() {
    this._routeTable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeTableInput() {
    return this._routeTable;
  }

  // safi - computed: false, optional: true, required: false
  private _safi?: string; 
  public get safi() {
    return this.getStringAttribute('safi');
  }
  public set safi(value: string) {
    this._safi = value;
  }
  public resetSafi() {
    this._safi = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safiInput() {
    return this._safi;
  }
}
export interface LogicalRouterVrfBgpPolicyExportRules {
  /**
  * Action
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#action LogicalRouter#action}
  */
  readonly action?: LogicalRouterVrfBgpPolicyExportRulesAction;
  /**
  * Enable
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#enable LogicalRouter#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * Match
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#match LogicalRouter#match}
  */
  readonly match?: LogicalRouterVrfBgpPolicyExportRulesMatch;
  /**
  * Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#name LogicalRouter#name}
  */
  readonly name: string;
  /**
  * Used by
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#used_by LogicalRouter#used_by}
  */
  readonly usedBy?: string[];
}

export function logicalRouterVrfBgpPolicyExportRulesToTerraform(struct?: LogicalRouterVrfBgpPolicyExportRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: logicalRouterVrfBgpPolicyExportRulesActionToTerraform(struct!.action),
    enable: cdktf.booleanToTerraform(struct!.enable),
    match: logicalRouterVrfBgpPolicyExportRulesMatchToTerraform(struct!.match),
    name: cdktf.stringToTerraform(struct!.name),
    used_by: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.usedBy),
  }
}


export function logicalRouterVrfBgpPolicyExportRulesToHclTerraform(struct?: LogicalRouterVrfBgpPolicyExportRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: logicalRouterVrfBgpPolicyExportRulesActionToHclTerraform(struct!.action),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyExportRulesAction",
    },
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    match: {
      value: logicalRouterVrfBgpPolicyExportRulesMatchToHclTerraform(struct!.match),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyExportRulesMatch",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    used_by: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.usedBy),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyExportRulesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyExportRules | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action?.internalValue;
    }
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._match?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._usedBy !== undefined) {
      hasAnyValues = true;
      internalValueResult.usedBy = this._usedBy;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyExportRules | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action.internalValue = undefined;
      this._enable = undefined;
      this._match.internalValue = undefined;
      this._name = undefined;
      this._usedBy = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action.internalValue = value.action;
      this._enable = value.enable;
      this._match.internalValue = value.match;
      this._name = value.name;
      this._usedBy = value.usedBy;
    }
  }

  // action - computed: false, optional: true, required: false
  private _action = new LogicalRouterVrfBgpPolicyExportRulesActionOutputReference(this, "action");
  public get action() {
    return this._action;
  }
  public putAction(value: LogicalRouterVrfBgpPolicyExportRulesAction) {
    this._action.internalValue = value;
  }
  public resetAction() {
    this._action.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action.internalValue;
  }

  // enable - computed: false, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // match - computed: false, optional: true, required: false
  private _match = new LogicalRouterVrfBgpPolicyExportRulesMatchOutputReference(this, "match");
  public get match() {
    return this._match;
  }
  public putMatch(value: LogicalRouterVrfBgpPolicyExportRulesMatch) {
    this._match.internalValue = value;
  }
  public resetMatch() {
    this._match.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match.internalValue;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // used_by - computed: false, optional: true, required: false
  private _usedBy?: string[]; 
  public get usedBy() {
    return this.getListAttribute('used_by');
  }
  public set usedBy(value: string[]) {
    this._usedBy = value;
  }
  public resetUsedBy() {
    this._usedBy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usedByInput() {
    return this._usedBy;
  }
}

export class LogicalRouterVrfBgpPolicyExportRulesList extends cdktf.ComplexList {
  public internalValue? : LogicalRouterVrfBgpPolicyExportRules[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): LogicalRouterVrfBgpPolicyExportRulesOutputReference {
    return new LogicalRouterVrfBgpPolicyExportRulesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface LogicalRouterVrfBgpPolicyExport {
  /**
  * Rules
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#rules LogicalRouter#rules}
  */
  readonly rules?: LogicalRouterVrfBgpPolicyExportRules[] | cdktf.IResolvable;
}

export function logicalRouterVrfBgpPolicyExportToTerraform(struct?: LogicalRouterVrfBgpPolicyExport | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    rules: cdktf.listMapper(logicalRouterVrfBgpPolicyExportRulesToTerraform, false)(struct!.rules),
  }
}


export function logicalRouterVrfBgpPolicyExportToHclTerraform(struct?: LogicalRouterVrfBgpPolicyExport | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    rules: {
      value: cdktf.listMapperHcl(logicalRouterVrfBgpPolicyExportRulesToHclTerraform, false)(struct!.rules),
      isBlock: true,
      type: "list",
      storageClassType: "LogicalRouterVrfBgpPolicyExportRulesList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyExportOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyExport | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._rules?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rules = this._rules?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyExport | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._rules.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._rules.internalValue = value.rules;
    }
  }

  // rules - computed: false, optional: true, required: false
  private _rules = new LogicalRouterVrfBgpPolicyExportRulesList(this, "rules", false);
  public get rules() {
    return this._rules;
  }
  public putRules(value: LogicalRouterVrfBgpPolicyExportRules[] | cdktf.IResolvable) {
    this._rules.internalValue = value;
  }
  public resetRules() {
    this._rules.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rulesInput() {
    return this._rules.internalValue;
  }
}
export interface LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateAsPathNone {
}

export function logicalRouterVrfBgpPolicyImportRulesActionAllowUpdateAsPathNoneToTerraform(struct?: LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateAsPathNone | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function logicalRouterVrfBgpPolicyImportRulesActionAllowUpdateAsPathNoneToHclTerraform(struct?: LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateAsPathNone | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateAsPathNoneOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateAsPathNone | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateAsPathNone | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateAsPathRemove {
}

export function logicalRouterVrfBgpPolicyImportRulesActionAllowUpdateAsPathRemoveToTerraform(struct?: LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateAsPathRemove | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function logicalRouterVrfBgpPolicyImportRulesActionAllowUpdateAsPathRemoveToHclTerraform(struct?: LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateAsPathRemove | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateAsPathRemoveOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateAsPathRemove | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateAsPathRemove | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateAsPath {
  /**
  * None
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#none LogicalRouter#none}
  */
  readonly none?: LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateAsPathNone;
  /**
  * Prepend
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#prepend LogicalRouter#prepend}
  */
  readonly prepend?: number;
  /**
  * Remove
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#remove LogicalRouter#remove}
  */
  readonly remove?: LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateAsPathRemove;
  /**
  * Remove and prepend
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#remove_and_prepend LogicalRouter#remove_and_prepend}
  */
  readonly removeAndPrepend?: number;
}

export function logicalRouterVrfBgpPolicyImportRulesActionAllowUpdateAsPathToTerraform(struct?: LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateAsPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    none: logicalRouterVrfBgpPolicyImportRulesActionAllowUpdateAsPathNoneToTerraform(struct!.none),
    prepend: cdktf.numberToTerraform(struct!.prepend),
    remove: logicalRouterVrfBgpPolicyImportRulesActionAllowUpdateAsPathRemoveToTerraform(struct!.remove),
    remove_and_prepend: cdktf.numberToTerraform(struct!.removeAndPrepend),
  }
}


export function logicalRouterVrfBgpPolicyImportRulesActionAllowUpdateAsPathToHclTerraform(struct?: LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateAsPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    none: {
      value: logicalRouterVrfBgpPolicyImportRulesActionAllowUpdateAsPathNoneToHclTerraform(struct!.none),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateAsPathNone",
    },
    prepend: {
      value: cdktf.numberToHclTerraform(struct!.prepend),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    remove: {
      value: logicalRouterVrfBgpPolicyImportRulesActionAllowUpdateAsPathRemoveToHclTerraform(struct!.remove),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateAsPathRemove",
    },
    remove_and_prepend: {
      value: cdktf.numberToHclTerraform(struct!.removeAndPrepend),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateAsPathOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateAsPath | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._none?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.none = this._none?.internalValue;
    }
    if (this._prepend !== undefined) {
      hasAnyValues = true;
      internalValueResult.prepend = this._prepend;
    }
    if (this._remove?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.remove = this._remove?.internalValue;
    }
    if (this._removeAndPrepend !== undefined) {
      hasAnyValues = true;
      internalValueResult.removeAndPrepend = this._removeAndPrepend;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateAsPath | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._none.internalValue = undefined;
      this._prepend = undefined;
      this._remove.internalValue = undefined;
      this._removeAndPrepend = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._none.internalValue = value.none;
      this._prepend = value.prepend;
      this._remove.internalValue = value.remove;
      this._removeAndPrepend = value.removeAndPrepend;
    }
  }

  // none - computed: false, optional: true, required: false
  private _none = new LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateAsPathNoneOutputReference(this, "none");
  public get none() {
    return this._none;
  }
  public putNone(value: LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateAsPathNone) {
    this._none.internalValue = value;
  }
  public resetNone() {
    this._none.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get noneInput() {
    return this._none.internalValue;
  }

  // prepend - computed: false, optional: true, required: false
  private _prepend?: number; 
  public get prepend() {
    return this.getNumberAttribute('prepend');
  }
  public set prepend(value: number) {
    this._prepend = value;
  }
  public resetPrepend() {
    this._prepend = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prependInput() {
    return this._prepend;
  }

  // remove - computed: false, optional: true, required: false
  private _remove = new LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateAsPathRemoveOutputReference(this, "remove");
  public get remove() {
    return this._remove;
  }
  public putRemove(value: LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateAsPathRemove) {
    this._remove.internalValue = value;
  }
  public resetRemove() {
    this._remove.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeInput() {
    return this._remove.internalValue;
  }

  // remove_and_prepend - computed: false, optional: true, required: false
  private _removeAndPrepend?: number; 
  public get removeAndPrepend() {
    return this.getNumberAttribute('remove_and_prepend');
  }
  public set removeAndPrepend(value: number) {
    this._removeAndPrepend = value;
  }
  public resetRemoveAndPrepend() {
    this._removeAndPrepend = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeAndPrependInput() {
    return this._removeAndPrepend;
  }
}
export interface LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateCommunityNone {
}

export function logicalRouterVrfBgpPolicyImportRulesActionAllowUpdateCommunityNoneToTerraform(struct?: LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateCommunityNone | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function logicalRouterVrfBgpPolicyImportRulesActionAllowUpdateCommunityNoneToHclTerraform(struct?: LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateCommunityNone | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateCommunityNoneOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateCommunityNone | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateCommunityNone | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAll {
}

export function logicalRouterVrfBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllToTerraform(struct?: LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAll | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function logicalRouterVrfBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllToHclTerraform(struct?: LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAll | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAll | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAll | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateCommunity {
  /**
  * Append
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#append LogicalRouter#append}
  */
  readonly append?: string[];
  /**
  * None
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#none LogicalRouter#none}
  */
  readonly none?: LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateCommunityNone;
  /**
  * Overwrite
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#overwrite LogicalRouter#overwrite}
  */
  readonly overwrite?: string[];
  /**
  * Remove all
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#remove_all LogicalRouter#remove_all}
  */
  readonly removeAll?: LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAll;
  /**
  * Remove regex
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#remove_regex LogicalRouter#remove_regex}
  */
  readonly removeRegex?: string;
}

export function logicalRouterVrfBgpPolicyImportRulesActionAllowUpdateCommunityToTerraform(struct?: LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    append: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.append),
    none: logicalRouterVrfBgpPolicyImportRulesActionAllowUpdateCommunityNoneToTerraform(struct!.none),
    overwrite: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.overwrite),
    remove_all: logicalRouterVrfBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllToTerraform(struct!.removeAll),
    remove_regex: cdktf.stringToTerraform(struct!.removeRegex),
  }
}


export function logicalRouterVrfBgpPolicyImportRulesActionAllowUpdateCommunityToHclTerraform(struct?: LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    append: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.append),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    none: {
      value: logicalRouterVrfBgpPolicyImportRulesActionAllowUpdateCommunityNoneToHclTerraform(struct!.none),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateCommunityNone",
    },
    overwrite: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.overwrite),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    remove_all: {
      value: logicalRouterVrfBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllToHclTerraform(struct!.removeAll),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAll",
    },
    remove_regex: {
      value: cdktf.stringToHclTerraform(struct!.removeRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateCommunityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateCommunity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._append !== undefined) {
      hasAnyValues = true;
      internalValueResult.append = this._append;
    }
    if (this._none?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.none = this._none?.internalValue;
    }
    if (this._overwrite !== undefined) {
      hasAnyValues = true;
      internalValueResult.overwrite = this._overwrite;
    }
    if (this._removeAll?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.removeAll = this._removeAll?.internalValue;
    }
    if (this._removeRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.removeRegex = this._removeRegex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateCommunity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._append = undefined;
      this._none.internalValue = undefined;
      this._overwrite = undefined;
      this._removeAll.internalValue = undefined;
      this._removeRegex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._append = value.append;
      this._none.internalValue = value.none;
      this._overwrite = value.overwrite;
      this._removeAll.internalValue = value.removeAll;
      this._removeRegex = value.removeRegex;
    }
  }

  // append - computed: false, optional: true, required: false
  private _append?: string[]; 
  public get append() {
    return this.getListAttribute('append');
  }
  public set append(value: string[]) {
    this._append = value;
  }
  public resetAppend() {
    this._append = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appendInput() {
    return this._append;
  }

  // none - computed: false, optional: true, required: false
  private _none = new LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateCommunityNoneOutputReference(this, "none");
  public get none() {
    return this._none;
  }
  public putNone(value: LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateCommunityNone) {
    this._none.internalValue = value;
  }
  public resetNone() {
    this._none.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get noneInput() {
    return this._none.internalValue;
  }

  // overwrite - computed: false, optional: true, required: false
  private _overwrite?: string[]; 
  public get overwrite() {
    return this.getListAttribute('overwrite');
  }
  public set overwrite(value: string[]) {
    this._overwrite = value;
  }
  public resetOverwrite() {
    this._overwrite = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overwriteInput() {
    return this._overwrite;
  }

  // remove_all - computed: false, optional: true, required: false
  private _removeAll = new LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllOutputReference(this, "remove_all");
  public get removeAll() {
    return this._removeAll;
  }
  public putRemoveAll(value: LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAll) {
    this._removeAll.internalValue = value;
  }
  public resetRemoveAll() {
    this._removeAll.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeAllInput() {
    return this._removeAll.internalValue;
  }

  // remove_regex - computed: false, optional: true, required: false
  private _removeRegex?: string; 
  public get removeRegex() {
    return this.getStringAttribute('remove_regex');
  }
  public set removeRegex(value: string) {
    this._removeRegex = value;
  }
  public resetRemoveRegex() {
    this._removeRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeRegexInput() {
    return this._removeRegex;
  }
}
export interface LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNone {
}

export function logicalRouterVrfBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneToTerraform(struct?: LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNone | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function logicalRouterVrfBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneToHclTerraform(struct?: LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNone | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNone | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNone | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAll {
}

export function logicalRouterVrfBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllToTerraform(struct?: LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAll | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function logicalRouterVrfBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllToHclTerraform(struct?: LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAll | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAll | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAll | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateExtendedCommunity {
  /**
  * Append
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#append LogicalRouter#append}
  */
  readonly append?: string[];
  /**
  * None
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#none LogicalRouter#none}
  */
  readonly none?: LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNone;
  /**
  * Overwrite
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#overwrite LogicalRouter#overwrite}
  */
  readonly overwrite?: string[];
  /**
  * Remove all
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#remove_all LogicalRouter#remove_all}
  */
  readonly removeAll?: LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAll;
  /**
  * Remove regex
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#remove_regex LogicalRouter#remove_regex}
  */
  readonly removeRegex?: string;
}

export function logicalRouterVrfBgpPolicyImportRulesActionAllowUpdateExtendedCommunityToTerraform(struct?: LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateExtendedCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    append: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.append),
    none: logicalRouterVrfBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneToTerraform(struct!.none),
    overwrite: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.overwrite),
    remove_all: logicalRouterVrfBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllToTerraform(struct!.removeAll),
    remove_regex: cdktf.stringToTerraform(struct!.removeRegex),
  }
}


export function logicalRouterVrfBgpPolicyImportRulesActionAllowUpdateExtendedCommunityToHclTerraform(struct?: LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateExtendedCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    append: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.append),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    none: {
      value: logicalRouterVrfBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneToHclTerraform(struct!.none),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNone",
    },
    overwrite: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.overwrite),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    remove_all: {
      value: logicalRouterVrfBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllToHclTerraform(struct!.removeAll),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAll",
    },
    remove_regex: {
      value: cdktf.stringToHclTerraform(struct!.removeRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateExtendedCommunityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateExtendedCommunity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._append !== undefined) {
      hasAnyValues = true;
      internalValueResult.append = this._append;
    }
    if (this._none?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.none = this._none?.internalValue;
    }
    if (this._overwrite !== undefined) {
      hasAnyValues = true;
      internalValueResult.overwrite = this._overwrite;
    }
    if (this._removeAll?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.removeAll = this._removeAll?.internalValue;
    }
    if (this._removeRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.removeRegex = this._removeRegex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateExtendedCommunity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._append = undefined;
      this._none.internalValue = undefined;
      this._overwrite = undefined;
      this._removeAll.internalValue = undefined;
      this._removeRegex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._append = value.append;
      this._none.internalValue = value.none;
      this._overwrite = value.overwrite;
      this._removeAll.internalValue = value.removeAll;
      this._removeRegex = value.removeRegex;
    }
  }

  // append - computed: false, optional: true, required: false
  private _append?: string[]; 
  public get append() {
    return this.getListAttribute('append');
  }
  public set append(value: string[]) {
    this._append = value;
  }
  public resetAppend() {
    this._append = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appendInput() {
    return this._append;
  }

  // none - computed: false, optional: true, required: false
  private _none = new LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneOutputReference(this, "none");
  public get none() {
    return this._none;
  }
  public putNone(value: LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNone) {
    this._none.internalValue = value;
  }
  public resetNone() {
    this._none.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get noneInput() {
    return this._none.internalValue;
  }

  // overwrite - computed: false, optional: true, required: false
  private _overwrite?: string[]; 
  public get overwrite() {
    return this.getListAttribute('overwrite');
  }
  public set overwrite(value: string[]) {
    this._overwrite = value;
  }
  public resetOverwrite() {
    this._overwrite = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overwriteInput() {
    return this._overwrite;
  }

  // remove_all - computed: false, optional: true, required: false
  private _removeAll = new LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllOutputReference(this, "remove_all");
  public get removeAll() {
    return this._removeAll;
  }
  public putRemoveAll(value: LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAll) {
    this._removeAll.internalValue = value;
  }
  public resetRemoveAll() {
    this._removeAll.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeAllInput() {
    return this._removeAll.internalValue;
  }

  // remove_regex - computed: false, optional: true, required: false
  private _removeRegex?: string; 
  public get removeRegex() {
    return this.getStringAttribute('remove_regex');
  }
  public set removeRegex(value: string) {
    this._removeRegex = value;
  }
  public resetRemoveRegex() {
    this._removeRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeRegexInput() {
    return this._removeRegex;
  }
}
export interface LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdate {
  /**
  * As path
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#as_path LogicalRouter#as_path}
  */
  readonly asPath?: LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateAsPath;
  /**
  * As path limit
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#as_path_limit LogicalRouter#as_path_limit}
  */
  readonly asPathLimit?: number;
  /**
  * Community
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#community LogicalRouter#community}
  */
  readonly community?: LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateCommunity;
  /**
  * Extended community
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#extended_community LogicalRouter#extended_community}
  */
  readonly extendedCommunity?: LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateExtendedCommunity;
  /**
  * Local preference
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#local_preference LogicalRouter#local_preference}
  */
  readonly localPreference?: number;
  /**
  * Med
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#med LogicalRouter#med}
  */
  readonly med?: number;
  /**
  * Nexthop
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#nexthop LogicalRouter#nexthop}
  */
  readonly nexthop?: string;
  /**
  * Origin
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#origin LogicalRouter#origin}
  */
  readonly origin?: string;
  /**
  * Weight
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#weight LogicalRouter#weight}
  */
  readonly weight?: number;
}

export function logicalRouterVrfBgpPolicyImportRulesActionAllowUpdateToTerraform(struct?: LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    as_path: logicalRouterVrfBgpPolicyImportRulesActionAllowUpdateAsPathToTerraform(struct!.asPath),
    as_path_limit: cdktf.numberToTerraform(struct!.asPathLimit),
    community: logicalRouterVrfBgpPolicyImportRulesActionAllowUpdateCommunityToTerraform(struct!.community),
    extended_community: logicalRouterVrfBgpPolicyImportRulesActionAllowUpdateExtendedCommunityToTerraform(struct!.extendedCommunity),
    local_preference: cdktf.numberToTerraform(struct!.localPreference),
    med: cdktf.numberToTerraform(struct!.med),
    nexthop: cdktf.stringToTerraform(struct!.nexthop),
    origin: cdktf.stringToTerraform(struct!.origin),
    weight: cdktf.numberToTerraform(struct!.weight),
  }
}


export function logicalRouterVrfBgpPolicyImportRulesActionAllowUpdateToHclTerraform(struct?: LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    as_path: {
      value: logicalRouterVrfBgpPolicyImportRulesActionAllowUpdateAsPathToHclTerraform(struct!.asPath),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateAsPath",
    },
    as_path_limit: {
      value: cdktf.numberToHclTerraform(struct!.asPathLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    community: {
      value: logicalRouterVrfBgpPolicyImportRulesActionAllowUpdateCommunityToHclTerraform(struct!.community),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateCommunity",
    },
    extended_community: {
      value: logicalRouterVrfBgpPolicyImportRulesActionAllowUpdateExtendedCommunityToHclTerraform(struct!.extendedCommunity),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateExtendedCommunity",
    },
    local_preference: {
      value: cdktf.numberToHclTerraform(struct!.localPreference),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    med: {
      value: cdktf.numberToHclTerraform(struct!.med),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    nexthop: {
      value: cdktf.stringToHclTerraform(struct!.nexthop),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    origin: {
      value: cdktf.stringToHclTerraform(struct!.origin),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    weight: {
      value: cdktf.numberToHclTerraform(struct!.weight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdate | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._asPath?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.asPath = this._asPath?.internalValue;
    }
    if (this._asPathLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.asPathLimit = this._asPathLimit;
    }
    if (this._community?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.community = this._community?.internalValue;
    }
    if (this._extendedCommunity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extendedCommunity = this._extendedCommunity?.internalValue;
    }
    if (this._localPreference !== undefined) {
      hasAnyValues = true;
      internalValueResult.localPreference = this._localPreference;
    }
    if (this._med !== undefined) {
      hasAnyValues = true;
      internalValueResult.med = this._med;
    }
    if (this._nexthop !== undefined) {
      hasAnyValues = true;
      internalValueResult.nexthop = this._nexthop;
    }
    if (this._origin !== undefined) {
      hasAnyValues = true;
      internalValueResult.origin = this._origin;
    }
    if (this._weight !== undefined) {
      hasAnyValues = true;
      internalValueResult.weight = this._weight;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdate | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._asPath.internalValue = undefined;
      this._asPathLimit = undefined;
      this._community.internalValue = undefined;
      this._extendedCommunity.internalValue = undefined;
      this._localPreference = undefined;
      this._med = undefined;
      this._nexthop = undefined;
      this._origin = undefined;
      this._weight = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._asPath.internalValue = value.asPath;
      this._asPathLimit = value.asPathLimit;
      this._community.internalValue = value.community;
      this._extendedCommunity.internalValue = value.extendedCommunity;
      this._localPreference = value.localPreference;
      this._med = value.med;
      this._nexthop = value.nexthop;
      this._origin = value.origin;
      this._weight = value.weight;
    }
  }

  // as_path - computed: false, optional: true, required: false
  private _asPath = new LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateAsPathOutputReference(this, "as_path");
  public get asPath() {
    return this._asPath;
  }
  public putAsPath(value: LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateAsPath) {
    this._asPath.internalValue = value;
  }
  public resetAsPath() {
    this._asPath.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asPathInput() {
    return this._asPath.internalValue;
  }

  // as_path_limit - computed: false, optional: true, required: false
  private _asPathLimit?: number; 
  public get asPathLimit() {
    return this.getNumberAttribute('as_path_limit');
  }
  public set asPathLimit(value: number) {
    this._asPathLimit = value;
  }
  public resetAsPathLimit() {
    this._asPathLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asPathLimitInput() {
    return this._asPathLimit;
  }

  // community - computed: false, optional: true, required: false
  private _community = new LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateCommunityOutputReference(this, "community");
  public get community() {
    return this._community;
  }
  public putCommunity(value: LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateCommunity) {
    this._community.internalValue = value;
  }
  public resetCommunity() {
    this._community.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get communityInput() {
    return this._community.internalValue;
  }

  // extended_community - computed: false, optional: true, required: false
  private _extendedCommunity = new LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateExtendedCommunityOutputReference(this, "extended_community");
  public get extendedCommunity() {
    return this._extendedCommunity;
  }
  public putExtendedCommunity(value: LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateExtendedCommunity) {
    this._extendedCommunity.internalValue = value;
  }
  public resetExtendedCommunity() {
    this._extendedCommunity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extendedCommunityInput() {
    return this._extendedCommunity.internalValue;
  }

  // local_preference - computed: false, optional: true, required: false
  private _localPreference?: number; 
  public get localPreference() {
    return this.getNumberAttribute('local_preference');
  }
  public set localPreference(value: number) {
    this._localPreference = value;
  }
  public resetLocalPreference() {
    this._localPreference = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localPreferenceInput() {
    return this._localPreference;
  }

  // med - computed: false, optional: true, required: false
  private _med?: number; 
  public get med() {
    return this.getNumberAttribute('med');
  }
  public set med(value: number) {
    this._med = value;
  }
  public resetMed() {
    this._med = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get medInput() {
    return this._med;
  }

  // nexthop - computed: false, optional: true, required: false
  private _nexthop?: string; 
  public get nexthop() {
    return this.getStringAttribute('nexthop');
  }
  public set nexthop(value: string) {
    this._nexthop = value;
  }
  public resetNexthop() {
    this._nexthop = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nexthopInput() {
    return this._nexthop;
  }

  // origin - computed: false, optional: true, required: false
  private _origin?: string; 
  public get origin() {
    return this.getStringAttribute('origin');
  }
  public set origin(value: string) {
    this._origin = value;
  }
  public resetOrigin() {
    this._origin = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get originInput() {
    return this._origin;
  }

  // weight - computed: false, optional: true, required: false
  private _weight?: number; 
  public get weight() {
    return this.getNumberAttribute('weight');
  }
  public set weight(value: number) {
    this._weight = value;
  }
  public resetWeight() {
    this._weight = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get weightInput() {
    return this._weight;
  }
}
export interface LogicalRouterVrfBgpPolicyImportRulesActionAllow {
  /**
  * Dampening
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#dampening LogicalRouter#dampening}
  */
  readonly dampening?: string;
  /**
  * Update
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#update LogicalRouter#update}
  */
  readonly update?: LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdate;
}

export function logicalRouterVrfBgpPolicyImportRulesActionAllowToTerraform(struct?: LogicalRouterVrfBgpPolicyImportRulesActionAllow | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dampening: cdktf.stringToTerraform(struct!.dampening),
    update: logicalRouterVrfBgpPolicyImportRulesActionAllowUpdateToTerraform(struct!.update),
  }
}


export function logicalRouterVrfBgpPolicyImportRulesActionAllowToHclTerraform(struct?: LogicalRouterVrfBgpPolicyImportRulesActionAllow | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dampening: {
      value: cdktf.stringToHclTerraform(struct!.dampening),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    update: {
      value: logicalRouterVrfBgpPolicyImportRulesActionAllowUpdateToHclTerraform(struct!.update),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdate",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyImportRulesActionAllowOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyImportRulesActionAllow | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dampening !== undefined) {
      hasAnyValues = true;
      internalValueResult.dampening = this._dampening;
    }
    if (this._update?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.update = this._update?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyImportRulesActionAllow | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dampening = undefined;
      this._update.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dampening = value.dampening;
      this._update.internalValue = value.update;
    }
  }

  // dampening - computed: false, optional: true, required: false
  private _dampening?: string; 
  public get dampening() {
    return this.getStringAttribute('dampening');
  }
  public set dampening(value: string) {
    this._dampening = value;
  }
  public resetDampening() {
    this._dampening = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dampeningInput() {
    return this._dampening;
  }

  // update - computed: false, optional: true, required: false
  private _update = new LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdateOutputReference(this, "update");
  public get update() {
    return this._update;
  }
  public putUpdate(value: LogicalRouterVrfBgpPolicyImportRulesActionAllowUpdate) {
    this._update.internalValue = value;
  }
  public resetUpdate() {
    this._update.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get updateInput() {
    return this._update.internalValue;
  }
}
export interface LogicalRouterVrfBgpPolicyImportRulesActionDeny {
}

export function logicalRouterVrfBgpPolicyImportRulesActionDenyToTerraform(struct?: LogicalRouterVrfBgpPolicyImportRulesActionDeny | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function logicalRouterVrfBgpPolicyImportRulesActionDenyToHclTerraform(struct?: LogicalRouterVrfBgpPolicyImportRulesActionDeny | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class LogicalRouterVrfBgpPolicyImportRulesActionDenyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyImportRulesActionDeny | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyImportRulesActionDeny | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface LogicalRouterVrfBgpPolicyImportRulesAction {
  /**
  * Allow
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#allow LogicalRouter#allow}
  */
  readonly allow?: LogicalRouterVrfBgpPolicyImportRulesActionAllow;
  /**
  * Deny
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#deny LogicalRouter#deny}
  */
  readonly deny?: LogicalRouterVrfBgpPolicyImportRulesActionDeny;
}

export function logicalRouterVrfBgpPolicyImportRulesActionToTerraform(struct?: LogicalRouterVrfBgpPolicyImportRulesAction | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow: logicalRouterVrfBgpPolicyImportRulesActionAllowToTerraform(struct!.allow),
    deny: logicalRouterVrfBgpPolicyImportRulesActionDenyToTerraform(struct!.deny),
  }
}


export function logicalRouterVrfBgpPolicyImportRulesActionToHclTerraform(struct?: LogicalRouterVrfBgpPolicyImportRulesAction | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow: {
      value: logicalRouterVrfBgpPolicyImportRulesActionAllowToHclTerraform(struct!.allow),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyImportRulesActionAllow",
    },
    deny: {
      value: logicalRouterVrfBgpPolicyImportRulesActionDenyToHclTerraform(struct!.deny),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyImportRulesActionDeny",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyImportRulesActionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyImportRulesAction | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allow?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.allow = this._allow?.internalValue;
    }
    if (this._deny?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.deny = this._deny?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyImportRulesAction | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allow.internalValue = undefined;
      this._deny.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allow.internalValue = value.allow;
      this._deny.internalValue = value.deny;
    }
  }

  // allow - computed: false, optional: true, required: false
  private _allow = new LogicalRouterVrfBgpPolicyImportRulesActionAllowOutputReference(this, "allow");
  public get allow() {
    return this._allow;
  }
  public putAllow(value: LogicalRouterVrfBgpPolicyImportRulesActionAllow) {
    this._allow.internalValue = value;
  }
  public resetAllow() {
    this._allow.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowInput() {
    return this._allow.internalValue;
  }

  // deny - computed: false, optional: true, required: false
  private _deny = new LogicalRouterVrfBgpPolicyImportRulesActionDenyOutputReference(this, "deny");
  public get deny() {
    return this._deny;
  }
  public putDeny(value: LogicalRouterVrfBgpPolicyImportRulesActionDeny) {
    this._deny.internalValue = value;
  }
  public resetDeny() {
    this._deny.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get denyInput() {
    return this._deny.internalValue;
  }
}
export interface LogicalRouterVrfBgpPolicyImportRulesMatchAddressPrefix {
  /**
  * Exact
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#exact LogicalRouter#exact}
  */
  readonly exact?: boolean | cdktf.IResolvable;
  /**
  * Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#name LogicalRouter#name}
  */
  readonly name: string;
}

export function logicalRouterVrfBgpPolicyImportRulesMatchAddressPrefixToTerraform(struct?: LogicalRouterVrfBgpPolicyImportRulesMatchAddressPrefix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    exact: cdktf.booleanToTerraform(struct!.exact),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function logicalRouterVrfBgpPolicyImportRulesMatchAddressPrefixToHclTerraform(struct?: LogicalRouterVrfBgpPolicyImportRulesMatchAddressPrefix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    exact: {
      value: cdktf.booleanToHclTerraform(struct!.exact),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyImportRulesMatchAddressPrefixOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyImportRulesMatchAddressPrefix | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._exact !== undefined) {
      hasAnyValues = true;
      internalValueResult.exact = this._exact;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyImportRulesMatchAddressPrefix | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._exact = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._exact = value.exact;
      this._name = value.name;
    }
  }

  // exact - computed: false, optional: true, required: false
  private _exact?: boolean | cdktf.IResolvable; 
  public get exact() {
    return this.getBooleanAttribute('exact');
  }
  public set exact(value: boolean | cdktf.IResolvable) {
    this._exact = value;
  }
  public resetExact() {
    this._exact = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exactInput() {
    return this._exact;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class LogicalRouterVrfBgpPolicyImportRulesMatchAddressPrefixList extends cdktf.ComplexList {
  public internalValue? : LogicalRouterVrfBgpPolicyImportRulesMatchAddressPrefix[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): LogicalRouterVrfBgpPolicyImportRulesMatchAddressPrefixOutputReference {
    return new LogicalRouterVrfBgpPolicyImportRulesMatchAddressPrefixOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface LogicalRouterVrfBgpPolicyImportRulesMatchAsPath {
  /**
  * Regex
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#regex LogicalRouter#regex}
  */
  readonly regex?: string;
}

export function logicalRouterVrfBgpPolicyImportRulesMatchAsPathToTerraform(struct?: LogicalRouterVrfBgpPolicyImportRulesMatchAsPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function logicalRouterVrfBgpPolicyImportRulesMatchAsPathToHclTerraform(struct?: LogicalRouterVrfBgpPolicyImportRulesMatchAsPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyImportRulesMatchAsPathOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyImportRulesMatchAsPath | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyImportRulesMatchAsPath | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._regex = value.regex;
    }
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface LogicalRouterVrfBgpPolicyImportRulesMatchCommunity {
  /**
  * Regex
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#regex LogicalRouter#regex}
  */
  readonly regex?: string;
}

export function logicalRouterVrfBgpPolicyImportRulesMatchCommunityToTerraform(struct?: LogicalRouterVrfBgpPolicyImportRulesMatchCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function logicalRouterVrfBgpPolicyImportRulesMatchCommunityToHclTerraform(struct?: LogicalRouterVrfBgpPolicyImportRulesMatchCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyImportRulesMatchCommunityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyImportRulesMatchCommunity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyImportRulesMatchCommunity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._regex = value.regex;
    }
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface LogicalRouterVrfBgpPolicyImportRulesMatchExtendedCommunity {
  /**
  * Regex
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#regex LogicalRouter#regex}
  */
  readonly regex?: string;
}

export function logicalRouterVrfBgpPolicyImportRulesMatchExtendedCommunityToTerraform(struct?: LogicalRouterVrfBgpPolicyImportRulesMatchExtendedCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function logicalRouterVrfBgpPolicyImportRulesMatchExtendedCommunityToHclTerraform(struct?: LogicalRouterVrfBgpPolicyImportRulesMatchExtendedCommunity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyImportRulesMatchExtendedCommunityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyImportRulesMatchExtendedCommunity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyImportRulesMatchExtendedCommunity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._regex = value.regex;
    }
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface LogicalRouterVrfBgpPolicyImportRulesMatch {
  /**
  * Address prefix
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#address_prefix LogicalRouter#address_prefix}
  */
  readonly addressPrefix?: LogicalRouterVrfBgpPolicyImportRulesMatchAddressPrefix[] | cdktf.IResolvable;
  /**
  * Afi
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#afi LogicalRouter#afi}
  */
  readonly afi?: string;
  /**
  * As path
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#as_path LogicalRouter#as_path}
  */
  readonly asPath?: LogicalRouterVrfBgpPolicyImportRulesMatchAsPath;
  /**
  * Community
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#community LogicalRouter#community}
  */
  readonly community?: LogicalRouterVrfBgpPolicyImportRulesMatchCommunity;
  /**
  * Extended community
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#extended_community LogicalRouter#extended_community}
  */
  readonly extendedCommunity?: LogicalRouterVrfBgpPolicyImportRulesMatchExtendedCommunity;
  /**
  * From peer
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#from_peer LogicalRouter#from_peer}
  */
  readonly fromPeer?: string[];
  /**
  * Med
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#med LogicalRouter#med}
  */
  readonly med?: number;
  /**
  * Nexthop
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#nexthop LogicalRouter#nexthop}
  */
  readonly nexthop?: string[];
  /**
  * Route table
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#route_table LogicalRouter#route_table}
  */
  readonly routeTable?: string;
  /**
  * Safi
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#safi LogicalRouter#safi}
  */
  readonly safi?: string;
}

export function logicalRouterVrfBgpPolicyImportRulesMatchToTerraform(struct?: LogicalRouterVrfBgpPolicyImportRulesMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address_prefix: cdktf.listMapper(logicalRouterVrfBgpPolicyImportRulesMatchAddressPrefixToTerraform, false)(struct!.addressPrefix),
    afi: cdktf.stringToTerraform(struct!.afi),
    as_path: logicalRouterVrfBgpPolicyImportRulesMatchAsPathToTerraform(struct!.asPath),
    community: logicalRouterVrfBgpPolicyImportRulesMatchCommunityToTerraform(struct!.community),
    extended_community: logicalRouterVrfBgpPolicyImportRulesMatchExtendedCommunityToTerraform(struct!.extendedCommunity),
    from_peer: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.fromPeer),
    med: cdktf.numberToTerraform(struct!.med),
    nexthop: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.nexthop),
    route_table: cdktf.stringToTerraform(struct!.routeTable),
    safi: cdktf.stringToTerraform(struct!.safi),
  }
}


export function logicalRouterVrfBgpPolicyImportRulesMatchToHclTerraform(struct?: LogicalRouterVrfBgpPolicyImportRulesMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address_prefix: {
      value: cdktf.listMapperHcl(logicalRouterVrfBgpPolicyImportRulesMatchAddressPrefixToHclTerraform, false)(struct!.addressPrefix),
      isBlock: true,
      type: "list",
      storageClassType: "LogicalRouterVrfBgpPolicyImportRulesMatchAddressPrefixList",
    },
    afi: {
      value: cdktf.stringToHclTerraform(struct!.afi),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    as_path: {
      value: logicalRouterVrfBgpPolicyImportRulesMatchAsPathToHclTerraform(struct!.asPath),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyImportRulesMatchAsPath",
    },
    community: {
      value: logicalRouterVrfBgpPolicyImportRulesMatchCommunityToHclTerraform(struct!.community),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyImportRulesMatchCommunity",
    },
    extended_community: {
      value: logicalRouterVrfBgpPolicyImportRulesMatchExtendedCommunityToHclTerraform(struct!.extendedCommunity),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyImportRulesMatchExtendedCommunity",
    },
    from_peer: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.fromPeer),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    med: {
      value: cdktf.numberToHclTerraform(struct!.med),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    nexthop: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.nexthop),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    route_table: {
      value: cdktf.stringToHclTerraform(struct!.routeTable),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    safi: {
      value: cdktf.stringToHclTerraform(struct!.safi),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyImportRulesMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyImportRulesMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addressPrefix?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.addressPrefix = this._addressPrefix?.internalValue;
    }
    if (this._afi !== undefined) {
      hasAnyValues = true;
      internalValueResult.afi = this._afi;
    }
    if (this._asPath?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.asPath = this._asPath?.internalValue;
    }
    if (this._community?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.community = this._community?.internalValue;
    }
    if (this._extendedCommunity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extendedCommunity = this._extendedCommunity?.internalValue;
    }
    if (this._fromPeer !== undefined) {
      hasAnyValues = true;
      internalValueResult.fromPeer = this._fromPeer;
    }
    if (this._med !== undefined) {
      hasAnyValues = true;
      internalValueResult.med = this._med;
    }
    if (this._nexthop !== undefined) {
      hasAnyValues = true;
      internalValueResult.nexthop = this._nexthop;
    }
    if (this._routeTable !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeTable = this._routeTable;
    }
    if (this._safi !== undefined) {
      hasAnyValues = true;
      internalValueResult.safi = this._safi;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyImportRulesMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addressPrefix.internalValue = undefined;
      this._afi = undefined;
      this._asPath.internalValue = undefined;
      this._community.internalValue = undefined;
      this._extendedCommunity.internalValue = undefined;
      this._fromPeer = undefined;
      this._med = undefined;
      this._nexthop = undefined;
      this._routeTable = undefined;
      this._safi = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addressPrefix.internalValue = value.addressPrefix;
      this._afi = value.afi;
      this._asPath.internalValue = value.asPath;
      this._community.internalValue = value.community;
      this._extendedCommunity.internalValue = value.extendedCommunity;
      this._fromPeer = value.fromPeer;
      this._med = value.med;
      this._nexthop = value.nexthop;
      this._routeTable = value.routeTable;
      this._safi = value.safi;
    }
  }

  // address_prefix - computed: false, optional: true, required: false
  private _addressPrefix = new LogicalRouterVrfBgpPolicyImportRulesMatchAddressPrefixList(this, "address_prefix", false);
  public get addressPrefix() {
    return this._addressPrefix;
  }
  public putAddressPrefix(value: LogicalRouterVrfBgpPolicyImportRulesMatchAddressPrefix[] | cdktf.IResolvable) {
    this._addressPrefix.internalValue = value;
  }
  public resetAddressPrefix() {
    this._addressPrefix.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressPrefixInput() {
    return this._addressPrefix.internalValue;
  }

  // afi - computed: false, optional: true, required: false
  private _afi?: string; 
  public get afi() {
    return this.getStringAttribute('afi');
  }
  public set afi(value: string) {
    this._afi = value;
  }
  public resetAfi() {
    this._afi = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get afiInput() {
    return this._afi;
  }

  // as_path - computed: false, optional: true, required: false
  private _asPath = new LogicalRouterVrfBgpPolicyImportRulesMatchAsPathOutputReference(this, "as_path");
  public get asPath() {
    return this._asPath;
  }
  public putAsPath(value: LogicalRouterVrfBgpPolicyImportRulesMatchAsPath) {
    this._asPath.internalValue = value;
  }
  public resetAsPath() {
    this._asPath.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asPathInput() {
    return this._asPath.internalValue;
  }

  // community - computed: false, optional: true, required: false
  private _community = new LogicalRouterVrfBgpPolicyImportRulesMatchCommunityOutputReference(this, "community");
  public get community() {
    return this._community;
  }
  public putCommunity(value: LogicalRouterVrfBgpPolicyImportRulesMatchCommunity) {
    this._community.internalValue = value;
  }
  public resetCommunity() {
    this._community.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get communityInput() {
    return this._community.internalValue;
  }

  // extended_community - computed: false, optional: true, required: false
  private _extendedCommunity = new LogicalRouterVrfBgpPolicyImportRulesMatchExtendedCommunityOutputReference(this, "extended_community");
  public get extendedCommunity() {
    return this._extendedCommunity;
  }
  public putExtendedCommunity(value: LogicalRouterVrfBgpPolicyImportRulesMatchExtendedCommunity) {
    this._extendedCommunity.internalValue = value;
  }
  public resetExtendedCommunity() {
    this._extendedCommunity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extendedCommunityInput() {
    return this._extendedCommunity.internalValue;
  }

  // from_peer - computed: false, optional: true, required: false
  private _fromPeer?: string[]; 
  public get fromPeer() {
    return this.getListAttribute('from_peer');
  }
  public set fromPeer(value: string[]) {
    this._fromPeer = value;
  }
  public resetFromPeer() {
    this._fromPeer = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fromPeerInput() {
    return this._fromPeer;
  }

  // med - computed: false, optional: true, required: false
  private _med?: number; 
  public get med() {
    return this.getNumberAttribute('med');
  }
  public set med(value: number) {
    this._med = value;
  }
  public resetMed() {
    this._med = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get medInput() {
    return this._med;
  }

  // nexthop - computed: false, optional: true, required: false
  private _nexthop?: string[]; 
  public get nexthop() {
    return this.getListAttribute('nexthop');
  }
  public set nexthop(value: string[]) {
    this._nexthop = value;
  }
  public resetNexthop() {
    this._nexthop = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nexthopInput() {
    return this._nexthop;
  }

  // route_table - computed: false, optional: true, required: false
  private _routeTable?: string; 
  public get routeTable() {
    return this.getStringAttribute('route_table');
  }
  public set routeTable(value: string) {
    this._routeTable = value;
  }
  public resetRouteTable() {
    this._routeTable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeTableInput() {
    return this._routeTable;
  }

  // safi - computed: false, optional: true, required: false
  private _safi?: string; 
  public get safi() {
    return this.getStringAttribute('safi');
  }
  public set safi(value: string) {
    this._safi = value;
  }
  public resetSafi() {
    this._safi = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safiInput() {
    return this._safi;
  }
}
export interface LogicalRouterVrfBgpPolicyImportRules {
  /**
  * Action
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#action LogicalRouter#action}
  */
  readonly action?: LogicalRouterVrfBgpPolicyImportRulesAction;
  /**
  * Enable
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#enable LogicalRouter#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * Match
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#match LogicalRouter#match}
  */
  readonly match?: LogicalRouterVrfBgpPolicyImportRulesMatch;
  /**
  * Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#name LogicalRouter#name}
  */
  readonly name: string;
  /**
  * Used by
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#used_by LogicalRouter#used_by}
  */
  readonly usedBy?: string[];
}

export function logicalRouterVrfBgpPolicyImportRulesToTerraform(struct?: LogicalRouterVrfBgpPolicyImportRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: logicalRouterVrfBgpPolicyImportRulesActionToTerraform(struct!.action),
    enable: cdktf.booleanToTerraform(struct!.enable),
    match: logicalRouterVrfBgpPolicyImportRulesMatchToTerraform(struct!.match),
    name: cdktf.stringToTerraform(struct!.name),
    used_by: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.usedBy),
  }
}


export function logicalRouterVrfBgpPolicyImportRulesToHclTerraform(struct?: LogicalRouterVrfBgpPolicyImportRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: logicalRouterVrfBgpPolicyImportRulesActionToHclTerraform(struct!.action),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyImportRulesAction",
    },
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    match: {
      value: logicalRouterVrfBgpPolicyImportRulesMatchToHclTerraform(struct!.match),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyImportRulesMatch",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    used_by: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.usedBy),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyImportRulesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyImportRules | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action?.internalValue;
    }
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._match?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._usedBy !== undefined) {
      hasAnyValues = true;
      internalValueResult.usedBy = this._usedBy;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyImportRules | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action.internalValue = undefined;
      this._enable = undefined;
      this._match.internalValue = undefined;
      this._name = undefined;
      this._usedBy = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action.internalValue = value.action;
      this._enable = value.enable;
      this._match.internalValue = value.match;
      this._name = value.name;
      this._usedBy = value.usedBy;
    }
  }

  // action - computed: false, optional: true, required: false
  private _action = new LogicalRouterVrfBgpPolicyImportRulesActionOutputReference(this, "action");
  public get action() {
    return this._action;
  }
  public putAction(value: LogicalRouterVrfBgpPolicyImportRulesAction) {
    this._action.internalValue = value;
  }
  public resetAction() {
    this._action.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action.internalValue;
  }

  // enable - computed: false, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // match - computed: false, optional: true, required: false
  private _match = new LogicalRouterVrfBgpPolicyImportRulesMatchOutputReference(this, "match");
  public get match() {
    return this._match;
  }
  public putMatch(value: LogicalRouterVrfBgpPolicyImportRulesMatch) {
    this._match.internalValue = value;
  }
  public resetMatch() {
    this._match.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match.internalValue;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // used_by - computed: false, optional: true, required: false
  private _usedBy?: string[]; 
  public get usedBy() {
    return this.getListAttribute('used_by');
  }
  public set usedBy(value: string[]) {
    this._usedBy = value;
  }
  public resetUsedBy() {
    this._usedBy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usedByInput() {
    return this._usedBy;
  }
}

export class LogicalRouterVrfBgpPolicyImportRulesList extends cdktf.ComplexList {
  public internalValue? : LogicalRouterVrfBgpPolicyImportRules[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): LogicalRouterVrfBgpPolicyImportRulesOutputReference {
    return new LogicalRouterVrfBgpPolicyImportRulesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface LogicalRouterVrfBgpPolicyImport {
  /**
  * Rules
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#rules LogicalRouter#rules}
  */
  readonly rules?: LogicalRouterVrfBgpPolicyImportRules[] | cdktf.IResolvable;
}

export function logicalRouterVrfBgpPolicyImportToTerraform(struct?: LogicalRouterVrfBgpPolicyImport | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    rules: cdktf.listMapper(logicalRouterVrfBgpPolicyImportRulesToTerraform, false)(struct!.rules),
  }
}


export function logicalRouterVrfBgpPolicyImportToHclTerraform(struct?: LogicalRouterVrfBgpPolicyImport | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    rules: {
      value: cdktf.listMapperHcl(logicalRouterVrfBgpPolicyImportRulesToHclTerraform, false)(struct!.rules),
      isBlock: true,
      type: "list",
      storageClassType: "LogicalRouterVrfBgpPolicyImportRulesList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyImportOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicyImport | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._rules?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rules = this._rules?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicyImport | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._rules.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._rules.internalValue = value.rules;
    }
  }

  // rules - computed: false, optional: true, required: false
  private _rules = new LogicalRouterVrfBgpPolicyImportRulesList(this, "rules", false);
  public get rules() {
    return this._rules;
  }
  public putRules(value: LogicalRouterVrfBgpPolicyImportRules[] | cdktf.IResolvable) {
    this._rules.internalValue = value;
  }
  public resetRules() {
    this._rules.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rulesInput() {
    return this._rules.internalValue;
  }
}
export interface LogicalRouterVrfBgpPolicy {
  /**
  * Aggregation
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#aggregation LogicalRouter#aggregation}
  */
  readonly aggregation?: LogicalRouterVrfBgpPolicyAggregation;
  /**
  * Conditional advertisement
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#conditional_advertisement LogicalRouter#conditional_advertisement}
  */
  readonly conditionalAdvertisement?: LogicalRouterVrfBgpPolicyConditionalAdvertisement;
  /**
  * Export
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#export LogicalRouter#export}
  */
  readonly export?: LogicalRouterVrfBgpPolicyExport;
  /**
  * Import
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#import LogicalRouter#import}
  */
  readonly import?: LogicalRouterVrfBgpPolicyImport;
}

export function logicalRouterVrfBgpPolicyToTerraform(struct?: LogicalRouterVrfBgpPolicy | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    aggregation: logicalRouterVrfBgpPolicyAggregationToTerraform(struct!.aggregation),
    conditional_advertisement: logicalRouterVrfBgpPolicyConditionalAdvertisementToTerraform(struct!.conditionalAdvertisement),
    export: logicalRouterVrfBgpPolicyExportToTerraform(struct!.export),
    import: logicalRouterVrfBgpPolicyImportToTerraform(struct!.import),
  }
}


export function logicalRouterVrfBgpPolicyToHclTerraform(struct?: LogicalRouterVrfBgpPolicy | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    aggregation: {
      value: logicalRouterVrfBgpPolicyAggregationToHclTerraform(struct!.aggregation),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyAggregation",
    },
    conditional_advertisement: {
      value: logicalRouterVrfBgpPolicyConditionalAdvertisementToHclTerraform(struct!.conditionalAdvertisement),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyConditionalAdvertisement",
    },
    export: {
      value: logicalRouterVrfBgpPolicyExportToHclTerraform(struct!.export),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyExport",
    },
    import: {
      value: logicalRouterVrfBgpPolicyImportToHclTerraform(struct!.import),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicyImport",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpPolicyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpPolicy | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._aggregation?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.aggregation = this._aggregation?.internalValue;
    }
    if (this._conditionalAdvertisement?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.conditionalAdvertisement = this._conditionalAdvertisement?.internalValue;
    }
    if (this._export?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.export = this._export?.internalValue;
    }
    if (this._import?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.import = this._import?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpPolicy | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._aggregation.internalValue = undefined;
      this._conditionalAdvertisement.internalValue = undefined;
      this._export.internalValue = undefined;
      this._import.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._aggregation.internalValue = value.aggregation;
      this._conditionalAdvertisement.internalValue = value.conditionalAdvertisement;
      this._export.internalValue = value.export;
      this._import.internalValue = value.import;
    }
  }

  // aggregation - computed: false, optional: true, required: false
  private _aggregation = new LogicalRouterVrfBgpPolicyAggregationOutputReference(this, "aggregation");
  public get aggregation() {
    return this._aggregation;
  }
  public putAggregation(value: LogicalRouterVrfBgpPolicyAggregation) {
    this._aggregation.internalValue = value;
  }
  public resetAggregation() {
    this._aggregation.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aggregationInput() {
    return this._aggregation.internalValue;
  }

  // conditional_advertisement - computed: false, optional: true, required: false
  private _conditionalAdvertisement = new LogicalRouterVrfBgpPolicyConditionalAdvertisementOutputReference(this, "conditional_advertisement");
  public get conditionalAdvertisement() {
    return this._conditionalAdvertisement;
  }
  public putConditionalAdvertisement(value: LogicalRouterVrfBgpPolicyConditionalAdvertisement) {
    this._conditionalAdvertisement.internalValue = value;
  }
  public resetConditionalAdvertisement() {
    this._conditionalAdvertisement.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get conditionalAdvertisementInput() {
    return this._conditionalAdvertisement.internalValue;
  }

  // export - computed: false, optional: true, required: false
  private _export = new LogicalRouterVrfBgpPolicyExportOutputReference(this, "export");
  public get export() {
    return this._export;
  }
  public putExport(value: LogicalRouterVrfBgpPolicyExport) {
    this._export.internalValue = value;
  }
  public resetExport() {
    this._export.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exportInput() {
    return this._export.internalValue;
  }

  // import - computed: false, optional: true, required: false
  private _import = new LogicalRouterVrfBgpPolicyImportOutputReference(this, "import");
  public get import() {
    return this._import;
  }
  public putImport(value: LogicalRouterVrfBgpPolicyImport) {
    this._import.internalValue = value;
  }
  public resetImport() {
    this._import.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get importInput() {
    return this._import.internalValue;
  }
}
export interface LogicalRouterVrfBgpRedistRules {
  /**
  * Address family identifier
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#address_family_identifier LogicalRouter#address_family_identifier}
  */
  readonly addressFamilyIdentifier?: string;
  /**
  * Enable
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#enable LogicalRouter#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * Metric
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#metric LogicalRouter#metric}
  */
  readonly metric?: number;
  /**
  * Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#name LogicalRouter#name}
  */
  readonly name: string;
  /**
  * Route table
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#route_table LogicalRouter#route_table}
  */
  readonly routeTable?: string;
  /**
  * Set as path limit
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#set_as_path_limit LogicalRouter#set_as_path_limit}
  */
  readonly setAsPathLimit?: number;
  /**
  * Set community
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#set_community LogicalRouter#set_community}
  */
  readonly setCommunity?: string[];
  /**
  * Set extended community
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#set_extended_community LogicalRouter#set_extended_community}
  */
  readonly setExtendedCommunity?: string[];
  /**
  * Set local preference
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#set_local_preference LogicalRouter#set_local_preference}
  */
  readonly setLocalPreference?: number;
  /**
  * Set med
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#set_med LogicalRouter#set_med}
  */
  readonly setMed?: number;
  /**
  * Set origin
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#set_origin LogicalRouter#set_origin}
  */
  readonly setOrigin?: string;
}

export function logicalRouterVrfBgpRedistRulesToTerraform(struct?: LogicalRouterVrfBgpRedistRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address_family_identifier: cdktf.stringToTerraform(struct!.addressFamilyIdentifier),
    enable: cdktf.booleanToTerraform(struct!.enable),
    metric: cdktf.numberToTerraform(struct!.metric),
    name: cdktf.stringToTerraform(struct!.name),
    route_table: cdktf.stringToTerraform(struct!.routeTable),
    set_as_path_limit: cdktf.numberToTerraform(struct!.setAsPathLimit),
    set_community: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.setCommunity),
    set_extended_community: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.setExtendedCommunity),
    set_local_preference: cdktf.numberToTerraform(struct!.setLocalPreference),
    set_med: cdktf.numberToTerraform(struct!.setMed),
    set_origin: cdktf.stringToTerraform(struct!.setOrigin),
  }
}


export function logicalRouterVrfBgpRedistRulesToHclTerraform(struct?: LogicalRouterVrfBgpRedistRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address_family_identifier: {
      value: cdktf.stringToHclTerraform(struct!.addressFamilyIdentifier),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    metric: {
      value: cdktf.numberToHclTerraform(struct!.metric),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    route_table: {
      value: cdktf.stringToHclTerraform(struct!.routeTable),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    set_as_path_limit: {
      value: cdktf.numberToHclTerraform(struct!.setAsPathLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    set_community: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.setCommunity),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    set_extended_community: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.setExtendedCommunity),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    set_local_preference: {
      value: cdktf.numberToHclTerraform(struct!.setLocalPreference),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    set_med: {
      value: cdktf.numberToHclTerraform(struct!.setMed),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    set_origin: {
      value: cdktf.stringToHclTerraform(struct!.setOrigin),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpRedistRulesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): LogicalRouterVrfBgpRedistRules | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addressFamilyIdentifier !== undefined) {
      hasAnyValues = true;
      internalValueResult.addressFamilyIdentifier = this._addressFamilyIdentifier;
    }
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._metric !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._routeTable !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeTable = this._routeTable;
    }
    if (this._setAsPathLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.setAsPathLimit = this._setAsPathLimit;
    }
    if (this._setCommunity !== undefined) {
      hasAnyValues = true;
      internalValueResult.setCommunity = this._setCommunity;
    }
    if (this._setExtendedCommunity !== undefined) {
      hasAnyValues = true;
      internalValueResult.setExtendedCommunity = this._setExtendedCommunity;
    }
    if (this._setLocalPreference !== undefined) {
      hasAnyValues = true;
      internalValueResult.setLocalPreference = this._setLocalPreference;
    }
    if (this._setMed !== undefined) {
      hasAnyValues = true;
      internalValueResult.setMed = this._setMed;
    }
    if (this._setOrigin !== undefined) {
      hasAnyValues = true;
      internalValueResult.setOrigin = this._setOrigin;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpRedistRules | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addressFamilyIdentifier = undefined;
      this._enable = undefined;
      this._metric = undefined;
      this._name = undefined;
      this._routeTable = undefined;
      this._setAsPathLimit = undefined;
      this._setCommunity = undefined;
      this._setExtendedCommunity = undefined;
      this._setLocalPreference = undefined;
      this._setMed = undefined;
      this._setOrigin = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addressFamilyIdentifier = value.addressFamilyIdentifier;
      this._enable = value.enable;
      this._metric = value.metric;
      this._name = value.name;
      this._routeTable = value.routeTable;
      this._setAsPathLimit = value.setAsPathLimit;
      this._setCommunity = value.setCommunity;
      this._setExtendedCommunity = value.setExtendedCommunity;
      this._setLocalPreference = value.setLocalPreference;
      this._setMed = value.setMed;
      this._setOrigin = value.setOrigin;
    }
  }

  // address_family_identifier - computed: false, optional: true, required: false
  private _addressFamilyIdentifier?: string; 
  public get addressFamilyIdentifier() {
    return this.getStringAttribute('address_family_identifier');
  }
  public set addressFamilyIdentifier(value: string) {
    this._addressFamilyIdentifier = value;
  }
  public resetAddressFamilyIdentifier() {
    this._addressFamilyIdentifier = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressFamilyIdentifierInput() {
    return this._addressFamilyIdentifier;
  }

  // enable - computed: false, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // metric - computed: false, optional: true, required: false
  private _metric?: number; 
  public get metric() {
    return this.getNumberAttribute('metric');
  }
  public set metric(value: number) {
    this._metric = value;
  }
  public resetMetric() {
    this._metric = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // route_table - computed: false, optional: true, required: false
  private _routeTable?: string; 
  public get routeTable() {
    return this.getStringAttribute('route_table');
  }
  public set routeTable(value: string) {
    this._routeTable = value;
  }
  public resetRouteTable() {
    this._routeTable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeTableInput() {
    return this._routeTable;
  }

  // set_as_path_limit - computed: false, optional: true, required: false
  private _setAsPathLimit?: number; 
  public get setAsPathLimit() {
    return this.getNumberAttribute('set_as_path_limit');
  }
  public set setAsPathLimit(value: number) {
    this._setAsPathLimit = value;
  }
  public resetSetAsPathLimit() {
    this._setAsPathLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setAsPathLimitInput() {
    return this._setAsPathLimit;
  }

  // set_community - computed: false, optional: true, required: false
  private _setCommunity?: string[]; 
  public get setCommunity() {
    return this.getListAttribute('set_community');
  }
  public set setCommunity(value: string[]) {
    this._setCommunity = value;
  }
  public resetSetCommunity() {
    this._setCommunity = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setCommunityInput() {
    return this._setCommunity;
  }

  // set_extended_community - computed: false, optional: true, required: false
  private _setExtendedCommunity?: string[]; 
  public get setExtendedCommunity() {
    return this.getListAttribute('set_extended_community');
  }
  public set setExtendedCommunity(value: string[]) {
    this._setExtendedCommunity = value;
  }
  public resetSetExtendedCommunity() {
    this._setExtendedCommunity = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setExtendedCommunityInput() {
    return this._setExtendedCommunity;
  }

  // set_local_preference - computed: false, optional: true, required: false
  private _setLocalPreference?: number; 
  public get setLocalPreference() {
    return this.getNumberAttribute('set_local_preference');
  }
  public set setLocalPreference(value: number) {
    this._setLocalPreference = value;
  }
  public resetSetLocalPreference() {
    this._setLocalPreference = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setLocalPreferenceInput() {
    return this._setLocalPreference;
  }

  // set_med - computed: false, optional: true, required: false
  private _setMed?: number; 
  public get setMed() {
    return this.getNumberAttribute('set_med');
  }
  public set setMed(value: number) {
    this._setMed = value;
  }
  public resetSetMed() {
    this._setMed = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setMedInput() {
    return this._setMed;
  }

  // set_origin - computed: false, optional: true, required: false
  private _setOrigin?: string; 
  public get setOrigin() {
    return this.getStringAttribute('set_origin');
  }
  public set setOrigin(value: string) {
    this._setOrigin = value;
  }
  public resetSetOrigin() {
    this._setOrigin = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setOriginInput() {
    return this._setOrigin;
  }
}

export class LogicalRouterVrfBgpRedistRulesList extends cdktf.ComplexList {
  public internalValue? : LogicalRouterVrfBgpRedistRules[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): LogicalRouterVrfBgpRedistRulesOutputReference {
    return new LogicalRouterVrfBgpRedistRulesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface LogicalRouterVrfBgpRedistributionProfileIpv4 {
  /**
  * Unicast
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#unicast LogicalRouter#unicast}
  */
  readonly unicast?: string;
}

export function logicalRouterVrfBgpRedistributionProfileIpv4ToTerraform(struct?: LogicalRouterVrfBgpRedistributionProfileIpv4 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    unicast: cdktf.stringToTerraform(struct!.unicast),
  }
}


export function logicalRouterVrfBgpRedistributionProfileIpv4ToHclTerraform(struct?: LogicalRouterVrfBgpRedistributionProfileIpv4 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    unicast: {
      value: cdktf.stringToHclTerraform(struct!.unicast),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpRedistributionProfileIpv4OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpRedistributionProfileIpv4 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._unicast !== undefined) {
      hasAnyValues = true;
      internalValueResult.unicast = this._unicast;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpRedistributionProfileIpv4 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._unicast = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._unicast = value.unicast;
    }
  }

  // unicast - computed: false, optional: true, required: false
  private _unicast?: string; 
  public get unicast() {
    return this.getStringAttribute('unicast');
  }
  public set unicast(value: string) {
    this._unicast = value;
  }
  public resetUnicast() {
    this._unicast = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get unicastInput() {
    return this._unicast;
  }
}
export interface LogicalRouterVrfBgpRedistributionProfileIpv6 {
  /**
  * Unicast
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#unicast LogicalRouter#unicast}
  */
  readonly unicast?: string;
}

export function logicalRouterVrfBgpRedistributionProfileIpv6ToTerraform(struct?: LogicalRouterVrfBgpRedistributionProfileIpv6 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    unicast: cdktf.stringToTerraform(struct!.unicast),
  }
}


export function logicalRouterVrfBgpRedistributionProfileIpv6ToHclTerraform(struct?: LogicalRouterVrfBgpRedistributionProfileIpv6 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    unicast: {
      value: cdktf.stringToHclTerraform(struct!.unicast),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpRedistributionProfileIpv6OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpRedistributionProfileIpv6 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._unicast !== undefined) {
      hasAnyValues = true;
      internalValueResult.unicast = this._unicast;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpRedistributionProfileIpv6 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._unicast = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._unicast = value.unicast;
    }
  }

  // unicast - computed: false, optional: true, required: false
  private _unicast?: string; 
  public get unicast() {
    return this.getStringAttribute('unicast');
  }
  public set unicast(value: string) {
    this._unicast = value;
  }
  public resetUnicast() {
    this._unicast = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get unicastInput() {
    return this._unicast;
  }
}
export interface LogicalRouterVrfBgpRedistributionProfile {
  /**
  * Ipv4
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#ipv4 LogicalRouter#ipv4}
  */
  readonly ipv4?: LogicalRouterVrfBgpRedistributionProfileIpv4;
  /**
  * Ipv6
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#ipv6 LogicalRouter#ipv6}
  */
  readonly ipv6?: LogicalRouterVrfBgpRedistributionProfileIpv6;
}

export function logicalRouterVrfBgpRedistributionProfileToTerraform(struct?: LogicalRouterVrfBgpRedistributionProfile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ipv4: logicalRouterVrfBgpRedistributionProfileIpv4ToTerraform(struct!.ipv4),
    ipv6: logicalRouterVrfBgpRedistributionProfileIpv6ToTerraform(struct!.ipv6),
  }
}


export function logicalRouterVrfBgpRedistributionProfileToHclTerraform(struct?: LogicalRouterVrfBgpRedistributionProfile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ipv4: {
      value: logicalRouterVrfBgpRedistributionProfileIpv4ToHclTerraform(struct!.ipv4),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpRedistributionProfileIpv4",
    },
    ipv6: {
      value: logicalRouterVrfBgpRedistributionProfileIpv6ToHclTerraform(struct!.ipv6),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpRedistributionProfileIpv6",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpRedistributionProfileOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgpRedistributionProfile | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ipv4?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipv4 = this._ipv4?.internalValue;
    }
    if (this._ipv6?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipv6 = this._ipv6?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgpRedistributionProfile | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ipv4.internalValue = undefined;
      this._ipv6.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ipv4.internalValue = value.ipv4;
      this._ipv6.internalValue = value.ipv6;
    }
  }

  // ipv4 - computed: false, optional: true, required: false
  private _ipv4 = new LogicalRouterVrfBgpRedistributionProfileIpv4OutputReference(this, "ipv4");
  public get ipv4() {
    return this._ipv4;
  }
  public putIpv4(value: LogicalRouterVrfBgpRedistributionProfileIpv4) {
    this._ipv4.internalValue = value;
  }
  public resetIpv4() {
    this._ipv4.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipv4Input() {
    return this._ipv4.internalValue;
  }

  // ipv6 - computed: false, optional: true, required: false
  private _ipv6 = new LogicalRouterVrfBgpRedistributionProfileIpv6OutputReference(this, "ipv6");
  public get ipv6() {
    return this._ipv6;
  }
  public putIpv6(value: LogicalRouterVrfBgpRedistributionProfileIpv6) {
    this._ipv6.internalValue = value;
  }
  public resetIpv6() {
    this._ipv6.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipv6Input() {
    return this._ipv6.internalValue;
  }
}
export interface LogicalRouterVrfBgp {
  /**
  * Advertise network
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#advertise_network LogicalRouter#advertise_network}
  */
  readonly advertiseNetwork?: LogicalRouterVrfBgpAdvertiseNetwork;
  /**
  * Aggregate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#aggregate LogicalRouter#aggregate}
  */
  readonly aggregate?: LogicalRouterVrfBgpAggregate;
  /**
  * Aggregate routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#aggregate_routes LogicalRouter#aggregate_routes}
  */
  readonly aggregateRoutes?: LogicalRouterVrfBgpAggregateRoutes[] | cdktf.IResolvable;
  /**
  * Allow redist default route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#allow_redist_default_route LogicalRouter#allow_redist_default_route}
  */
  readonly allowRedistDefaultRoute?: boolean | cdktf.IResolvable;
  /**
  * Always advertise network route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#always_advertise_network_route LogicalRouter#always_advertise_network_route}
  */
  readonly alwaysAdvertiseNetworkRoute?: boolean | cdktf.IResolvable;
  /**
  * As format
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#as_format LogicalRouter#as_format}
  */
  readonly asFormat?: string;
  /**
  * Confederation member as
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#confederation_member_as LogicalRouter#confederation_member_as}
  */
  readonly confederationMemberAs?: string;
  /**
  * Default local preference
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#default_local_preference LogicalRouter#default_local_preference}
  */
  readonly defaultLocalPreference?: number;
  /**
  * Ecmp multi as
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#ecmp_multi_as LogicalRouter#ecmp_multi_as}
  */
  readonly ecmpMultiAs?: boolean | cdktf.IResolvable;
  /**
  * Enable
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#enable LogicalRouter#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * Enforce first as
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#enforce_first_as LogicalRouter#enforce_first_as}
  */
  readonly enforceFirstAs?: boolean | cdktf.IResolvable;
  /**
  * Fast external failover
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#fast_external_failover LogicalRouter#fast_external_failover}
  */
  readonly fastExternalFailover?: boolean | cdktf.IResolvable;
  /**
  * Global bfd
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#global_bfd LogicalRouter#global_bfd}
  */
  readonly globalBfd?: LogicalRouterVrfBgpGlobalBfd;
  /**
  * Graceful restart
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#graceful_restart LogicalRouter#graceful_restart}
  */
  readonly gracefulRestart?: LogicalRouterVrfBgpGracefulRestart;
  /**
  * Graceful shutdown
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#graceful_shutdown LogicalRouter#graceful_shutdown}
  */
  readonly gracefulShutdown?: boolean | cdktf.IResolvable;
  /**
  * Install route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#install_route LogicalRouter#install_route}
  */
  readonly installRoute?: boolean | cdktf.IResolvable;
  /**
  * Local as
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#local_as LogicalRouter#local_as}
  */
  readonly localAs?: string;
  /**
  * Med
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#med LogicalRouter#med}
  */
  readonly med?: LogicalRouterVrfBgpMed;
  /**
  * Peer group
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#peer_group LogicalRouter#peer_group}
  */
  readonly peerGroup?: LogicalRouterVrfBgpPeerGroup[] | cdktf.IResolvable;
  /**
  * Policy
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#policy LogicalRouter#policy}
  */
  readonly policy?: LogicalRouterVrfBgpPolicy;
  /**
  * Redist rules
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#redist_rules LogicalRouter#redist_rules}
  */
  readonly redistRules?: LogicalRouterVrfBgpRedistRules[] | cdktf.IResolvable;
  /**
  * Redistribution profile
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#redistribution_profile LogicalRouter#redistribution_profile}
  */
  readonly redistributionProfile?: LogicalRouterVrfBgpRedistributionProfile;
  /**
  * Reject default route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#reject_default_route LogicalRouter#reject_default_route}
  */
  readonly rejectDefaultRoute?: boolean | cdktf.IResolvable;
  /**
  * Router id
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#router_id LogicalRouter#router_id}
  */
  readonly routerId?: string;
}

export function logicalRouterVrfBgpToTerraform(struct?: LogicalRouterVrfBgp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    advertise_network: logicalRouterVrfBgpAdvertiseNetworkToTerraform(struct!.advertiseNetwork),
    aggregate: logicalRouterVrfBgpAggregateToTerraform(struct!.aggregate),
    aggregate_routes: cdktf.listMapper(logicalRouterVrfBgpAggregateRoutesToTerraform, false)(struct!.aggregateRoutes),
    allow_redist_default_route: cdktf.booleanToTerraform(struct!.allowRedistDefaultRoute),
    always_advertise_network_route: cdktf.booleanToTerraform(struct!.alwaysAdvertiseNetworkRoute),
    as_format: cdktf.stringToTerraform(struct!.asFormat),
    confederation_member_as: cdktf.stringToTerraform(struct!.confederationMemberAs),
    default_local_preference: cdktf.numberToTerraform(struct!.defaultLocalPreference),
    ecmp_multi_as: cdktf.booleanToTerraform(struct!.ecmpMultiAs),
    enable: cdktf.booleanToTerraform(struct!.enable),
    enforce_first_as: cdktf.booleanToTerraform(struct!.enforceFirstAs),
    fast_external_failover: cdktf.booleanToTerraform(struct!.fastExternalFailover),
    global_bfd: logicalRouterVrfBgpGlobalBfdToTerraform(struct!.globalBfd),
    graceful_restart: logicalRouterVrfBgpGracefulRestartToTerraform(struct!.gracefulRestart),
    graceful_shutdown: cdktf.booleanToTerraform(struct!.gracefulShutdown),
    install_route: cdktf.booleanToTerraform(struct!.installRoute),
    local_as: cdktf.stringToTerraform(struct!.localAs),
    med: logicalRouterVrfBgpMedToTerraform(struct!.med),
    peer_group: cdktf.listMapper(logicalRouterVrfBgpPeerGroupToTerraform, false)(struct!.peerGroup),
    policy: logicalRouterVrfBgpPolicyToTerraform(struct!.policy),
    redist_rules: cdktf.listMapper(logicalRouterVrfBgpRedistRulesToTerraform, false)(struct!.redistRules),
    redistribution_profile: logicalRouterVrfBgpRedistributionProfileToTerraform(struct!.redistributionProfile),
    reject_default_route: cdktf.booleanToTerraform(struct!.rejectDefaultRoute),
    router_id: cdktf.stringToTerraform(struct!.routerId),
  }
}


export function logicalRouterVrfBgpToHclTerraform(struct?: LogicalRouterVrfBgp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    advertise_network: {
      value: logicalRouterVrfBgpAdvertiseNetworkToHclTerraform(struct!.advertiseNetwork),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpAdvertiseNetwork",
    },
    aggregate: {
      value: logicalRouterVrfBgpAggregateToHclTerraform(struct!.aggregate),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpAggregate",
    },
    aggregate_routes: {
      value: cdktf.listMapperHcl(logicalRouterVrfBgpAggregateRoutesToHclTerraform, false)(struct!.aggregateRoutes),
      isBlock: true,
      type: "list",
      storageClassType: "LogicalRouterVrfBgpAggregateRoutesList",
    },
    allow_redist_default_route: {
      value: cdktf.booleanToHclTerraform(struct!.allowRedistDefaultRoute),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    always_advertise_network_route: {
      value: cdktf.booleanToHclTerraform(struct!.alwaysAdvertiseNetworkRoute),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    as_format: {
      value: cdktf.stringToHclTerraform(struct!.asFormat),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    confederation_member_as: {
      value: cdktf.stringToHclTerraform(struct!.confederationMemberAs),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    default_local_preference: {
      value: cdktf.numberToHclTerraform(struct!.defaultLocalPreference),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    ecmp_multi_as: {
      value: cdktf.booleanToHclTerraform(struct!.ecmpMultiAs),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enforce_first_as: {
      value: cdktf.booleanToHclTerraform(struct!.enforceFirstAs),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    fast_external_failover: {
      value: cdktf.booleanToHclTerraform(struct!.fastExternalFailover),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    global_bfd: {
      value: logicalRouterVrfBgpGlobalBfdToHclTerraform(struct!.globalBfd),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpGlobalBfd",
    },
    graceful_restart: {
      value: logicalRouterVrfBgpGracefulRestartToHclTerraform(struct!.gracefulRestart),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpGracefulRestart",
    },
    graceful_shutdown: {
      value: cdktf.booleanToHclTerraform(struct!.gracefulShutdown),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    install_route: {
      value: cdktf.booleanToHclTerraform(struct!.installRoute),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    local_as: {
      value: cdktf.stringToHclTerraform(struct!.localAs),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    med: {
      value: logicalRouterVrfBgpMedToHclTerraform(struct!.med),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpMed",
    },
    peer_group: {
      value: cdktf.listMapperHcl(logicalRouterVrfBgpPeerGroupToHclTerraform, false)(struct!.peerGroup),
      isBlock: true,
      type: "list",
      storageClassType: "LogicalRouterVrfBgpPeerGroupList",
    },
    policy: {
      value: logicalRouterVrfBgpPolicyToHclTerraform(struct!.policy),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpPolicy",
    },
    redist_rules: {
      value: cdktf.listMapperHcl(logicalRouterVrfBgpRedistRulesToHclTerraform, false)(struct!.redistRules),
      isBlock: true,
      type: "list",
      storageClassType: "LogicalRouterVrfBgpRedistRulesList",
    },
    redistribution_profile: {
      value: logicalRouterVrfBgpRedistributionProfileToHclTerraform(struct!.redistributionProfile),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfBgpRedistributionProfile",
    },
    reject_default_route: {
      value: cdktf.booleanToHclTerraform(struct!.rejectDefaultRoute),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    router_id: {
      value: cdktf.stringToHclTerraform(struct!.routerId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfBgpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfBgp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._advertiseNetwork?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.advertiseNetwork = this._advertiseNetwork?.internalValue;
    }
    if (this._aggregate?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.aggregate = this._aggregate?.internalValue;
    }
    if (this._aggregateRoutes?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.aggregateRoutes = this._aggregateRoutes?.internalValue;
    }
    if (this._allowRedistDefaultRoute !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowRedistDefaultRoute = this._allowRedistDefaultRoute;
    }
    if (this._alwaysAdvertiseNetworkRoute !== undefined) {
      hasAnyValues = true;
      internalValueResult.alwaysAdvertiseNetworkRoute = this._alwaysAdvertiseNetworkRoute;
    }
    if (this._asFormat !== undefined) {
      hasAnyValues = true;
      internalValueResult.asFormat = this._asFormat;
    }
    if (this._confederationMemberAs !== undefined) {
      hasAnyValues = true;
      internalValueResult.confederationMemberAs = this._confederationMemberAs;
    }
    if (this._defaultLocalPreference !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultLocalPreference = this._defaultLocalPreference;
    }
    if (this._ecmpMultiAs !== undefined) {
      hasAnyValues = true;
      internalValueResult.ecmpMultiAs = this._ecmpMultiAs;
    }
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._enforceFirstAs !== undefined) {
      hasAnyValues = true;
      internalValueResult.enforceFirstAs = this._enforceFirstAs;
    }
    if (this._fastExternalFailover !== undefined) {
      hasAnyValues = true;
      internalValueResult.fastExternalFailover = this._fastExternalFailover;
    }
    if (this._globalBfd?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.globalBfd = this._globalBfd?.internalValue;
    }
    if (this._gracefulRestart?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.gracefulRestart = this._gracefulRestart?.internalValue;
    }
    if (this._gracefulShutdown !== undefined) {
      hasAnyValues = true;
      internalValueResult.gracefulShutdown = this._gracefulShutdown;
    }
    if (this._installRoute !== undefined) {
      hasAnyValues = true;
      internalValueResult.installRoute = this._installRoute;
    }
    if (this._localAs !== undefined) {
      hasAnyValues = true;
      internalValueResult.localAs = this._localAs;
    }
    if (this._med?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.med = this._med?.internalValue;
    }
    if (this._peerGroup?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.peerGroup = this._peerGroup?.internalValue;
    }
    if (this._policy?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.policy = this._policy?.internalValue;
    }
    if (this._redistRules?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.redistRules = this._redistRules?.internalValue;
    }
    if (this._redistributionProfile?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.redistributionProfile = this._redistributionProfile?.internalValue;
    }
    if (this._rejectDefaultRoute !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectDefaultRoute = this._rejectDefaultRoute;
    }
    if (this._routerId !== undefined) {
      hasAnyValues = true;
      internalValueResult.routerId = this._routerId;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfBgp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._advertiseNetwork.internalValue = undefined;
      this._aggregate.internalValue = undefined;
      this._aggregateRoutes.internalValue = undefined;
      this._allowRedistDefaultRoute = undefined;
      this._alwaysAdvertiseNetworkRoute = undefined;
      this._asFormat = undefined;
      this._confederationMemberAs = undefined;
      this._defaultLocalPreference = undefined;
      this._ecmpMultiAs = undefined;
      this._enable = undefined;
      this._enforceFirstAs = undefined;
      this._fastExternalFailover = undefined;
      this._globalBfd.internalValue = undefined;
      this._gracefulRestart.internalValue = undefined;
      this._gracefulShutdown = undefined;
      this._installRoute = undefined;
      this._localAs = undefined;
      this._med.internalValue = undefined;
      this._peerGroup.internalValue = undefined;
      this._policy.internalValue = undefined;
      this._redistRules.internalValue = undefined;
      this._redistributionProfile.internalValue = undefined;
      this._rejectDefaultRoute = undefined;
      this._routerId = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._advertiseNetwork.internalValue = value.advertiseNetwork;
      this._aggregate.internalValue = value.aggregate;
      this._aggregateRoutes.internalValue = value.aggregateRoutes;
      this._allowRedistDefaultRoute = value.allowRedistDefaultRoute;
      this._alwaysAdvertiseNetworkRoute = value.alwaysAdvertiseNetworkRoute;
      this._asFormat = value.asFormat;
      this._confederationMemberAs = value.confederationMemberAs;
      this._defaultLocalPreference = value.defaultLocalPreference;
      this._ecmpMultiAs = value.ecmpMultiAs;
      this._enable = value.enable;
      this._enforceFirstAs = value.enforceFirstAs;
      this._fastExternalFailover = value.fastExternalFailover;
      this._globalBfd.internalValue = value.globalBfd;
      this._gracefulRestart.internalValue = value.gracefulRestart;
      this._gracefulShutdown = value.gracefulShutdown;
      this._installRoute = value.installRoute;
      this._localAs = value.localAs;
      this._med.internalValue = value.med;
      this._peerGroup.internalValue = value.peerGroup;
      this._policy.internalValue = value.policy;
      this._redistRules.internalValue = value.redistRules;
      this._redistributionProfile.internalValue = value.redistributionProfile;
      this._rejectDefaultRoute = value.rejectDefaultRoute;
      this._routerId = value.routerId;
    }
  }

  // advertise_network - computed: false, optional: true, required: false
  private _advertiseNetwork = new LogicalRouterVrfBgpAdvertiseNetworkOutputReference(this, "advertise_network");
  public get advertiseNetwork() {
    return this._advertiseNetwork;
  }
  public putAdvertiseNetwork(value: LogicalRouterVrfBgpAdvertiseNetwork) {
    this._advertiseNetwork.internalValue = value;
  }
  public resetAdvertiseNetwork() {
    this._advertiseNetwork.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get advertiseNetworkInput() {
    return this._advertiseNetwork.internalValue;
  }

  // aggregate - computed: false, optional: true, required: false
  private _aggregate = new LogicalRouterVrfBgpAggregateOutputReference(this, "aggregate");
  public get aggregate() {
    return this._aggregate;
  }
  public putAggregate(value: LogicalRouterVrfBgpAggregate) {
    this._aggregate.internalValue = value;
  }
  public resetAggregate() {
    this._aggregate.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aggregateInput() {
    return this._aggregate.internalValue;
  }

  // aggregate_routes - computed: false, optional: true, required: false
  private _aggregateRoutes = new LogicalRouterVrfBgpAggregateRoutesList(this, "aggregate_routes", false);
  public get aggregateRoutes() {
    return this._aggregateRoutes;
  }
  public putAggregateRoutes(value: LogicalRouterVrfBgpAggregateRoutes[] | cdktf.IResolvable) {
    this._aggregateRoutes.internalValue = value;
  }
  public resetAggregateRoutes() {
    this._aggregateRoutes.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aggregateRoutesInput() {
    return this._aggregateRoutes.internalValue;
  }

  // allow_redist_default_route - computed: false, optional: true, required: false
  private _allowRedistDefaultRoute?: boolean | cdktf.IResolvable; 
  public get allowRedistDefaultRoute() {
    return this.getBooleanAttribute('allow_redist_default_route');
  }
  public set allowRedistDefaultRoute(value: boolean | cdktf.IResolvable) {
    this._allowRedistDefaultRoute = value;
  }
  public resetAllowRedistDefaultRoute() {
    this._allowRedistDefaultRoute = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowRedistDefaultRouteInput() {
    return this._allowRedistDefaultRoute;
  }

  // always_advertise_network_route - computed: false, optional: true, required: false
  private _alwaysAdvertiseNetworkRoute?: boolean | cdktf.IResolvable; 
  public get alwaysAdvertiseNetworkRoute() {
    return this.getBooleanAttribute('always_advertise_network_route');
  }
  public set alwaysAdvertiseNetworkRoute(value: boolean | cdktf.IResolvable) {
    this._alwaysAdvertiseNetworkRoute = value;
  }
  public resetAlwaysAdvertiseNetworkRoute() {
    this._alwaysAdvertiseNetworkRoute = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get alwaysAdvertiseNetworkRouteInput() {
    return this._alwaysAdvertiseNetworkRoute;
  }

  // as_format - computed: false, optional: true, required: false
  private _asFormat?: string; 
  public get asFormat() {
    return this.getStringAttribute('as_format');
  }
  public set asFormat(value: string) {
    this._asFormat = value;
  }
  public resetAsFormat() {
    this._asFormat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asFormatInput() {
    return this._asFormat;
  }

  // confederation_member_as - computed: false, optional: true, required: false
  private _confederationMemberAs?: string; 
  public get confederationMemberAs() {
    return this.getStringAttribute('confederation_member_as');
  }
  public set confederationMemberAs(value: string) {
    this._confederationMemberAs = value;
  }
  public resetConfederationMemberAs() {
    this._confederationMemberAs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get confederationMemberAsInput() {
    return this._confederationMemberAs;
  }

  // default_local_preference - computed: false, optional: true, required: false
  private _defaultLocalPreference?: number; 
  public get defaultLocalPreference() {
    return this.getNumberAttribute('default_local_preference');
  }
  public set defaultLocalPreference(value: number) {
    this._defaultLocalPreference = value;
  }
  public resetDefaultLocalPreference() {
    this._defaultLocalPreference = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultLocalPreferenceInput() {
    return this._defaultLocalPreference;
  }

  // ecmp_multi_as - computed: false, optional: true, required: false
  private _ecmpMultiAs?: boolean | cdktf.IResolvable; 
  public get ecmpMultiAs() {
    return this.getBooleanAttribute('ecmp_multi_as');
  }
  public set ecmpMultiAs(value: boolean | cdktf.IResolvable) {
    this._ecmpMultiAs = value;
  }
  public resetEcmpMultiAs() {
    this._ecmpMultiAs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ecmpMultiAsInput() {
    return this._ecmpMultiAs;
  }

  // enable - computed: false, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // enforce_first_as - computed: false, optional: true, required: false
  private _enforceFirstAs?: boolean | cdktf.IResolvable; 
  public get enforceFirstAs() {
    return this.getBooleanAttribute('enforce_first_as');
  }
  public set enforceFirstAs(value: boolean | cdktf.IResolvable) {
    this._enforceFirstAs = value;
  }
  public resetEnforceFirstAs() {
    this._enforceFirstAs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enforceFirstAsInput() {
    return this._enforceFirstAs;
  }

  // fast_external_failover - computed: false, optional: true, required: false
  private _fastExternalFailover?: boolean | cdktf.IResolvable; 
  public get fastExternalFailover() {
    return this.getBooleanAttribute('fast_external_failover');
  }
  public set fastExternalFailover(value: boolean | cdktf.IResolvable) {
    this._fastExternalFailover = value;
  }
  public resetFastExternalFailover() {
    this._fastExternalFailover = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fastExternalFailoverInput() {
    return this._fastExternalFailover;
  }

  // global_bfd - computed: false, optional: true, required: false
  private _globalBfd = new LogicalRouterVrfBgpGlobalBfdOutputReference(this, "global_bfd");
  public get globalBfd() {
    return this._globalBfd;
  }
  public putGlobalBfd(value: LogicalRouterVrfBgpGlobalBfd) {
    this._globalBfd.internalValue = value;
  }
  public resetGlobalBfd() {
    this._globalBfd.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get globalBfdInput() {
    return this._globalBfd.internalValue;
  }

  // graceful_restart - computed: false, optional: true, required: false
  private _gracefulRestart = new LogicalRouterVrfBgpGracefulRestartOutputReference(this, "graceful_restart");
  public get gracefulRestart() {
    return this._gracefulRestart;
  }
  public putGracefulRestart(value: LogicalRouterVrfBgpGracefulRestart) {
    this._gracefulRestart.internalValue = value;
  }
  public resetGracefulRestart() {
    this._gracefulRestart.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gracefulRestartInput() {
    return this._gracefulRestart.internalValue;
  }

  // graceful_shutdown - computed: false, optional: true, required: false
  private _gracefulShutdown?: boolean | cdktf.IResolvable; 
  public get gracefulShutdown() {
    return this.getBooleanAttribute('graceful_shutdown');
  }
  public set gracefulShutdown(value: boolean | cdktf.IResolvable) {
    this._gracefulShutdown = value;
  }
  public resetGracefulShutdown() {
    this._gracefulShutdown = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gracefulShutdownInput() {
    return this._gracefulShutdown;
  }

  // install_route - computed: false, optional: true, required: false
  private _installRoute?: boolean | cdktf.IResolvable; 
  public get installRoute() {
    return this.getBooleanAttribute('install_route');
  }
  public set installRoute(value: boolean | cdktf.IResolvable) {
    this._installRoute = value;
  }
  public resetInstallRoute() {
    this._installRoute = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get installRouteInput() {
    return this._installRoute;
  }

  // local_as - computed: false, optional: true, required: false
  private _localAs?: string; 
  public get localAs() {
    return this.getStringAttribute('local_as');
  }
  public set localAs(value: string) {
    this._localAs = value;
  }
  public resetLocalAs() {
    this._localAs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localAsInput() {
    return this._localAs;
  }

  // med - computed: false, optional: true, required: false
  private _med = new LogicalRouterVrfBgpMedOutputReference(this, "med");
  public get med() {
    return this._med;
  }
  public putMed(value: LogicalRouterVrfBgpMed) {
    this._med.internalValue = value;
  }
  public resetMed() {
    this._med.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get medInput() {
    return this._med.internalValue;
  }

  // peer_group - computed: false, optional: true, required: false
  private _peerGroup = new LogicalRouterVrfBgpPeerGroupList(this, "peer_group", false);
  public get peerGroup() {
    return this._peerGroup;
  }
  public putPeerGroup(value: LogicalRouterVrfBgpPeerGroup[] | cdktf.IResolvable) {
    this._peerGroup.internalValue = value;
  }
  public resetPeerGroup() {
    this._peerGroup.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get peerGroupInput() {
    return this._peerGroup.internalValue;
  }

  // policy - computed: false, optional: true, required: false
  private _policy = new LogicalRouterVrfBgpPolicyOutputReference(this, "policy");
  public get policy() {
    return this._policy;
  }
  public putPolicy(value: LogicalRouterVrfBgpPolicy) {
    this._policy.internalValue = value;
  }
  public resetPolicy() {
    this._policy.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get policyInput() {
    return this._policy.internalValue;
  }

  // redist_rules - computed: false, optional: true, required: false
  private _redistRules = new LogicalRouterVrfBgpRedistRulesList(this, "redist_rules", false);
  public get redistRules() {
    return this._redistRules;
  }
  public putRedistRules(value: LogicalRouterVrfBgpRedistRules[] | cdktf.IResolvable) {
    this._redistRules.internalValue = value;
  }
  public resetRedistRules() {
    this._redistRules.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get redistRulesInput() {
    return this._redistRules.internalValue;
  }

  // redistribution_profile - computed: false, optional: true, required: false
  private _redistributionProfile = new LogicalRouterVrfBgpRedistributionProfileOutputReference(this, "redistribution_profile");
  public get redistributionProfile() {
    return this._redistributionProfile;
  }
  public putRedistributionProfile(value: LogicalRouterVrfBgpRedistributionProfile) {
    this._redistributionProfile.internalValue = value;
  }
  public resetRedistributionProfile() {
    this._redistributionProfile.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get redistributionProfileInput() {
    return this._redistributionProfile.internalValue;
  }

  // reject_default_route - computed: false, optional: true, required: false
  private _rejectDefaultRoute?: boolean | cdktf.IResolvable; 
  public get rejectDefaultRoute() {
    return this.getBooleanAttribute('reject_default_route');
  }
  public set rejectDefaultRoute(value: boolean | cdktf.IResolvable) {
    this._rejectDefaultRoute = value;
  }
  public resetRejectDefaultRoute() {
    this._rejectDefaultRoute = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectDefaultRouteInput() {
    return this._rejectDefaultRoute;
  }

  // router_id - computed: false, optional: true, required: false
  private _routerId?: string; 
  public get routerId() {
    return this.getStringAttribute('router_id');
  }
  public set routerId(value: string) {
    this._routerId = value;
  }
  public resetRouterId() {
    this._routerId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routerIdInput() {
    return this._routerId;
  }
}
export interface LogicalRouterVrfEcmpAlgorithmBalancedRoundRobin {
}

export function logicalRouterVrfEcmpAlgorithmBalancedRoundRobinToTerraform(struct?: LogicalRouterVrfEcmpAlgorithmBalancedRoundRobin | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function logicalRouterVrfEcmpAlgorithmBalancedRoundRobinToHclTerraform(struct?: LogicalRouterVrfEcmpAlgorithmBalancedRoundRobin | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class LogicalRouterVrfEcmpAlgorithmBalancedRoundRobinOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfEcmpAlgorithmBalancedRoundRobin | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfEcmpAlgorithmBalancedRoundRobin | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface LogicalRouterVrfEcmpAlgorithmIpHash {
  /**
  * Hash seed
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#hash_seed LogicalRouter#hash_seed}
  */
  readonly hashSeed?: number;
  /**
  * Src only
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#src_only LogicalRouter#src_only}
  */
  readonly srcOnly?: boolean | cdktf.IResolvable;
  /**
  * Use port
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#use_port LogicalRouter#use_port}
  */
  readonly usePort?: boolean | cdktf.IResolvable;
}

export function logicalRouterVrfEcmpAlgorithmIpHashToTerraform(struct?: LogicalRouterVrfEcmpAlgorithmIpHash | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    hash_seed: cdktf.numberToTerraform(struct!.hashSeed),
    src_only: cdktf.booleanToTerraform(struct!.srcOnly),
    use_port: cdktf.booleanToTerraform(struct!.usePort),
  }
}


export function logicalRouterVrfEcmpAlgorithmIpHashToHclTerraform(struct?: LogicalRouterVrfEcmpAlgorithmIpHash | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    hash_seed: {
      value: cdktf.numberToHclTerraform(struct!.hashSeed),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    src_only: {
      value: cdktf.booleanToHclTerraform(struct!.srcOnly),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    use_port: {
      value: cdktf.booleanToHclTerraform(struct!.usePort),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfEcmpAlgorithmIpHashOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfEcmpAlgorithmIpHash | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._hashSeed !== undefined) {
      hasAnyValues = true;
      internalValueResult.hashSeed = this._hashSeed;
    }
    if (this._srcOnly !== undefined) {
      hasAnyValues = true;
      internalValueResult.srcOnly = this._srcOnly;
    }
    if (this._usePort !== undefined) {
      hasAnyValues = true;
      internalValueResult.usePort = this._usePort;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfEcmpAlgorithmIpHash | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._hashSeed = undefined;
      this._srcOnly = undefined;
      this._usePort = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._hashSeed = value.hashSeed;
      this._srcOnly = value.srcOnly;
      this._usePort = value.usePort;
    }
  }

  // hash_seed - computed: false, optional: true, required: false
  private _hashSeed?: number; 
  public get hashSeed() {
    return this.getNumberAttribute('hash_seed');
  }
  public set hashSeed(value: number) {
    this._hashSeed = value;
  }
  public resetHashSeed() {
    this._hashSeed = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hashSeedInput() {
    return this._hashSeed;
  }

  // src_only - computed: false, optional: true, required: false
  private _srcOnly?: boolean | cdktf.IResolvable; 
  public get srcOnly() {
    return this.getBooleanAttribute('src_only');
  }
  public set srcOnly(value: boolean | cdktf.IResolvable) {
    this._srcOnly = value;
  }
  public resetSrcOnly() {
    this._srcOnly = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get srcOnlyInput() {
    return this._srcOnly;
  }

  // use_port - computed: false, optional: true, required: false
  private _usePort?: boolean | cdktf.IResolvable; 
  public get usePort() {
    return this.getBooleanAttribute('use_port');
  }
  public set usePort(value: boolean | cdktf.IResolvable) {
    this._usePort = value;
  }
  public resetUsePort() {
    this._usePort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usePortInput() {
    return this._usePort;
  }
}
export interface LogicalRouterVrfEcmpAlgorithmIpModulo {
}

export function logicalRouterVrfEcmpAlgorithmIpModuloToTerraform(struct?: LogicalRouterVrfEcmpAlgorithmIpModulo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function logicalRouterVrfEcmpAlgorithmIpModuloToHclTerraform(struct?: LogicalRouterVrfEcmpAlgorithmIpModulo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class LogicalRouterVrfEcmpAlgorithmIpModuloOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfEcmpAlgorithmIpModulo | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfEcmpAlgorithmIpModulo | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface LogicalRouterVrfEcmpAlgorithmWeightedRoundRobinInterface {
  /**
  * Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#name LogicalRouter#name}
  */
  readonly name: string;
  /**
  * Weight
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#weight LogicalRouter#weight}
  */
  readonly weight?: number;
}

export function logicalRouterVrfEcmpAlgorithmWeightedRoundRobinInterfaceToTerraform(struct?: LogicalRouterVrfEcmpAlgorithmWeightedRoundRobinInterface | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    weight: cdktf.numberToTerraform(struct!.weight),
  }
}


export function logicalRouterVrfEcmpAlgorithmWeightedRoundRobinInterfaceToHclTerraform(struct?: LogicalRouterVrfEcmpAlgorithmWeightedRoundRobinInterface | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    weight: {
      value: cdktf.numberToHclTerraform(struct!.weight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfEcmpAlgorithmWeightedRoundRobinInterfaceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): LogicalRouterVrfEcmpAlgorithmWeightedRoundRobinInterface | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._weight !== undefined) {
      hasAnyValues = true;
      internalValueResult.weight = this._weight;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfEcmpAlgorithmWeightedRoundRobinInterface | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._weight = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._weight = value.weight;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // weight - computed: false, optional: true, required: false
  private _weight?: number; 
  public get weight() {
    return this.getNumberAttribute('weight');
  }
  public set weight(value: number) {
    this._weight = value;
  }
  public resetWeight() {
    this._weight = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get weightInput() {
    return this._weight;
  }
}

export class LogicalRouterVrfEcmpAlgorithmWeightedRoundRobinInterfaceList extends cdktf.ComplexList {
  public internalValue? : LogicalRouterVrfEcmpAlgorithmWeightedRoundRobinInterface[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): LogicalRouterVrfEcmpAlgorithmWeightedRoundRobinInterfaceOutputReference {
    return new LogicalRouterVrfEcmpAlgorithmWeightedRoundRobinInterfaceOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface LogicalRouterVrfEcmpAlgorithmWeightedRoundRobin {
  /**
  * Interface
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#interface LogicalRouter#interface}
  */
  readonly interface?: LogicalRouterVrfEcmpAlgorithmWeightedRoundRobinInterface[] | cdktf.IResolvable;
}

export function logicalRouterVrfEcmpAlgorithmWeightedRoundRobinToTerraform(struct?: LogicalRouterVrfEcmpAlgorithmWeightedRoundRobin | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    interface: cdktf.listMapper(logicalRouterVrfEcmpAlgorithmWeightedRoundRobinInterfaceToTerraform, false)(struct!.interface),
  }
}


export function logicalRouterVrfEcmpAlgorithmWeightedRoundRobinToHclTerraform(struct?: LogicalRouterVrfEcmpAlgorithmWeightedRoundRobin | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    interface: {
      value: cdktf.listMapperHcl(logicalRouterVrfEcmpAlgorithmWeightedRoundRobinInterfaceToHclTerraform, false)(struct!.interface),
      isBlock: true,
      type: "list",
      storageClassType: "LogicalRouterVrfEcmpAlgorithmWeightedRoundRobinInterfaceList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfEcmpAlgorithmWeightedRoundRobinOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfEcmpAlgorithmWeightedRoundRobin | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._interface?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.interface = this._interface?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfEcmpAlgorithmWeightedRoundRobin | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._interface.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._interface.internalValue = value.interface;
    }
  }

  // interface - computed: false, optional: true, required: false
  private _interface = new LogicalRouterVrfEcmpAlgorithmWeightedRoundRobinInterfaceList(this, "interface", false);
  public get interface() {
    return this._interface;
  }
  public putInterface(value: LogicalRouterVrfEcmpAlgorithmWeightedRoundRobinInterface[] | cdktf.IResolvable) {
    this._interface.internalValue = value;
  }
  public resetInterface() {
    this._interface.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfaceInput() {
    return this._interface.internalValue;
  }
}
export interface LogicalRouterVrfEcmpAlgorithm {
  /**
  * Balanced round robin
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#balanced_round_robin LogicalRouter#balanced_round_robin}
  */
  readonly balancedRoundRobin?: LogicalRouterVrfEcmpAlgorithmBalancedRoundRobin;
  /**
  * Ip hash
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#ip_hash LogicalRouter#ip_hash}
  */
  readonly ipHash?: LogicalRouterVrfEcmpAlgorithmIpHash;
  /**
  * Ip modulo
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#ip_modulo LogicalRouter#ip_modulo}
  */
  readonly ipModulo?: LogicalRouterVrfEcmpAlgorithmIpModulo;
  /**
  * Weighted round robin
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#weighted_round_robin LogicalRouter#weighted_round_robin}
  */
  readonly weightedRoundRobin?: LogicalRouterVrfEcmpAlgorithmWeightedRoundRobin;
}

export function logicalRouterVrfEcmpAlgorithmToTerraform(struct?: LogicalRouterVrfEcmpAlgorithm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    balanced_round_robin: logicalRouterVrfEcmpAlgorithmBalancedRoundRobinToTerraform(struct!.balancedRoundRobin),
    ip_hash: logicalRouterVrfEcmpAlgorithmIpHashToTerraform(struct!.ipHash),
    ip_modulo: logicalRouterVrfEcmpAlgorithmIpModuloToTerraform(struct!.ipModulo),
    weighted_round_robin: logicalRouterVrfEcmpAlgorithmWeightedRoundRobinToTerraform(struct!.weightedRoundRobin),
  }
}


export function logicalRouterVrfEcmpAlgorithmToHclTerraform(struct?: LogicalRouterVrfEcmpAlgorithm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    balanced_round_robin: {
      value: logicalRouterVrfEcmpAlgorithmBalancedRoundRobinToHclTerraform(struct!.balancedRoundRobin),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfEcmpAlgorithmBalancedRoundRobin",
    },
    ip_hash: {
      value: logicalRouterVrfEcmpAlgorithmIpHashToHclTerraform(struct!.ipHash),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfEcmpAlgorithmIpHash",
    },
    ip_modulo: {
      value: logicalRouterVrfEcmpAlgorithmIpModuloToHclTerraform(struct!.ipModulo),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfEcmpAlgorithmIpModulo",
    },
    weighted_round_robin: {
      value: logicalRouterVrfEcmpAlgorithmWeightedRoundRobinToHclTerraform(struct!.weightedRoundRobin),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfEcmpAlgorithmWeightedRoundRobin",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfEcmpAlgorithmOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfEcmpAlgorithm | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._balancedRoundRobin?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.balancedRoundRobin = this._balancedRoundRobin?.internalValue;
    }
    if (this._ipHash?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipHash = this._ipHash?.internalValue;
    }
    if (this._ipModulo?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipModulo = this._ipModulo?.internalValue;
    }
    if (this._weightedRoundRobin?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.weightedRoundRobin = this._weightedRoundRobin?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfEcmpAlgorithm | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._balancedRoundRobin.internalValue = undefined;
      this._ipHash.internalValue = undefined;
      this._ipModulo.internalValue = undefined;
      this._weightedRoundRobin.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._balancedRoundRobin.internalValue = value.balancedRoundRobin;
      this._ipHash.internalValue = value.ipHash;
      this._ipModulo.internalValue = value.ipModulo;
      this._weightedRoundRobin.internalValue = value.weightedRoundRobin;
    }
  }

  // balanced_round_robin - computed: false, optional: true, required: false
  private _balancedRoundRobin = new LogicalRouterVrfEcmpAlgorithmBalancedRoundRobinOutputReference(this, "balanced_round_robin");
  public get balancedRoundRobin() {
    return this._balancedRoundRobin;
  }
  public putBalancedRoundRobin(value: LogicalRouterVrfEcmpAlgorithmBalancedRoundRobin) {
    this._balancedRoundRobin.internalValue = value;
  }
  public resetBalancedRoundRobin() {
    this._balancedRoundRobin.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get balancedRoundRobinInput() {
    return this._balancedRoundRobin.internalValue;
  }

  // ip_hash - computed: false, optional: true, required: false
  private _ipHash = new LogicalRouterVrfEcmpAlgorithmIpHashOutputReference(this, "ip_hash");
  public get ipHash() {
    return this._ipHash;
  }
  public putIpHash(value: LogicalRouterVrfEcmpAlgorithmIpHash) {
    this._ipHash.internalValue = value;
  }
  public resetIpHash() {
    this._ipHash.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipHashInput() {
    return this._ipHash.internalValue;
  }

  // ip_modulo - computed: false, optional: true, required: false
  private _ipModulo = new LogicalRouterVrfEcmpAlgorithmIpModuloOutputReference(this, "ip_modulo");
  public get ipModulo() {
    return this._ipModulo;
  }
  public putIpModulo(value: LogicalRouterVrfEcmpAlgorithmIpModulo) {
    this._ipModulo.internalValue = value;
  }
  public resetIpModulo() {
    this._ipModulo.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipModuloInput() {
    return this._ipModulo.internalValue;
  }

  // weighted_round_robin - computed: false, optional: true, required: false
  private _weightedRoundRobin = new LogicalRouterVrfEcmpAlgorithmWeightedRoundRobinOutputReference(this, "weighted_round_robin");
  public get weightedRoundRobin() {
    return this._weightedRoundRobin;
  }
  public putWeightedRoundRobin(value: LogicalRouterVrfEcmpAlgorithmWeightedRoundRobin) {
    this._weightedRoundRobin.internalValue = value;
  }
  public resetWeightedRoundRobin() {
    this._weightedRoundRobin.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get weightedRoundRobinInput() {
    return this._weightedRoundRobin.internalValue;
  }
}
export interface LogicalRouterVrfEcmp {
  /**
  * Algorithm
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#algorithm LogicalRouter#algorithm}
  */
  readonly algorithm?: LogicalRouterVrfEcmpAlgorithm;
  /**
  * Enable
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#enable LogicalRouter#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * Max path
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#max_path LogicalRouter#max_path}
  */
  readonly maxPath?: number;
  /**
  * Strict source path
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#strict_source_path LogicalRouter#strict_source_path}
  */
  readonly strictSourcePath?: boolean | cdktf.IResolvable;
  /**
  * Symmetric return
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#symmetric_return LogicalRouter#symmetric_return}
  */
  readonly symmetricReturn?: boolean | cdktf.IResolvable;
}

export function logicalRouterVrfEcmpToTerraform(struct?: LogicalRouterVrfEcmp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    algorithm: logicalRouterVrfEcmpAlgorithmToTerraform(struct!.algorithm),
    enable: cdktf.booleanToTerraform(struct!.enable),
    max_path: cdktf.numberToTerraform(struct!.maxPath),
    strict_source_path: cdktf.booleanToTerraform(struct!.strictSourcePath),
    symmetric_return: cdktf.booleanToTerraform(struct!.symmetricReturn),
  }
}


export function logicalRouterVrfEcmpToHclTerraform(struct?: LogicalRouterVrfEcmp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    algorithm: {
      value: logicalRouterVrfEcmpAlgorithmToHclTerraform(struct!.algorithm),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfEcmpAlgorithm",
    },
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_path: {
      value: cdktf.numberToHclTerraform(struct!.maxPath),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    strict_source_path: {
      value: cdktf.booleanToHclTerraform(struct!.strictSourcePath),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    symmetric_return: {
      value: cdktf.booleanToHclTerraform(struct!.symmetricReturn),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfEcmpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfEcmp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._algorithm?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.algorithm = this._algorithm?.internalValue;
    }
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._maxPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPath = this._maxPath;
    }
    if (this._strictSourcePath !== undefined) {
      hasAnyValues = true;
      internalValueResult.strictSourcePath = this._strictSourcePath;
    }
    if (this._symmetricReturn !== undefined) {
      hasAnyValues = true;
      internalValueResult.symmetricReturn = this._symmetricReturn;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfEcmp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._algorithm.internalValue = undefined;
      this._enable = undefined;
      this._maxPath = undefined;
      this._strictSourcePath = undefined;
      this._symmetricReturn = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._algorithm.internalValue = value.algorithm;
      this._enable = value.enable;
      this._maxPath = value.maxPath;
      this._strictSourcePath = value.strictSourcePath;
      this._symmetricReturn = value.symmetricReturn;
    }
  }

  // algorithm - computed: false, optional: true, required: false
  private _algorithm = new LogicalRouterVrfEcmpAlgorithmOutputReference(this, "algorithm");
  public get algorithm() {
    return this._algorithm;
  }
  public putAlgorithm(value: LogicalRouterVrfEcmpAlgorithm) {
    this._algorithm.internalValue = value;
  }
  public resetAlgorithm() {
    this._algorithm.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get algorithmInput() {
    return this._algorithm.internalValue;
  }

  // enable - computed: false, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // max_path - computed: false, optional: true, required: false
  private _maxPath?: number; 
  public get maxPath() {
    return this.getNumberAttribute('max_path');
  }
  public set maxPath(value: number) {
    this._maxPath = value;
  }
  public resetMaxPath() {
    this._maxPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPathInput() {
    return this._maxPath;
  }

  // strict_source_path - computed: false, optional: true, required: false
  private _strictSourcePath?: boolean | cdktf.IResolvable; 
  public get strictSourcePath() {
    return this.getBooleanAttribute('strict_source_path');
  }
  public set strictSourcePath(value: boolean | cdktf.IResolvable) {
    this._strictSourcePath = value;
  }
  public resetStrictSourcePath() {
    this._strictSourcePath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get strictSourcePathInput() {
    return this._strictSourcePath;
  }

  // symmetric_return - computed: false, optional: true, required: false
  private _symmetricReturn?: boolean | cdktf.IResolvable; 
  public get symmetricReturn() {
    return this.getBooleanAttribute('symmetric_return');
  }
  public set symmetricReturn(value: boolean | cdktf.IResolvable) {
    this._symmetricReturn = value;
  }
  public resetSymmetricReturn() {
    this._symmetricReturn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get symmetricReturnInput() {
    return this._symmetricReturn;
  }
}
export interface LogicalRouterVrfMulticastIgmpDynamicInterface {
  /**
  * Group filter
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#group_filter LogicalRouter#group_filter}
  */
  readonly groupFilter?: string;
  /**
  * Max groups
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#max_groups LogicalRouter#max_groups}
  */
  readonly maxGroups?: string;
  /**
  * Max sources
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#max_sources LogicalRouter#max_sources}
  */
  readonly maxSources?: string;
  /**
  * Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#name LogicalRouter#name}
  */
  readonly name: string;
  /**
  * Query profile
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#query_profile LogicalRouter#query_profile}
  */
  readonly queryProfile?: string;
  /**
  * Robustness
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#robustness LogicalRouter#robustness}
  */
  readonly robustness?: string;
  /**
  * Router alert policing
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#router_alert_policing LogicalRouter#router_alert_policing}
  */
  readonly routerAlertPolicing?: boolean | cdktf.IResolvable;
  /**
  * Version
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#version LogicalRouter#version}
  */
  readonly version?: string;
}

export function logicalRouterVrfMulticastIgmpDynamicInterfaceToTerraform(struct?: LogicalRouterVrfMulticastIgmpDynamicInterface | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    group_filter: cdktf.stringToTerraform(struct!.groupFilter),
    max_groups: cdktf.stringToTerraform(struct!.maxGroups),
    max_sources: cdktf.stringToTerraform(struct!.maxSources),
    name: cdktf.stringToTerraform(struct!.name),
    query_profile: cdktf.stringToTerraform(struct!.queryProfile),
    robustness: cdktf.stringToTerraform(struct!.robustness),
    router_alert_policing: cdktf.booleanToTerraform(struct!.routerAlertPolicing),
    version: cdktf.stringToTerraform(struct!.version),
  }
}


export function logicalRouterVrfMulticastIgmpDynamicInterfaceToHclTerraform(struct?: LogicalRouterVrfMulticastIgmpDynamicInterface | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    group_filter: {
      value: cdktf.stringToHclTerraform(struct!.groupFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_groups: {
      value: cdktf.stringToHclTerraform(struct!.maxGroups),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_sources: {
      value: cdktf.stringToHclTerraform(struct!.maxSources),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    query_profile: {
      value: cdktf.stringToHclTerraform(struct!.queryProfile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    robustness: {
      value: cdktf.stringToHclTerraform(struct!.robustness),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    router_alert_policing: {
      value: cdktf.booleanToHclTerraform(struct!.routerAlertPolicing),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    version: {
      value: cdktf.stringToHclTerraform(struct!.version),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfMulticastIgmpDynamicInterfaceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): LogicalRouterVrfMulticastIgmpDynamicInterface | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._groupFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupFilter = this._groupFilter;
    }
    if (this._maxGroups !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxGroups = this._maxGroups;
    }
    if (this._maxSources !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSources = this._maxSources;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._queryProfile !== undefined) {
      hasAnyValues = true;
      internalValueResult.queryProfile = this._queryProfile;
    }
    if (this._robustness !== undefined) {
      hasAnyValues = true;
      internalValueResult.robustness = this._robustness;
    }
    if (this._routerAlertPolicing !== undefined) {
      hasAnyValues = true;
      internalValueResult.routerAlertPolicing = this._routerAlertPolicing;
    }
    if (this._version !== undefined) {
      hasAnyValues = true;
      internalValueResult.version = this._version;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfMulticastIgmpDynamicInterface | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._groupFilter = undefined;
      this._maxGroups = undefined;
      this._maxSources = undefined;
      this._name = undefined;
      this._queryProfile = undefined;
      this._robustness = undefined;
      this._routerAlertPolicing = undefined;
      this._version = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._groupFilter = value.groupFilter;
      this._maxGroups = value.maxGroups;
      this._maxSources = value.maxSources;
      this._name = value.name;
      this._queryProfile = value.queryProfile;
      this._robustness = value.robustness;
      this._routerAlertPolicing = value.routerAlertPolicing;
      this._version = value.version;
    }
  }

  // group_filter - computed: false, optional: true, required: false
  private _groupFilter?: string; 
  public get groupFilter() {
    return this.getStringAttribute('group_filter');
  }
  public set groupFilter(value: string) {
    this._groupFilter = value;
  }
  public resetGroupFilter() {
    this._groupFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupFilterInput() {
    return this._groupFilter;
  }

  // max_groups - computed: false, optional: true, required: false
  private _maxGroups?: string; 
  public get maxGroups() {
    return this.getStringAttribute('max_groups');
  }
  public set maxGroups(value: string) {
    this._maxGroups = value;
  }
  public resetMaxGroups() {
    this._maxGroups = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxGroupsInput() {
    return this._maxGroups;
  }

  // max_sources - computed: false, optional: true, required: false
  private _maxSources?: string; 
  public get maxSources() {
    return this.getStringAttribute('max_sources');
  }
  public set maxSources(value: string) {
    this._maxSources = value;
  }
  public resetMaxSources() {
    this._maxSources = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSourcesInput() {
    return this._maxSources;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // query_profile - computed: false, optional: true, required: false
  private _queryProfile?: string; 
  public get queryProfile() {
    return this.getStringAttribute('query_profile');
  }
  public set queryProfile(value: string) {
    this._queryProfile = value;
  }
  public resetQueryProfile() {
    this._queryProfile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get queryProfileInput() {
    return this._queryProfile;
  }

  // robustness - computed: false, optional: true, required: false
  private _robustness?: string; 
  public get robustness() {
    return this.getStringAttribute('robustness');
  }
  public set robustness(value: string) {
    this._robustness = value;
  }
  public resetRobustness() {
    this._robustness = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get robustnessInput() {
    return this._robustness;
  }

  // router_alert_policing - computed: false, optional: true, required: false
  private _routerAlertPolicing?: boolean | cdktf.IResolvable; 
  public get routerAlertPolicing() {
    return this.getBooleanAttribute('router_alert_policing');
  }
  public set routerAlertPolicing(value: boolean | cdktf.IResolvable) {
    this._routerAlertPolicing = value;
  }
  public resetRouterAlertPolicing() {
    this._routerAlertPolicing = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routerAlertPolicingInput() {
    return this._routerAlertPolicing;
  }

  // version - computed: false, optional: true, required: false
  private _version?: string; 
  public get version() {
    return this.getStringAttribute('version');
  }
  public set version(value: string) {
    this._version = value;
  }
  public resetVersion() {
    this._version = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get versionInput() {
    return this._version;
  }
}

export class LogicalRouterVrfMulticastIgmpDynamicInterfaceList extends cdktf.ComplexList {
  public internalValue? : LogicalRouterVrfMulticastIgmpDynamicInterface[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): LogicalRouterVrfMulticastIgmpDynamicInterfaceOutputReference {
    return new LogicalRouterVrfMulticastIgmpDynamicInterfaceOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface LogicalRouterVrfMulticastIgmpDynamic {
  /**
  * Interface
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#interface LogicalRouter#interface}
  */
  readonly interface?: LogicalRouterVrfMulticastIgmpDynamicInterface[] | cdktf.IResolvable;
}

export function logicalRouterVrfMulticastIgmpDynamicToTerraform(struct?: LogicalRouterVrfMulticastIgmpDynamic | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    interface: cdktf.listMapper(logicalRouterVrfMulticastIgmpDynamicInterfaceToTerraform, false)(struct!.interface),
  }
}


export function logicalRouterVrfMulticastIgmpDynamicToHclTerraform(struct?: LogicalRouterVrfMulticastIgmpDynamic | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    interface: {
      value: cdktf.listMapperHcl(logicalRouterVrfMulticastIgmpDynamicInterfaceToHclTerraform, false)(struct!.interface),
      isBlock: true,
      type: "list",
      storageClassType: "LogicalRouterVrfMulticastIgmpDynamicInterfaceList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfMulticastIgmpDynamicOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfMulticastIgmpDynamic | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._interface?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.interface = this._interface?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfMulticastIgmpDynamic | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._interface.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._interface.internalValue = value.interface;
    }
  }

  // interface - computed: false, optional: true, required: false
  private _interface = new LogicalRouterVrfMulticastIgmpDynamicInterfaceList(this, "interface", false);
  public get interface() {
    return this._interface;
  }
  public putInterface(value: LogicalRouterVrfMulticastIgmpDynamicInterface[] | cdktf.IResolvable) {
    this._interface.internalValue = value;
  }
  public resetInterface() {
    this._interface.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfaceInput() {
    return this._interface.internalValue;
  }
}
export interface LogicalRouterVrfMulticastIgmpStatic {
  /**
  * Group address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#group_address LogicalRouter#group_address}
  */
  readonly groupAddress?: string;
  /**
  * Interface
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#interface LogicalRouter#interface}
  */
  readonly interface?: string;
  /**
  * Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#name LogicalRouter#name}
  */
  readonly name: string;
  /**
  * Source address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#source_address LogicalRouter#source_address}
  */
  readonly sourceAddress?: string;
}

export function logicalRouterVrfMulticastIgmpStaticToTerraform(struct?: LogicalRouterVrfMulticastIgmpStatic | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    group_address: cdktf.stringToTerraform(struct!.groupAddress),
    interface: cdktf.stringToTerraform(struct!.interface),
    name: cdktf.stringToTerraform(struct!.name),
    source_address: cdktf.stringToTerraform(struct!.sourceAddress),
  }
}


export function logicalRouterVrfMulticastIgmpStaticToHclTerraform(struct?: LogicalRouterVrfMulticastIgmpStatic | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    group_address: {
      value: cdktf.stringToHclTerraform(struct!.groupAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    interface: {
      value: cdktf.stringToHclTerraform(struct!.interface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    source_address: {
      value: cdktf.stringToHclTerraform(struct!.sourceAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfMulticastIgmpStaticOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): LogicalRouterVrfMulticastIgmpStatic | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._groupAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupAddress = this._groupAddress;
    }
    if (this._interface !== undefined) {
      hasAnyValues = true;
      internalValueResult.interface = this._interface;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._sourceAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceAddress = this._sourceAddress;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfMulticastIgmpStatic | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._groupAddress = undefined;
      this._interface = undefined;
      this._name = undefined;
      this._sourceAddress = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._groupAddress = value.groupAddress;
      this._interface = value.interface;
      this._name = value.name;
      this._sourceAddress = value.sourceAddress;
    }
  }

  // group_address - computed: false, optional: true, required: false
  private _groupAddress?: string; 
  public get groupAddress() {
    return this.getStringAttribute('group_address');
  }
  public set groupAddress(value: string) {
    this._groupAddress = value;
  }
  public resetGroupAddress() {
    this._groupAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupAddressInput() {
    return this._groupAddress;
  }

  // interface - computed: false, optional: true, required: false
  private _interface?: string; 
  public get interface() {
    return this.getStringAttribute('interface');
  }
  public set interface(value: string) {
    this._interface = value;
  }
  public resetInterface() {
    this._interface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfaceInput() {
    return this._interface;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // source_address - computed: false, optional: true, required: false
  private _sourceAddress?: string; 
  public get sourceAddress() {
    return this.getStringAttribute('source_address');
  }
  public set sourceAddress(value: string) {
    this._sourceAddress = value;
  }
  public resetSourceAddress() {
    this._sourceAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceAddressInput() {
    return this._sourceAddress;
  }
}

export class LogicalRouterVrfMulticastIgmpStaticList extends cdktf.ComplexList {
  public internalValue? : LogicalRouterVrfMulticastIgmpStatic[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): LogicalRouterVrfMulticastIgmpStaticOutputReference {
    return new LogicalRouterVrfMulticastIgmpStaticOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface LogicalRouterVrfMulticastIgmp {
  /**
  * Dynamic
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#dynamic LogicalRouter#dynamic}
  */
  readonly dynamic?: LogicalRouterVrfMulticastIgmpDynamic;
  /**
  * Enable
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#enable LogicalRouter#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * Static
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#static LogicalRouter#static}
  */
  readonly static?: LogicalRouterVrfMulticastIgmpStatic[] | cdktf.IResolvable;
}

export function logicalRouterVrfMulticastIgmpToTerraform(struct?: LogicalRouterVrfMulticastIgmp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dynamic: logicalRouterVrfMulticastIgmpDynamicToTerraform(struct!.dynamic),
    enable: cdktf.booleanToTerraform(struct!.enable),
    static: cdktf.listMapper(logicalRouterVrfMulticastIgmpStaticToTerraform, false)(struct!.static),
  }
}


export function logicalRouterVrfMulticastIgmpToHclTerraform(struct?: LogicalRouterVrfMulticastIgmp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dynamic: {
      value: logicalRouterVrfMulticastIgmpDynamicToHclTerraform(struct!.dynamic),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfMulticastIgmpDynamic",
    },
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    static: {
      value: cdktf.listMapperHcl(logicalRouterVrfMulticastIgmpStaticToHclTerraform, false)(struct!.static),
      isBlock: true,
      type: "list",
      storageClassType: "LogicalRouterVrfMulticastIgmpStaticList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfMulticastIgmpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfMulticastIgmp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dynamic?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dynamic = this._dynamic?.internalValue;
    }
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._static?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.static = this._static?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfMulticastIgmp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dynamic.internalValue = undefined;
      this._enable = undefined;
      this._static.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dynamic.internalValue = value.dynamic;
      this._enable = value.enable;
      this._static.internalValue = value.static;
    }
  }

  // dynamic - computed: false, optional: true, required: false
  private _dynamic = new LogicalRouterVrfMulticastIgmpDynamicOutputReference(this, "dynamic");
  public get dynamic() {
    return this._dynamic;
  }
  public putDynamic(value: LogicalRouterVrfMulticastIgmpDynamic) {
    this._dynamic.internalValue = value;
  }
  public resetDynamic() {
    this._dynamic.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dynamicInput() {
    return this._dynamic.internalValue;
  }

  // enable - computed: false, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // static - computed: false, optional: true, required: false
  private _static = new LogicalRouterVrfMulticastIgmpStaticList(this, "static", false);
  public get static() {
    return this._static;
  }
  public putStatic(value: LogicalRouterVrfMulticastIgmpStatic[] | cdktf.IResolvable) {
    this._static.internalValue = value;
  }
  public resetStatic() {
    this._static.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get staticInput() {
    return this._static.internalValue;
  }
}
export interface LogicalRouterVrfMulticastInterfaceGroupGroupPermissionAnySourceMulticast {
  /**
  * Group address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#group_address LogicalRouter#group_address}
  */
  readonly groupAddress?: string;
  /**
  * Included
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#included LogicalRouter#included}
  */
  readonly included?: boolean | cdktf.IResolvable;
  /**
  * Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#name LogicalRouter#name}
  */
  readonly name: string;
}

export function logicalRouterVrfMulticastInterfaceGroupGroupPermissionAnySourceMulticastToTerraform(struct?: LogicalRouterVrfMulticastInterfaceGroupGroupPermissionAnySourceMulticast | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    group_address: cdktf.stringToTerraform(struct!.groupAddress),
    included: cdktf.booleanToTerraform(struct!.included),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function logicalRouterVrfMulticastInterfaceGroupGroupPermissionAnySourceMulticastToHclTerraform(struct?: LogicalRouterVrfMulticastInterfaceGroupGroupPermissionAnySourceMulticast | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    group_address: {
      value: cdktf.stringToHclTerraform(struct!.groupAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    included: {
      value: cdktf.booleanToHclTerraform(struct!.included),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfMulticastInterfaceGroupGroupPermissionAnySourceMulticastOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): LogicalRouterVrfMulticastInterfaceGroupGroupPermissionAnySourceMulticast | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._groupAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupAddress = this._groupAddress;
    }
    if (this._included !== undefined) {
      hasAnyValues = true;
      internalValueResult.included = this._included;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfMulticastInterfaceGroupGroupPermissionAnySourceMulticast | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._groupAddress = undefined;
      this._included = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._groupAddress = value.groupAddress;
      this._included = value.included;
      this._name = value.name;
    }
  }

  // group_address - computed: false, optional: true, required: false
  private _groupAddress?: string; 
  public get groupAddress() {
    return this.getStringAttribute('group_address');
  }
  public set groupAddress(value: string) {
    this._groupAddress = value;
  }
  public resetGroupAddress() {
    this._groupAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupAddressInput() {
    return this._groupAddress;
  }

  // included - computed: false, optional: true, required: false
  private _included?: boolean | cdktf.IResolvable; 
  public get included() {
    return this.getBooleanAttribute('included');
  }
  public set included(value: boolean | cdktf.IResolvable) {
    this._included = value;
  }
  public resetIncluded() {
    this._included = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get includedInput() {
    return this._included;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class LogicalRouterVrfMulticastInterfaceGroupGroupPermissionAnySourceMulticastList extends cdktf.ComplexList {
  public internalValue? : LogicalRouterVrfMulticastInterfaceGroupGroupPermissionAnySourceMulticast[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): LogicalRouterVrfMulticastInterfaceGroupGroupPermissionAnySourceMulticastOutputReference {
    return new LogicalRouterVrfMulticastInterfaceGroupGroupPermissionAnySourceMulticastOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface LogicalRouterVrfMulticastInterfaceGroupGroupPermissionSourceSpecificMulticast {
  /**
  * Group address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#group_address LogicalRouter#group_address}
  */
  readonly groupAddress?: string;
  /**
  * Included
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#included LogicalRouter#included}
  */
  readonly included?: boolean | cdktf.IResolvable;
  /**
  * Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#name LogicalRouter#name}
  */
  readonly name: string;
  /**
  * Source address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#source_address LogicalRouter#source_address}
  */
  readonly sourceAddress?: string;
}

export function logicalRouterVrfMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastToTerraform(struct?: LogicalRouterVrfMulticastInterfaceGroupGroupPermissionSourceSpecificMulticast | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    group_address: cdktf.stringToTerraform(struct!.groupAddress),
    included: cdktf.booleanToTerraform(struct!.included),
    name: cdktf.stringToTerraform(struct!.name),
    source_address: cdktf.stringToTerraform(struct!.sourceAddress),
  }
}


export function logicalRouterVrfMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastToHclTerraform(struct?: LogicalRouterVrfMulticastInterfaceGroupGroupPermissionSourceSpecificMulticast | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    group_address: {
      value: cdktf.stringToHclTerraform(struct!.groupAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    included: {
      value: cdktf.booleanToHclTerraform(struct!.included),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    source_address: {
      value: cdktf.stringToHclTerraform(struct!.sourceAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): LogicalRouterVrfMulticastInterfaceGroupGroupPermissionSourceSpecificMulticast | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._groupAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupAddress = this._groupAddress;
    }
    if (this._included !== undefined) {
      hasAnyValues = true;
      internalValueResult.included = this._included;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._sourceAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceAddress = this._sourceAddress;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfMulticastInterfaceGroupGroupPermissionSourceSpecificMulticast | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._groupAddress = undefined;
      this._included = undefined;
      this._name = undefined;
      this._sourceAddress = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._groupAddress = value.groupAddress;
      this._included = value.included;
      this._name = value.name;
      this._sourceAddress = value.sourceAddress;
    }
  }

  // group_address - computed: false, optional: true, required: false
  private _groupAddress?: string; 
  public get groupAddress() {
    return this.getStringAttribute('group_address');
  }
  public set groupAddress(value: string) {
    this._groupAddress = value;
  }
  public resetGroupAddress() {
    this._groupAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupAddressInput() {
    return this._groupAddress;
  }

  // included - computed: false, optional: true, required: false
  private _included?: boolean | cdktf.IResolvable; 
  public get included() {
    return this.getBooleanAttribute('included');
  }
  public set included(value: boolean | cdktf.IResolvable) {
    this._included = value;
  }
  public resetIncluded() {
    this._included = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get includedInput() {
    return this._included;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // source_address - computed: false, optional: true, required: false
  private _sourceAddress?: string; 
  public get sourceAddress() {
    return this.getStringAttribute('source_address');
  }
  public set sourceAddress(value: string) {
    this._sourceAddress = value;
  }
  public resetSourceAddress() {
    this._sourceAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceAddressInput() {
    return this._sourceAddress;
  }
}

export class LogicalRouterVrfMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastList extends cdktf.ComplexList {
  public internalValue? : LogicalRouterVrfMulticastInterfaceGroupGroupPermissionSourceSpecificMulticast[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): LogicalRouterVrfMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastOutputReference {
    return new LogicalRouterVrfMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface LogicalRouterVrfMulticastInterfaceGroupGroupPermission {
  /**
  * Any source multicast
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#any_source_multicast LogicalRouter#any_source_multicast}
  */
  readonly anySourceMulticast?: LogicalRouterVrfMulticastInterfaceGroupGroupPermissionAnySourceMulticast[] | cdktf.IResolvable;
  /**
  * Source specific multicast
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#source_specific_multicast LogicalRouter#source_specific_multicast}
  */
  readonly sourceSpecificMulticast?: LogicalRouterVrfMulticastInterfaceGroupGroupPermissionSourceSpecificMulticast[] | cdktf.IResolvable;
}

export function logicalRouterVrfMulticastInterfaceGroupGroupPermissionToTerraform(struct?: LogicalRouterVrfMulticastInterfaceGroupGroupPermission | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    any_source_multicast: cdktf.listMapper(logicalRouterVrfMulticastInterfaceGroupGroupPermissionAnySourceMulticastToTerraform, false)(struct!.anySourceMulticast),
    source_specific_multicast: cdktf.listMapper(logicalRouterVrfMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastToTerraform, false)(struct!.sourceSpecificMulticast),
  }
}


export function logicalRouterVrfMulticastInterfaceGroupGroupPermissionToHclTerraform(struct?: LogicalRouterVrfMulticastInterfaceGroupGroupPermission | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    any_source_multicast: {
      value: cdktf.listMapperHcl(logicalRouterVrfMulticastInterfaceGroupGroupPermissionAnySourceMulticastToHclTerraform, false)(struct!.anySourceMulticast),
      isBlock: true,
      type: "list",
      storageClassType: "LogicalRouterVrfMulticastInterfaceGroupGroupPermissionAnySourceMulticastList",
    },
    source_specific_multicast: {
      value: cdktf.listMapperHcl(logicalRouterVrfMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastToHclTerraform, false)(struct!.sourceSpecificMulticast),
      isBlock: true,
      type: "list",
      storageClassType: "LogicalRouterVrfMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfMulticastInterfaceGroupGroupPermissionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfMulticastInterfaceGroupGroupPermission | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._anySourceMulticast?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.anySourceMulticast = this._anySourceMulticast?.internalValue;
    }
    if (this._sourceSpecificMulticast?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceSpecificMulticast = this._sourceSpecificMulticast?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfMulticastInterfaceGroupGroupPermission | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._anySourceMulticast.internalValue = undefined;
      this._sourceSpecificMulticast.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._anySourceMulticast.internalValue = value.anySourceMulticast;
      this._sourceSpecificMulticast.internalValue = value.sourceSpecificMulticast;
    }
  }

  // any_source_multicast - computed: false, optional: true, required: false
  private _anySourceMulticast = new LogicalRouterVrfMulticastInterfaceGroupGroupPermissionAnySourceMulticastList(this, "any_source_multicast", false);
  public get anySourceMulticast() {
    return this._anySourceMulticast;
  }
  public putAnySourceMulticast(value: LogicalRouterVrfMulticastInterfaceGroupGroupPermissionAnySourceMulticast[] | cdktf.IResolvable) {
    this._anySourceMulticast.internalValue = value;
  }
  public resetAnySourceMulticast() {
    this._anySourceMulticast.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get anySourceMulticastInput() {
    return this._anySourceMulticast.internalValue;
  }

  // source_specific_multicast - computed: false, optional: true, required: false
  private _sourceSpecificMulticast = new LogicalRouterVrfMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastList(this, "source_specific_multicast", false);
  public get sourceSpecificMulticast() {
    return this._sourceSpecificMulticast;
  }
  public putSourceSpecificMulticast(value: LogicalRouterVrfMulticastInterfaceGroupGroupPermissionSourceSpecificMulticast[] | cdktf.IResolvable) {
    this._sourceSpecificMulticast.internalValue = value;
  }
  public resetSourceSpecificMulticast() {
    this._sourceSpecificMulticast.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceSpecificMulticastInput() {
    return this._sourceSpecificMulticast.internalValue;
  }
}
export interface LogicalRouterVrfMulticastInterfaceGroupIgmp {
  /**
  * Enable
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#enable LogicalRouter#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * Immediate leave
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#immediate_leave LogicalRouter#immediate_leave}
  */
  readonly immediateLeave?: boolean | cdktf.IResolvable;
  /**
  * Last member query interval
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#last_member_query_interval LogicalRouter#last_member_query_interval}
  */
  readonly lastMemberQueryInterval?: number;
  /**
  * Max groups
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#max_groups LogicalRouter#max_groups}
  */
  readonly maxGroups?: string;
  /**
  * Max query response time
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#max_query_response_time LogicalRouter#max_query_response_time}
  */
  readonly maxQueryResponseTime?: number;
  /**
  * Max sources
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#max_sources LogicalRouter#max_sources}
  */
  readonly maxSources?: string;
  /**
  * Mode
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#mode LogicalRouter#mode}
  */
  readonly mode?: string;
  /**
  * Query interval
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#query_interval LogicalRouter#query_interval}
  */
  readonly queryInterval?: number;
  /**
  * Robustness
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#robustness LogicalRouter#robustness}
  */
  readonly robustness?: string;
  /**
  * Router alert policing
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#router_alert_policing LogicalRouter#router_alert_policing}
  */
  readonly routerAlertPolicing?: boolean | cdktf.IResolvable;
  /**
  * Version
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#version LogicalRouter#version}
  */
  readonly version?: string;
}

export function logicalRouterVrfMulticastInterfaceGroupIgmpToTerraform(struct?: LogicalRouterVrfMulticastInterfaceGroupIgmp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enable: cdktf.booleanToTerraform(struct!.enable),
    immediate_leave: cdktf.booleanToTerraform(struct!.immediateLeave),
    last_member_query_interval: cdktf.numberToTerraform(struct!.lastMemberQueryInterval),
    max_groups: cdktf.stringToTerraform(struct!.maxGroups),
    max_query_response_time: cdktf.numberToTerraform(struct!.maxQueryResponseTime),
    max_sources: cdktf.stringToTerraform(struct!.maxSources),
    mode: cdktf.stringToTerraform(struct!.mode),
    query_interval: cdktf.numberToTerraform(struct!.queryInterval),
    robustness: cdktf.stringToTerraform(struct!.robustness),
    router_alert_policing: cdktf.booleanToTerraform(struct!.routerAlertPolicing),
    version: cdktf.stringToTerraform(struct!.version),
  }
}


export function logicalRouterVrfMulticastInterfaceGroupIgmpToHclTerraform(struct?: LogicalRouterVrfMulticastInterfaceGroupIgmp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    immediate_leave: {
      value: cdktf.booleanToHclTerraform(struct!.immediateLeave),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    last_member_query_interval: {
      value: cdktf.numberToHclTerraform(struct!.lastMemberQueryInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_groups: {
      value: cdktf.stringToHclTerraform(struct!.maxGroups),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_query_response_time: {
      value: cdktf.numberToHclTerraform(struct!.maxQueryResponseTime),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_sources: {
      value: cdktf.stringToHclTerraform(struct!.maxSources),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    query_interval: {
      value: cdktf.numberToHclTerraform(struct!.queryInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    robustness: {
      value: cdktf.stringToHclTerraform(struct!.robustness),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    router_alert_policing: {
      value: cdktf.booleanToHclTerraform(struct!.routerAlertPolicing),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    version: {
      value: cdktf.stringToHclTerraform(struct!.version),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfMulticastInterfaceGroupIgmpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfMulticastInterfaceGroupIgmp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._immediateLeave !== undefined) {
      hasAnyValues = true;
      internalValueResult.immediateLeave = this._immediateLeave;
    }
    if (this._lastMemberQueryInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.lastMemberQueryInterval = this._lastMemberQueryInterval;
    }
    if (this._maxGroups !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxGroups = this._maxGroups;
    }
    if (this._maxQueryResponseTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxQueryResponseTime = this._maxQueryResponseTime;
    }
    if (this._maxSources !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSources = this._maxSources;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._queryInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.queryInterval = this._queryInterval;
    }
    if (this._robustness !== undefined) {
      hasAnyValues = true;
      internalValueResult.robustness = this._robustness;
    }
    if (this._routerAlertPolicing !== undefined) {
      hasAnyValues = true;
      internalValueResult.routerAlertPolicing = this._routerAlertPolicing;
    }
    if (this._version !== undefined) {
      hasAnyValues = true;
      internalValueResult.version = this._version;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfMulticastInterfaceGroupIgmp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enable = undefined;
      this._immediateLeave = undefined;
      this._lastMemberQueryInterval = undefined;
      this._maxGroups = undefined;
      this._maxQueryResponseTime = undefined;
      this._maxSources = undefined;
      this._mode = undefined;
      this._queryInterval = undefined;
      this._robustness = undefined;
      this._routerAlertPolicing = undefined;
      this._version = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enable = value.enable;
      this._immediateLeave = value.immediateLeave;
      this._lastMemberQueryInterval = value.lastMemberQueryInterval;
      this._maxGroups = value.maxGroups;
      this._maxQueryResponseTime = value.maxQueryResponseTime;
      this._maxSources = value.maxSources;
      this._mode = value.mode;
      this._queryInterval = value.queryInterval;
      this._robustness = value.robustness;
      this._routerAlertPolicing = value.routerAlertPolicing;
      this._version = value.version;
    }
  }

  // enable - computed: false, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // immediate_leave - computed: false, optional: true, required: false
  private _immediateLeave?: boolean | cdktf.IResolvable; 
  public get immediateLeave() {
    return this.getBooleanAttribute('immediate_leave');
  }
  public set immediateLeave(value: boolean | cdktf.IResolvable) {
    this._immediateLeave = value;
  }
  public resetImmediateLeave() {
    this._immediateLeave = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get immediateLeaveInput() {
    return this._immediateLeave;
  }

  // last_member_query_interval - computed: false, optional: true, required: false
  private _lastMemberQueryInterval?: number; 
  public get lastMemberQueryInterval() {
    return this.getNumberAttribute('last_member_query_interval');
  }
  public set lastMemberQueryInterval(value: number) {
    this._lastMemberQueryInterval = value;
  }
  public resetLastMemberQueryInterval() {
    this._lastMemberQueryInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lastMemberQueryIntervalInput() {
    return this._lastMemberQueryInterval;
  }

  // max_groups - computed: false, optional: true, required: false
  private _maxGroups?: string; 
  public get maxGroups() {
    return this.getStringAttribute('max_groups');
  }
  public set maxGroups(value: string) {
    this._maxGroups = value;
  }
  public resetMaxGroups() {
    this._maxGroups = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxGroupsInput() {
    return this._maxGroups;
  }

  // max_query_response_time - computed: false, optional: true, required: false
  private _maxQueryResponseTime?: number; 
  public get maxQueryResponseTime() {
    return this.getNumberAttribute('max_query_response_time');
  }
  public set maxQueryResponseTime(value: number) {
    this._maxQueryResponseTime = value;
  }
  public resetMaxQueryResponseTime() {
    this._maxQueryResponseTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxQueryResponseTimeInput() {
    return this._maxQueryResponseTime;
  }

  // max_sources - computed: false, optional: true, required: false
  private _maxSources?: string; 
  public get maxSources() {
    return this.getStringAttribute('max_sources');
  }
  public set maxSources(value: string) {
    this._maxSources = value;
  }
  public resetMaxSources() {
    this._maxSources = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSourcesInput() {
    return this._maxSources;
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // query_interval - computed: false, optional: true, required: false
  private _queryInterval?: number; 
  public get queryInterval() {
    return this.getNumberAttribute('query_interval');
  }
  public set queryInterval(value: number) {
    this._queryInterval = value;
  }
  public resetQueryInterval() {
    this._queryInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get queryIntervalInput() {
    return this._queryInterval;
  }

  // robustness - computed: false, optional: true, required: false
  private _robustness?: string; 
  public get robustness() {
    return this.getStringAttribute('robustness');
  }
  public set robustness(value: string) {
    this._robustness = value;
  }
  public resetRobustness() {
    this._robustness = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get robustnessInput() {
    return this._robustness;
  }

  // router_alert_policing - computed: false, optional: true, required: false
  private _routerAlertPolicing?: boolean | cdktf.IResolvable; 
  public get routerAlertPolicing() {
    return this.getBooleanAttribute('router_alert_policing');
  }
  public set routerAlertPolicing(value: boolean | cdktf.IResolvable) {
    this._routerAlertPolicing = value;
  }
  public resetRouterAlertPolicing() {
    this._routerAlertPolicing = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routerAlertPolicingInput() {
    return this._routerAlertPolicing;
  }

  // version - computed: false, optional: true, required: false
  private _version?: string; 
  public get version() {
    return this.getStringAttribute('version');
  }
  public set version(value: string) {
    this._version = value;
  }
  public resetVersion() {
    this._version = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get versionInput() {
    return this._version;
  }
}
export interface LogicalRouterVrfMulticastInterfaceGroupPimAllowedNeighbors {
  /**
  * Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#name LogicalRouter#name}
  */
  readonly name: string;
}

export function logicalRouterVrfMulticastInterfaceGroupPimAllowedNeighborsToTerraform(struct?: LogicalRouterVrfMulticastInterfaceGroupPimAllowedNeighbors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function logicalRouterVrfMulticastInterfaceGroupPimAllowedNeighborsToHclTerraform(struct?: LogicalRouterVrfMulticastInterfaceGroupPimAllowedNeighbors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfMulticastInterfaceGroupPimAllowedNeighborsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): LogicalRouterVrfMulticastInterfaceGroupPimAllowedNeighbors | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfMulticastInterfaceGroupPimAllowedNeighbors | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class LogicalRouterVrfMulticastInterfaceGroupPimAllowedNeighborsList extends cdktf.ComplexList {
  public internalValue? : LogicalRouterVrfMulticastInterfaceGroupPimAllowedNeighbors[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): LogicalRouterVrfMulticastInterfaceGroupPimAllowedNeighborsOutputReference {
    return new LogicalRouterVrfMulticastInterfaceGroupPimAllowedNeighborsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface LogicalRouterVrfMulticastInterfaceGroupPim {
  /**
  * Allowed neighbors
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#allowed_neighbors LogicalRouter#allowed_neighbors}
  */
  readonly allowedNeighbors?: LogicalRouterVrfMulticastInterfaceGroupPimAllowedNeighbors[] | cdktf.IResolvable;
  /**
  * Assert interval
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#assert_interval LogicalRouter#assert_interval}
  */
  readonly assertInterval?: number;
  /**
  * Bsr border
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#bsr_border LogicalRouter#bsr_border}
  */
  readonly bsrBorder?: boolean | cdktf.IResolvable;
  /**
  * Dr priority
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#dr_priority LogicalRouter#dr_priority}
  */
  readonly drPriority?: number;
  /**
  * Enable
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#enable LogicalRouter#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * Hello interval
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#hello_interval LogicalRouter#hello_interval}
  */
  readonly helloInterval?: number;
  /**
  * Join prune interval
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#join_prune_interval LogicalRouter#join_prune_interval}
  */
  readonly joinPruneInterval?: number;
}

export function logicalRouterVrfMulticastInterfaceGroupPimToTerraform(struct?: LogicalRouterVrfMulticastInterfaceGroupPim | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allowed_neighbors: cdktf.listMapper(logicalRouterVrfMulticastInterfaceGroupPimAllowedNeighborsToTerraform, false)(struct!.allowedNeighbors),
    assert_interval: cdktf.numberToTerraform(struct!.assertInterval),
    bsr_border: cdktf.booleanToTerraform(struct!.bsrBorder),
    dr_priority: cdktf.numberToTerraform(struct!.drPriority),
    enable: cdktf.booleanToTerraform(struct!.enable),
    hello_interval: cdktf.numberToTerraform(struct!.helloInterval),
    join_prune_interval: cdktf.numberToTerraform(struct!.joinPruneInterval),
  }
}


export function logicalRouterVrfMulticastInterfaceGroupPimToHclTerraform(struct?: LogicalRouterVrfMulticastInterfaceGroupPim | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allowed_neighbors: {
      value: cdktf.listMapperHcl(logicalRouterVrfMulticastInterfaceGroupPimAllowedNeighborsToHclTerraform, false)(struct!.allowedNeighbors),
      isBlock: true,
      type: "list",
      storageClassType: "LogicalRouterVrfMulticastInterfaceGroupPimAllowedNeighborsList",
    },
    assert_interval: {
      value: cdktf.numberToHclTerraform(struct!.assertInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    bsr_border: {
      value: cdktf.booleanToHclTerraform(struct!.bsrBorder),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    dr_priority: {
      value: cdktf.numberToHclTerraform(struct!.drPriority),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    hello_interval: {
      value: cdktf.numberToHclTerraform(struct!.helloInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    join_prune_interval: {
      value: cdktf.numberToHclTerraform(struct!.joinPruneInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfMulticastInterfaceGroupPimOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfMulticastInterfaceGroupPim | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowedNeighbors?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowedNeighbors = this._allowedNeighbors?.internalValue;
    }
    if (this._assertInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.assertInterval = this._assertInterval;
    }
    if (this._bsrBorder !== undefined) {
      hasAnyValues = true;
      internalValueResult.bsrBorder = this._bsrBorder;
    }
    if (this._drPriority !== undefined) {
      hasAnyValues = true;
      internalValueResult.drPriority = this._drPriority;
    }
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._helloInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.helloInterval = this._helloInterval;
    }
    if (this._joinPruneInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.joinPruneInterval = this._joinPruneInterval;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfMulticastInterfaceGroupPim | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allowedNeighbors.internalValue = undefined;
      this._assertInterval = undefined;
      this._bsrBorder = undefined;
      this._drPriority = undefined;
      this._enable = undefined;
      this._helloInterval = undefined;
      this._joinPruneInterval = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allowedNeighbors.internalValue = value.allowedNeighbors;
      this._assertInterval = value.assertInterval;
      this._bsrBorder = value.bsrBorder;
      this._drPriority = value.drPriority;
      this._enable = value.enable;
      this._helloInterval = value.helloInterval;
      this._joinPruneInterval = value.joinPruneInterval;
    }
  }

  // allowed_neighbors - computed: false, optional: true, required: false
  private _allowedNeighbors = new LogicalRouterVrfMulticastInterfaceGroupPimAllowedNeighborsList(this, "allowed_neighbors", false);
  public get allowedNeighbors() {
    return this._allowedNeighbors;
  }
  public putAllowedNeighbors(value: LogicalRouterVrfMulticastInterfaceGroupPimAllowedNeighbors[] | cdktf.IResolvable) {
    this._allowedNeighbors.internalValue = value;
  }
  public resetAllowedNeighbors() {
    this._allowedNeighbors.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowedNeighborsInput() {
    return this._allowedNeighbors.internalValue;
  }

  // assert_interval - computed: false, optional: true, required: false
  private _assertInterval?: number; 
  public get assertInterval() {
    return this.getNumberAttribute('assert_interval');
  }
  public set assertInterval(value: number) {
    this._assertInterval = value;
  }
  public resetAssertInterval() {
    this._assertInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assertIntervalInput() {
    return this._assertInterval;
  }

  // bsr_border - computed: false, optional: true, required: false
  private _bsrBorder?: boolean | cdktf.IResolvable; 
  public get bsrBorder() {
    return this.getBooleanAttribute('bsr_border');
  }
  public set bsrBorder(value: boolean | cdktf.IResolvable) {
    this._bsrBorder = value;
  }
  public resetBsrBorder() {
    this._bsrBorder = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bsrBorderInput() {
    return this._bsrBorder;
  }

  // dr_priority - computed: false, optional: true, required: false
  private _drPriority?: number; 
  public get drPriority() {
    return this.getNumberAttribute('dr_priority');
  }
  public set drPriority(value: number) {
    this._drPriority = value;
  }
  public resetDrPriority() {
    this._drPriority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get drPriorityInput() {
    return this._drPriority;
  }

  // enable - computed: false, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // hello_interval - computed: false, optional: true, required: false
  private _helloInterval?: number; 
  public get helloInterval() {
    return this.getNumberAttribute('hello_interval');
  }
  public set helloInterval(value: number) {
    this._helloInterval = value;
  }
  public resetHelloInterval() {
    this._helloInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get helloIntervalInput() {
    return this._helloInterval;
  }

  // join_prune_interval - computed: false, optional: true, required: false
  private _joinPruneInterval?: number; 
  public get joinPruneInterval() {
    return this.getNumberAttribute('join_prune_interval');
  }
  public set joinPruneInterval(value: number) {
    this._joinPruneInterval = value;
  }
  public resetJoinPruneInterval() {
    this._joinPruneInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get joinPruneIntervalInput() {
    return this._joinPruneInterval;
  }
}
export interface LogicalRouterVrfMulticastInterfaceGroup {
  /**
  * Description
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#description LogicalRouter#description}
  */
  readonly description?: string;
  /**
  * Group permission
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#group_permission LogicalRouter#group_permission}
  */
  readonly groupPermission?: LogicalRouterVrfMulticastInterfaceGroupGroupPermission;
  /**
  * Igmp
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#igmp LogicalRouter#igmp}
  */
  readonly igmp?: LogicalRouterVrfMulticastInterfaceGroupIgmp;
  /**
  * Interface
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#interface LogicalRouter#interface}
  */
  readonly interface?: string[];
  /**
  * Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#name LogicalRouter#name}
  */
  readonly name: string;
  /**
  * Pim
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#pim LogicalRouter#pim}
  */
  readonly pim?: LogicalRouterVrfMulticastInterfaceGroupPim;
}

export function logicalRouterVrfMulticastInterfaceGroupToTerraform(struct?: LogicalRouterVrfMulticastInterfaceGroup | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    description: cdktf.stringToTerraform(struct!.description),
    group_permission: logicalRouterVrfMulticastInterfaceGroupGroupPermissionToTerraform(struct!.groupPermission),
    igmp: logicalRouterVrfMulticastInterfaceGroupIgmpToTerraform(struct!.igmp),
    interface: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.interface),
    name: cdktf.stringToTerraform(struct!.name),
    pim: logicalRouterVrfMulticastInterfaceGroupPimToTerraform(struct!.pim),
  }
}


export function logicalRouterVrfMulticastInterfaceGroupToHclTerraform(struct?: LogicalRouterVrfMulticastInterfaceGroup | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    group_permission: {
      value: logicalRouterVrfMulticastInterfaceGroupGroupPermissionToHclTerraform(struct!.groupPermission),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfMulticastInterfaceGroupGroupPermission",
    },
    igmp: {
      value: logicalRouterVrfMulticastInterfaceGroupIgmpToHclTerraform(struct!.igmp),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfMulticastInterfaceGroupIgmp",
    },
    interface: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.interface),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pim: {
      value: logicalRouterVrfMulticastInterfaceGroupPimToHclTerraform(struct!.pim),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfMulticastInterfaceGroupPim",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfMulticastInterfaceGroupOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): LogicalRouterVrfMulticastInterfaceGroup | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._groupPermission?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupPermission = this._groupPermission?.internalValue;
    }
    if (this._igmp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.igmp = this._igmp?.internalValue;
    }
    if (this._interface !== undefined) {
      hasAnyValues = true;
      internalValueResult.interface = this._interface;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._pim?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pim = this._pim?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfMulticastInterfaceGroup | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._description = undefined;
      this._groupPermission.internalValue = undefined;
      this._igmp.internalValue = undefined;
      this._interface = undefined;
      this._name = undefined;
      this._pim.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._description = value.description;
      this._groupPermission.internalValue = value.groupPermission;
      this._igmp.internalValue = value.igmp;
      this._interface = value.interface;
      this._name = value.name;
      this._pim.internalValue = value.pim;
    }
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // group_permission - computed: false, optional: true, required: false
  private _groupPermission = new LogicalRouterVrfMulticastInterfaceGroupGroupPermissionOutputReference(this, "group_permission");
  public get groupPermission() {
    return this._groupPermission;
  }
  public putGroupPermission(value: LogicalRouterVrfMulticastInterfaceGroupGroupPermission) {
    this._groupPermission.internalValue = value;
  }
  public resetGroupPermission() {
    this._groupPermission.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupPermissionInput() {
    return this._groupPermission.internalValue;
  }

  // igmp - computed: false, optional: true, required: false
  private _igmp = new LogicalRouterVrfMulticastInterfaceGroupIgmpOutputReference(this, "igmp");
  public get igmp() {
    return this._igmp;
  }
  public putIgmp(value: LogicalRouterVrfMulticastInterfaceGroupIgmp) {
    this._igmp.internalValue = value;
  }
  public resetIgmp() {
    this._igmp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get igmpInput() {
    return this._igmp.internalValue;
  }

  // interface - computed: false, optional: true, required: false
  private _interface?: string[]; 
  public get interface() {
    return this.getListAttribute('interface');
  }
  public set interface(value: string[]) {
    this._interface = value;
  }
  public resetInterface() {
    this._interface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfaceInput() {
    return this._interface;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // pim - computed: false, optional: true, required: false
  private _pim = new LogicalRouterVrfMulticastInterfaceGroupPimOutputReference(this, "pim");
  public get pim() {
    return this._pim;
  }
  public putPim(value: LogicalRouterVrfMulticastInterfaceGroupPim) {
    this._pim.internalValue = value;
  }
  public resetPim() {
    this._pim.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pimInput() {
    return this._pim.internalValue;
  }
}

export class LogicalRouterVrfMulticastInterfaceGroupList extends cdktf.ComplexList {
  public internalValue? : LogicalRouterVrfMulticastInterfaceGroup[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): LogicalRouterVrfMulticastInterfaceGroupOutputReference {
    return new LogicalRouterVrfMulticastInterfaceGroupOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface LogicalRouterVrfMulticastMsdpOriginatorId {
  /**
  * Interface
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#interface LogicalRouter#interface}
  */
  readonly interface?: string;
  /**
  * Ip
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#ip LogicalRouter#ip}
  */
  readonly ip?: string;
}

export function logicalRouterVrfMulticastMsdpOriginatorIdToTerraform(struct?: LogicalRouterVrfMulticastMsdpOriginatorId | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    interface: cdktf.stringToTerraform(struct!.interface),
    ip: cdktf.stringToTerraform(struct!.ip),
  }
}


export function logicalRouterVrfMulticastMsdpOriginatorIdToHclTerraform(struct?: LogicalRouterVrfMulticastMsdpOriginatorId | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    interface: {
      value: cdktf.stringToHclTerraform(struct!.interface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip: {
      value: cdktf.stringToHclTerraform(struct!.ip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfMulticastMsdpOriginatorIdOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfMulticastMsdpOriginatorId | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._interface !== undefined) {
      hasAnyValues = true;
      internalValueResult.interface = this._interface;
    }
    if (this._ip !== undefined) {
      hasAnyValues = true;
      internalValueResult.ip = this._ip;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfMulticastMsdpOriginatorId | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._interface = undefined;
      this._ip = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._interface = value.interface;
      this._ip = value.ip;
    }
  }

  // interface - computed: false, optional: true, required: false
  private _interface?: string; 
  public get interface() {
    return this.getStringAttribute('interface');
  }
  public set interface(value: string) {
    this._interface = value;
  }
  public resetInterface() {
    this._interface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfaceInput() {
    return this._interface;
  }

  // ip - computed: false, optional: true, required: false
  private _ip?: string; 
  public get ip() {
    return this.getStringAttribute('ip');
  }
  public set ip(value: string) {
    this._ip = value;
  }
  public resetIp() {
    this._ip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipInput() {
    return this._ip;
  }
}
export interface LogicalRouterVrfMulticastMsdpPeerLocalAddress {
  /**
  * Interface
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#interface LogicalRouter#interface}
  */
  readonly interface?: string;
  /**
  * Ip
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#ip LogicalRouter#ip}
  */
  readonly ip?: string;
}

export function logicalRouterVrfMulticastMsdpPeerLocalAddressToTerraform(struct?: LogicalRouterVrfMulticastMsdpPeerLocalAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    interface: cdktf.stringToTerraform(struct!.interface),
    ip: cdktf.stringToTerraform(struct!.ip),
  }
}


export function logicalRouterVrfMulticastMsdpPeerLocalAddressToHclTerraform(struct?: LogicalRouterVrfMulticastMsdpPeerLocalAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    interface: {
      value: cdktf.stringToHclTerraform(struct!.interface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip: {
      value: cdktf.stringToHclTerraform(struct!.ip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfMulticastMsdpPeerLocalAddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfMulticastMsdpPeerLocalAddress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._interface !== undefined) {
      hasAnyValues = true;
      internalValueResult.interface = this._interface;
    }
    if (this._ip !== undefined) {
      hasAnyValues = true;
      internalValueResult.ip = this._ip;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfMulticastMsdpPeerLocalAddress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._interface = undefined;
      this._ip = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._interface = value.interface;
      this._ip = value.ip;
    }
  }

  // interface - computed: false, optional: true, required: false
  private _interface?: string; 
  public get interface() {
    return this.getStringAttribute('interface');
  }
  public set interface(value: string) {
    this._interface = value;
  }
  public resetInterface() {
    this._interface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfaceInput() {
    return this._interface;
  }

  // ip - computed: false, optional: true, required: false
  private _ip?: string; 
  public get ip() {
    return this.getStringAttribute('ip');
  }
  public set ip(value: string) {
    this._ip = value;
  }
  public resetIp() {
    this._ip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipInput() {
    return this._ip;
  }
}
export interface LogicalRouterVrfMulticastMsdpPeerPeerAddress {
  /**
  * Fqdn
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#fqdn LogicalRouter#fqdn}
  */
  readonly fqdn?: string;
  /**
  * Ip
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#ip LogicalRouter#ip}
  */
  readonly ip?: string;
}

export function logicalRouterVrfMulticastMsdpPeerPeerAddressToTerraform(struct?: LogicalRouterVrfMulticastMsdpPeerPeerAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    fqdn: cdktf.stringToTerraform(struct!.fqdn),
    ip: cdktf.stringToTerraform(struct!.ip),
  }
}


export function logicalRouterVrfMulticastMsdpPeerPeerAddressToHclTerraform(struct?: LogicalRouterVrfMulticastMsdpPeerPeerAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    fqdn: {
      value: cdktf.stringToHclTerraform(struct!.fqdn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip: {
      value: cdktf.stringToHclTerraform(struct!.ip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfMulticastMsdpPeerPeerAddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfMulticastMsdpPeerPeerAddress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fqdn !== undefined) {
      hasAnyValues = true;
      internalValueResult.fqdn = this._fqdn;
    }
    if (this._ip !== undefined) {
      hasAnyValues = true;
      internalValueResult.ip = this._ip;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfMulticastMsdpPeerPeerAddress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fqdn = undefined;
      this._ip = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fqdn = value.fqdn;
      this._ip = value.ip;
    }
  }

  // fqdn - computed: false, optional: true, required: false
  private _fqdn?: string; 
  public get fqdn() {
    return this.getStringAttribute('fqdn');
  }
  public set fqdn(value: string) {
    this._fqdn = value;
  }
  public resetFqdn() {
    this._fqdn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fqdnInput() {
    return this._fqdn;
  }

  // ip - computed: false, optional: true, required: false
  private _ip?: string; 
  public get ip() {
    return this.getStringAttribute('ip');
  }
  public set ip(value: string) {
    this._ip = value;
  }
  public resetIp() {
    this._ip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipInput() {
    return this._ip;
  }
}
export interface LogicalRouterVrfMulticastMsdpPeer {
  /**
  * Authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#authentication LogicalRouter#authentication}
  */
  readonly authentication?: string;
  /**
  * Enable
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#enable LogicalRouter#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * Inbound sa filter
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#inbound_sa_filter LogicalRouter#inbound_sa_filter}
  */
  readonly inboundSaFilter?: string;
  /**
  * Local address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#local_address LogicalRouter#local_address}
  */
  readonly localAddress?: LogicalRouterVrfMulticastMsdpPeerLocalAddress;
  /**
  * Max sa
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#max_sa LogicalRouter#max_sa}
  */
  readonly maxSa?: number;
  /**
  * Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#name LogicalRouter#name}
  */
  readonly name: string;
  /**
  * Outbound sa filter
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#outbound_sa_filter LogicalRouter#outbound_sa_filter}
  */
  readonly outboundSaFilter?: string;
  /**
  * Peer address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#peer_address LogicalRouter#peer_address}
  */
  readonly peerAddress?: LogicalRouterVrfMulticastMsdpPeerPeerAddress;
  /**
  * Peer as
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#peer_as LogicalRouter#peer_as}
  */
  readonly peerAs?: string;
}

export function logicalRouterVrfMulticastMsdpPeerToTerraform(struct?: LogicalRouterVrfMulticastMsdpPeer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    authentication: cdktf.stringToTerraform(struct!.authentication),
    enable: cdktf.booleanToTerraform(struct!.enable),
    inbound_sa_filter: cdktf.stringToTerraform(struct!.inboundSaFilter),
    local_address: logicalRouterVrfMulticastMsdpPeerLocalAddressToTerraform(struct!.localAddress),
    max_sa: cdktf.numberToTerraform(struct!.maxSa),
    name: cdktf.stringToTerraform(struct!.name),
    outbound_sa_filter: cdktf.stringToTerraform(struct!.outboundSaFilter),
    peer_address: logicalRouterVrfMulticastMsdpPeerPeerAddressToTerraform(struct!.peerAddress),
    peer_as: cdktf.stringToTerraform(struct!.peerAs),
  }
}


export function logicalRouterVrfMulticastMsdpPeerToHclTerraform(struct?: LogicalRouterVrfMulticastMsdpPeer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    authentication: {
      value: cdktf.stringToHclTerraform(struct!.authentication),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    inbound_sa_filter: {
      value: cdktf.stringToHclTerraform(struct!.inboundSaFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    local_address: {
      value: logicalRouterVrfMulticastMsdpPeerLocalAddressToHclTerraform(struct!.localAddress),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfMulticastMsdpPeerLocalAddress",
    },
    max_sa: {
      value: cdktf.numberToHclTerraform(struct!.maxSa),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    outbound_sa_filter: {
      value: cdktf.stringToHclTerraform(struct!.outboundSaFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    peer_address: {
      value: logicalRouterVrfMulticastMsdpPeerPeerAddressToHclTerraform(struct!.peerAddress),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfMulticastMsdpPeerPeerAddress",
    },
    peer_as: {
      value: cdktf.stringToHclTerraform(struct!.peerAs),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfMulticastMsdpPeerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): LogicalRouterVrfMulticastMsdpPeer | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authentication !== undefined) {
      hasAnyValues = true;
      internalValueResult.authentication = this._authentication;
    }
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._inboundSaFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.inboundSaFilter = this._inboundSaFilter;
    }
    if (this._localAddress?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.localAddress = this._localAddress?.internalValue;
    }
    if (this._maxSa !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSa = this._maxSa;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._outboundSaFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.outboundSaFilter = this._outboundSaFilter;
    }
    if (this._peerAddress?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.peerAddress = this._peerAddress?.internalValue;
    }
    if (this._peerAs !== undefined) {
      hasAnyValues = true;
      internalValueResult.peerAs = this._peerAs;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfMulticastMsdpPeer | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authentication = undefined;
      this._enable = undefined;
      this._inboundSaFilter = undefined;
      this._localAddress.internalValue = undefined;
      this._maxSa = undefined;
      this._name = undefined;
      this._outboundSaFilter = undefined;
      this._peerAddress.internalValue = undefined;
      this._peerAs = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authentication = value.authentication;
      this._enable = value.enable;
      this._inboundSaFilter = value.inboundSaFilter;
      this._localAddress.internalValue = value.localAddress;
      this._maxSa = value.maxSa;
      this._name = value.name;
      this._outboundSaFilter = value.outboundSaFilter;
      this._peerAddress.internalValue = value.peerAddress;
      this._peerAs = value.peerAs;
    }
  }

  // authentication - computed: false, optional: true, required: false
  private _authentication?: string; 
  public get authentication() {
    return this.getStringAttribute('authentication');
  }
  public set authentication(value: string) {
    this._authentication = value;
  }
  public resetAuthentication() {
    this._authentication = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authenticationInput() {
    return this._authentication;
  }

  // enable - computed: false, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // inbound_sa_filter - computed: false, optional: true, required: false
  private _inboundSaFilter?: string; 
  public get inboundSaFilter() {
    return this.getStringAttribute('inbound_sa_filter');
  }
  public set inboundSaFilter(value: string) {
    this._inboundSaFilter = value;
  }
  public resetInboundSaFilter() {
    this._inboundSaFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inboundSaFilterInput() {
    return this._inboundSaFilter;
  }

  // local_address - computed: false, optional: true, required: false
  private _localAddress = new LogicalRouterVrfMulticastMsdpPeerLocalAddressOutputReference(this, "local_address");
  public get localAddress() {
    return this._localAddress;
  }
  public putLocalAddress(value: LogicalRouterVrfMulticastMsdpPeerLocalAddress) {
    this._localAddress.internalValue = value;
  }
  public resetLocalAddress() {
    this._localAddress.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localAddressInput() {
    return this._localAddress.internalValue;
  }

  // max_sa - computed: false, optional: true, required: false
  private _maxSa?: number; 
  public get maxSa() {
    return this.getNumberAttribute('max_sa');
  }
  public set maxSa(value: number) {
    this._maxSa = value;
  }
  public resetMaxSa() {
    this._maxSa = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSaInput() {
    return this._maxSa;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // outbound_sa_filter - computed: false, optional: true, required: false
  private _outboundSaFilter?: string; 
  public get outboundSaFilter() {
    return this.getStringAttribute('outbound_sa_filter');
  }
  public set outboundSaFilter(value: string) {
    this._outboundSaFilter = value;
  }
  public resetOutboundSaFilter() {
    this._outboundSaFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get outboundSaFilterInput() {
    return this._outboundSaFilter;
  }

  // peer_address - computed: false, optional: true, required: false
  private _peerAddress = new LogicalRouterVrfMulticastMsdpPeerPeerAddressOutputReference(this, "peer_address");
  public get peerAddress() {
    return this._peerAddress;
  }
  public putPeerAddress(value: LogicalRouterVrfMulticastMsdpPeerPeerAddress) {
    this._peerAddress.internalValue = value;
  }
  public resetPeerAddress() {
    this._peerAddress.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get peerAddressInput() {
    return this._peerAddress.internalValue;
  }

  // peer_as - computed: false, optional: true, required: false
  private _peerAs?: string; 
  public get peerAs() {
    return this.getStringAttribute('peer_as');
  }
  public set peerAs(value: string) {
    this._peerAs = value;
  }
  public resetPeerAs() {
    this._peerAs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get peerAsInput() {
    return this._peerAs;
  }
}

export class LogicalRouterVrfMulticastMsdpPeerList extends cdktf.ComplexList {
  public internalValue? : LogicalRouterVrfMulticastMsdpPeer[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): LogicalRouterVrfMulticastMsdpPeerOutputReference {
    return new LogicalRouterVrfMulticastMsdpPeerOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface LogicalRouterVrfMulticastMsdp {
  /**
  * Enable
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#enable LogicalRouter#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * Global authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#global_authentication LogicalRouter#global_authentication}
  */
  readonly globalAuthentication?: string;
  /**
  * Global timer
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#global_timer LogicalRouter#global_timer}
  */
  readonly globalTimer?: string;
  /**
  * Originator id
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#originator_id LogicalRouter#originator_id}
  */
  readonly originatorId?: LogicalRouterVrfMulticastMsdpOriginatorId;
  /**
  * Peer
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#peer LogicalRouter#peer}
  */
  readonly peer?: LogicalRouterVrfMulticastMsdpPeer[] | cdktf.IResolvable;
}

export function logicalRouterVrfMulticastMsdpToTerraform(struct?: LogicalRouterVrfMulticastMsdp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enable: cdktf.booleanToTerraform(struct!.enable),
    global_authentication: cdktf.stringToTerraform(struct!.globalAuthentication),
    global_timer: cdktf.stringToTerraform(struct!.globalTimer),
    originator_id: logicalRouterVrfMulticastMsdpOriginatorIdToTerraform(struct!.originatorId),
    peer: cdktf.listMapper(logicalRouterVrfMulticastMsdpPeerToTerraform, false)(struct!.peer),
  }
}


export function logicalRouterVrfMulticastMsdpToHclTerraform(struct?: LogicalRouterVrfMulticastMsdp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    global_authentication: {
      value: cdktf.stringToHclTerraform(struct!.globalAuthentication),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    global_timer: {
      value: cdktf.stringToHclTerraform(struct!.globalTimer),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    originator_id: {
      value: logicalRouterVrfMulticastMsdpOriginatorIdToHclTerraform(struct!.originatorId),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfMulticastMsdpOriginatorId",
    },
    peer: {
      value: cdktf.listMapperHcl(logicalRouterVrfMulticastMsdpPeerToHclTerraform, false)(struct!.peer),
      isBlock: true,
      type: "list",
      storageClassType: "LogicalRouterVrfMulticastMsdpPeerList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfMulticastMsdpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfMulticastMsdp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._globalAuthentication !== undefined) {
      hasAnyValues = true;
      internalValueResult.globalAuthentication = this._globalAuthentication;
    }
    if (this._globalTimer !== undefined) {
      hasAnyValues = true;
      internalValueResult.globalTimer = this._globalTimer;
    }
    if (this._originatorId?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.originatorId = this._originatorId?.internalValue;
    }
    if (this._peer?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.peer = this._peer?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfMulticastMsdp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enable = undefined;
      this._globalAuthentication = undefined;
      this._globalTimer = undefined;
      this._originatorId.internalValue = undefined;
      this._peer.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enable = value.enable;
      this._globalAuthentication = value.globalAuthentication;
      this._globalTimer = value.globalTimer;
      this._originatorId.internalValue = value.originatorId;
      this._peer.internalValue = value.peer;
    }
  }

  // enable - computed: false, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // global_authentication - computed: false, optional: true, required: false
  private _globalAuthentication?: string; 
  public get globalAuthentication() {
    return this.getStringAttribute('global_authentication');
  }
  public set globalAuthentication(value: string) {
    this._globalAuthentication = value;
  }
  public resetGlobalAuthentication() {
    this._globalAuthentication = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get globalAuthenticationInput() {
    return this._globalAuthentication;
  }

  // global_timer - computed: false, optional: true, required: false
  private _globalTimer?: string; 
  public get globalTimer() {
    return this.getStringAttribute('global_timer');
  }
  public set globalTimer(value: string) {
    this._globalTimer = value;
  }
  public resetGlobalTimer() {
    this._globalTimer = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get globalTimerInput() {
    return this._globalTimer;
  }

  // originator_id - computed: false, optional: true, required: false
  private _originatorId = new LogicalRouterVrfMulticastMsdpOriginatorIdOutputReference(this, "originator_id");
  public get originatorId() {
    return this._originatorId;
  }
  public putOriginatorId(value: LogicalRouterVrfMulticastMsdpOriginatorId) {
    this._originatorId.internalValue = value;
  }
  public resetOriginatorId() {
    this._originatorId.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get originatorIdInput() {
    return this._originatorId.internalValue;
  }

  // peer - computed: false, optional: true, required: false
  private _peer = new LogicalRouterVrfMulticastMsdpPeerList(this, "peer", false);
  public get peer() {
    return this._peer;
  }
  public putPeer(value: LogicalRouterVrfMulticastMsdpPeer[] | cdktf.IResolvable) {
    this._peer.internalValue = value;
  }
  public resetPeer() {
    this._peer.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get peerInput() {
    return this._peer.internalValue;
  }
}
export interface LogicalRouterVrfMulticastPimInterface {
  /**
  * Description
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#description LogicalRouter#description}
  */
  readonly description?: string;
  /**
  * Dr priority
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#dr_priority LogicalRouter#dr_priority}
  */
  readonly drPriority?: number;
  /**
  * If timer
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#if_timer LogicalRouter#if_timer}
  */
  readonly ifTimer?: string;
  /**
  * Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#name LogicalRouter#name}
  */
  readonly name: string;
  /**
  * Neighbor filter
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#neighbor_filter LogicalRouter#neighbor_filter}
  */
  readonly neighborFilter?: string;
  /**
  * Send bsm
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#send_bsm LogicalRouter#send_bsm}
  */
  readonly sendBsm?: boolean | cdktf.IResolvable;
}

export function logicalRouterVrfMulticastPimInterfaceToTerraform(struct?: LogicalRouterVrfMulticastPimInterface | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    description: cdktf.stringToTerraform(struct!.description),
    dr_priority: cdktf.numberToTerraform(struct!.drPriority),
    if_timer: cdktf.stringToTerraform(struct!.ifTimer),
    name: cdktf.stringToTerraform(struct!.name),
    neighbor_filter: cdktf.stringToTerraform(struct!.neighborFilter),
    send_bsm: cdktf.booleanToTerraform(struct!.sendBsm),
  }
}


export function logicalRouterVrfMulticastPimInterfaceToHclTerraform(struct?: LogicalRouterVrfMulticastPimInterface | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dr_priority: {
      value: cdktf.numberToHclTerraform(struct!.drPriority),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    if_timer: {
      value: cdktf.stringToHclTerraform(struct!.ifTimer),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    neighbor_filter: {
      value: cdktf.stringToHclTerraform(struct!.neighborFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    send_bsm: {
      value: cdktf.booleanToHclTerraform(struct!.sendBsm),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfMulticastPimInterfaceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): LogicalRouterVrfMulticastPimInterface | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._drPriority !== undefined) {
      hasAnyValues = true;
      internalValueResult.drPriority = this._drPriority;
    }
    if (this._ifTimer !== undefined) {
      hasAnyValues = true;
      internalValueResult.ifTimer = this._ifTimer;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._neighborFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.neighborFilter = this._neighborFilter;
    }
    if (this._sendBsm !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendBsm = this._sendBsm;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfMulticastPimInterface | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._description = undefined;
      this._drPriority = undefined;
      this._ifTimer = undefined;
      this._name = undefined;
      this._neighborFilter = undefined;
      this._sendBsm = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._description = value.description;
      this._drPriority = value.drPriority;
      this._ifTimer = value.ifTimer;
      this._name = value.name;
      this._neighborFilter = value.neighborFilter;
      this._sendBsm = value.sendBsm;
    }
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // dr_priority - computed: false, optional: true, required: false
  private _drPriority?: number; 
  public get drPriority() {
    return this.getNumberAttribute('dr_priority');
  }
  public set drPriority(value: number) {
    this._drPriority = value;
  }
  public resetDrPriority() {
    this._drPriority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get drPriorityInput() {
    return this._drPriority;
  }

  // if_timer - computed: false, optional: true, required: false
  private _ifTimer?: string; 
  public get ifTimer() {
    return this.getStringAttribute('if_timer');
  }
  public set ifTimer(value: string) {
    this._ifTimer = value;
  }
  public resetIfTimer() {
    this._ifTimer = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ifTimerInput() {
    return this._ifTimer;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // neighbor_filter - computed: false, optional: true, required: false
  private _neighborFilter?: string; 
  public get neighborFilter() {
    return this.getStringAttribute('neighbor_filter');
  }
  public set neighborFilter(value: string) {
    this._neighborFilter = value;
  }
  public resetNeighborFilter() {
    this._neighborFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get neighborFilterInput() {
    return this._neighborFilter;
  }

  // send_bsm - computed: false, optional: true, required: false
  private _sendBsm?: boolean | cdktf.IResolvable; 
  public get sendBsm() {
    return this.getBooleanAttribute('send_bsm');
  }
  public set sendBsm(value: boolean | cdktf.IResolvable) {
    this._sendBsm = value;
  }
  public resetSendBsm() {
    this._sendBsm = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendBsmInput() {
    return this._sendBsm;
  }
}

export class LogicalRouterVrfMulticastPimInterfaceList extends cdktf.ComplexList {
  public internalValue? : LogicalRouterVrfMulticastPimInterface[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): LogicalRouterVrfMulticastPimInterfaceOutputReference {
    return new LogicalRouterVrfMulticastPimInterfaceOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface LogicalRouterVrfMulticastPimRpExternalRp {
  /**
  * Group list
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#group_list LogicalRouter#group_list}
  */
  readonly groupList?: string;
  /**
  * Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#name LogicalRouter#name}
  */
  readonly name?: string;
  /**
  * Override
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#override LogicalRouter#override}
  */
  readonly override?: boolean | cdktf.IResolvable;
}

export function logicalRouterVrfMulticastPimRpExternalRpToTerraform(struct?: LogicalRouterVrfMulticastPimRpExternalRp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    group_list: cdktf.stringToTerraform(struct!.groupList),
    name: cdktf.stringToTerraform(struct!.name),
    override: cdktf.booleanToTerraform(struct!.override),
  }
}


export function logicalRouterVrfMulticastPimRpExternalRpToHclTerraform(struct?: LogicalRouterVrfMulticastPimRpExternalRp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    group_list: {
      value: cdktf.stringToHclTerraform(struct!.groupList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    override: {
      value: cdktf.booleanToHclTerraform(struct!.override),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfMulticastPimRpExternalRpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): LogicalRouterVrfMulticastPimRpExternalRp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._groupList !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupList = this._groupList;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._override !== undefined) {
      hasAnyValues = true;
      internalValueResult.override = this._override;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfMulticastPimRpExternalRp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._groupList = undefined;
      this._name = undefined;
      this._override = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._groupList = value.groupList;
      this._name = value.name;
      this._override = value.override;
    }
  }

  // group_list - computed: false, optional: true, required: false
  private _groupList?: string; 
  public get groupList() {
    return this.getStringAttribute('group_list');
  }
  public set groupList(value: string) {
    this._groupList = value;
  }
  public resetGroupList() {
    this._groupList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupListInput() {
    return this._groupList;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // override - computed: false, optional: true, required: false
  private _override?: boolean | cdktf.IResolvable; 
  public get override() {
    return this.getBooleanAttribute('override');
  }
  public set override(value: boolean | cdktf.IResolvable) {
    this._override = value;
  }
  public resetOverride() {
    this._override = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overrideInput() {
    return this._override;
  }
}

export class LogicalRouterVrfMulticastPimRpExternalRpList extends cdktf.ComplexList {
  public internalValue? : LogicalRouterVrfMulticastPimRpExternalRp[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): LogicalRouterVrfMulticastPimRpExternalRpOutputReference {
    return new LogicalRouterVrfMulticastPimRpExternalRpOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface LogicalRouterVrfMulticastPimRpLocalRpCandidateRp {
  /**
  * Address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#address LogicalRouter#address}
  */
  readonly address?: string;
  /**
  * Advertisement interval
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#advertisement_interval LogicalRouter#advertisement_interval}
  */
  readonly advertisementInterval?: number;
  /**
  * Group list
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#group_list LogicalRouter#group_list}
  */
  readonly groupList?: string;
  /**
  * Interface
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#interface LogicalRouter#interface}
  */
  readonly interface?: string;
  /**
  * Priority
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#priority LogicalRouter#priority}
  */
  readonly priority?: number;
}

export function logicalRouterVrfMulticastPimRpLocalRpCandidateRpToTerraform(struct?: LogicalRouterVrfMulticastPimRpLocalRpCandidateRp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: cdktf.stringToTerraform(struct!.address),
    advertisement_interval: cdktf.numberToTerraform(struct!.advertisementInterval),
    group_list: cdktf.stringToTerraform(struct!.groupList),
    interface: cdktf.stringToTerraform(struct!.interface),
    priority: cdktf.numberToTerraform(struct!.priority),
  }
}


export function logicalRouterVrfMulticastPimRpLocalRpCandidateRpToHclTerraform(struct?: LogicalRouterVrfMulticastPimRpLocalRpCandidateRp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: cdktf.stringToHclTerraform(struct!.address),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    advertisement_interval: {
      value: cdktf.numberToHclTerraform(struct!.advertisementInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    group_list: {
      value: cdktf.stringToHclTerraform(struct!.groupList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    interface: {
      value: cdktf.stringToHclTerraform(struct!.interface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priority: {
      value: cdktf.numberToHclTerraform(struct!.priority),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfMulticastPimRpLocalRpCandidateRpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfMulticastPimRpLocalRpCandidateRp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address;
    }
    if (this._advertisementInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.advertisementInterval = this._advertisementInterval;
    }
    if (this._groupList !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupList = this._groupList;
    }
    if (this._interface !== undefined) {
      hasAnyValues = true;
      internalValueResult.interface = this._interface;
    }
    if (this._priority !== undefined) {
      hasAnyValues = true;
      internalValueResult.priority = this._priority;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfMulticastPimRpLocalRpCandidateRp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address = undefined;
      this._advertisementInterval = undefined;
      this._groupList = undefined;
      this._interface = undefined;
      this._priority = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address = value.address;
      this._advertisementInterval = value.advertisementInterval;
      this._groupList = value.groupList;
      this._interface = value.interface;
      this._priority = value.priority;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address?: string; 
  public get address() {
    return this.getStringAttribute('address');
  }
  public set address(value: string) {
    this._address = value;
  }
  public resetAddress() {
    this._address = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address;
  }

  // advertisement_interval - computed: false, optional: true, required: false
  private _advertisementInterval?: number; 
  public get advertisementInterval() {
    return this.getNumberAttribute('advertisement_interval');
  }
  public set advertisementInterval(value: number) {
    this._advertisementInterval = value;
  }
  public resetAdvertisementInterval() {
    this._advertisementInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get advertisementIntervalInput() {
    return this._advertisementInterval;
  }

  // group_list - computed: false, optional: true, required: false
  private _groupList?: string; 
  public get groupList() {
    return this.getStringAttribute('group_list');
  }
  public set groupList(value: string) {
    this._groupList = value;
  }
  public resetGroupList() {
    this._groupList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupListInput() {
    return this._groupList;
  }

  // interface - computed: false, optional: true, required: false
  private _interface?: string; 
  public get interface() {
    return this.getStringAttribute('interface');
  }
  public set interface(value: string) {
    this._interface = value;
  }
  public resetInterface() {
    this._interface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfaceInput() {
    return this._interface;
  }

  // priority - computed: false, optional: true, required: false
  private _priority?: number; 
  public get priority() {
    return this.getNumberAttribute('priority');
  }
  public set priority(value: number) {
    this._priority = value;
  }
  public resetPriority() {
    this._priority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get priorityInput() {
    return this._priority;
  }
}
export interface LogicalRouterVrfMulticastPimRpLocalRpStaticRp {
  /**
  * Address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#address LogicalRouter#address}
  */
  readonly address?: string;
  /**
  * Group list
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#group_list LogicalRouter#group_list}
  */
  readonly groupList?: string;
  /**
  * Interface
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#interface LogicalRouter#interface}
  */
  readonly interface?: string;
  /**
  * Override
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#override LogicalRouter#override}
  */
  readonly override?: boolean | cdktf.IResolvable;
}

export function logicalRouterVrfMulticastPimRpLocalRpStaticRpToTerraform(struct?: LogicalRouterVrfMulticastPimRpLocalRpStaticRp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: cdktf.stringToTerraform(struct!.address),
    group_list: cdktf.stringToTerraform(struct!.groupList),
    interface: cdktf.stringToTerraform(struct!.interface),
    override: cdktf.booleanToTerraform(struct!.override),
  }
}


export function logicalRouterVrfMulticastPimRpLocalRpStaticRpToHclTerraform(struct?: LogicalRouterVrfMulticastPimRpLocalRpStaticRp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: cdktf.stringToHclTerraform(struct!.address),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    group_list: {
      value: cdktf.stringToHclTerraform(struct!.groupList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    interface: {
      value: cdktf.stringToHclTerraform(struct!.interface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    override: {
      value: cdktf.booleanToHclTerraform(struct!.override),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfMulticastPimRpLocalRpStaticRpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfMulticastPimRpLocalRpStaticRp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address;
    }
    if (this._groupList !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupList = this._groupList;
    }
    if (this._interface !== undefined) {
      hasAnyValues = true;
      internalValueResult.interface = this._interface;
    }
    if (this._override !== undefined) {
      hasAnyValues = true;
      internalValueResult.override = this._override;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfMulticastPimRpLocalRpStaticRp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address = undefined;
      this._groupList = undefined;
      this._interface = undefined;
      this._override = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address = value.address;
      this._groupList = value.groupList;
      this._interface = value.interface;
      this._override = value.override;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address?: string; 
  public get address() {
    return this.getStringAttribute('address');
  }
  public set address(value: string) {
    this._address = value;
  }
  public resetAddress() {
    this._address = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address;
  }

  // group_list - computed: false, optional: true, required: false
  private _groupList?: string; 
  public get groupList() {
    return this.getStringAttribute('group_list');
  }
  public set groupList(value: string) {
    this._groupList = value;
  }
  public resetGroupList() {
    this._groupList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupListInput() {
    return this._groupList;
  }

  // interface - computed: false, optional: true, required: false
  private _interface?: string; 
  public get interface() {
    return this.getStringAttribute('interface');
  }
  public set interface(value: string) {
    this._interface = value;
  }
  public resetInterface() {
    this._interface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfaceInput() {
    return this._interface;
  }

  // override - computed: false, optional: true, required: false
  private _override?: boolean | cdktf.IResolvable; 
  public get override() {
    return this.getBooleanAttribute('override');
  }
  public set override(value: boolean | cdktf.IResolvable) {
    this._override = value;
  }
  public resetOverride() {
    this._override = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overrideInput() {
    return this._override;
  }
}
export interface LogicalRouterVrfMulticastPimRpLocalRp {
  /**
  * Candidate rp
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#candidate_rp LogicalRouter#candidate_rp}
  */
  readonly candidateRp?: LogicalRouterVrfMulticastPimRpLocalRpCandidateRp;
  /**
  * Static rp
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#static_rp LogicalRouter#static_rp}
  */
  readonly staticRp?: LogicalRouterVrfMulticastPimRpLocalRpStaticRp;
}

export function logicalRouterVrfMulticastPimRpLocalRpToTerraform(struct?: LogicalRouterVrfMulticastPimRpLocalRp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    candidate_rp: logicalRouterVrfMulticastPimRpLocalRpCandidateRpToTerraform(struct!.candidateRp),
    static_rp: logicalRouterVrfMulticastPimRpLocalRpStaticRpToTerraform(struct!.staticRp),
  }
}


export function logicalRouterVrfMulticastPimRpLocalRpToHclTerraform(struct?: LogicalRouterVrfMulticastPimRpLocalRp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    candidate_rp: {
      value: logicalRouterVrfMulticastPimRpLocalRpCandidateRpToHclTerraform(struct!.candidateRp),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfMulticastPimRpLocalRpCandidateRp",
    },
    static_rp: {
      value: logicalRouterVrfMulticastPimRpLocalRpStaticRpToHclTerraform(struct!.staticRp),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfMulticastPimRpLocalRpStaticRp",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfMulticastPimRpLocalRpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfMulticastPimRpLocalRp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._candidateRp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.candidateRp = this._candidateRp?.internalValue;
    }
    if (this._staticRp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.staticRp = this._staticRp?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfMulticastPimRpLocalRp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._candidateRp.internalValue = undefined;
      this._staticRp.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._candidateRp.internalValue = value.candidateRp;
      this._staticRp.internalValue = value.staticRp;
    }
  }

  // candidate_rp - computed: false, optional: true, required: false
  private _candidateRp = new LogicalRouterVrfMulticastPimRpLocalRpCandidateRpOutputReference(this, "candidate_rp");
  public get candidateRp() {
    return this._candidateRp;
  }
  public putCandidateRp(value: LogicalRouterVrfMulticastPimRpLocalRpCandidateRp) {
    this._candidateRp.internalValue = value;
  }
  public resetCandidateRp() {
    this._candidateRp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get candidateRpInput() {
    return this._candidateRp.internalValue;
  }

  // static_rp - computed: false, optional: true, required: false
  private _staticRp = new LogicalRouterVrfMulticastPimRpLocalRpStaticRpOutputReference(this, "static_rp");
  public get staticRp() {
    return this._staticRp;
  }
  public putStaticRp(value: LogicalRouterVrfMulticastPimRpLocalRpStaticRp) {
    this._staticRp.internalValue = value;
  }
  public resetStaticRp() {
    this._staticRp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get staticRpInput() {
    return this._staticRp.internalValue;
  }
}
export interface LogicalRouterVrfMulticastPimRp {
  /**
  * External rp
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#external_rp LogicalRouter#external_rp}
  */
  readonly externalRp?: LogicalRouterVrfMulticastPimRpExternalRp[] | cdktf.IResolvable;
  /**
  * Local rp
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#local_rp LogicalRouter#local_rp}
  */
  readonly localRp?: LogicalRouterVrfMulticastPimRpLocalRp;
}

export function logicalRouterVrfMulticastPimRpToTerraform(struct?: LogicalRouterVrfMulticastPimRp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    external_rp: cdktf.listMapper(logicalRouterVrfMulticastPimRpExternalRpToTerraform, false)(struct!.externalRp),
    local_rp: logicalRouterVrfMulticastPimRpLocalRpToTerraform(struct!.localRp),
  }
}


export function logicalRouterVrfMulticastPimRpToHclTerraform(struct?: LogicalRouterVrfMulticastPimRp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    external_rp: {
      value: cdktf.listMapperHcl(logicalRouterVrfMulticastPimRpExternalRpToHclTerraform, false)(struct!.externalRp),
      isBlock: true,
      type: "list",
      storageClassType: "LogicalRouterVrfMulticastPimRpExternalRpList",
    },
    local_rp: {
      value: logicalRouterVrfMulticastPimRpLocalRpToHclTerraform(struct!.localRp),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfMulticastPimRpLocalRp",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfMulticastPimRpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfMulticastPimRp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._externalRp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.externalRp = this._externalRp?.internalValue;
    }
    if (this._localRp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.localRp = this._localRp?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfMulticastPimRp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._externalRp.internalValue = undefined;
      this._localRp.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._externalRp.internalValue = value.externalRp;
      this._localRp.internalValue = value.localRp;
    }
  }

  // external_rp - computed: false, optional: true, required: false
  private _externalRp = new LogicalRouterVrfMulticastPimRpExternalRpList(this, "external_rp", false);
  public get externalRp() {
    return this._externalRp;
  }
  public putExternalRp(value: LogicalRouterVrfMulticastPimRpExternalRp[] | cdktf.IResolvable) {
    this._externalRp.internalValue = value;
  }
  public resetExternalRp() {
    this._externalRp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get externalRpInput() {
    return this._externalRp.internalValue;
  }

  // local_rp - computed: false, optional: true, required: false
  private _localRp = new LogicalRouterVrfMulticastPimRpLocalRpOutputReference(this, "local_rp");
  public get localRp() {
    return this._localRp;
  }
  public putLocalRp(value: LogicalRouterVrfMulticastPimRpLocalRp) {
    this._localRp.internalValue = value;
  }
  public resetLocalRp() {
    this._localRp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localRpInput() {
    return this._localRp.internalValue;
  }
}
export interface LogicalRouterVrfMulticastPimSptThreshold {
  /**
  * Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#name LogicalRouter#name}
  */
  readonly name: string;
  /**
  * Threshold
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#threshold LogicalRouter#threshold}
  */
  readonly threshold?: string;
}

export function logicalRouterVrfMulticastPimSptThresholdToTerraform(struct?: LogicalRouterVrfMulticastPimSptThreshold | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    threshold: cdktf.stringToTerraform(struct!.threshold),
  }
}


export function logicalRouterVrfMulticastPimSptThresholdToHclTerraform(struct?: LogicalRouterVrfMulticastPimSptThreshold | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    threshold: {
      value: cdktf.stringToHclTerraform(struct!.threshold),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfMulticastPimSptThresholdOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): LogicalRouterVrfMulticastPimSptThreshold | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._threshold !== undefined) {
      hasAnyValues = true;
      internalValueResult.threshold = this._threshold;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfMulticastPimSptThreshold | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._threshold = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._threshold = value.threshold;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // threshold - computed: false, optional: true, required: false
  private _threshold?: string; 
  public get threshold() {
    return this.getStringAttribute('threshold');
  }
  public set threshold(value: string) {
    this._threshold = value;
  }
  public resetThreshold() {
    this._threshold = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get thresholdInput() {
    return this._threshold;
  }
}

export class LogicalRouterVrfMulticastPimSptThresholdList extends cdktf.ComplexList {
  public internalValue? : LogicalRouterVrfMulticastPimSptThreshold[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): LogicalRouterVrfMulticastPimSptThresholdOutputReference {
    return new LogicalRouterVrfMulticastPimSptThresholdOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface LogicalRouterVrfMulticastPimSsmAddressSpace {
  /**
  * Group list
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#group_list LogicalRouter#group_list}
  */
  readonly groupList?: string;
}

export function logicalRouterVrfMulticastPimSsmAddressSpaceToTerraform(struct?: LogicalRouterVrfMulticastPimSsmAddressSpace | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    group_list: cdktf.stringToTerraform(struct!.groupList),
  }
}


export function logicalRouterVrfMulticastPimSsmAddressSpaceToHclTerraform(struct?: LogicalRouterVrfMulticastPimSsmAddressSpace | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    group_list: {
      value: cdktf.stringToHclTerraform(struct!.groupList),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfMulticastPimSsmAddressSpaceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfMulticastPimSsmAddressSpace | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._groupList !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupList = this._groupList;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfMulticastPimSsmAddressSpace | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._groupList = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._groupList = value.groupList;
    }
  }

  // group_list - computed: false, optional: true, required: false
  private _groupList?: string; 
  public get groupList() {
    return this.getStringAttribute('group_list');
  }
  public set groupList(value: string) {
    this._groupList = value;
  }
  public resetGroupList() {
    this._groupList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupListInput() {
    return this._groupList;
  }
}
export interface LogicalRouterVrfMulticastPim {
  /**
  * Enable
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#enable LogicalRouter#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * Group permission
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#group_permission LogicalRouter#group_permission}
  */
  readonly groupPermission?: string;
  /**
  * If timer global
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#if_timer_global LogicalRouter#if_timer_global}
  */
  readonly ifTimerGlobal?: string;
  /**
  * Interface
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#interface LogicalRouter#interface}
  */
  readonly interface?: LogicalRouterVrfMulticastPimInterface[] | cdktf.IResolvable;
  /**
  * Route ageout time
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#route_ageout_time LogicalRouter#route_ageout_time}
  */
  readonly routeAgeoutTime?: number;
  /**
  * Rp
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#rp LogicalRouter#rp}
  */
  readonly rp?: LogicalRouterVrfMulticastPimRp;
  /**
  * Rpf lookup mode
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#rpf_lookup_mode LogicalRouter#rpf_lookup_mode}
  */
  readonly rpfLookupMode?: string;
  /**
  * Spt threshold
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#spt_threshold LogicalRouter#spt_threshold}
  */
  readonly sptThreshold?: LogicalRouterVrfMulticastPimSptThreshold[] | cdktf.IResolvable;
  /**
  * Ssm address space
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#ssm_address_space LogicalRouter#ssm_address_space}
  */
  readonly ssmAddressSpace?: LogicalRouterVrfMulticastPimSsmAddressSpace;
}

export function logicalRouterVrfMulticastPimToTerraform(struct?: LogicalRouterVrfMulticastPim | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enable: cdktf.booleanToTerraform(struct!.enable),
    group_permission: cdktf.stringToTerraform(struct!.groupPermission),
    if_timer_global: cdktf.stringToTerraform(struct!.ifTimerGlobal),
    interface: cdktf.listMapper(logicalRouterVrfMulticastPimInterfaceToTerraform, false)(struct!.interface),
    route_ageout_time: cdktf.numberToTerraform(struct!.routeAgeoutTime),
    rp: logicalRouterVrfMulticastPimRpToTerraform(struct!.rp),
    rpf_lookup_mode: cdktf.stringToTerraform(struct!.rpfLookupMode),
    spt_threshold: cdktf.listMapper(logicalRouterVrfMulticastPimSptThresholdToTerraform, false)(struct!.sptThreshold),
    ssm_address_space: logicalRouterVrfMulticastPimSsmAddressSpaceToTerraform(struct!.ssmAddressSpace),
  }
}


export function logicalRouterVrfMulticastPimToHclTerraform(struct?: LogicalRouterVrfMulticastPim | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    group_permission: {
      value: cdktf.stringToHclTerraform(struct!.groupPermission),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    if_timer_global: {
      value: cdktf.stringToHclTerraform(struct!.ifTimerGlobal),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    interface: {
      value: cdktf.listMapperHcl(logicalRouterVrfMulticastPimInterfaceToHclTerraform, false)(struct!.interface),
      isBlock: true,
      type: "list",
      storageClassType: "LogicalRouterVrfMulticastPimInterfaceList",
    },
    route_ageout_time: {
      value: cdktf.numberToHclTerraform(struct!.routeAgeoutTime),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    rp: {
      value: logicalRouterVrfMulticastPimRpToHclTerraform(struct!.rp),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfMulticastPimRp",
    },
    rpf_lookup_mode: {
      value: cdktf.stringToHclTerraform(struct!.rpfLookupMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    spt_threshold: {
      value: cdktf.listMapperHcl(logicalRouterVrfMulticastPimSptThresholdToHclTerraform, false)(struct!.sptThreshold),
      isBlock: true,
      type: "list",
      storageClassType: "LogicalRouterVrfMulticastPimSptThresholdList",
    },
    ssm_address_space: {
      value: logicalRouterVrfMulticastPimSsmAddressSpaceToHclTerraform(struct!.ssmAddressSpace),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfMulticastPimSsmAddressSpace",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfMulticastPimOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfMulticastPim | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._groupPermission !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupPermission = this._groupPermission;
    }
    if (this._ifTimerGlobal !== undefined) {
      hasAnyValues = true;
      internalValueResult.ifTimerGlobal = this._ifTimerGlobal;
    }
    if (this._interface?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.interface = this._interface?.internalValue;
    }
    if (this._routeAgeoutTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeAgeoutTime = this._routeAgeoutTime;
    }
    if (this._rp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rp = this._rp?.internalValue;
    }
    if (this._rpfLookupMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.rpfLookupMode = this._rpfLookupMode;
    }
    if (this._sptThreshold?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sptThreshold = this._sptThreshold?.internalValue;
    }
    if (this._ssmAddressSpace?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ssmAddressSpace = this._ssmAddressSpace?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfMulticastPim | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enable = undefined;
      this._groupPermission = undefined;
      this._ifTimerGlobal = undefined;
      this._interface.internalValue = undefined;
      this._routeAgeoutTime = undefined;
      this._rp.internalValue = undefined;
      this._rpfLookupMode = undefined;
      this._sptThreshold.internalValue = undefined;
      this._ssmAddressSpace.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enable = value.enable;
      this._groupPermission = value.groupPermission;
      this._ifTimerGlobal = value.ifTimerGlobal;
      this._interface.internalValue = value.interface;
      this._routeAgeoutTime = value.routeAgeoutTime;
      this._rp.internalValue = value.rp;
      this._rpfLookupMode = value.rpfLookupMode;
      this._sptThreshold.internalValue = value.sptThreshold;
      this._ssmAddressSpace.internalValue = value.ssmAddressSpace;
    }
  }

  // enable - computed: false, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // group_permission - computed: false, optional: true, required: false
  private _groupPermission?: string; 
  public get groupPermission() {
    return this.getStringAttribute('group_permission');
  }
  public set groupPermission(value: string) {
    this._groupPermission = value;
  }
  public resetGroupPermission() {
    this._groupPermission = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupPermissionInput() {
    return this._groupPermission;
  }

  // if_timer_global - computed: false, optional: true, required: false
  private _ifTimerGlobal?: string; 
  public get ifTimerGlobal() {
    return this.getStringAttribute('if_timer_global');
  }
  public set ifTimerGlobal(value: string) {
    this._ifTimerGlobal = value;
  }
  public resetIfTimerGlobal() {
    this._ifTimerGlobal = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ifTimerGlobalInput() {
    return this._ifTimerGlobal;
  }

  // interface - computed: false, optional: true, required: false
  private _interface = new LogicalRouterVrfMulticastPimInterfaceList(this, "interface", false);
  public get interface() {
    return this._interface;
  }
  public putInterface(value: LogicalRouterVrfMulticastPimInterface[] | cdktf.IResolvable) {
    this._interface.internalValue = value;
  }
  public resetInterface() {
    this._interface.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfaceInput() {
    return this._interface.internalValue;
  }

  // route_ageout_time - computed: false, optional: true, required: false
  private _routeAgeoutTime?: number; 
  public get routeAgeoutTime() {
    return this.getNumberAttribute('route_ageout_time');
  }
  public set routeAgeoutTime(value: number) {
    this._routeAgeoutTime = value;
  }
  public resetRouteAgeoutTime() {
    this._routeAgeoutTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeAgeoutTimeInput() {
    return this._routeAgeoutTime;
  }

  // rp - computed: false, optional: true, required: false
  private _rp = new LogicalRouterVrfMulticastPimRpOutputReference(this, "rp");
  public get rp() {
    return this._rp;
  }
  public putRp(value: LogicalRouterVrfMulticastPimRp) {
    this._rp.internalValue = value;
  }
  public resetRp() {
    this._rp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rpInput() {
    return this._rp.internalValue;
  }

  // rpf_lookup_mode - computed: false, optional: true, required: false
  private _rpfLookupMode?: string; 
  public get rpfLookupMode() {
    return this.getStringAttribute('rpf_lookup_mode');
  }
  public set rpfLookupMode(value: string) {
    this._rpfLookupMode = value;
  }
  public resetRpfLookupMode() {
    this._rpfLookupMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rpfLookupModeInput() {
    return this._rpfLookupMode;
  }

  // spt_threshold - computed: false, optional: true, required: false
  private _sptThreshold = new LogicalRouterVrfMulticastPimSptThresholdList(this, "spt_threshold", false);
  public get sptThreshold() {
    return this._sptThreshold;
  }
  public putSptThreshold(value: LogicalRouterVrfMulticastPimSptThreshold[] | cdktf.IResolvable) {
    this._sptThreshold.internalValue = value;
  }
  public resetSptThreshold() {
    this._sptThreshold.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sptThresholdInput() {
    return this._sptThreshold.internalValue;
  }

  // ssm_address_space - computed: false, optional: true, required: false
  private _ssmAddressSpace = new LogicalRouterVrfMulticastPimSsmAddressSpaceOutputReference(this, "ssm_address_space");
  public get ssmAddressSpace() {
    return this._ssmAddressSpace;
  }
  public putSsmAddressSpace(value: LogicalRouterVrfMulticastPimSsmAddressSpace) {
    this._ssmAddressSpace.internalValue = value;
  }
  public resetSsmAddressSpace() {
    this._ssmAddressSpace.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ssmAddressSpaceInput() {
    return this._ssmAddressSpace.internalValue;
  }
}
export interface LogicalRouterVrfMulticastRpExternalRp {
  /**
  * Group addresses
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#group_addresses LogicalRouter#group_addresses}
  */
  readonly groupAddresses?: string[];
  /**
  * Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#name LogicalRouter#name}
  */
  readonly name: string;
  /**
  * Override
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#override LogicalRouter#override}
  */
  readonly override?: boolean | cdktf.IResolvable;
}

export function logicalRouterVrfMulticastRpExternalRpToTerraform(struct?: LogicalRouterVrfMulticastRpExternalRp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    group_addresses: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.groupAddresses),
    name: cdktf.stringToTerraform(struct!.name),
    override: cdktf.booleanToTerraform(struct!.override),
  }
}


export function logicalRouterVrfMulticastRpExternalRpToHclTerraform(struct?: LogicalRouterVrfMulticastRpExternalRp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    group_addresses: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.groupAddresses),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    override: {
      value: cdktf.booleanToHclTerraform(struct!.override),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfMulticastRpExternalRpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): LogicalRouterVrfMulticastRpExternalRp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._groupAddresses !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupAddresses = this._groupAddresses;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._override !== undefined) {
      hasAnyValues = true;
      internalValueResult.override = this._override;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfMulticastRpExternalRp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._groupAddresses = undefined;
      this._name = undefined;
      this._override = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._groupAddresses = value.groupAddresses;
      this._name = value.name;
      this._override = value.override;
    }
  }

  // group_addresses - computed: false, optional: true, required: false
  private _groupAddresses?: string[]; 
  public get groupAddresses() {
    return this.getListAttribute('group_addresses');
  }
  public set groupAddresses(value: string[]) {
    this._groupAddresses = value;
  }
  public resetGroupAddresses() {
    this._groupAddresses = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupAddressesInput() {
    return this._groupAddresses;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // override - computed: false, optional: true, required: false
  private _override?: boolean | cdktf.IResolvable; 
  public get override() {
    return this.getBooleanAttribute('override');
  }
  public set override(value: boolean | cdktf.IResolvable) {
    this._override = value;
  }
  public resetOverride() {
    this._override = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overrideInput() {
    return this._override;
  }
}

export class LogicalRouterVrfMulticastRpExternalRpList extends cdktf.ComplexList {
  public internalValue? : LogicalRouterVrfMulticastRpExternalRp[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): LogicalRouterVrfMulticastRpExternalRpOutputReference {
    return new LogicalRouterVrfMulticastRpExternalRpOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface LogicalRouterVrfMulticastRpLocalRpCandidateRp {
  /**
  * Address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#address LogicalRouter#address}
  */
  readonly address?: string;
  /**
  * Advertisement interval
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#advertisement_interval LogicalRouter#advertisement_interval}
  */
  readonly advertisementInterval?: number;
  /**
  * Group addresses
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#group_addresses LogicalRouter#group_addresses}
  */
  readonly groupAddresses?: string[];
  /**
  * Interface
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#interface LogicalRouter#interface}
  */
  readonly interface?: string;
  /**
  * Priority
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#priority LogicalRouter#priority}
  */
  readonly priority?: number;
}

export function logicalRouterVrfMulticastRpLocalRpCandidateRpToTerraform(struct?: LogicalRouterVrfMulticastRpLocalRpCandidateRp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: cdktf.stringToTerraform(struct!.address),
    advertisement_interval: cdktf.numberToTerraform(struct!.advertisementInterval),
    group_addresses: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.groupAddresses),
    interface: cdktf.stringToTerraform(struct!.interface),
    priority: cdktf.numberToTerraform(struct!.priority),
  }
}


export function logicalRouterVrfMulticastRpLocalRpCandidateRpToHclTerraform(struct?: LogicalRouterVrfMulticastRpLocalRpCandidateRp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: cdktf.stringToHclTerraform(struct!.address),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    advertisement_interval: {
      value: cdktf.numberToHclTerraform(struct!.advertisementInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    group_addresses: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.groupAddresses),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    interface: {
      value: cdktf.stringToHclTerraform(struct!.interface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priority: {
      value: cdktf.numberToHclTerraform(struct!.priority),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfMulticastRpLocalRpCandidateRpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfMulticastRpLocalRpCandidateRp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address;
    }
    if (this._advertisementInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.advertisementInterval = this._advertisementInterval;
    }
    if (this._groupAddresses !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupAddresses = this._groupAddresses;
    }
    if (this._interface !== undefined) {
      hasAnyValues = true;
      internalValueResult.interface = this._interface;
    }
    if (this._priority !== undefined) {
      hasAnyValues = true;
      internalValueResult.priority = this._priority;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfMulticastRpLocalRpCandidateRp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address = undefined;
      this._advertisementInterval = undefined;
      this._groupAddresses = undefined;
      this._interface = undefined;
      this._priority = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address = value.address;
      this._advertisementInterval = value.advertisementInterval;
      this._groupAddresses = value.groupAddresses;
      this._interface = value.interface;
      this._priority = value.priority;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address?: string; 
  public get address() {
    return this.getStringAttribute('address');
  }
  public set address(value: string) {
    this._address = value;
  }
  public resetAddress() {
    this._address = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address;
  }

  // advertisement_interval - computed: false, optional: true, required: false
  private _advertisementInterval?: number; 
  public get advertisementInterval() {
    return this.getNumberAttribute('advertisement_interval');
  }
  public set advertisementInterval(value: number) {
    this._advertisementInterval = value;
  }
  public resetAdvertisementInterval() {
    this._advertisementInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get advertisementIntervalInput() {
    return this._advertisementInterval;
  }

  // group_addresses - computed: false, optional: true, required: false
  private _groupAddresses?: string[]; 
  public get groupAddresses() {
    return this.getListAttribute('group_addresses');
  }
  public set groupAddresses(value: string[]) {
    this._groupAddresses = value;
  }
  public resetGroupAddresses() {
    this._groupAddresses = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupAddressesInput() {
    return this._groupAddresses;
  }

  // interface - computed: false, optional: true, required: false
  private _interface?: string; 
  public get interface() {
    return this.getStringAttribute('interface');
  }
  public set interface(value: string) {
    this._interface = value;
  }
  public resetInterface() {
    this._interface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfaceInput() {
    return this._interface;
  }

  // priority - computed: false, optional: true, required: false
  private _priority?: number; 
  public get priority() {
    return this.getNumberAttribute('priority');
  }
  public set priority(value: number) {
    this._priority = value;
  }
  public resetPriority() {
    this._priority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get priorityInput() {
    return this._priority;
  }
}
export interface LogicalRouterVrfMulticastRpLocalRpStaticRp {
  /**
  * Address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#address LogicalRouter#address}
  */
  readonly address?: string;
  /**
  * Group addresses
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#group_addresses LogicalRouter#group_addresses}
  */
  readonly groupAddresses?: string[];
  /**
  * Interface
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#interface LogicalRouter#interface}
  */
  readonly interface?: string;
  /**
  * Override
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#override LogicalRouter#override}
  */
  readonly override?: boolean | cdktf.IResolvable;
}

export function logicalRouterVrfMulticastRpLocalRpStaticRpToTerraform(struct?: LogicalRouterVrfMulticastRpLocalRpStaticRp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: cdktf.stringToTerraform(struct!.address),
    group_addresses: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.groupAddresses),
    interface: cdktf.stringToTerraform(struct!.interface),
    override: cdktf.booleanToTerraform(struct!.override),
  }
}


export function logicalRouterVrfMulticastRpLocalRpStaticRpToHclTerraform(struct?: LogicalRouterVrfMulticastRpLocalRpStaticRp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: cdktf.stringToHclTerraform(struct!.address),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    group_addresses: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.groupAddresses),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    interface: {
      value: cdktf.stringToHclTerraform(struct!.interface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    override: {
      value: cdktf.booleanToHclTerraform(struct!.override),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfMulticastRpLocalRpStaticRpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfMulticastRpLocalRpStaticRp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address;
    }
    if (this._groupAddresses !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupAddresses = this._groupAddresses;
    }
    if (this._interface !== undefined) {
      hasAnyValues = true;
      internalValueResult.interface = this._interface;
    }
    if (this._override !== undefined) {
      hasAnyValues = true;
      internalValueResult.override = this._override;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfMulticastRpLocalRpStaticRp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address = undefined;
      this._groupAddresses = undefined;
      this._interface = undefined;
      this._override = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address = value.address;
      this._groupAddresses = value.groupAddresses;
      this._interface = value.interface;
      this._override = value.override;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address?: string; 
  public get address() {
    return this.getStringAttribute('address');
  }
  public set address(value: string) {
    this._address = value;
  }
  public resetAddress() {
    this._address = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address;
  }

  // group_addresses - computed: false, optional: true, required: false
  private _groupAddresses?: string[]; 
  public get groupAddresses() {
    return this.getListAttribute('group_addresses');
  }
  public set groupAddresses(value: string[]) {
    this._groupAddresses = value;
  }
  public resetGroupAddresses() {
    this._groupAddresses = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupAddressesInput() {
    return this._groupAddresses;
  }

  // interface - computed: false, optional: true, required: false
  private _interface?: string; 
  public get interface() {
    return this.getStringAttribute('interface');
  }
  public set interface(value: string) {
    this._interface = value;
  }
  public resetInterface() {
    this._interface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfaceInput() {
    return this._interface;
  }

  // override - computed: false, optional: true, required: false
  private _override?: boolean | cdktf.IResolvable; 
  public get override() {
    return this.getBooleanAttribute('override');
  }
  public set override(value: boolean | cdktf.IResolvable) {
    this._override = value;
  }
  public resetOverride() {
    this._override = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overrideInput() {
    return this._override;
  }
}
export interface LogicalRouterVrfMulticastRpLocalRp {
  /**
  * Candidate rp
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#candidate_rp LogicalRouter#candidate_rp}
  */
  readonly candidateRp?: LogicalRouterVrfMulticastRpLocalRpCandidateRp;
  /**
  * Static rp
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#static_rp LogicalRouter#static_rp}
  */
  readonly staticRp?: LogicalRouterVrfMulticastRpLocalRpStaticRp;
}

export function logicalRouterVrfMulticastRpLocalRpToTerraform(struct?: LogicalRouterVrfMulticastRpLocalRp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    candidate_rp: logicalRouterVrfMulticastRpLocalRpCandidateRpToTerraform(struct!.candidateRp),
    static_rp: logicalRouterVrfMulticastRpLocalRpStaticRpToTerraform(struct!.staticRp),
  }
}


export function logicalRouterVrfMulticastRpLocalRpToHclTerraform(struct?: LogicalRouterVrfMulticastRpLocalRp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    candidate_rp: {
      value: logicalRouterVrfMulticastRpLocalRpCandidateRpToHclTerraform(struct!.candidateRp),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfMulticastRpLocalRpCandidateRp",
    },
    static_rp: {
      value: logicalRouterVrfMulticastRpLocalRpStaticRpToHclTerraform(struct!.staticRp),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfMulticastRpLocalRpStaticRp",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfMulticastRpLocalRpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfMulticastRpLocalRp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._candidateRp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.candidateRp = this._candidateRp?.internalValue;
    }
    if (this._staticRp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.staticRp = this._staticRp?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfMulticastRpLocalRp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._candidateRp.internalValue = undefined;
      this._staticRp.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._candidateRp.internalValue = value.candidateRp;
      this._staticRp.internalValue = value.staticRp;
    }
  }

  // candidate_rp - computed: false, optional: true, required: false
  private _candidateRp = new LogicalRouterVrfMulticastRpLocalRpCandidateRpOutputReference(this, "candidate_rp");
  public get candidateRp() {
    return this._candidateRp;
  }
  public putCandidateRp(value: LogicalRouterVrfMulticastRpLocalRpCandidateRp) {
    this._candidateRp.internalValue = value;
  }
  public resetCandidateRp() {
    this._candidateRp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get candidateRpInput() {
    return this._candidateRp.internalValue;
  }

  // static_rp - computed: false, optional: true, required: false
  private _staticRp = new LogicalRouterVrfMulticastRpLocalRpStaticRpOutputReference(this, "static_rp");
  public get staticRp() {
    return this._staticRp;
  }
  public putStaticRp(value: LogicalRouterVrfMulticastRpLocalRpStaticRp) {
    this._staticRp.internalValue = value;
  }
  public resetStaticRp() {
    this._staticRp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get staticRpInput() {
    return this._staticRp.internalValue;
  }
}
export interface LogicalRouterVrfMulticastRp {
  /**
  * External rp
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#external_rp LogicalRouter#external_rp}
  */
  readonly externalRp?: LogicalRouterVrfMulticastRpExternalRp[] | cdktf.IResolvable;
  /**
  * Local rp
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#local_rp LogicalRouter#local_rp}
  */
  readonly localRp?: LogicalRouterVrfMulticastRpLocalRp;
}

export function logicalRouterVrfMulticastRpToTerraform(struct?: LogicalRouterVrfMulticastRp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    external_rp: cdktf.listMapper(logicalRouterVrfMulticastRpExternalRpToTerraform, false)(struct!.externalRp),
    local_rp: logicalRouterVrfMulticastRpLocalRpToTerraform(struct!.localRp),
  }
}


export function logicalRouterVrfMulticastRpToHclTerraform(struct?: LogicalRouterVrfMulticastRp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    external_rp: {
      value: cdktf.listMapperHcl(logicalRouterVrfMulticastRpExternalRpToHclTerraform, false)(struct!.externalRp),
      isBlock: true,
      type: "list",
      storageClassType: "LogicalRouterVrfMulticastRpExternalRpList",
    },
    local_rp: {
      value: logicalRouterVrfMulticastRpLocalRpToHclTerraform(struct!.localRp),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfMulticastRpLocalRp",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfMulticastRpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfMulticastRp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._externalRp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.externalRp = this._externalRp?.internalValue;
    }
    if (this._localRp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.localRp = this._localRp?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfMulticastRp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._externalRp.internalValue = undefined;
      this._localRp.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._externalRp.internalValue = value.externalRp;
      this._localRp.internalValue = value.localRp;
    }
  }

  // external_rp - computed: false, optional: true, required: false
  private _externalRp = new LogicalRouterVrfMulticastRpExternalRpList(this, "external_rp", false);
  public get externalRp() {
    return this._externalRp;
  }
  public putExternalRp(value: LogicalRouterVrfMulticastRpExternalRp[] | cdktf.IResolvable) {
    this._externalRp.internalValue = value;
  }
  public resetExternalRp() {
    this._externalRp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get externalRpInput() {
    return this._externalRp.internalValue;
  }

  // local_rp - computed: false, optional: true, required: false
  private _localRp = new LogicalRouterVrfMulticastRpLocalRpOutputReference(this, "local_rp");
  public get localRp() {
    return this._localRp;
  }
  public putLocalRp(value: LogicalRouterVrfMulticastRpLocalRp) {
    this._localRp.internalValue = value;
  }
  public resetLocalRp() {
    this._localRp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localRpInput() {
    return this._localRp.internalValue;
  }
}
export interface LogicalRouterVrfMulticastSptThreshold {
  /**
  * Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#name LogicalRouter#name}
  */
  readonly name: string;
  /**
  * Threshold
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#threshold LogicalRouter#threshold}
  */
  readonly threshold?: string;
}

export function logicalRouterVrfMulticastSptThresholdToTerraform(struct?: LogicalRouterVrfMulticastSptThreshold | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    threshold: cdktf.stringToTerraform(struct!.threshold),
  }
}


export function logicalRouterVrfMulticastSptThresholdToHclTerraform(struct?: LogicalRouterVrfMulticastSptThreshold | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    threshold: {
      value: cdktf.stringToHclTerraform(struct!.threshold),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfMulticastSptThresholdOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): LogicalRouterVrfMulticastSptThreshold | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._threshold !== undefined) {
      hasAnyValues = true;
      internalValueResult.threshold = this._threshold;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfMulticastSptThreshold | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._threshold = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._threshold = value.threshold;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // threshold - computed: false, optional: true, required: false
  private _threshold?: string; 
  public get threshold() {
    return this.getStringAttribute('threshold');
  }
  public set threshold(value: string) {
    this._threshold = value;
  }
  public resetThreshold() {
    this._threshold = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get thresholdInput() {
    return this._threshold;
  }
}

export class LogicalRouterVrfMulticastSptThresholdList extends cdktf.ComplexList {
  public internalValue? : LogicalRouterVrfMulticastSptThreshold[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): LogicalRouterVrfMulticastSptThresholdOutputReference {
    return new LogicalRouterVrfMulticastSptThresholdOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface LogicalRouterVrfMulticastSsmAddressSpace {
  /**
  * Group address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#group_address LogicalRouter#group_address}
  */
  readonly groupAddress?: string;
  /**
  * Included
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#included LogicalRouter#included}
  */
  readonly included?: boolean | cdktf.IResolvable;
  /**
  * Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#name LogicalRouter#name}
  */
  readonly name: string;
}

export function logicalRouterVrfMulticastSsmAddressSpaceToTerraform(struct?: LogicalRouterVrfMulticastSsmAddressSpace | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    group_address: cdktf.stringToTerraform(struct!.groupAddress),
    included: cdktf.booleanToTerraform(struct!.included),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function logicalRouterVrfMulticastSsmAddressSpaceToHclTerraform(struct?: LogicalRouterVrfMulticastSsmAddressSpace | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    group_address: {
      value: cdktf.stringToHclTerraform(struct!.groupAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    included: {
      value: cdktf.booleanToHclTerraform(struct!.included),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfMulticastSsmAddressSpaceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): LogicalRouterVrfMulticastSsmAddressSpace | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._groupAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupAddress = this._groupAddress;
    }
    if (this._included !== undefined) {
      hasAnyValues = true;
      internalValueResult.included = this._included;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfMulticastSsmAddressSpace | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._groupAddress = undefined;
      this._included = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._groupAddress = value.groupAddress;
      this._included = value.included;
      this._name = value.name;
    }
  }

  // group_address - computed: false, optional: true, required: false
  private _groupAddress?: string; 
  public get groupAddress() {
    return this.getStringAttribute('group_address');
  }
  public set groupAddress(value: string) {
    this._groupAddress = value;
  }
  public resetGroupAddress() {
    this._groupAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupAddressInput() {
    return this._groupAddress;
  }

  // included - computed: false, optional: true, required: false
  private _included?: boolean | cdktf.IResolvable; 
  public get included() {
    return this.getBooleanAttribute('included');
  }
  public set included(value: boolean | cdktf.IResolvable) {
    this._included = value;
  }
  public resetIncluded() {
    this._included = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get includedInput() {
    return this._included;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class LogicalRouterVrfMulticastSsmAddressSpaceList extends cdktf.ComplexList {
  public internalValue? : LogicalRouterVrfMulticastSsmAddressSpace[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): LogicalRouterVrfMulticastSsmAddressSpaceOutputReference {
    return new LogicalRouterVrfMulticastSsmAddressSpaceOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface LogicalRouterVrfMulticastStaticRouteNexthop {
  /**
  * Ip address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#ip_address LogicalRouter#ip_address}
  */
  readonly ipAddress?: string;
}

export function logicalRouterVrfMulticastStaticRouteNexthopToTerraform(struct?: LogicalRouterVrfMulticastStaticRouteNexthop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ip_address: cdktf.stringToTerraform(struct!.ipAddress),
  }
}


export function logicalRouterVrfMulticastStaticRouteNexthopToHclTerraform(struct?: LogicalRouterVrfMulticastStaticRouteNexthop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ip_address: {
      value: cdktf.stringToHclTerraform(struct!.ipAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfMulticastStaticRouteNexthopOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfMulticastStaticRouteNexthop | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ipAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipAddress = this._ipAddress;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfMulticastStaticRouteNexthop | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ipAddress = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ipAddress = value.ipAddress;
    }
  }

  // ip_address - computed: false, optional: true, required: false
  private _ipAddress?: string; 
  public get ipAddress() {
    return this.getStringAttribute('ip_address');
  }
  public set ipAddress(value: string) {
    this._ipAddress = value;
  }
  public resetIpAddress() {
    this._ipAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipAddressInput() {
    return this._ipAddress;
  }
}
export interface LogicalRouterVrfMulticastStaticRoute {
  /**
  * Destination
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#destination LogicalRouter#destination}
  */
  readonly destination?: string;
  /**
  * Interface
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#interface LogicalRouter#interface}
  */
  readonly interface?: string;
  /**
  * Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#name LogicalRouter#name}
  */
  readonly name: string;
  /**
  * Nexthop
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#nexthop LogicalRouter#nexthop}
  */
  readonly nexthop?: LogicalRouterVrfMulticastStaticRouteNexthop;
  /**
  * Preference
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#preference LogicalRouter#preference}
  */
  readonly preference?: number;
}

export function logicalRouterVrfMulticastStaticRouteToTerraform(struct?: LogicalRouterVrfMulticastStaticRoute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    destination: cdktf.stringToTerraform(struct!.destination),
    interface: cdktf.stringToTerraform(struct!.interface),
    name: cdktf.stringToTerraform(struct!.name),
    nexthop: logicalRouterVrfMulticastStaticRouteNexthopToTerraform(struct!.nexthop),
    preference: cdktf.numberToTerraform(struct!.preference),
  }
}


export function logicalRouterVrfMulticastStaticRouteToHclTerraform(struct?: LogicalRouterVrfMulticastStaticRoute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    destination: {
      value: cdktf.stringToHclTerraform(struct!.destination),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    interface: {
      value: cdktf.stringToHclTerraform(struct!.interface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    nexthop: {
      value: logicalRouterVrfMulticastStaticRouteNexthopToHclTerraform(struct!.nexthop),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfMulticastStaticRouteNexthop",
    },
    preference: {
      value: cdktf.numberToHclTerraform(struct!.preference),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfMulticastStaticRouteOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): LogicalRouterVrfMulticastStaticRoute | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._destination !== undefined) {
      hasAnyValues = true;
      internalValueResult.destination = this._destination;
    }
    if (this._interface !== undefined) {
      hasAnyValues = true;
      internalValueResult.interface = this._interface;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._nexthop?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nexthop = this._nexthop?.internalValue;
    }
    if (this._preference !== undefined) {
      hasAnyValues = true;
      internalValueResult.preference = this._preference;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfMulticastStaticRoute | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._destination = undefined;
      this._interface = undefined;
      this._name = undefined;
      this._nexthop.internalValue = undefined;
      this._preference = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._destination = value.destination;
      this._interface = value.interface;
      this._name = value.name;
      this._nexthop.internalValue = value.nexthop;
      this._preference = value.preference;
    }
  }

  // destination - computed: false, optional: true, required: false
  private _destination?: string; 
  public get destination() {
    return this.getStringAttribute('destination');
  }
  public set destination(value: string) {
    this._destination = value;
  }
  public resetDestination() {
    this._destination = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get destinationInput() {
    return this._destination;
  }

  // interface - computed: false, optional: true, required: false
  private _interface?: string; 
  public get interface() {
    return this.getStringAttribute('interface');
  }
  public set interface(value: string) {
    this._interface = value;
  }
  public resetInterface() {
    this._interface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfaceInput() {
    return this._interface;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // nexthop - computed: false, optional: true, required: false
  private _nexthop = new LogicalRouterVrfMulticastStaticRouteNexthopOutputReference(this, "nexthop");
  public get nexthop() {
    return this._nexthop;
  }
  public putNexthop(value: LogicalRouterVrfMulticastStaticRouteNexthop) {
    this._nexthop.internalValue = value;
  }
  public resetNexthop() {
    this._nexthop.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nexthopInput() {
    return this._nexthop.internalValue;
  }

  // preference - computed: false, optional: true, required: false
  private _preference?: number; 
  public get preference() {
    return this.getNumberAttribute('preference');
  }
  public set preference(value: number) {
    this._preference = value;
  }
  public resetPreference() {
    this._preference = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preferenceInput() {
    return this._preference;
  }
}

export class LogicalRouterVrfMulticastStaticRouteList extends cdktf.ComplexList {
  public internalValue? : LogicalRouterVrfMulticastStaticRoute[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): LogicalRouterVrfMulticastStaticRouteOutputReference {
    return new LogicalRouterVrfMulticastStaticRouteOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface LogicalRouterVrfMulticast {
  /**
  * Enable
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#enable LogicalRouter#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * Enable v6
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#enable_v6 LogicalRouter#enable_v6}
  */
  readonly enableV6?: boolean | cdktf.IResolvable;
  /**
  * Igmp
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#igmp LogicalRouter#igmp}
  */
  readonly igmp?: LogicalRouterVrfMulticastIgmp;
  /**
  * Interface group
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#interface_group LogicalRouter#interface_group}
  */
  readonly interfaceGroup?: LogicalRouterVrfMulticastInterfaceGroup[] | cdktf.IResolvable;
  /**
  * Mode
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#mode LogicalRouter#mode}
  */
  readonly mode?: string;
  /**
  * Msdp
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#msdp LogicalRouter#msdp}
  */
  readonly msdp?: LogicalRouterVrfMulticastMsdp;
  /**
  * Pim
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#pim LogicalRouter#pim}
  */
  readonly pim?: LogicalRouterVrfMulticastPim;
  /**
  * Route ageout time
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#route_ageout_time LogicalRouter#route_ageout_time}
  */
  readonly routeAgeoutTime?: number;
  /**
  * Rp
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#rp LogicalRouter#rp}
  */
  readonly rp?: LogicalRouterVrfMulticastRp;
  /**
  * Spt threshold
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#spt_threshold LogicalRouter#spt_threshold}
  */
  readonly sptThreshold?: LogicalRouterVrfMulticastSptThreshold[] | cdktf.IResolvable;
  /**
  * Ssm address space
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#ssm_address_space LogicalRouter#ssm_address_space}
  */
  readonly ssmAddressSpace?: LogicalRouterVrfMulticastSsmAddressSpace[] | cdktf.IResolvable;
  /**
  * Static route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#static_route LogicalRouter#static_route}
  */
  readonly staticRoute?: LogicalRouterVrfMulticastStaticRoute[] | cdktf.IResolvable;
}

export function logicalRouterVrfMulticastToTerraform(struct?: LogicalRouterVrfMulticast | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enable: cdktf.booleanToTerraform(struct!.enable),
    enable_v6: cdktf.booleanToTerraform(struct!.enableV6),
    igmp: logicalRouterVrfMulticastIgmpToTerraform(struct!.igmp),
    interface_group: cdktf.listMapper(logicalRouterVrfMulticastInterfaceGroupToTerraform, false)(struct!.interfaceGroup),
    mode: cdktf.stringToTerraform(struct!.mode),
    msdp: logicalRouterVrfMulticastMsdpToTerraform(struct!.msdp),
    pim: logicalRouterVrfMulticastPimToTerraform(struct!.pim),
    route_ageout_time: cdktf.numberToTerraform(struct!.routeAgeoutTime),
    rp: logicalRouterVrfMulticastRpToTerraform(struct!.rp),
    spt_threshold: cdktf.listMapper(logicalRouterVrfMulticastSptThresholdToTerraform, false)(struct!.sptThreshold),
    ssm_address_space: cdktf.listMapper(logicalRouterVrfMulticastSsmAddressSpaceToTerraform, false)(struct!.ssmAddressSpace),
    static_route: cdktf.listMapper(logicalRouterVrfMulticastStaticRouteToTerraform, false)(struct!.staticRoute),
  }
}


export function logicalRouterVrfMulticastToHclTerraform(struct?: LogicalRouterVrfMulticast | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_v6: {
      value: cdktf.booleanToHclTerraform(struct!.enableV6),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    igmp: {
      value: logicalRouterVrfMulticastIgmpToHclTerraform(struct!.igmp),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfMulticastIgmp",
    },
    interface_group: {
      value: cdktf.listMapperHcl(logicalRouterVrfMulticastInterfaceGroupToHclTerraform, false)(struct!.interfaceGroup),
      isBlock: true,
      type: "list",
      storageClassType: "LogicalRouterVrfMulticastInterfaceGroupList",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    msdp: {
      value: logicalRouterVrfMulticastMsdpToHclTerraform(struct!.msdp),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfMulticastMsdp",
    },
    pim: {
      value: logicalRouterVrfMulticastPimToHclTerraform(struct!.pim),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfMulticastPim",
    },
    route_ageout_time: {
      value: cdktf.numberToHclTerraform(struct!.routeAgeoutTime),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    rp: {
      value: logicalRouterVrfMulticastRpToHclTerraform(struct!.rp),
      isBlock: true,
      type: "struct",
      storageClassType: "LogicalRouterVrfMulticastRp",
    },
    spt_threshold: {
      value: cdktf.listMapperHcl(logicalRouterVrfMulticastSptThresholdToHclTerraform, false)(struct!.sptThreshold),
      isBlock: true,
      type: "list",
      storageClassType: "LogicalRouterVrfMulticastSptThresholdList",
    },
    ssm_address_space: {
      value: cdktf.listMapperHcl(logicalRouterVrfMulticastSsmAddressSpaceToHclTerraform, false)(struct!.ssmAddressSpace),
      isBlock: true,
      type: "list",
      storageClassType: "LogicalRouterVrfMulticastSsmAddressSpaceList",
    },
    static_route: {
      value: cdktf.listMapperHcl(logicalRouterVrfMulticastStaticRouteToHclTerraform, false)(struct!.staticRoute),
      isBlock: true,
      type: "list",
      storageClassType: "LogicalRouterVrfMulticastStaticRouteList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfMulticastOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfMulticast | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._enableV6 !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableV6 = this._enableV6;
    }
    if (this._igmp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.igmp = this._igmp?.internalValue;
    }
    if (this._interfaceGroup?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.interfaceGroup = this._interfaceGroup?.internalValue;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._msdp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.msdp = this._msdp?.internalValue;
    }
    if (this._pim?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pim = this._pim?.internalValue;
    }
    if (this._routeAgeoutTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeAgeoutTime = this._routeAgeoutTime;
    }
    if (this._rp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rp = this._rp?.internalValue;
    }
    if (this._sptThreshold?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sptThreshold = this._sptThreshold?.internalValue;
    }
    if (this._ssmAddressSpace?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ssmAddressSpace = this._ssmAddressSpace?.internalValue;
    }
    if (this._staticRoute?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.staticRoute = this._staticRoute?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfMulticast | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enable = undefined;
      this._enableV6 = undefined;
      this._igmp.internalValue = undefined;
      this._interfaceGroup.internalValue = undefined;
      this._mode = undefined;
      this._msdp.internalValue = undefined;
      this._pim.internalValue = undefined;
      this._routeAgeoutTime = undefined;
      this._rp.internalValue = undefined;
      this._sptThreshold.internalValue = undefined;
      this._ssmAddressSpace.internalValue = undefined;
      this._staticRoute.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enable = value.enable;
      this._enableV6 = value.enableV6;
      this._igmp.internalValue = value.igmp;
      this._interfaceGroup.internalValue = value.interfaceGroup;
      this._mode = value.mode;
      this._msdp.internalValue = value.msdp;
      this._pim.internalValue = value.pim;
      this._routeAgeoutTime = value.routeAgeoutTime;
      this._rp.internalValue = value.rp;
      this._sptThreshold.internalValue = value.sptThreshold;
      this._ssmAddressSpace.internalValue = value.ssmAddressSpace;
      this._staticRoute.internalValue = value.staticRoute;
    }
  }

  // enable - computed: false, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // enable_v6 - computed: false, optional: true, required: false
  private _enableV6?: boolean | cdktf.IResolvable; 
  public get enableV6() {
    return this.getBooleanAttribute('enable_v6');
  }
  public set enableV6(value: boolean | cdktf.IResolvable) {
    this._enableV6 = value;
  }
  public resetEnableV6() {
    this._enableV6 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableV6Input() {
    return this._enableV6;
  }

  // igmp - computed: false, optional: true, required: false
  private _igmp = new LogicalRouterVrfMulticastIgmpOutputReference(this, "igmp");
  public get igmp() {
    return this._igmp;
  }
  public putIgmp(value: LogicalRouterVrfMulticastIgmp) {
    this._igmp.internalValue = value;
  }
  public resetIgmp() {
    this._igmp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get igmpInput() {
    return this._igmp.internalValue;
  }

  // interface_group - computed: false, optional: true, required: false
  private _interfaceGroup = new LogicalRouterVrfMulticastInterfaceGroupList(this, "interface_group", false);
  public get interfaceGroup() {
    return this._interfaceGroup;
  }
  public putInterfaceGroup(value: LogicalRouterVrfMulticastInterfaceGroup[] | cdktf.IResolvable) {
    this._interfaceGroup.internalValue = value;
  }
  public resetInterfaceGroup() {
    this._interfaceGroup.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfaceGroupInput() {
    return this._interfaceGroup.internalValue;
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // msdp - computed: false, optional: true, required: false
  private _msdp = new LogicalRouterVrfMulticastMsdpOutputReference(this, "msdp");
  public get msdp() {
    return this._msdp;
  }
  public putMsdp(value: LogicalRouterVrfMulticastMsdp) {
    this._msdp.internalValue = value;
  }
  public resetMsdp() {
    this._msdp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get msdpInput() {
    return this._msdp.internalValue;
  }

  // pim - computed: false, optional: true, required: false
  private _pim = new LogicalRouterVrfMulticastPimOutputReference(this, "pim");
  public get pim() {
    return this._pim;
  }
  public putPim(value: LogicalRouterVrfMulticastPim) {
    this._pim.internalValue = value;
  }
  public resetPim() {
    this._pim.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pimInput() {
    return this._pim.internalValue;
  }

  // route_ageout_time - computed: false, optional: true, required: false
  private _routeAgeoutTime?: number; 
  public get routeAgeoutTime() {
    return this.getNumberAttribute('route_ageout_time');
  }
  public set routeAgeoutTime(value: number) {
    this._routeAgeoutTime = value;
  }
  public resetRouteAgeoutTime() {
    this._routeAgeoutTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeAgeoutTimeInput() {
    return this._routeAgeoutTime;
  }

  // rp - computed: false, optional: true, required: false
  private _rp = new LogicalRouterVrfMulticastRpOutputReference(this, "rp");
  public get rp() {
    return this._rp;
  }
  public putRp(value: LogicalRouterVrfMulticastRp) {
    this._rp.internalValue = value;
  }
  public resetRp() {
    this._rp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rpInput() {
    return this._rp.internalValue;
  }

  // spt_threshold - computed: false, optional: true, required: false
  private _sptThreshold = new LogicalRouterVrfMulticastSptThresholdList(this, "spt_threshold", false);
  public get sptThreshold() {
    return this._sptThreshold;
  }
  public putSptThreshold(value: LogicalRouterVrfMulticastSptThreshold[] | cdktf.IResolvable) {
    this._sptThreshold.internalValue = value;
  }
  public resetSptThreshold() {
    this._sptThreshold.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sptThresholdInput() {
    return this._sptThreshold.internalValue;
  }

  // ssm_address_space - computed: false, optional: true, required: false
  private _ssmAddressSpace = new LogicalRouterVrfMulticastSsmAddressSpaceList(this, "ssm_address_space", false);
  public get ssmAddressSpace() {
    return this._ssmAddressSpace;
  }
  public putSsmAddressSpace(value: LogicalRouterVrfMulticastSsmAddressSpace[] | cdktf.IResolvable) {
    this._ssmAddressSpace.internalValue = value;
  }
  public resetSsmAddressSpace() {
    this._ssmAddressSpace.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ssmAddressSpaceInput() {
    return this._ssmAddressSpace.internalValue;
  }

  // static_route - computed: false, optional: true, required: false
  private _staticRoute = new LogicalRouterVrfMulticastStaticRouteList(this, "static_route", false);
  public get staticRoute() {
    return this._staticRoute;
  }
  public putStaticRoute(value: LogicalRouterVrfMulticastStaticRoute[] | cdktf.IResolvable) {
    this._staticRoute.internalValue = value;
  }
  public resetStaticRoute() {
    this._staticRoute.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get staticRouteInput() {
    return this._staticRoute.internalValue;
  }
}
export interface LogicalRouterVrfOspfAreaInterfaceBfd {
  /**
  * Profile
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/logical_router#profile LogicalRouter#profile}
  */
  readonly profile?: string;
}

export function logicalRouterVrfOspfAreaInterfaceBfdToTerraform(struct?: LogicalRouterVrfOspfAreaInterfaceBfd | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    profile: cdktf.stringToTerraform(struct!.profile),
  }
}


export function logicalRouterVrfOspfAreaInterfaceBfdToHclTerraform(struct?: LogicalRouterVrfOspfAreaInterfaceBfd | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    profile: {
      value: cdktf.stringToHclTerraform(struct!.profile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class LogicalRouterVrfOspfAreaInterfaceBfdOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfOspfAreaInterfaceBfd | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._profile !== undefined) {
      hasAnyValues = true;
      internalValueResult.profile = this._profile;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfOspfAreaInterfaceBfd | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._profile = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._profile = value.profile;
    }
  }

  // profile - computed: false, optional: true, required: false
  private _profile?: string; 
  public get profile() {
    return this.getStringAttribute('profile');
  }
  public set profile(value: string) {
    this._profile = value;
  }
  public resetProfile() {
    this._profile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get profileInput() {
    return this._profile;
  }
}
export interface LogicalRouterVrfOspfAreaInterfaceLinkTypeBroadcast {
}

export function logicalRouterVrfOspfAreaInterfaceLinkTypeBroadcastToTerraform(struct?: LogicalRouterVrfOspfAreaInterfaceLinkTypeBroadcast | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function logicalRouterVrfOspfAreaInterfaceLinkTypeBroadcastToHclTerraform(struct?: LogicalRouterVrfOspfAreaInterfaceLinkTypeBroadcast | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class LogicalRouterVrfOspfAreaInterfaceLinkTypeBroadcastOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): LogicalRouterVrfOspfAreaInterfaceLinkTypeBroadcast | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: LogicalRouterVrfOspfAreaInterfaceLinkTypeBroadcast | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
