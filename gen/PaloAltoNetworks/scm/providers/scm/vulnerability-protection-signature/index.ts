// https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface VulnerabilityProtectionSignatureConfig extends cdktf.TerraformMetaArguments {
  /**
  * Affected host
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#affected_host VulnerabilityProtectionSignature#affected_host}
  */
  readonly affectedHost?: VulnerabilityProtectionSignatureAffectedHost;
  /**
  * Bugtraq
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#bugtraq VulnerabilityProtectionSignature#bugtraq}
  */
  readonly bugtraq?: string[];
  /**
  * Comment
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#comment VulnerabilityProtectionSignature#comment}
  */
  readonly comment?: string;
  /**
  * Cve
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#cve VulnerabilityProtectionSignature#cve}
  */
  readonly cve?: string[];
  /**
  * Default action
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#default_action VulnerabilityProtectionSignature#default_action}
  */
  readonly defaultAction?: VulnerabilityProtectionSignatureDefaultAction;
  /**
  * The device in which the resource is defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#device VulnerabilityProtectionSignature#device}
  */
  readonly device?: string;
  /**
  * Direction
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#direction VulnerabilityProtectionSignature#direction}
  */
  readonly direction?: string;
  /**
  * The folder in which the resource is defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#folder VulnerabilityProtectionSignature#folder}
  */
  readonly folder?: string;
  /**
  * Reference
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#reference VulnerabilityProtectionSignature#reference}
  */
  readonly reference?: string[];
  /**
  * Severity
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#severity VulnerabilityProtectionSignature#severity}
  */
  readonly severity?: string;
  /**
  * vulnerability protection signature
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#signature VulnerabilityProtectionSignature#signature}
  */
  readonly signature?: VulnerabilityProtectionSignatureSignature;
  /**
  * The snippet in which the resource is defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#snippet VulnerabilityProtectionSignature#snippet}
  */
  readonly snippet?: string;
  /**
  * threat id range <41000-45000> and <6800001-6900000>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#threat_id VulnerabilityProtectionSignature#threat_id}
  */
  readonly threatId: number;
  /**
  * Threatname
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#threatname VulnerabilityProtectionSignature#threatname}
  */
  readonly threatname: string;
  /**
  * Vendor
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#vendor VulnerabilityProtectionSignature#vendor}
  */
  readonly vendor?: string[];
}
export interface VulnerabilityProtectionSignatureAffectedHost {
  /**
  * Client
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#client VulnerabilityProtectionSignature#client}
  */
  readonly client?: boolean | cdktf.IResolvable;
  /**
  * Server
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#server VulnerabilityProtectionSignature#server}
  */
  readonly server?: boolean | cdktf.IResolvable;
}

export function vulnerabilityProtectionSignatureAffectedHostToTerraform(struct?: VulnerabilityProtectionSignatureAffectedHost | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    client: cdktf.booleanToTerraform(struct!.client),
    server: cdktf.booleanToTerraform(struct!.server),
  }
}


export function vulnerabilityProtectionSignatureAffectedHostToHclTerraform(struct?: VulnerabilityProtectionSignatureAffectedHost | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    client: {
      value: cdktf.booleanToHclTerraform(struct!.client),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    server: {
      value: cdktf.booleanToHclTerraform(struct!.server),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VulnerabilityProtectionSignatureAffectedHostOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VulnerabilityProtectionSignatureAffectedHost | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._client !== undefined) {
      hasAnyValues = true;
      internalValueResult.client = this._client;
    }
    if (this._server !== undefined) {
      hasAnyValues = true;
      internalValueResult.server = this._server;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VulnerabilityProtectionSignatureAffectedHost | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._client = undefined;
      this._server = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._client = value.client;
      this._server = value.server;
    }
  }

  // client - computed: false, optional: true, required: false
  private _client?: boolean | cdktf.IResolvable; 
  public get client() {
    return this.getBooleanAttribute('client');
  }
  public set client(value: boolean | cdktf.IResolvable) {
    this._client = value;
  }
  public resetClient() {
    this._client = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientInput() {
    return this._client;
  }

  // server - computed: false, optional: true, required: false
  private _server?: boolean | cdktf.IResolvable; 
  public get server() {
    return this.getBooleanAttribute('server');
  }
  public set server(value: boolean | cdktf.IResolvable) {
    this._server = value;
  }
  public resetServer() {
    this._server = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverInput() {
    return this._server;
  }
}
export interface VulnerabilityProtectionSignatureDefaultActionAlert {
}

export function vulnerabilityProtectionSignatureDefaultActionAlertToTerraform(struct?: VulnerabilityProtectionSignatureDefaultActionAlert | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function vulnerabilityProtectionSignatureDefaultActionAlertToHclTerraform(struct?: VulnerabilityProtectionSignatureDefaultActionAlert | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class VulnerabilityProtectionSignatureDefaultActionAlertOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VulnerabilityProtectionSignatureDefaultActionAlert | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VulnerabilityProtectionSignatureDefaultActionAlert | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface VulnerabilityProtectionSignatureDefaultActionAllow {
}

export function vulnerabilityProtectionSignatureDefaultActionAllowToTerraform(struct?: VulnerabilityProtectionSignatureDefaultActionAllow | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function vulnerabilityProtectionSignatureDefaultActionAllowToHclTerraform(struct?: VulnerabilityProtectionSignatureDefaultActionAllow | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class VulnerabilityProtectionSignatureDefaultActionAllowOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VulnerabilityProtectionSignatureDefaultActionAllow | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VulnerabilityProtectionSignatureDefaultActionAllow | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface VulnerabilityProtectionSignatureDefaultActionBlockIp {
  /**
  * Duration
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#duration VulnerabilityProtectionSignature#duration}
  */
  readonly duration?: number;
  /**
  * Track by
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#track_by VulnerabilityProtectionSignature#track_by}
  */
  readonly trackBy?: string;
}

export function vulnerabilityProtectionSignatureDefaultActionBlockIpToTerraform(struct?: VulnerabilityProtectionSignatureDefaultActionBlockIp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    duration: cdktf.numberToTerraform(struct!.duration),
    track_by: cdktf.stringToTerraform(struct!.trackBy),
  }
}


export function vulnerabilityProtectionSignatureDefaultActionBlockIpToHclTerraform(struct?: VulnerabilityProtectionSignatureDefaultActionBlockIp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    duration: {
      value: cdktf.numberToHclTerraform(struct!.duration),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    track_by: {
      value: cdktf.stringToHclTerraform(struct!.trackBy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VulnerabilityProtectionSignatureDefaultActionBlockIpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VulnerabilityProtectionSignatureDefaultActionBlockIp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._duration !== undefined) {
      hasAnyValues = true;
      internalValueResult.duration = this._duration;
    }
    if (this._trackBy !== undefined) {
      hasAnyValues = true;
      internalValueResult.trackBy = this._trackBy;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VulnerabilityProtectionSignatureDefaultActionBlockIp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._duration = undefined;
      this._trackBy = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._duration = value.duration;
      this._trackBy = value.trackBy;
    }
  }

  // duration - computed: false, optional: true, required: false
  private _duration?: number; 
  public get duration() {
    return this.getNumberAttribute('duration');
  }
  public set duration(value: number) {
    this._duration = value;
  }
  public resetDuration() {
    this._duration = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get durationInput() {
    return this._duration;
  }

  // track_by - computed: false, optional: true, required: false
  private _trackBy?: string; 
  public get trackBy() {
    return this.getStringAttribute('track_by');
  }
  public set trackBy(value: string) {
    this._trackBy = value;
  }
  public resetTrackBy() {
    this._trackBy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get trackByInput() {
    return this._trackBy;
  }
}
export interface VulnerabilityProtectionSignatureDefaultActionDrop {
}

export function vulnerabilityProtectionSignatureDefaultActionDropToTerraform(struct?: VulnerabilityProtectionSignatureDefaultActionDrop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function vulnerabilityProtectionSignatureDefaultActionDropToHclTerraform(struct?: VulnerabilityProtectionSignatureDefaultActionDrop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class VulnerabilityProtectionSignatureDefaultActionDropOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VulnerabilityProtectionSignatureDefaultActionDrop | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VulnerabilityProtectionSignatureDefaultActionDrop | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface VulnerabilityProtectionSignatureDefaultActionResetBoth {
}

export function vulnerabilityProtectionSignatureDefaultActionResetBothToTerraform(struct?: VulnerabilityProtectionSignatureDefaultActionResetBoth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function vulnerabilityProtectionSignatureDefaultActionResetBothToHclTerraform(struct?: VulnerabilityProtectionSignatureDefaultActionResetBoth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class VulnerabilityProtectionSignatureDefaultActionResetBothOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VulnerabilityProtectionSignatureDefaultActionResetBoth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VulnerabilityProtectionSignatureDefaultActionResetBoth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface VulnerabilityProtectionSignatureDefaultActionResetClient {
}

export function vulnerabilityProtectionSignatureDefaultActionResetClientToTerraform(struct?: VulnerabilityProtectionSignatureDefaultActionResetClient | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function vulnerabilityProtectionSignatureDefaultActionResetClientToHclTerraform(struct?: VulnerabilityProtectionSignatureDefaultActionResetClient | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class VulnerabilityProtectionSignatureDefaultActionResetClientOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VulnerabilityProtectionSignatureDefaultActionResetClient | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VulnerabilityProtectionSignatureDefaultActionResetClient | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface VulnerabilityProtectionSignatureDefaultActionResetServer {
}

export function vulnerabilityProtectionSignatureDefaultActionResetServerToTerraform(struct?: VulnerabilityProtectionSignatureDefaultActionResetServer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function vulnerabilityProtectionSignatureDefaultActionResetServerToHclTerraform(struct?: VulnerabilityProtectionSignatureDefaultActionResetServer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class VulnerabilityProtectionSignatureDefaultActionResetServerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VulnerabilityProtectionSignatureDefaultActionResetServer | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VulnerabilityProtectionSignatureDefaultActionResetServer | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface VulnerabilityProtectionSignatureDefaultAction {
  /**
  * Alert
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#alert VulnerabilityProtectionSignature#alert}
  */
  readonly alert?: VulnerabilityProtectionSignatureDefaultActionAlert;
  /**
  * Allow
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#allow VulnerabilityProtectionSignature#allow}
  */
  readonly allow?: VulnerabilityProtectionSignatureDefaultActionAllow;
  /**
  * vulnerability protection bugtraq block ip
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#block_ip VulnerabilityProtectionSignature#block_ip}
  */
  readonly blockIp?: VulnerabilityProtectionSignatureDefaultActionBlockIp;
  /**
  * Drop
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#drop VulnerabilityProtectionSignature#drop}
  */
  readonly drop?: VulnerabilityProtectionSignatureDefaultActionDrop;
  /**
  * Reset both
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#reset_both VulnerabilityProtectionSignature#reset_both}
  */
  readonly resetBoth?: VulnerabilityProtectionSignatureDefaultActionResetBoth;
  /**
  * Reset client
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#reset_client VulnerabilityProtectionSignature#reset_client}
  */
  readonly resetClient?: VulnerabilityProtectionSignatureDefaultActionResetClient;
  /**
  * Reset server
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#reset_server VulnerabilityProtectionSignature#reset_server}
  */
  readonly resetServer?: VulnerabilityProtectionSignatureDefaultActionResetServer;
}

export function vulnerabilityProtectionSignatureDefaultActionToTerraform(struct?: VulnerabilityProtectionSignatureDefaultAction | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    alert: vulnerabilityProtectionSignatureDefaultActionAlertToTerraform(struct!.alert),
    allow: vulnerabilityProtectionSignatureDefaultActionAllowToTerraform(struct!.allow),
    block_ip: vulnerabilityProtectionSignatureDefaultActionBlockIpToTerraform(struct!.blockIp),
    drop: vulnerabilityProtectionSignatureDefaultActionDropToTerraform(struct!.drop),
    reset_both: vulnerabilityProtectionSignatureDefaultActionResetBothToTerraform(struct!.resetBoth),
    reset_client: vulnerabilityProtectionSignatureDefaultActionResetClientToTerraform(struct!.resetClient),
    reset_server: vulnerabilityProtectionSignatureDefaultActionResetServerToTerraform(struct!.resetServer),
  }
}


export function vulnerabilityProtectionSignatureDefaultActionToHclTerraform(struct?: VulnerabilityProtectionSignatureDefaultAction | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    alert: {
      value: vulnerabilityProtectionSignatureDefaultActionAlertToHclTerraform(struct!.alert),
      isBlock: true,
      type: "struct",
      storageClassType: "VulnerabilityProtectionSignatureDefaultActionAlert",
    },
    allow: {
      value: vulnerabilityProtectionSignatureDefaultActionAllowToHclTerraform(struct!.allow),
      isBlock: true,
      type: "struct",
      storageClassType: "VulnerabilityProtectionSignatureDefaultActionAllow",
    },
    block_ip: {
      value: vulnerabilityProtectionSignatureDefaultActionBlockIpToHclTerraform(struct!.blockIp),
      isBlock: true,
      type: "struct",
      storageClassType: "VulnerabilityProtectionSignatureDefaultActionBlockIp",
    },
    drop: {
      value: vulnerabilityProtectionSignatureDefaultActionDropToHclTerraform(struct!.drop),
      isBlock: true,
      type: "struct",
      storageClassType: "VulnerabilityProtectionSignatureDefaultActionDrop",
    },
    reset_both: {
      value: vulnerabilityProtectionSignatureDefaultActionResetBothToHclTerraform(struct!.resetBoth),
      isBlock: true,
      type: "struct",
      storageClassType: "VulnerabilityProtectionSignatureDefaultActionResetBoth",
    },
    reset_client: {
      value: vulnerabilityProtectionSignatureDefaultActionResetClientToHclTerraform(struct!.resetClient),
      isBlock: true,
      type: "struct",
      storageClassType: "VulnerabilityProtectionSignatureDefaultActionResetClient",
    },
    reset_server: {
      value: vulnerabilityProtectionSignatureDefaultActionResetServerToHclTerraform(struct!.resetServer),
      isBlock: true,
      type: "struct",
      storageClassType: "VulnerabilityProtectionSignatureDefaultActionResetServer",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VulnerabilityProtectionSignatureDefaultActionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VulnerabilityProtectionSignatureDefaultAction | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._alert?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.alert = this._alert?.internalValue;
    }
    if (this._allow?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.allow = this._allow?.internalValue;
    }
    if (this._blockIp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.blockIp = this._blockIp?.internalValue;
    }
    if (this._drop?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.drop = this._drop?.internalValue;
    }
    if (this._resetBoth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resetBoth = this._resetBoth?.internalValue;
    }
    if (this._resetClient?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resetClient = this._resetClient?.internalValue;
    }
    if (this._resetServer?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resetServer = this._resetServer?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VulnerabilityProtectionSignatureDefaultAction | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._alert.internalValue = undefined;
      this._allow.internalValue = undefined;
      this._blockIp.internalValue = undefined;
      this._drop.internalValue = undefined;
      this._resetBoth.internalValue = undefined;
      this._resetClient.internalValue = undefined;
      this._resetServer.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._alert.internalValue = value.alert;
      this._allow.internalValue = value.allow;
      this._blockIp.internalValue = value.blockIp;
      this._drop.internalValue = value.drop;
      this._resetBoth.internalValue = value.resetBoth;
      this._resetClient.internalValue = value.resetClient;
      this._resetServer.internalValue = value.resetServer;
    }
  }

  // alert - computed: false, optional: true, required: false
  private _alert = new VulnerabilityProtectionSignatureDefaultActionAlertOutputReference(this, "alert");
  public get alert() {
    return this._alert;
  }
  public putAlert(value: VulnerabilityProtectionSignatureDefaultActionAlert) {
    this._alert.internalValue = value;
  }
  public resetAlert() {
    this._alert.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get alertInput() {
    return this._alert.internalValue;
  }

  // allow - computed: false, optional: true, required: false
  private _allow = new VulnerabilityProtectionSignatureDefaultActionAllowOutputReference(this, "allow");
  public get allow() {
    return this._allow;
  }
  public putAllow(value: VulnerabilityProtectionSignatureDefaultActionAllow) {
    this._allow.internalValue = value;
  }
  public resetAllow() {
    this._allow.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowInput() {
    return this._allow.internalValue;
  }

  // block_ip - computed: false, optional: true, required: false
  private _blockIp = new VulnerabilityProtectionSignatureDefaultActionBlockIpOutputReference(this, "block_ip");
  public get blockIp() {
    return this._blockIp;
  }
  public putBlockIp(value: VulnerabilityProtectionSignatureDefaultActionBlockIp) {
    this._blockIp.internalValue = value;
  }
  public resetBlockIp() {
    this._blockIp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get blockIpInput() {
    return this._blockIp.internalValue;
  }

  // drop - computed: false, optional: true, required: false
  private _drop = new VulnerabilityProtectionSignatureDefaultActionDropOutputReference(this, "drop");
  public get drop() {
    return this._drop;
  }
  public putDrop(value: VulnerabilityProtectionSignatureDefaultActionDrop) {
    this._drop.internalValue = value;
  }
  public resetDrop() {
    this._drop.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dropInput() {
    return this._drop.internalValue;
  }

  // reset_both - computed: false, optional: true, required: false
  private _resetBoth = new VulnerabilityProtectionSignatureDefaultActionResetBothOutputReference(this, "reset_both");
  public get resetBoth() {
    return this._resetBoth;
  }
  public putResetBoth(value: VulnerabilityProtectionSignatureDefaultActionResetBoth) {
    this._resetBoth.internalValue = value;
  }
  public resetResetBoth() {
    this._resetBoth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resetBothInput() {
    return this._resetBoth.internalValue;
  }

  // reset_client - computed: false, optional: true, required: false
  private _resetClient = new VulnerabilityProtectionSignatureDefaultActionResetClientOutputReference(this, "reset_client");
  public get resetClient() {
    return this._resetClient;
  }
  public putResetClient(value: VulnerabilityProtectionSignatureDefaultActionResetClient) {
    this._resetClient.internalValue = value;
  }
  public resetResetClient() {
    this._resetClient.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resetClientInput() {
    return this._resetClient.internalValue;
  }

  // reset_server - computed: false, optional: true, required: false
  private _resetServer = new VulnerabilityProtectionSignatureDefaultActionResetServerOutputReference(this, "reset_server");
  public get resetServer() {
    return this._resetServer;
  }
  public putResetServer(value: VulnerabilityProtectionSignatureDefaultActionResetServer) {
    this._resetServer.internalValue = value;
  }
  public resetResetServer() {
    this._resetServer.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resetServerInput() {
    return this._resetServer.internalValue;
  }
}
export interface VulnerabilityProtectionSignatureSignatureCombinationAndConditionOrCondition {
  /**
  * Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#name VulnerabilityProtectionSignature#name}
  */
  readonly name?: string;
  /**
  * Threat id
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#threat_id VulnerabilityProtectionSignature#threat_id}
  */
  readonly threatId?: string;
}

export function vulnerabilityProtectionSignatureSignatureCombinationAndConditionOrConditionToTerraform(struct?: VulnerabilityProtectionSignatureSignatureCombinationAndConditionOrCondition | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    threat_id: cdktf.stringToTerraform(struct!.threatId),
  }
}


export function vulnerabilityProtectionSignatureSignatureCombinationAndConditionOrConditionToHclTerraform(struct?: VulnerabilityProtectionSignatureSignatureCombinationAndConditionOrCondition | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    threat_id: {
      value: cdktf.stringToHclTerraform(struct!.threatId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VulnerabilityProtectionSignatureSignatureCombinationAndConditionOrConditionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): VulnerabilityProtectionSignatureSignatureCombinationAndConditionOrCondition | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._threatId !== undefined) {
      hasAnyValues = true;
      internalValueResult.threatId = this._threatId;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VulnerabilityProtectionSignatureSignatureCombinationAndConditionOrCondition | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._threatId = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._threatId = value.threatId;
    }
  }

  // name - computed: true, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // threat_id - computed: true, optional: true, required: false
  private _threatId?: string; 
  public get threatId() {
    return this.getStringAttribute('threat_id');
  }
  public set threatId(value: string) {
    this._threatId = value;
  }
  public resetThreatId() {
    this._threatId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get threatIdInput() {
    return this._threatId;
  }
}

export class VulnerabilityProtectionSignatureSignatureCombinationAndConditionOrConditionList extends cdktf.ComplexList {
  public internalValue? : VulnerabilityProtectionSignatureSignatureCombinationAndConditionOrCondition[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): VulnerabilityProtectionSignatureSignatureCombinationAndConditionOrConditionOutputReference {
    return new VulnerabilityProtectionSignatureSignatureCombinationAndConditionOrConditionOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface VulnerabilityProtectionSignatureSignatureCombinationAndCondition {
  /**
  * Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#name VulnerabilityProtectionSignature#name}
  */
  readonly name?: string;
  /**
  * vulnerability protection signature combination object and condition object or condition
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#or_condition VulnerabilityProtectionSignature#or_condition}
  */
  readonly orCondition?: VulnerabilityProtectionSignatureSignatureCombinationAndConditionOrCondition[] | cdktf.IResolvable;
}

export function vulnerabilityProtectionSignatureSignatureCombinationAndConditionToTerraform(struct?: VulnerabilityProtectionSignatureSignatureCombinationAndCondition | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    or_condition: cdktf.listMapper(vulnerabilityProtectionSignatureSignatureCombinationAndConditionOrConditionToTerraform, false)(struct!.orCondition),
  }
}


export function vulnerabilityProtectionSignatureSignatureCombinationAndConditionToHclTerraform(struct?: VulnerabilityProtectionSignatureSignatureCombinationAndCondition | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    or_condition: {
      value: cdktf.listMapperHcl(vulnerabilityProtectionSignatureSignatureCombinationAndConditionOrConditionToHclTerraform, false)(struct!.orCondition),
      isBlock: true,
      type: "list",
      storageClassType: "VulnerabilityProtectionSignatureSignatureCombinationAndConditionOrConditionList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VulnerabilityProtectionSignatureSignatureCombinationAndConditionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): VulnerabilityProtectionSignatureSignatureCombinationAndCondition | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._orCondition?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.orCondition = this._orCondition?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VulnerabilityProtectionSignatureSignatureCombinationAndCondition | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._orCondition.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._orCondition.internalValue = value.orCondition;
    }
  }

  // name - computed: true, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // or_condition - computed: true, optional: true, required: false
  private _orCondition = new VulnerabilityProtectionSignatureSignatureCombinationAndConditionOrConditionList(this, "or_condition", false);
  public get orCondition() {
    return this._orCondition;
  }
  public putOrCondition(value: VulnerabilityProtectionSignatureSignatureCombinationAndConditionOrCondition[] | cdktf.IResolvable) {
    this._orCondition.internalValue = value;
  }
  public resetOrCondition() {
    this._orCondition.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get orConditionInput() {
    return this._orCondition.internalValue;
  }
}

export class VulnerabilityProtectionSignatureSignatureCombinationAndConditionList extends cdktf.ComplexList {
  public internalValue? : VulnerabilityProtectionSignatureSignatureCombinationAndCondition[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): VulnerabilityProtectionSignatureSignatureCombinationAndConditionOutputReference {
    return new VulnerabilityProtectionSignatureSignatureCombinationAndConditionOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface VulnerabilityProtectionSignatureSignatureCombinationTimeAttribute {
  /**
  * Interval
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#interval VulnerabilityProtectionSignature#interval}
  */
  readonly interval?: number;
  /**
  * Threshold
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#threshold VulnerabilityProtectionSignature#threshold}
  */
  readonly threshold?: number;
  /**
  * Track by
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#track_by VulnerabilityProtectionSignature#track_by}
  */
  readonly trackBy?: string;
}

export function vulnerabilityProtectionSignatureSignatureCombinationTimeAttributeToTerraform(struct?: VulnerabilityProtectionSignatureSignatureCombinationTimeAttribute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    interval: cdktf.numberToTerraform(struct!.interval),
    threshold: cdktf.numberToTerraform(struct!.threshold),
    track_by: cdktf.stringToTerraform(struct!.trackBy),
  }
}


export function vulnerabilityProtectionSignatureSignatureCombinationTimeAttributeToHclTerraform(struct?: VulnerabilityProtectionSignatureSignatureCombinationTimeAttribute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    interval: {
      value: cdktf.numberToHclTerraform(struct!.interval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    threshold: {
      value: cdktf.numberToHclTerraform(struct!.threshold),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    track_by: {
      value: cdktf.stringToHclTerraform(struct!.trackBy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VulnerabilityProtectionSignatureSignatureCombinationTimeAttributeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VulnerabilityProtectionSignatureSignatureCombinationTimeAttribute | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._interval !== undefined) {
      hasAnyValues = true;
      internalValueResult.interval = this._interval;
    }
    if (this._threshold !== undefined) {
      hasAnyValues = true;
      internalValueResult.threshold = this._threshold;
    }
    if (this._trackBy !== undefined) {
      hasAnyValues = true;
      internalValueResult.trackBy = this._trackBy;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VulnerabilityProtectionSignatureSignatureCombinationTimeAttribute | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._interval = undefined;
      this._threshold = undefined;
      this._trackBy = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._interval = value.interval;
      this._threshold = value.threshold;
      this._trackBy = value.trackBy;
    }
  }

  // interval - computed: true, optional: true, required: false
  private _interval?: number; 
  public get interval() {
    return this.getNumberAttribute('interval');
  }
  public set interval(value: number) {
    this._interval = value;
  }
  public resetInterval() {
    this._interval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get intervalInput() {
    return this._interval;
  }

  // threshold - computed: true, optional: true, required: false
  private _threshold?: number; 
  public get threshold() {
    return this.getNumberAttribute('threshold');
  }
  public set threshold(value: number) {
    this._threshold = value;
  }
  public resetThreshold() {
    this._threshold = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get thresholdInput() {
    return this._threshold;
  }

  // track_by - computed: true, optional: true, required: false
  private _trackBy?: string; 
  public get trackBy() {
    return this.getStringAttribute('track_by');
  }
  public set trackBy(value: string) {
    this._trackBy = value;
  }
  public resetTrackBy() {
    this._trackBy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get trackByInput() {
    return this._trackBy;
  }
}
export interface VulnerabilityProtectionSignatureSignatureCombination {
  /**
  * vulnerability protection signature combination object and condition
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#and_condition VulnerabilityProtectionSignature#and_condition}
  */
  readonly andCondition?: VulnerabilityProtectionSignatureSignatureCombinationAndCondition[] | cdktf.IResolvable;
  /**
  * Order free
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#order_free VulnerabilityProtectionSignature#order_free}
  */
  readonly orderFree?: boolean | cdktf.IResolvable;
  /**
  * Time attribute
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#time_attribute VulnerabilityProtectionSignature#time_attribute}
  */
  readonly timeAttribute?: VulnerabilityProtectionSignatureSignatureCombinationTimeAttribute;
}

export function vulnerabilityProtectionSignatureSignatureCombinationToTerraform(struct?: VulnerabilityProtectionSignatureSignatureCombination | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    and_condition: cdktf.listMapper(vulnerabilityProtectionSignatureSignatureCombinationAndConditionToTerraform, false)(struct!.andCondition),
    order_free: cdktf.booleanToTerraform(struct!.orderFree),
    time_attribute: vulnerabilityProtectionSignatureSignatureCombinationTimeAttributeToTerraform(struct!.timeAttribute),
  }
}


export function vulnerabilityProtectionSignatureSignatureCombinationToHclTerraform(struct?: VulnerabilityProtectionSignatureSignatureCombination | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    and_condition: {
      value: cdktf.listMapperHcl(vulnerabilityProtectionSignatureSignatureCombinationAndConditionToHclTerraform, false)(struct!.andCondition),
      isBlock: true,
      type: "list",
      storageClassType: "VulnerabilityProtectionSignatureSignatureCombinationAndConditionList",
    },
    order_free: {
      value: cdktf.booleanToHclTerraform(struct!.orderFree),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    time_attribute: {
      value: vulnerabilityProtectionSignatureSignatureCombinationTimeAttributeToHclTerraform(struct!.timeAttribute),
      isBlock: true,
      type: "struct",
      storageClassType: "VulnerabilityProtectionSignatureSignatureCombinationTimeAttribute",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VulnerabilityProtectionSignatureSignatureCombinationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VulnerabilityProtectionSignatureSignatureCombination | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._andCondition?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.andCondition = this._andCondition?.internalValue;
    }
    if (this._orderFree !== undefined) {
      hasAnyValues = true;
      internalValueResult.orderFree = this._orderFree;
    }
    if (this._timeAttribute?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeAttribute = this._timeAttribute?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VulnerabilityProtectionSignatureSignatureCombination | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._andCondition.internalValue = undefined;
      this._orderFree = undefined;
      this._timeAttribute.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._andCondition.internalValue = value.andCondition;
      this._orderFree = value.orderFree;
      this._timeAttribute.internalValue = value.timeAttribute;
    }
  }

  // and_condition - computed: true, optional: true, required: false
  private _andCondition = new VulnerabilityProtectionSignatureSignatureCombinationAndConditionList(this, "and_condition", false);
  public get andCondition() {
    return this._andCondition;
  }
  public putAndCondition(value: VulnerabilityProtectionSignatureSignatureCombinationAndCondition[] | cdktf.IResolvable) {
    this._andCondition.internalValue = value;
  }
  public resetAndCondition() {
    this._andCondition.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get andConditionInput() {
    return this._andCondition.internalValue;
  }

  // order_free - computed: true, optional: true, required: false
  private _orderFree?: boolean | cdktf.IResolvable; 
  public get orderFree() {
    return this.getBooleanAttribute('order_free');
  }
  public set orderFree(value: boolean | cdktf.IResolvable) {
    this._orderFree = value;
  }
  public resetOrderFree() {
    this._orderFree = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get orderFreeInput() {
    return this._orderFree;
  }

  // time_attribute - computed: true, optional: true, required: false
  private _timeAttribute = new VulnerabilityProtectionSignatureSignatureCombinationTimeAttributeOutputReference(this, "time_attribute");
  public get timeAttribute() {
    return this._timeAttribute;
  }
  public putTimeAttribute(value: VulnerabilityProtectionSignatureSignatureCombinationTimeAttribute) {
    this._timeAttribute.internalValue = value;
  }
  public resetTimeAttribute() {
    this._timeAttribute.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeAttributeInput() {
    return this._timeAttribute.internalValue;
  }
}
export interface VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualToQualifier {
  /**
  * Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#name VulnerabilityProtectionSignature#name}
  */
  readonly name?: string;
  /**
  * Value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#value VulnerabilityProtectionSignature#value}
  */
  readonly value?: string;
}

export function vulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualToQualifierToTerraform(struct?: VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualToQualifier | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function vulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualToQualifierToHclTerraform(struct?: VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualToQualifier | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualToQualifierOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualToQualifier | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualToQualifier | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: true, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: true, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualToQualifierList extends cdktf.ComplexList {
  public internalValue? : VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualToQualifier[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualToQualifierOutputReference {
    return new VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualToQualifierOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualTo {
  /**
  * Context
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#context VulnerabilityProtectionSignature#context}
  */
  readonly context?: string;
  /**
  * Negate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#negate VulnerabilityProtectionSignature#negate}
  */
  readonly negate?: boolean | cdktf.IResolvable;
  /**
  * vulnerability protection signature standard object and condition object or condition object operators equal_to qualifier array
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#qualifier VulnerabilityProtectionSignature#qualifier}
  */
  readonly qualifier?: VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualToQualifier[] | cdktf.IResolvable;
  /**
  * Value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#value VulnerabilityProtectionSignature#value}
  */
  readonly value?: number;
}

export function vulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualToToTerraform(struct?: VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualTo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    context: cdktf.stringToTerraform(struct!.context),
    negate: cdktf.booleanToTerraform(struct!.negate),
    qualifier: cdktf.listMapper(vulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualToQualifierToTerraform, false)(struct!.qualifier),
    value: cdktf.numberToTerraform(struct!.value),
  }
}


export function vulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualToToHclTerraform(struct?: VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualTo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    context: {
      value: cdktf.stringToHclTerraform(struct!.context),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    negate: {
      value: cdktf.booleanToHclTerraform(struct!.negate),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    qualifier: {
      value: cdktf.listMapperHcl(vulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualToQualifierToHclTerraform, false)(struct!.qualifier),
      isBlock: true,
      type: "list",
      storageClassType: "VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualToQualifierList",
    },
    value: {
      value: cdktf.numberToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualToOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualTo | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._context !== undefined) {
      hasAnyValues = true;
      internalValueResult.context = this._context;
    }
    if (this._negate !== undefined) {
      hasAnyValues = true;
      internalValueResult.negate = this._negate;
    }
    if (this._qualifier?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.qualifier = this._qualifier?.internalValue;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualTo | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._context = undefined;
      this._negate = undefined;
      this._qualifier.internalValue = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._context = value.context;
      this._negate = value.negate;
      this._qualifier.internalValue = value.qualifier;
      this._value = value.value;
    }
  }

  // context - computed: true, optional: true, required: false
  private _context?: string; 
  public get context() {
    return this.getStringAttribute('context');
  }
  public set context(value: string) {
    this._context = value;
  }
  public resetContext() {
    this._context = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contextInput() {
    return this._context;
  }

  // negate - computed: true, optional: true, required: false
  private _negate?: boolean | cdktf.IResolvable; 
  public get negate() {
    return this.getBooleanAttribute('negate');
  }
  public set negate(value: boolean | cdktf.IResolvable) {
    this._negate = value;
  }
  public resetNegate() {
    this._negate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get negateInput() {
    return this._negate;
  }

  // qualifier - computed: true, optional: true, required: false
  private _qualifier = new VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualToQualifierList(this, "qualifier", false);
  public get qualifier() {
    return this._qualifier;
  }
  public putQualifier(value: VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualToQualifier[] | cdktf.IResolvable) {
    this._qualifier.internalValue = value;
  }
  public resetQualifier() {
    this._qualifier.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get qualifierInput() {
    return this._qualifier.internalValue;
  }

  // value - computed: true, optional: true, required: false
  private _value?: number; 
  public get value() {
    return this.getNumberAttribute('value');
  }
  public set value(value: number) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanQualifier {
  /**
  * Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#name VulnerabilityProtectionSignature#name}
  */
  readonly name?: string;
  /**
  * Value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#value VulnerabilityProtectionSignature#value}
  */
  readonly value?: string;
}

export function vulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanQualifierToTerraform(struct?: VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanQualifier | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function vulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanQualifierToHclTerraform(struct?: VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanQualifier | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanQualifierOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanQualifier | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanQualifier | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: true, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: true, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanQualifierList extends cdktf.ComplexList {
  public internalValue? : VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanQualifier[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanQualifierOutputReference {
    return new VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanQualifierOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThan {
  /**
  * Context
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#context VulnerabilityProtectionSignature#context}
  */
  readonly context?: string;
  /**
  * vulnerability protection signature standard object and condition object or condition object operators greater_than qualifier
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#qualifier VulnerabilityProtectionSignature#qualifier}
  */
  readonly qualifier?: VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanQualifier[] | cdktf.IResolvable;
  /**
  * Value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#value VulnerabilityProtectionSignature#value}
  */
  readonly value?: number;
}

export function vulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanToTerraform(struct?: VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThan | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    context: cdktf.stringToTerraform(struct!.context),
    qualifier: cdktf.listMapper(vulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanQualifierToTerraform, false)(struct!.qualifier),
    value: cdktf.numberToTerraform(struct!.value),
  }
}


export function vulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanToHclTerraform(struct?: VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThan | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    context: {
      value: cdktf.stringToHclTerraform(struct!.context),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    qualifier: {
      value: cdktf.listMapperHcl(vulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanQualifierToHclTerraform, false)(struct!.qualifier),
      isBlock: true,
      type: "list",
      storageClassType: "VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanQualifierList",
    },
    value: {
      value: cdktf.numberToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThan | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._context !== undefined) {
      hasAnyValues = true;
      internalValueResult.context = this._context;
    }
    if (this._qualifier?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.qualifier = this._qualifier?.internalValue;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThan | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._context = undefined;
      this._qualifier.internalValue = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._context = value.context;
      this._qualifier.internalValue = value.qualifier;
      this._value = value.value;
    }
  }

  // context - computed: true, optional: true, required: false
  private _context?: string; 
  public get context() {
    return this.getStringAttribute('context');
  }
  public set context(value: string) {
    this._context = value;
  }
  public resetContext() {
    this._context = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contextInput() {
    return this._context;
  }

  // qualifier - computed: true, optional: true, required: false
  private _qualifier = new VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanQualifierList(this, "qualifier", false);
  public get qualifier() {
    return this._qualifier;
  }
  public putQualifier(value: VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanQualifier[] | cdktf.IResolvable) {
    this._qualifier.internalValue = value;
  }
  public resetQualifier() {
    this._qualifier.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get qualifierInput() {
    return this._qualifier.internalValue;
  }

  // value - computed: true, optional: true, required: false
  private _value?: number; 
  public get value() {
    return this.getNumberAttribute('value');
  }
  public set value(value: number) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThanQualifier {
  /**
  * Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#name VulnerabilityProtectionSignature#name}
  */
  readonly name?: string;
  /**
  * Value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#value VulnerabilityProtectionSignature#value}
  */
  readonly value?: string;
}

export function vulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThanQualifierToTerraform(struct?: VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThanQualifier | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function vulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThanQualifierToHclTerraform(struct?: VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThanQualifier | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThanQualifierOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThanQualifier | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThanQualifier | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: true, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: true, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThanQualifierList extends cdktf.ComplexList {
  public internalValue? : VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThanQualifier[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThanQualifierOutputReference {
    return new VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThanQualifierOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThan {
  /**
  * Context
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#context VulnerabilityProtectionSignature#context}
  */
  readonly context?: string;
  /**
  * vulnerability protection signature standard object and condition object or condition object operators less_than array
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#qualifier VulnerabilityProtectionSignature#qualifier}
  */
  readonly qualifier?: VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThanQualifier[] | cdktf.IResolvable;
  /**
  * Value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#value VulnerabilityProtectionSignature#value}
  */
  readonly value?: number;
}

export function vulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThanToTerraform(struct?: VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThan | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    context: cdktf.stringToTerraform(struct!.context),
    qualifier: cdktf.listMapper(vulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThanQualifierToTerraform, false)(struct!.qualifier),
    value: cdktf.numberToTerraform(struct!.value),
  }
}


export function vulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThanToHclTerraform(struct?: VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThan | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    context: {
      value: cdktf.stringToHclTerraform(struct!.context),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    qualifier: {
      value: cdktf.listMapperHcl(vulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThanQualifierToHclTerraform, false)(struct!.qualifier),
      isBlock: true,
      type: "list",
      storageClassType: "VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThanQualifierList",
    },
    value: {
      value: cdktf.numberToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThanOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThan | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._context !== undefined) {
      hasAnyValues = true;
      internalValueResult.context = this._context;
    }
    if (this._qualifier?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.qualifier = this._qualifier?.internalValue;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThan | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._context = undefined;
      this._qualifier.internalValue = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._context = value.context;
      this._qualifier.internalValue = value.qualifier;
      this._value = value.value;
    }
  }

  // context - computed: true, optional: true, required: false
  private _context?: string; 
  public get context() {
    return this.getStringAttribute('context');
  }
  public set context(value: string) {
    this._context = value;
  }
  public resetContext() {
    this._context = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contextInput() {
    return this._context;
  }

  // qualifier - computed: true, optional: true, required: false
  private _qualifier = new VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThanQualifierList(this, "qualifier", false);
  public get qualifier() {
    return this._qualifier;
  }
  public putQualifier(value: VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThanQualifier[] | cdktf.IResolvable) {
    this._qualifier.internalValue = value;
  }
  public resetQualifier() {
    this._qualifier.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get qualifierInput() {
    return this._qualifier.internalValue;
  }

  // value - computed: true, optional: true, required: false
  private _value?: number; 
  public get value() {
    return this.getNumberAttribute('value');
  }
  public set value(value: number) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchQualifier {
  /**
  * Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#name VulnerabilityProtectionSignature#name}
  */
  readonly name?: string;
  /**
  * Value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#value VulnerabilityProtectionSignature#value}
  */
  readonly value?: string;
}

export function vulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchQualifierToTerraform(struct?: VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchQualifier | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function vulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchQualifierToHclTerraform(struct?: VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchQualifier | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchQualifierOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchQualifier | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchQualifier | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: true, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: true, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchQualifierList extends cdktf.ComplexList {
  public internalValue? : VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchQualifier[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchQualifierOutputReference {
    return new VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchQualifierOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatch {
  /**
  * Context
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#context VulnerabilityProtectionSignature#context}
  */
  readonly context?: string;
  /**
  * Negate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#negate VulnerabilityProtectionSignature#negate}
  */
  readonly negate?: boolean | cdktf.IResolvable;
  /**
  * Pattern
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#pattern VulnerabilityProtectionSignature#pattern}
  */
  readonly pattern?: string;
  /**
  * vulnerability protection signature standard object and condition object or condition object operators pattern match qualifier
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#qualifier VulnerabilityProtectionSignature#qualifier}
  */
  readonly qualifier?: VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchQualifier[] | cdktf.IResolvable;
}

export function vulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchToTerraform(struct?: VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    context: cdktf.stringToTerraform(struct!.context),
    negate: cdktf.booleanToTerraform(struct!.negate),
    pattern: cdktf.stringToTerraform(struct!.pattern),
    qualifier: cdktf.listMapper(vulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchQualifierToTerraform, false)(struct!.qualifier),
  }
}


export function vulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchToHclTerraform(struct?: VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    context: {
      value: cdktf.stringToHclTerraform(struct!.context),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    negate: {
      value: cdktf.booleanToHclTerraform(struct!.negate),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    pattern: {
      value: cdktf.stringToHclTerraform(struct!.pattern),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    qualifier: {
      value: cdktf.listMapperHcl(vulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchQualifierToHclTerraform, false)(struct!.qualifier),
      isBlock: true,
      type: "list",
      storageClassType: "VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchQualifierList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._context !== undefined) {
      hasAnyValues = true;
      internalValueResult.context = this._context;
    }
    if (this._negate !== undefined) {
      hasAnyValues = true;
      internalValueResult.negate = this._negate;
    }
    if (this._pattern !== undefined) {
      hasAnyValues = true;
      internalValueResult.pattern = this._pattern;
    }
    if (this._qualifier?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.qualifier = this._qualifier?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._context = undefined;
      this._negate = undefined;
      this._pattern = undefined;
      this._qualifier.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._context = value.context;
      this._negate = value.negate;
      this._pattern = value.pattern;
      this._qualifier.internalValue = value.qualifier;
    }
  }

  // context - computed: true, optional: true, required: false
  private _context?: string; 
  public get context() {
    return this.getStringAttribute('context');
  }
  public set context(value: string) {
    this._context = value;
  }
  public resetContext() {
    this._context = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contextInput() {
    return this._context;
  }

  // negate - computed: true, optional: true, required: false
  private _negate?: boolean | cdktf.IResolvable; 
  public get negate() {
    return this.getBooleanAttribute('negate');
  }
  public set negate(value: boolean | cdktf.IResolvable) {
    this._negate = value;
  }
  public resetNegate() {
    this._negate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get negateInput() {
    return this._negate;
  }

  // pattern - computed: true, optional: true, required: false
  private _pattern?: string; 
  public get pattern() {
    return this.getStringAttribute('pattern');
  }
  public set pattern(value: string) {
    this._pattern = value;
  }
  public resetPattern() {
    this._pattern = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get patternInput() {
    return this._pattern;
  }

  // qualifier - computed: true, optional: true, required: false
  private _qualifier = new VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchQualifierList(this, "qualifier", false);
  public get qualifier() {
    return this._qualifier;
  }
  public putQualifier(value: VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchQualifier[] | cdktf.IResolvable) {
    this._qualifier.internalValue = value;
  }
  public resetQualifier() {
    this._qualifier.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get qualifierInput() {
    return this._qualifier.internalValue;
  }
}
export interface VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperator {
  /**
  * vulnerability protection signature standard object and condition object or condition object operators equal_to
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#equal_to VulnerabilityProtectionSignature#equal_to}
  */
  readonly equalTo?: VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualTo;
  /**
  * vulnerability protection signature standard object and condition object or condition object operators greater_than
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#greater_than VulnerabilityProtectionSignature#greater_than}
  */
  readonly greaterThan?: VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThan;
  /**
  * vulnerability protection signature standard object and condition object or condition object operators less_than
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#less_than VulnerabilityProtectionSignature#less_than}
  */
  readonly lessThan?: VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThan;
  /**
  * vulnerability protection signature standard object and condition object or condition object operators pattern match
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#pattern_match VulnerabilityProtectionSignature#pattern_match}
  */
  readonly patternMatch?: VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatch;
}

export function vulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorToTerraform(struct?: VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    equal_to: vulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualToToTerraform(struct!.equalTo),
    greater_than: vulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanToTerraform(struct!.greaterThan),
    less_than: vulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThanToTerraform(struct!.lessThan),
    pattern_match: vulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchToTerraform(struct!.patternMatch),
  }
}


export function vulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorToHclTerraform(struct?: VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    equal_to: {
      value: vulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualToToHclTerraform(struct!.equalTo),
      isBlock: true,
      type: "struct",
      storageClassType: "VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualTo",
    },
    greater_than: {
      value: vulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanToHclTerraform(struct!.greaterThan),
      isBlock: true,
      type: "struct",
      storageClassType: "VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThan",
    },
    less_than: {
      value: vulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThanToHclTerraform(struct!.lessThan),
      isBlock: true,
      type: "struct",
      storageClassType: "VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThan",
    },
    pattern_match: {
      value: vulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchToHclTerraform(struct!.patternMatch),
      isBlock: true,
      type: "struct",
      storageClassType: "VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatch",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperator | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._equalTo?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.equalTo = this._equalTo?.internalValue;
    }
    if (this._greaterThan?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.greaterThan = this._greaterThan?.internalValue;
    }
    if (this._lessThan?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.lessThan = this._lessThan?.internalValue;
    }
    if (this._patternMatch?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.patternMatch = this._patternMatch?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperator | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._equalTo.internalValue = undefined;
      this._greaterThan.internalValue = undefined;
      this._lessThan.internalValue = undefined;
      this._patternMatch.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._equalTo.internalValue = value.equalTo;
      this._greaterThan.internalValue = value.greaterThan;
      this._lessThan.internalValue = value.lessThan;
      this._patternMatch.internalValue = value.patternMatch;
    }
  }

  // equal_to - computed: true, optional: true, required: false
  private _equalTo = new VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualToOutputReference(this, "equal_to");
  public get equalTo() {
    return this._equalTo;
  }
  public putEqualTo(value: VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorEqualTo) {
    this._equalTo.internalValue = value;
  }
  public resetEqualTo() {
    this._equalTo.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get equalToInput() {
    return this._equalTo.internalValue;
  }

  // greater_than - computed: true, optional: true, required: false
  private _greaterThan = new VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThanOutputReference(this, "greater_than");
  public get greaterThan() {
    return this._greaterThan;
  }
  public putGreaterThan(value: VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorGreaterThan) {
    this._greaterThan.internalValue = value;
  }
  public resetGreaterThan() {
    this._greaterThan.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get greaterThanInput() {
    return this._greaterThan.internalValue;
  }

  // less_than - computed: true, optional: true, required: false
  private _lessThan = new VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThanOutputReference(this, "less_than");
  public get lessThan() {
    return this._lessThan;
  }
  public putLessThan(value: VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorLessThan) {
    this._lessThan.internalValue = value;
  }
  public resetLessThan() {
    this._lessThan.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lessThanInput() {
    return this._lessThan.internalValue;
  }

  // pattern_match - computed: true, optional: true, required: false
  private _patternMatch = new VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatchOutputReference(this, "pattern_match");
  public get patternMatch() {
    return this._patternMatch;
  }
  public putPatternMatch(value: VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorPatternMatch) {
    this._patternMatch.internalValue = value;
  }
  public resetPatternMatch() {
    this._patternMatch.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get patternMatchInput() {
    return this._patternMatch.internalValue;
  }
}
export interface VulnerabilityProtectionSignatureSignatureStandardAndConditionOrCondition {
  /**
  * Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#name VulnerabilityProtectionSignature#name}
  */
  readonly name?: string;
  /**
  * vulnerability protection signature standard object and condition object or condition object operators
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#operator VulnerabilityProtectionSignature#operator}
  */
  readonly operator?: VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperator;
}

export function vulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionToTerraform(struct?: VulnerabilityProtectionSignatureSignatureStandardAndConditionOrCondition | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    operator: vulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorToTerraform(struct!.operator),
  }
}


export function vulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionToHclTerraform(struct?: VulnerabilityProtectionSignatureSignatureStandardAndConditionOrCondition | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: vulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorToHclTerraform(struct!.operator),
      isBlock: true,
      type: "struct",
      storageClassType: "VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperator",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): VulnerabilityProtectionSignatureSignatureStandardAndConditionOrCondition | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._operator?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VulnerabilityProtectionSignatureSignatureStandardAndConditionOrCondition | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._operator.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._operator.internalValue = value.operator;
    }
  }

  // name - computed: true, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // operator - computed: true, optional: true, required: false
  private _operator = new VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperatorOutputReference(this, "operator");
  public get operator() {
    return this._operator;
  }
  public putOperator(value: VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOperator) {
    this._operator.internalValue = value;
  }
  public resetOperator() {
    this._operator.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator.internalValue;
  }
}

export class VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionList extends cdktf.ComplexList {
  public internalValue? : VulnerabilityProtectionSignatureSignatureStandardAndConditionOrCondition[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOutputReference {
    return new VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface VulnerabilityProtectionSignatureSignatureStandardAndCondition {
  /**
  * Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#name VulnerabilityProtectionSignature#name}
  */
  readonly name?: string;
  /**
  * vulnerability protection signature standard object and condition object or condition
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#or_condition VulnerabilityProtectionSignature#or_condition}
  */
  readonly orCondition?: VulnerabilityProtectionSignatureSignatureStandardAndConditionOrCondition[] | cdktf.IResolvable;
}

export function vulnerabilityProtectionSignatureSignatureStandardAndConditionToTerraform(struct?: VulnerabilityProtectionSignatureSignatureStandardAndCondition | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    or_condition: cdktf.listMapper(vulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionToTerraform, false)(struct!.orCondition),
  }
}


export function vulnerabilityProtectionSignatureSignatureStandardAndConditionToHclTerraform(struct?: VulnerabilityProtectionSignatureSignatureStandardAndCondition | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    or_condition: {
      value: cdktf.listMapperHcl(vulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionToHclTerraform, false)(struct!.orCondition),
      isBlock: true,
      type: "list",
      storageClassType: "VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VulnerabilityProtectionSignatureSignatureStandardAndConditionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): VulnerabilityProtectionSignatureSignatureStandardAndCondition | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._orCondition?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.orCondition = this._orCondition?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VulnerabilityProtectionSignatureSignatureStandardAndCondition | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._orCondition.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._orCondition.internalValue = value.orCondition;
    }
  }

  // name - computed: true, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // or_condition - computed: true, optional: true, required: false
  private _orCondition = new VulnerabilityProtectionSignatureSignatureStandardAndConditionOrConditionList(this, "or_condition", false);
  public get orCondition() {
    return this._orCondition;
  }
  public putOrCondition(value: VulnerabilityProtectionSignatureSignatureStandardAndConditionOrCondition[] | cdktf.IResolvable) {
    this._orCondition.internalValue = value;
  }
  public resetOrCondition() {
    this._orCondition.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get orConditionInput() {
    return this._orCondition.internalValue;
  }
}

export class VulnerabilityProtectionSignatureSignatureStandardAndConditionList extends cdktf.ComplexList {
  public internalValue? : VulnerabilityProtectionSignatureSignatureStandardAndCondition[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): VulnerabilityProtectionSignatureSignatureStandardAndConditionOutputReference {
    return new VulnerabilityProtectionSignatureSignatureStandardAndConditionOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface VulnerabilityProtectionSignatureSignatureStandard {
  /**
  * vulnerability protection signature standard object and condition
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#and_condition VulnerabilityProtectionSignature#and_condition}
  */
  readonly andCondition?: VulnerabilityProtectionSignatureSignatureStandardAndCondition[] | cdktf.IResolvable;
  /**
  * Comment
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#comment VulnerabilityProtectionSignature#comment}
  */
  readonly comment?: string;
  /**
  * Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#name VulnerabilityProtectionSignature#name}
  */
  readonly name: string;
  /**
  * Order free
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#order_free VulnerabilityProtectionSignature#order_free}
  */
  readonly orderFree?: boolean | cdktf.IResolvable;
  /**
  * Scope
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#scope VulnerabilityProtectionSignature#scope}
  */
  readonly scope?: string;
}

export function vulnerabilityProtectionSignatureSignatureStandardToTerraform(struct?: VulnerabilityProtectionSignatureSignatureStandard | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    and_condition: cdktf.listMapper(vulnerabilityProtectionSignatureSignatureStandardAndConditionToTerraform, false)(struct!.andCondition),
    comment: cdktf.stringToTerraform(struct!.comment),
    name: cdktf.stringToTerraform(struct!.name),
    order_free: cdktf.booleanToTerraform(struct!.orderFree),
    scope: cdktf.stringToTerraform(struct!.scope),
  }
}


export function vulnerabilityProtectionSignatureSignatureStandardToHclTerraform(struct?: VulnerabilityProtectionSignatureSignatureStandard | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    and_condition: {
      value: cdktf.listMapperHcl(vulnerabilityProtectionSignatureSignatureStandardAndConditionToHclTerraform, false)(struct!.andCondition),
      isBlock: true,
      type: "list",
      storageClassType: "VulnerabilityProtectionSignatureSignatureStandardAndConditionList",
    },
    comment: {
      value: cdktf.stringToHclTerraform(struct!.comment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    order_free: {
      value: cdktf.booleanToHclTerraform(struct!.orderFree),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    scope: {
      value: cdktf.stringToHclTerraform(struct!.scope),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VulnerabilityProtectionSignatureSignatureStandardOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): VulnerabilityProtectionSignatureSignatureStandard | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._andCondition?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.andCondition = this._andCondition?.internalValue;
    }
    if (this._comment !== undefined) {
      hasAnyValues = true;
      internalValueResult.comment = this._comment;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._orderFree !== undefined) {
      hasAnyValues = true;
      internalValueResult.orderFree = this._orderFree;
    }
    if (this._scope !== undefined) {
      hasAnyValues = true;
      internalValueResult.scope = this._scope;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VulnerabilityProtectionSignatureSignatureStandard | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._andCondition.internalValue = undefined;
      this._comment = undefined;
      this._name = undefined;
      this._orderFree = undefined;
      this._scope = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._andCondition.internalValue = value.andCondition;
      this._comment = value.comment;
      this._name = value.name;
      this._orderFree = value.orderFree;
      this._scope = value.scope;
    }
  }

  // and_condition - computed: true, optional: true, required: false
  private _andCondition = new VulnerabilityProtectionSignatureSignatureStandardAndConditionList(this, "and_condition", false);
  public get andCondition() {
    return this._andCondition;
  }
  public putAndCondition(value: VulnerabilityProtectionSignatureSignatureStandardAndCondition[] | cdktf.IResolvable) {
    this._andCondition.internalValue = value;
  }
  public resetAndCondition() {
    this._andCondition.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get andConditionInput() {
    return this._andCondition.internalValue;
  }

  // comment - computed: true, optional: true, required: false
  private _comment?: string; 
  public get comment() {
    return this.getStringAttribute('comment');
  }
  public set comment(value: string) {
    this._comment = value;
  }
  public resetComment() {
    this._comment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commentInput() {
    return this._comment;
  }

  // name - computed: true, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // order_free - computed: true, optional: true, required: false
  private _orderFree?: boolean | cdktf.IResolvable; 
  public get orderFree() {
    return this.getBooleanAttribute('order_free');
  }
  public set orderFree(value: boolean | cdktf.IResolvable) {
    this._orderFree = value;
  }
  public resetOrderFree() {
    this._orderFree = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get orderFreeInput() {
    return this._orderFree;
  }

  // scope - computed: true, optional: true, required: false
  private _scope?: string; 
  public get scope() {
    return this.getStringAttribute('scope');
  }
  public set scope(value: string) {
    this._scope = value;
  }
  public resetScope() {
    this._scope = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scopeInput() {
    return this._scope;
  }
}

export class VulnerabilityProtectionSignatureSignatureStandardList extends cdktf.ComplexList {
  public internalValue? : VulnerabilityProtectionSignatureSignatureStandard[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): VulnerabilityProtectionSignatureSignatureStandardOutputReference {
    return new VulnerabilityProtectionSignatureSignatureStandardOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface VulnerabilityProtectionSignatureSignature {
  /**
  * vulnerability protection signature combination object
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#combination VulnerabilityProtectionSignature#combination}
  */
  readonly combination?: VulnerabilityProtectionSignatureSignatureCombination;
  /**
  * vulnerability protection signature standard array
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#standard VulnerabilityProtectionSignature#standard}
  */
  readonly standard?: VulnerabilityProtectionSignatureSignatureStandard[] | cdktf.IResolvable;
}

export function vulnerabilityProtectionSignatureSignatureToTerraform(struct?: VulnerabilityProtectionSignatureSignature | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    combination: vulnerabilityProtectionSignatureSignatureCombinationToTerraform(struct!.combination),
    standard: cdktf.listMapper(vulnerabilityProtectionSignatureSignatureStandardToTerraform, false)(struct!.standard),
  }
}


export function vulnerabilityProtectionSignatureSignatureToHclTerraform(struct?: VulnerabilityProtectionSignatureSignature | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    combination: {
      value: vulnerabilityProtectionSignatureSignatureCombinationToHclTerraform(struct!.combination),
      isBlock: true,
      type: "struct",
      storageClassType: "VulnerabilityProtectionSignatureSignatureCombination",
    },
    standard: {
      value: cdktf.listMapperHcl(vulnerabilityProtectionSignatureSignatureStandardToHclTerraform, false)(struct!.standard),
      isBlock: true,
      type: "list",
      storageClassType: "VulnerabilityProtectionSignatureSignatureStandardList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class VulnerabilityProtectionSignatureSignatureOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): VulnerabilityProtectionSignatureSignature | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._combination?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.combination = this._combination?.internalValue;
    }
    if (this._standard?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.standard = this._standard?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: VulnerabilityProtectionSignatureSignature | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._combination.internalValue = undefined;
      this._standard.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._combination.internalValue = value.combination;
      this._standard.internalValue = value.standard;
    }
  }

  // combination - computed: true, optional: true, required: false
  private _combination = new VulnerabilityProtectionSignatureSignatureCombinationOutputReference(this, "combination");
  public get combination() {
    return this._combination;
  }
  public putCombination(value: VulnerabilityProtectionSignatureSignatureCombination) {
    this._combination.internalValue = value;
  }
  public resetCombination() {
    this._combination.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get combinationInput() {
    return this._combination.internalValue;
  }

  // standard - computed: true, optional: true, required: false
  private _standard = new VulnerabilityProtectionSignatureSignatureStandardList(this, "standard", false);
  public get standard() {
    return this._standard;
  }
  public putStandard(value: VulnerabilityProtectionSignatureSignatureStandard[] | cdktf.IResolvable) {
    this._standard.internalValue = value;
  }
  public resetStandard() {
    this._standard.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get standardInput() {
    return this._standard.internalValue;
  }
}

/**
* Represents a {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature scm_vulnerability_protection_signature}
*/
export class VulnerabilityProtectionSignature extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType = "scm_vulnerability_protection_signature";

  // ==============
  // STATIC Methods
  // ==============
  /**
  * Generates CDKTF code for importing a VulnerabilityProtectionSignature resource upon running "cdktf plan <stack-name>"
  * @param scope The scope in which to define this construct
  * @param importToId The construct id used in the generated config for the VulnerabilityProtectionSignature to import
  * @param importFromId The id of the existing VulnerabilityProtectionSignature that should be imported. Refer to the {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature#import import section} in the documentation of this resource for the id to use
  * @param provider? Optional instance of the provider where the VulnerabilityProtectionSignature to import is found
  */
  public static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider) {
        return new cdktf.ImportableResource(scope, importToId, { terraformResourceType: "scm_vulnerability_protection_signature", importId: importFromId, provider });
      }

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://registry.terraform.io/providers/paloaltonetworks/scm/1.0.2/docs/resources/vulnerability_protection_signature scm_vulnerability_protection_signature} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options VulnerabilityProtectionSignatureConfig
  */
  public constructor(scope: Construct, id: string, config: VulnerabilityProtectionSignatureConfig) {
    super(scope, id, {
      terraformResourceType: 'scm_vulnerability_protection_signature',
      terraformGeneratorMetadata: {
        providerName: 'scm',
        providerVersion: '1.0.2'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle,
      provisioners: config.provisioners,
      connection: config.connection,
      forEach: config.forEach
    });
    this._affectedHost.internalValue = config.affectedHost;
    this._bugtraq = config.bugtraq;
    this._comment = config.comment;
    this._cve = config.cve;
    this._defaultAction.internalValue = config.defaultAction;
    this._device = config.device;
    this._direction = config.direction;
    this._folder = config.folder;
    this._reference = config.reference;
    this._severity = config.severity;
    this._signature.internalValue = config.signature;
    this._snippet = config.snippet;
    this._threatId = config.threatId;
    this._threatname = config.threatname;
    this._vendor = config.vendor;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // affected_host - computed: false, optional: true, required: false
  private _affectedHost = new VulnerabilityProtectionSignatureAffectedHostOutputReference(this, "affected_host");
  public get affectedHost() {
    return this._affectedHost;
  }
  public putAffectedHost(value: VulnerabilityProtectionSignatureAffectedHost) {
    this._affectedHost.internalValue = value;
  }
  public resetAffectedHost() {
    this._affectedHost.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get affectedHostInput() {
    return this._affectedHost.internalValue;
  }

  // bugtraq - computed: false, optional: true, required: false
  private _bugtraq?: string[]; 
  public get bugtraq() {
    return this.getListAttribute('bugtraq');
  }
  public set bugtraq(value: string[]) {
    this._bugtraq = value;
  }
  public resetBugtraq() {
    this._bugtraq = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bugtraqInput() {
    return this._bugtraq;
  }

  // comment - computed: false, optional: true, required: false
  private _comment?: string; 
  public get comment() {
    return this.getStringAttribute('comment');
  }
  public set comment(value: string) {
    this._comment = value;
  }
  public resetComment() {
    this._comment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commentInput() {
    return this._comment;
  }

  // cve - computed: false, optional: true, required: false
  private _cve?: string[]; 
  public get cve() {
    return this.getListAttribute('cve');
  }
  public set cve(value: string[]) {
    this._cve = value;
  }
  public resetCve() {
    this._cve = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cveInput() {
    return this._cve;
  }

  // default_action - computed: false, optional: true, required: false
  private _defaultAction = new VulnerabilityProtectionSignatureDefaultActionOutputReference(this, "default_action");
  public get defaultAction() {
    return this._defaultAction;
  }
  public putDefaultAction(value: VulnerabilityProtectionSignatureDefaultAction) {
    this._defaultAction.internalValue = value;
  }
  public resetDefaultAction() {
    this._defaultAction.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultActionInput() {
    return this._defaultAction.internalValue;
  }

  // device - computed: false, optional: true, required: false
  private _device?: string; 
  public get device() {
    return this.getStringAttribute('device');
  }
  public set device(value: string) {
    this._device = value;
  }
  public resetDevice() {
    this._device = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deviceInput() {
    return this._device;
  }

  // direction - computed: false, optional: true, required: false
  private _direction?: string; 
  public get direction() {
    return this.getStringAttribute('direction');
  }
  public set direction(value: string) {
    this._direction = value;
  }
  public resetDirection() {
    this._direction = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get directionInput() {
    return this._direction;
  }

  // folder - computed: false, optional: true, required: false
  private _folder?: string; 
  public get folder() {
    return this.getStringAttribute('folder');
  }
  public set folder(value: string) {
    this._folder = value;
  }
  public resetFolder() {
    this._folder = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get folderInput() {
    return this._folder;
  }

  // id - computed: true, optional: false, required: false
  public get id() {
    return this.getStringAttribute('id');
  }

  // reference - computed: false, optional: true, required: false
  private _reference?: string[]; 
  public get reference() {
    return this.getListAttribute('reference');
  }
  public set reference(value: string[]) {
    this._reference = value;
  }
  public resetReference() {
    this._reference = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get referenceInput() {
    return this._reference;
  }

  // severity - computed: false, optional: true, required: false
  private _severity?: string; 
  public get severity() {
    return this.getStringAttribute('severity');
  }
  public set severity(value: string) {
    this._severity = value;
  }
  public resetSeverity() {
    this._severity = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get severityInput() {
    return this._severity;
  }

  // signature - computed: true, optional: true, required: false
  private _signature = new VulnerabilityProtectionSignatureSignatureOutputReference(this, "signature");
  public get signature() {
    return this._signature;
  }
  public putSignature(value: VulnerabilityProtectionSignatureSignature) {
    this._signature.internalValue = value;
  }
  public resetSignature() {
    this._signature.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get signatureInput() {
    return this._signature.internalValue;
  }

  // snippet - computed: false, optional: true, required: false
  private _snippet?: string; 
  public get snippet() {
    return this.getStringAttribute('snippet');
  }
  public set snippet(value: string) {
    this._snippet = value;
  }
  public resetSnippet() {
    this._snippet = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get snippetInput() {
    return this._snippet;
  }

  // tfid - computed: true, optional: false, required: false
  public get tfid() {
    return this.getStringAttribute('tfid');
  }

  // threat_id - computed: false, optional: false, required: true
  private _threatId?: number; 
  public get threatId() {
    return this.getNumberAttribute('threat_id');
  }
  public set threatId(value: number) {
    this._threatId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get threatIdInput() {
    return this._threatId;
  }

  // threatname - computed: false, optional: false, required: true
  private _threatname?: string; 
  public get threatname() {
    return this.getStringAttribute('threatname');
  }
  public set threatname(value: string) {
    this._threatname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get threatnameInput() {
    return this._threatname;
  }

  // vendor - computed: false, optional: true, required: false
  private _vendor?: string[]; 
  public get vendor() {
    return this.getListAttribute('vendor');
  }
  public set vendor(value: string[]) {
    this._vendor = value;
  }
  public resetVendor() {
    this._vendor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vendorInput() {
    return this._vendor;
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      affected_host: vulnerabilityProtectionSignatureAffectedHostToTerraform(this._affectedHost.internalValue),
      bugtraq: cdktf.listMapper(cdktf.stringToTerraform, false)(this._bugtraq),
      comment: cdktf.stringToTerraform(this._comment),
      cve: cdktf.listMapper(cdktf.stringToTerraform, false)(this._cve),
      default_action: vulnerabilityProtectionSignatureDefaultActionToTerraform(this._defaultAction.internalValue),
      device: cdktf.stringToTerraform(this._device),
      direction: cdktf.stringToTerraform(this._direction),
      folder: cdktf.stringToTerraform(this._folder),
      reference: cdktf.listMapper(cdktf.stringToTerraform, false)(this._reference),
      severity: cdktf.stringToTerraform(this._severity),
      signature: vulnerabilityProtectionSignatureSignatureToTerraform(this._signature.internalValue),
      snippet: cdktf.stringToTerraform(this._snippet),
      threat_id: cdktf.numberToTerraform(this._threatId),
      threatname: cdktf.stringToTerraform(this._threatname),
      vendor: cdktf.listMapper(cdktf.stringToTerraform, false)(this._vendor),
    };
  }

  protected synthesizeHclAttributes(): { [name: string]: any } {
    const attrs = {
      affected_host: {
        value: vulnerabilityProtectionSignatureAffectedHostToHclTerraform(this._affectedHost.internalValue),
        isBlock: true,
        type: "struct",
        storageClassType: "VulnerabilityProtectionSignatureAffectedHost",
      },
      bugtraq: {
        value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(this._bugtraq),
        isBlock: false,
        type: "list",
        storageClassType: "stringList",
      },
      comment: {
        value: cdktf.stringToHclTerraform(this._comment),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      cve: {
        value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(this._cve),
        isBlock: false,
        type: "list",
        storageClassType: "stringList",
      },
      default_action: {
        value: vulnerabilityProtectionSignatureDefaultActionToHclTerraform(this._defaultAction.internalValue),
        isBlock: true,
        type: "struct",
        storageClassType: "VulnerabilityProtectionSignatureDefaultAction",
      },
      device: {
        value: cdktf.stringToHclTerraform(this._device),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      direction: {
        value: cdktf.stringToHclTerraform(this._direction),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      folder: {
        value: cdktf.stringToHclTerraform(this._folder),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      reference: {
        value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(this._reference),
        isBlock: false,
        type: "list",
        storageClassType: "stringList",
      },
      severity: {
        value: cdktf.stringToHclTerraform(this._severity),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      signature: {
        value: vulnerabilityProtectionSignatureSignatureToHclTerraform(this._signature.internalValue),
        isBlock: true,
        type: "struct",
        storageClassType: "VulnerabilityProtectionSignatureSignature",
      },
      snippet: {
        value: cdktf.stringToHclTerraform(this._snippet),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      threat_id: {
        value: cdktf.numberToHclTerraform(this._threatId),
        isBlock: false,
        type: "simple",
        storageClassType: "number",
      },
      threatname: {
        value: cdktf.stringToHclTerraform(this._threatname),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      vendor: {
        value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(this._vendor),
        isBlock: false,
        type: "list",
        storageClassType: "stringList",
      },
    };

    // remove undefined attributes
    return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined ))
  }
}
