// https://registry.terraform.io/providers/sysdiglabs/sysdig/3.1.0/docs/resources/secure_vulnerability_rule_bundle
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface SecureVulnerabilityRuleBundleConfig extends cdktf.TerraformMetaArguments {
  /**
  * Rule Bundle description
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/sysdiglabs/sysdig/3.1.0/docs/resources/secure_vulnerability_rule_bundle#description SecureVulnerabilityRuleBundle#description}
  */
  readonly description?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/sysdiglabs/sysdig/3.1.0/docs/resources/secure_vulnerability_rule_bundle#id SecureVulnerabilityRuleBundle#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Rule Bundle name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/sysdiglabs/sysdig/3.1.0/docs/resources/secure_vulnerability_rule_bundle#name SecureVulnerabilityRuleBundle#name}
  */
  readonly name: string;
  /**
  * rule block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/sysdiglabs/sysdig/3.1.0/docs/resources/secure_vulnerability_rule_bundle#rule SecureVulnerabilityRuleBundle#rule}
  */
  readonly rule: SecureVulnerabilityRuleBundleRule[] | cdktf.IResolvable;
  /**
  * timeouts block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/sysdiglabs/sysdig/3.1.0/docs/resources/secure_vulnerability_rule_bundle#timeouts SecureVulnerabilityRuleBundle#timeouts}
  */
  readonly timeouts?: SecureVulnerabilityRuleBundleTimeouts;
}
export interface SecureVulnerabilityRuleBundleRuleImageLabelLabelMustExistAndContainValue {
  /**
  * Label key that must exist in the image configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/sysdiglabs/sysdig/3.1.0/docs/resources/secure_vulnerability_rule_bundle#required_label SecureVulnerabilityRuleBundle#required_label}
  */
  readonly requiredLabel: string;
  /**
  * Expected value for the given label key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/sysdiglabs/sysdig/3.1.0/docs/resources/secure_vulnerability_rule_bundle#required_value SecureVulnerabilityRuleBundle#required_value}
  */
  readonly requiredValue: string;
}

export function secureVulnerabilityRuleBundleRuleImageLabelLabelMustExistAndContainValueToTerraform(struct?: SecureVulnerabilityRuleBundleRuleImageLabelLabelMustExistAndContainValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    required_label: cdktf.stringToTerraform(struct!.requiredLabel),
    required_value: cdktf.stringToTerraform(struct!.requiredValue),
  }
}


export function secureVulnerabilityRuleBundleRuleImageLabelLabelMustExistAndContainValueToHclTerraform(struct?: SecureVulnerabilityRuleBundleRuleImageLabelLabelMustExistAndContainValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    required_label: {
      value: cdktf.stringToHclTerraform(struct!.requiredLabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    required_value: {
      value: cdktf.stringToHclTerraform(struct!.requiredValue),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SecureVulnerabilityRuleBundleRuleImageLabelLabelMustExistAndContainValueOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SecureVulnerabilityRuleBundleRuleImageLabelLabelMustExistAndContainValue | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._requiredLabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.requiredLabel = this._requiredLabel;
    }
    if (this._requiredValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.requiredValue = this._requiredValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SecureVulnerabilityRuleBundleRuleImageLabelLabelMustExistAndContainValue | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._requiredLabel = undefined;
      this._requiredValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._requiredLabel = value.requiredLabel;
      this._requiredValue = value.requiredValue;
    }
  }

  // required_label - computed: false, optional: false, required: true
  private _requiredLabel?: string; 
  public get requiredLabel() {
    return this.getStringAttribute('required_label');
  }
  public set requiredLabel(value: string) {
    this._requiredLabel = value;
  }
  // Temporarily expose input value. Use with caution.
  public get requiredLabelInput() {
    return this._requiredLabel;
  }

  // required_value - computed: false, optional: false, required: true
  private _requiredValue?: string; 
  public get requiredValue() {
    return this.getStringAttribute('required_value');
  }
  public set requiredValue(value: string) {
    this._requiredValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get requiredValueInput() {
    return this._requiredValue;
  }
}

export class SecureVulnerabilityRuleBundleRuleImageLabelLabelMustExistAndContainValueList extends cdktf.ComplexList {
  public internalValue? : SecureVulnerabilityRuleBundleRuleImageLabelLabelMustExistAndContainValue[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SecureVulnerabilityRuleBundleRuleImageLabelLabelMustExistAndContainValueOutputReference {
    return new SecureVulnerabilityRuleBundleRuleImageLabelLabelMustExistAndContainValueOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SecureVulnerabilityRuleBundleRuleImageLabel {
  /**
  * A label key that must exist in the image configuration for the rule to match.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/sysdiglabs/sysdig/3.1.0/docs/resources/secure_vulnerability_rule_bundle#label_must_exist SecureVulnerabilityRuleBundle#label_must_exist}
  */
  readonly labelMustExist?: string;
  /**
  * A label key that must not exist in the image configuration for the rule to match.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/sysdiglabs/sysdig/3.1.0/docs/resources/secure_vulnerability_rule_bundle#label_must_not_exist SecureVulnerabilityRuleBundle#label_must_not_exist}
  */
  readonly labelMustNotExist?: string;
  /**
  * label_must_exist_and_contain_value block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/sysdiglabs/sysdig/3.1.0/docs/resources/secure_vulnerability_rule_bundle#label_must_exist_and_contain_value SecureVulnerabilityRuleBundle#label_must_exist_and_contain_value}
  */
  readonly labelMustExistAndContainValue?: SecureVulnerabilityRuleBundleRuleImageLabelLabelMustExistAndContainValue[] | cdktf.IResolvable;
}

export function secureVulnerabilityRuleBundleRuleImageLabelToTerraform(struct?: SecureVulnerabilityRuleBundleRuleImageLabelOutputReference | SecureVulnerabilityRuleBundleRuleImageLabel): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label_must_exist: cdktf.stringToTerraform(struct!.labelMustExist),
    label_must_not_exist: cdktf.stringToTerraform(struct!.labelMustNotExist),
    label_must_exist_and_contain_value: cdktf.listMapper(secureVulnerabilityRuleBundleRuleImageLabelLabelMustExistAndContainValueToTerraform, true)(struct!.labelMustExistAndContainValue),
  }
}


export function secureVulnerabilityRuleBundleRuleImageLabelToHclTerraform(struct?: SecureVulnerabilityRuleBundleRuleImageLabelOutputReference | SecureVulnerabilityRuleBundleRuleImageLabel): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label_must_exist: {
      value: cdktf.stringToHclTerraform(struct!.labelMustExist),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_must_not_exist: {
      value: cdktf.stringToHclTerraform(struct!.labelMustNotExist),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_must_exist_and_contain_value: {
      value: cdktf.listMapperHcl(secureVulnerabilityRuleBundleRuleImageLabelLabelMustExistAndContainValueToHclTerraform, true)(struct!.labelMustExistAndContainValue),
      isBlock: true,
      type: "list",
      storageClassType: "SecureVulnerabilityRuleBundleRuleImageLabelLabelMustExistAndContainValueList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SecureVulnerabilityRuleBundleRuleImageLabelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): SecureVulnerabilityRuleBundleRuleImageLabel | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._labelMustExist !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelMustExist = this._labelMustExist;
    }
    if (this._labelMustNotExist !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelMustNotExist = this._labelMustNotExist;
    }
    if (this._labelMustExistAndContainValue?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelMustExistAndContainValue = this._labelMustExistAndContainValue?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SecureVulnerabilityRuleBundleRuleImageLabel | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._labelMustExist = undefined;
      this._labelMustNotExist = undefined;
      this._labelMustExistAndContainValue.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._labelMustExist = value.labelMustExist;
      this._labelMustNotExist = value.labelMustNotExist;
      this._labelMustExistAndContainValue.internalValue = value.labelMustExistAndContainValue;
    }
  }

  // id - computed: true, optional: false, required: false
  public get id() {
    return this.getStringAttribute('id');
  }

  // label_must_exist - computed: false, optional: true, required: false
  private _labelMustExist?: string; 
  public get labelMustExist() {
    return this.getStringAttribute('label_must_exist');
  }
  public set labelMustExist(value: string) {
    this._labelMustExist = value;
  }
  public resetLabelMustExist() {
    this._labelMustExist = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelMustExistInput() {
    return this._labelMustExist;
  }

  // label_must_not_exist - computed: false, optional: true, required: false
  private _labelMustNotExist?: string; 
  public get labelMustNotExist() {
    return this.getStringAttribute('label_must_not_exist');
  }
  public set labelMustNotExist(value: string) {
    this._labelMustNotExist = value;
  }
  public resetLabelMustNotExist() {
    this._labelMustNotExist = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelMustNotExistInput() {
    return this._labelMustNotExist;
  }

  // label_must_exist_and_contain_value - computed: false, optional: true, required: false
  private _labelMustExistAndContainValue = new SecureVulnerabilityRuleBundleRuleImageLabelLabelMustExistAndContainValueList(this, "label_must_exist_and_contain_value", false);
  public get labelMustExistAndContainValue() {
    return this._labelMustExistAndContainValue;
  }
  public putLabelMustExistAndContainValue(value: SecureVulnerabilityRuleBundleRuleImageLabelLabelMustExistAndContainValue[] | cdktf.IResolvable) {
    this._labelMustExistAndContainValue.internalValue = value;
  }
  public resetLabelMustExistAndContainValue() {
    this._labelMustExistAndContainValue.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelMustExistAndContainValueInput() {
    return this._labelMustExistAndContainValue.internalValue;
  }
}
export interface SecureVulnerabilityRuleBundleRuleSeveritiesAndThreatsDisclosureDate {
  /**
  * Start of the date range (YYYY-MM-DD).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/sysdiglabs/sysdig/3.1.0/docs/resources/secure_vulnerability_rule_bundle#from SecureVulnerabilityRuleBundle#from}
  */
  readonly from: string;
  /**
  * End of the date range (YYYY-MM-DD).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/sysdiglabs/sysdig/3.1.0/docs/resources/secure_vulnerability_rule_bundle#to SecureVulnerabilityRuleBundle#to}
  */
  readonly to: string;
}

export function secureVulnerabilityRuleBundleRuleSeveritiesAndThreatsDisclosureDateToTerraform(struct?: SecureVulnerabilityRuleBundleRuleSeveritiesAndThreatsDisclosureDateOutputReference | SecureVulnerabilityRuleBundleRuleSeveritiesAndThreatsDisclosureDate): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    from: cdktf.stringToTerraform(struct!.from),
    to: cdktf.stringToTerraform(struct!.to),
  }
}


export function secureVulnerabilityRuleBundleRuleSeveritiesAndThreatsDisclosureDateToHclTerraform(struct?: SecureVulnerabilityRuleBundleRuleSeveritiesAndThreatsDisclosureDateOutputReference | SecureVulnerabilityRuleBundleRuleSeveritiesAndThreatsDisclosureDate): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    from: {
      value: cdktf.stringToHclTerraform(struct!.from),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    to: {
      value: cdktf.stringToHclTerraform(struct!.to),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SecureVulnerabilityRuleBundleRuleSeveritiesAndThreatsDisclosureDateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): SecureVulnerabilityRuleBundleRuleSeveritiesAndThreatsDisclosureDate | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._from !== undefined) {
      hasAnyValues = true;
      internalValueResult.from = this._from;
    }
    if (this._to !== undefined) {
      hasAnyValues = true;
      internalValueResult.to = this._to;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SecureVulnerabilityRuleBundleRuleSeveritiesAndThreatsDisclosureDate | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._from = undefined;
      this._to = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._from = value.from;
      this._to = value.to;
    }
  }

  // from - computed: false, optional: false, required: true
  private _from?: string; 
  public get from() {
    return this.getStringAttribute('from');
  }
  public set from(value: string) {
    this._from = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fromInput() {
    return this._from;
  }

  // to - computed: false, optional: false, required: true
  private _to?: string; 
  public get to() {
    return this.getStringAttribute('to');
  }
  public set to(value: string) {
    this._to = value;
  }
  // Temporarily expose input value. Use with caution.
  public get toInput() {
    return this._to;
  }
}
export interface SecureVulnerabilityRuleBundleRuleSeveritiesAndThreats {
  /**
  * Vulnerability has been in CISA KEV for at least this number of days.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/sysdiglabs/sysdig/3.1.0/docs/resources/secure_vulnerability_rule_bundle#cisa_kev_available_since_days SecureVulnerabilityRuleBundle#cisa_kev_available_since_days}
  */
  readonly cisaKevAvailableSinceDays?: number;
  /**
  * CISA KEV due date is within this number of days.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/sysdiglabs/sysdig/3.1.0/docs/resources/secure_vulnerability_rule_bundle#cisa_kev_due_date_in_days SecureVulnerabilityRuleBundle#cisa_kev_due_date_in_days}
  */
  readonly cisaKevDueDateInDays?: number;
  /**
  * Vulnerability is in a CISA KEV ransomware campaign.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/sysdiglabs/sysdig/3.1.0/docs/resources/secure_vulnerability_rule_bundle#cisa_kev_in_ransomware_campaign SecureVulnerabilityRuleBundle#cisa_kev_in_ransomware_campaign}
  */
  readonly cisaKevInRansomwareCampaign?: boolean | cdktf.IResolvable;
  /**
  * Vulnerability CVSS score must be at least this value.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/sysdiglabs/sysdig/3.1.0/docs/resources/secure_vulnerability_rule_bundle#cvss_at_least SecureVulnerabilityRuleBundle#cvss_at_least}
  */
  readonly cvssAtLeast?: number;
  /**
  * Vulnerability was disclosed more than this number of days ago.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/sysdiglabs/sysdig/3.1.0/docs/resources/secure_vulnerability_rule_bundle#disclosure_older_than_days SecureVulnerabilityRuleBundle#disclosure_older_than_days}
  */
  readonly disclosureOlderThanDays?: number;
  /**
  * EPSS percentile is at least this percentage.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/sysdiglabs/sysdig/3.1.0/docs/resources/secure_vulnerability_rule_bundle#epss_percentile_at_least_percentage SecureVulnerabilityRuleBundle#epss_percentile_at_least_percentage}
  */
  readonly epssPercentileAtLeastPercentage?: number;
  /**
  * EPSS score is at least this percentage.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/sysdiglabs/sysdig/3.1.0/docs/resources/secure_vulnerability_rule_bundle#epss_score_at_least_percentage SecureVulnerabilityRuleBundle#epss_score_at_least_percentage}
  */
  readonly epssScoreAtLeastPercentage?: number;
  /**
  * Exploit has a network attack vector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/sysdiglabs/sysdig/3.1.0/docs/resources/secure_vulnerability_rule_bundle#exploit_network_attack_vector SecureVulnerabilityRuleBundle#exploit_network_attack_vector}
  */
  readonly exploitNetworkAttackVector?: boolean | cdktf.IResolvable;
  /**
  * Exploit does not require admin privileges.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/sysdiglabs/sysdig/3.1.0/docs/resources/secure_vulnerability_rule_bundle#exploit_no_admin_privileges SecureVulnerabilityRuleBundle#exploit_no_admin_privileges}
  */
  readonly exploitNoAdminPrivileges?: boolean | cdktf.IResolvable;
  /**
  * Exploit does not require user interaction.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/sysdiglabs/sysdig/3.1.0/docs/resources/secure_vulnerability_rule_bundle#exploit_no_user_interaction SecureVulnerabilityRuleBundle#exploit_no_user_interaction}
  */
  readonly exploitNoUserInteraction?: boolean | cdktf.IResolvable;
  /**
  * A fix is available for the vulnerability.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/sysdiglabs/sysdig/3.1.0/docs/resources/secure_vulnerability_rule_bundle#fix_available SecureVulnerabilityRuleBundle#fix_available}
  */
  readonly fixAvailable?: boolean | cdktf.IResolvable;
  /**
  * A fix has been available for at least this number of days.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/sysdiglabs/sysdig/3.1.0/docs/resources/secure_vulnerability_rule_bundle#fix_available_since_days SecureVulnerabilityRuleBundle#fix_available_since_days}
  */
  readonly fixAvailableSinceDays?: number;
  /**
  * Package is currently in use at runtime.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/sysdiglabs/sysdig/3.1.0/docs/resources/secure_vulnerability_rule_bundle#in_use SecureVulnerabilityRuleBundle#in_use}
  */
  readonly inUse?: boolean | cdktf.IResolvable;
  /**
  * Type of the package.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/sysdiglabs/sysdig/3.1.0/docs/resources/secure_vulnerability_rule_bundle#package_type SecureVulnerabilityRuleBundle#package_type}
  */
  readonly packageType?: string;
  /**
  * A public exploit is available for the vulnerability.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/sysdiglabs/sysdig/3.1.0/docs/resources/secure_vulnerability_rule_bundle#public_exploit_available SecureVulnerabilityRuleBundle#public_exploit_available}
  */
  readonly publicExploitAvailable?: boolean | cdktf.IResolvable;
  /**
  * A public exploit has been available for at least this number of days.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/sysdiglabs/sysdig/3.1.0/docs/resources/secure_vulnerability_rule_bundle#public_exploit_available_since_days SecureVulnerabilityRuleBundle#public_exploit_available_since_days}
  */
  readonly publicExploitAvailableSinceDays?: number;
  /**
  * Vulnerability severity must be at least this level (critical, high, medium, low, negligible).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/sysdiglabs/sysdig/3.1.0/docs/resources/secure_vulnerability_rule_bundle#severity_at_least SecureVulnerabilityRuleBundle#severity_at_least}
  */
  readonly severityAtLeast?: string;
  /**
  * Vulnerability severity must be exactly this level.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/sysdiglabs/sysdig/3.1.0/docs/resources/secure_vulnerability_rule_bundle#severity_equals SecureVulnerabilityRuleBundle#severity_equals}
  */
  readonly severityEquals?: string;
  /**
  * disclosure_date block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/sysdiglabs/sysdig/3.1.0/docs/resources/secure_vulnerability_rule_bundle#disclosure_date SecureVulnerabilityRuleBundle#disclosure_date}
  */
  readonly disclosureDate?: SecureVulnerabilityRuleBundleRuleSeveritiesAndThreatsDisclosureDate;
}

export function secureVulnerabilityRuleBundleRuleSeveritiesAndThreatsToTerraform(struct?: SecureVulnerabilityRuleBundleRuleSeveritiesAndThreatsOutputReference | SecureVulnerabilityRuleBundleRuleSeveritiesAndThreats): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cisa_kev_available_since_days: cdktf.numberToTerraform(struct!.cisaKevAvailableSinceDays),
    cisa_kev_due_date_in_days: cdktf.numberToTerraform(struct!.cisaKevDueDateInDays),
    cisa_kev_in_ransomware_campaign: cdktf.booleanToTerraform(struct!.cisaKevInRansomwareCampaign),
    cvss_at_least: cdktf.numberToTerraform(struct!.cvssAtLeast),
    disclosure_older_than_days: cdktf.numberToTerraform(struct!.disclosureOlderThanDays),
    epss_percentile_at_least_percentage: cdktf.numberToTerraform(struct!.epssPercentileAtLeastPercentage),
    epss_score_at_least_percentage: cdktf.numberToTerraform(struct!.epssScoreAtLeastPercentage),
    exploit_network_attack_vector: cdktf.booleanToTerraform(struct!.exploitNetworkAttackVector),
    exploit_no_admin_privileges: cdktf.booleanToTerraform(struct!.exploitNoAdminPrivileges),
    exploit_no_user_interaction: cdktf.booleanToTerraform(struct!.exploitNoUserInteraction),
    fix_available: cdktf.booleanToTerraform(struct!.fixAvailable),
    fix_available_since_days: cdktf.numberToTerraform(struct!.fixAvailableSinceDays),
    in_use: cdktf.booleanToTerraform(struct!.inUse),
    package_type: cdktf.stringToTerraform(struct!.packageType),
    public_exploit_available: cdktf.booleanToTerraform(struct!.publicExploitAvailable),
    public_exploit_available_since_days: cdktf.numberToTerraform(struct!.publicExploitAvailableSinceDays),
    severity_at_least: cdktf.stringToTerraform(struct!.severityAtLeast),
    severity_equals: cdktf.stringToTerraform(struct!.severityEquals),
    disclosure_date: secureVulnerabilityRuleBundleRuleSeveritiesAndThreatsDisclosureDateToTerraform(struct!.disclosureDate),
  }
}


export function secureVulnerabilityRuleBundleRuleSeveritiesAndThreatsToHclTerraform(struct?: SecureVulnerabilityRuleBundleRuleSeveritiesAndThreatsOutputReference | SecureVulnerabilityRuleBundleRuleSeveritiesAndThreats): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cisa_kev_available_since_days: {
      value: cdktf.numberToHclTerraform(struct!.cisaKevAvailableSinceDays),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    cisa_kev_due_date_in_days: {
      value: cdktf.numberToHclTerraform(struct!.cisaKevDueDateInDays),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    cisa_kev_in_ransomware_campaign: {
      value: cdktf.booleanToHclTerraform(struct!.cisaKevInRansomwareCampaign),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    cvss_at_least: {
      value: cdktf.numberToHclTerraform(struct!.cvssAtLeast),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    disclosure_older_than_days: {
      value: cdktf.numberToHclTerraform(struct!.disclosureOlderThanDays),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    epss_percentile_at_least_percentage: {
      value: cdktf.numberToHclTerraform(struct!.epssPercentileAtLeastPercentage),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    epss_score_at_least_percentage: {
      value: cdktf.numberToHclTerraform(struct!.epssScoreAtLeastPercentage),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    exploit_network_attack_vector: {
      value: cdktf.booleanToHclTerraform(struct!.exploitNetworkAttackVector),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    exploit_no_admin_privileges: {
      value: cdktf.booleanToHclTerraform(struct!.exploitNoAdminPrivileges),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    exploit_no_user_interaction: {
      value: cdktf.booleanToHclTerraform(struct!.exploitNoUserInteraction),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    fix_available: {
      value: cdktf.booleanToHclTerraform(struct!.fixAvailable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    fix_available_since_days: {
      value: cdktf.numberToHclTerraform(struct!.fixAvailableSinceDays),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    in_use: {
      value: cdktf.booleanToHclTerraform(struct!.inUse),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    package_type: {
      value: cdktf.stringToHclTerraform(struct!.packageType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    public_exploit_available: {
      value: cdktf.booleanToHclTerraform(struct!.publicExploitAvailable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    public_exploit_available_since_days: {
      value: cdktf.numberToHclTerraform(struct!.publicExploitAvailableSinceDays),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    severity_at_least: {
      value: cdktf.stringToHclTerraform(struct!.severityAtLeast),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    severity_equals: {
      value: cdktf.stringToHclTerraform(struct!.severityEquals),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disclosure_date: {
      value: secureVulnerabilityRuleBundleRuleSeveritiesAndThreatsDisclosureDateToHclTerraform(struct!.disclosureDate),
      isBlock: true,
      type: "list",
      storageClassType: "SecureVulnerabilityRuleBundleRuleSeveritiesAndThreatsDisclosureDateList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SecureVulnerabilityRuleBundleRuleSeveritiesAndThreatsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): SecureVulnerabilityRuleBundleRuleSeveritiesAndThreats | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cisaKevAvailableSinceDays !== undefined) {
      hasAnyValues = true;
      internalValueResult.cisaKevAvailableSinceDays = this._cisaKevAvailableSinceDays;
    }
    if (this._cisaKevDueDateInDays !== undefined) {
      hasAnyValues = true;
      internalValueResult.cisaKevDueDateInDays = this._cisaKevDueDateInDays;
    }
    if (this._cisaKevInRansomwareCampaign !== undefined) {
      hasAnyValues = true;
      internalValueResult.cisaKevInRansomwareCampaign = this._cisaKevInRansomwareCampaign;
    }
    if (this._cvssAtLeast !== undefined) {
      hasAnyValues = true;
      internalValueResult.cvssAtLeast = this._cvssAtLeast;
    }
    if (this._disclosureOlderThanDays !== undefined) {
      hasAnyValues = true;
      internalValueResult.disclosureOlderThanDays = this._disclosureOlderThanDays;
    }
    if (this._epssPercentileAtLeastPercentage !== undefined) {
      hasAnyValues = true;
      internalValueResult.epssPercentileAtLeastPercentage = this._epssPercentileAtLeastPercentage;
    }
    if (this._epssScoreAtLeastPercentage !== undefined) {
      hasAnyValues = true;
      internalValueResult.epssScoreAtLeastPercentage = this._epssScoreAtLeastPercentage;
    }
    if (this._exploitNetworkAttackVector !== undefined) {
      hasAnyValues = true;
      internalValueResult.exploitNetworkAttackVector = this._exploitNetworkAttackVector;
    }
    if (this._exploitNoAdminPrivileges !== undefined) {
      hasAnyValues = true;
      internalValueResult.exploitNoAdminPrivileges = this._exploitNoAdminPrivileges;
    }
    if (this._exploitNoUserInteraction !== undefined) {
      hasAnyValues = true;
      internalValueResult.exploitNoUserInteraction = this._exploitNoUserInteraction;
    }
    if (this._fixAvailable !== undefined) {
      hasAnyValues = true;
      internalValueResult.fixAvailable = this._fixAvailable;
    }
    if (this._fixAvailableSinceDays !== undefined) {
      hasAnyValues = true;
      internalValueResult.fixAvailableSinceDays = this._fixAvailableSinceDays;
    }
    if (this._inUse !== undefined) {
      hasAnyValues = true;
      internalValueResult.inUse = this._inUse;
    }
    if (this._packageType !== undefined) {
      hasAnyValues = true;
      internalValueResult.packageType = this._packageType;
    }
    if (this._publicExploitAvailable !== undefined) {
      hasAnyValues = true;
      internalValueResult.publicExploitAvailable = this._publicExploitAvailable;
    }
    if (this._publicExploitAvailableSinceDays !== undefined) {
      hasAnyValues = true;
      internalValueResult.publicExploitAvailableSinceDays = this._publicExploitAvailableSinceDays;
    }
    if (this._severityAtLeast !== undefined) {
      hasAnyValues = true;
      internalValueResult.severityAtLeast = this._severityAtLeast;
    }
    if (this._severityEquals !== undefined) {
      hasAnyValues = true;
      internalValueResult.severityEquals = this._severityEquals;
    }
    if (this._disclosureDate?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.disclosureDate = this._disclosureDate?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SecureVulnerabilityRuleBundleRuleSeveritiesAndThreats | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._cisaKevAvailableSinceDays = undefined;
      this._cisaKevDueDateInDays = undefined;
      this._cisaKevInRansomwareCampaign = undefined;
      this._cvssAtLeast = undefined;
      this._disclosureOlderThanDays = undefined;
      this._epssPercentileAtLeastPercentage = undefined;
      this._epssScoreAtLeastPercentage = undefined;
      this._exploitNetworkAttackVector = undefined;
      this._exploitNoAdminPrivileges = undefined;
      this._exploitNoUserInteraction = undefined;
      this._fixAvailable = undefined;
      this._fixAvailableSinceDays = undefined;
      this._inUse = undefined;
      this._packageType = undefined;
      this._publicExploitAvailable = undefined;
      this._publicExploitAvailableSinceDays = undefined;
      this._severityAtLeast = undefined;
      this._severityEquals = undefined;
      this._disclosureDate.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._cisaKevAvailableSinceDays = value.cisaKevAvailableSinceDays;
      this._cisaKevDueDateInDays = value.cisaKevDueDateInDays;
      this._cisaKevInRansomwareCampaign = value.cisaKevInRansomwareCampaign;
      this._cvssAtLeast = value.cvssAtLeast;
      this._disclosureOlderThanDays = value.disclosureOlderThanDays;
      this._epssPercentileAtLeastPercentage = value.epssPercentileAtLeastPercentage;
      this._epssScoreAtLeastPercentage = value.epssScoreAtLeastPercentage;
      this._exploitNetworkAttackVector = value.exploitNetworkAttackVector;
      this._exploitNoAdminPrivileges = value.exploitNoAdminPrivileges;
      this._exploitNoUserInteraction = value.exploitNoUserInteraction;
      this._fixAvailable = value.fixAvailable;
      this._fixAvailableSinceDays = value.fixAvailableSinceDays;
      this._inUse = value.inUse;
      this._packageType = value.packageType;
      this._publicExploitAvailable = value.publicExploitAvailable;
      this._publicExploitAvailableSinceDays = value.publicExploitAvailableSinceDays;
      this._severityAtLeast = value.severityAtLeast;
      this._severityEquals = value.severityEquals;
      this._disclosureDate.internalValue = value.disclosureDate;
    }
  }

  // cisa_kev_available_since_days - computed: false, optional: true, required: false
  private _cisaKevAvailableSinceDays?: number; 
  public get cisaKevAvailableSinceDays() {
    return this.getNumberAttribute('cisa_kev_available_since_days');
  }
  public set cisaKevAvailableSinceDays(value: number) {
    this._cisaKevAvailableSinceDays = value;
  }
  public resetCisaKevAvailableSinceDays() {
    this._cisaKevAvailableSinceDays = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cisaKevAvailableSinceDaysInput() {
    return this._cisaKevAvailableSinceDays;
  }

  // cisa_kev_due_date_in_days - computed: false, optional: true, required: false
  private _cisaKevDueDateInDays?: number; 
  public get cisaKevDueDateInDays() {
    return this.getNumberAttribute('cisa_kev_due_date_in_days');
  }
  public set cisaKevDueDateInDays(value: number) {
    this._cisaKevDueDateInDays = value;
  }
  public resetCisaKevDueDateInDays() {
    this._cisaKevDueDateInDays = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cisaKevDueDateInDaysInput() {
    return this._cisaKevDueDateInDays;
  }

  // cisa_kev_in_ransomware_campaign - computed: false, optional: true, required: false
  private _cisaKevInRansomwareCampaign?: boolean | cdktf.IResolvable; 
  public get cisaKevInRansomwareCampaign() {
    return this.getBooleanAttribute('cisa_kev_in_ransomware_campaign');
  }
  public set cisaKevInRansomwareCampaign(value: boolean | cdktf.IResolvable) {
    this._cisaKevInRansomwareCampaign = value;
  }
  public resetCisaKevInRansomwareCampaign() {
    this._cisaKevInRansomwareCampaign = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cisaKevInRansomwareCampaignInput() {
    return this._cisaKevInRansomwareCampaign;
  }

  // cvss_at_least - computed: false, optional: true, required: false
  private _cvssAtLeast?: number; 
  public get cvssAtLeast() {
    return this.getNumberAttribute('cvss_at_least');
  }
  public set cvssAtLeast(value: number) {
    this._cvssAtLeast = value;
  }
  public resetCvssAtLeast() {
    this._cvssAtLeast = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cvssAtLeastInput() {
    return this._cvssAtLeast;
  }

  // disclosure_older_than_days - computed: false, optional: true, required: false
  private _disclosureOlderThanDays?: number; 
  public get disclosureOlderThanDays() {
    return this.getNumberAttribute('disclosure_older_than_days');
  }
  public set disclosureOlderThanDays(value: number) {
    this._disclosureOlderThanDays = value;
  }
  public resetDisclosureOlderThanDays() {
    this._disclosureOlderThanDays = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disclosureOlderThanDaysInput() {
    return this._disclosureOlderThanDays;
  }

  // epss_percentile_at_least_percentage - computed: false, optional: true, required: false
  private _epssPercentileAtLeastPercentage?: number; 
  public get epssPercentileAtLeastPercentage() {
    return this.getNumberAttribute('epss_percentile_at_least_percentage');
  }
  public set epssPercentileAtLeastPercentage(value: number) {
    this._epssPercentileAtLeastPercentage = value;
  }
  public resetEpssPercentileAtLeastPercentage() {
    this._epssPercentileAtLeastPercentage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get epssPercentileAtLeastPercentageInput() {
    return this._epssPercentileAtLeastPercentage;
  }

  // epss_score_at_least_percentage - computed: false, optional: true, required: false
  private _epssScoreAtLeastPercentage?: number; 
  public get epssScoreAtLeastPercentage() {
    return this.getNumberAttribute('epss_score_at_least_percentage');
  }
  public set epssScoreAtLeastPercentage(value: number) {
    this._epssScoreAtLeastPercentage = value;
  }
  public resetEpssScoreAtLeastPercentage() {
    this._epssScoreAtLeastPercentage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get epssScoreAtLeastPercentageInput() {
    return this._epssScoreAtLeastPercentage;
  }

  // exploit_network_attack_vector - computed: false, optional: true, required: false
  private _exploitNetworkAttackVector?: boolean | cdktf.IResolvable; 
  public get exploitNetworkAttackVector() {
    return this.getBooleanAttribute('exploit_network_attack_vector');
  }
  public set exploitNetworkAttackVector(value: boolean | cdktf.IResolvable) {
    this._exploitNetworkAttackVector = value;
  }
  public resetExploitNetworkAttackVector() {
    this._exploitNetworkAttackVector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exploitNetworkAttackVectorInput() {
    return this._exploitNetworkAttackVector;
  }

  // exploit_no_admin_privileges - computed: false, optional: true, required: false
  private _exploitNoAdminPrivileges?: boolean | cdktf.IResolvable; 
  public get exploitNoAdminPrivileges() {
    return this.getBooleanAttribute('exploit_no_admin_privileges');
  }
  public set exploitNoAdminPrivileges(value: boolean | cdktf.IResolvable) {
    this._exploitNoAdminPrivileges = value;
  }
  public resetExploitNoAdminPrivileges() {
    this._exploitNoAdminPrivileges = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exploitNoAdminPrivilegesInput() {
    return this._exploitNoAdminPrivileges;
  }

  // exploit_no_user_interaction - computed: false, optional: true, required: false
  private _exploitNoUserInteraction?: boolean | cdktf.IResolvable; 
  public get exploitNoUserInteraction() {
    return this.getBooleanAttribute('exploit_no_user_interaction');
  }
  public set exploitNoUserInteraction(value: boolean | cdktf.IResolvable) {
    this._exploitNoUserInteraction = value;
  }
  public resetExploitNoUserInteraction() {
    this._exploitNoUserInteraction = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exploitNoUserInteractionInput() {
    return this._exploitNoUserInteraction;
  }

  // fix_available - computed: false, optional: true, required: false
  private _fixAvailable?: boolean | cdktf.IResolvable; 
  public get fixAvailable() {
    return this.getBooleanAttribute('fix_available');
  }
  public set fixAvailable(value: boolean | cdktf.IResolvable) {
    this._fixAvailable = value;
  }
  public resetFixAvailable() {
    this._fixAvailable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fixAvailableInput() {
    return this._fixAvailable;
  }

  // fix_available_since_days - computed: false, optional: true, required: false
  private _fixAvailableSinceDays?: number; 
  public get fixAvailableSinceDays() {
    return this.getNumberAttribute('fix_available_since_days');
  }
  public set fixAvailableSinceDays(value: number) {
    this._fixAvailableSinceDays = value;
  }
  public resetFixAvailableSinceDays() {
    this._fixAvailableSinceDays = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fixAvailableSinceDaysInput() {
    return this._fixAvailableSinceDays;
  }

  // id - computed: true, optional: false, required: false
  public get id() {
    return this.getStringAttribute('id');
  }

  // in_use - computed: false, optional: true, required: false
  private _inUse?: boolean | cdktf.IResolvable; 
  public get inUse() {
    return this.getBooleanAttribute('in_use');
  }
  public set inUse(value: boolean | cdktf.IResolvable) {
    this._inUse = value;
  }
  public resetInUse() {
    this._inUse = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inUseInput() {
    return this._inUse;
  }

  // package_type - computed: false, optional: true, required: false
  private _packageType?: string; 
  public get packageType() {
    return this.getStringAttribute('package_type');
  }
  public set packageType(value: string) {
    this._packageType = value;
  }
  public resetPackageType() {
    this._packageType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get packageTypeInput() {
    return this._packageType;
  }

  // public_exploit_available - computed: false, optional: true, required: false
  private _publicExploitAvailable?: boolean | cdktf.IResolvable; 
  public get publicExploitAvailable() {
    return this.getBooleanAttribute('public_exploit_available');
  }
  public set publicExploitAvailable(value: boolean | cdktf.IResolvable) {
    this._publicExploitAvailable = value;
  }
  public resetPublicExploitAvailable() {
    this._publicExploitAvailable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get publicExploitAvailableInput() {
    return this._publicExploitAvailable;
  }

  // public_exploit_available_since_days - computed: false, optional: true, required: false
  private _publicExploitAvailableSinceDays?: number; 
  public get publicExploitAvailableSinceDays() {
    return this.getNumberAttribute('public_exploit_available_since_days');
  }
  public set publicExploitAvailableSinceDays(value: number) {
    this._publicExploitAvailableSinceDays = value;
  }
  public resetPublicExploitAvailableSinceDays() {
    this._publicExploitAvailableSinceDays = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get publicExploitAvailableSinceDaysInput() {
    return this._publicExploitAvailableSinceDays;
  }

  // severity_at_least - computed: false, optional: true, required: false
  private _severityAtLeast?: string; 
  public get severityAtLeast() {
    return this.getStringAttribute('severity_at_least');
  }
  public set severityAtLeast(value: string) {
    this._severityAtLeast = value;
  }
  public resetSeverityAtLeast() {
    this._severityAtLeast = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get severityAtLeastInput() {
    return this._severityAtLeast;
  }

  // severity_equals - computed: false, optional: true, required: false
  private _severityEquals?: string; 
  public get severityEquals() {
    return this.getStringAttribute('severity_equals');
  }
  public set severityEquals(value: string) {
    this._severityEquals = value;
  }
  public resetSeverityEquals() {
    this._severityEquals = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get severityEqualsInput() {
    return this._severityEquals;
  }

  // disclosure_date - computed: false, optional: true, required: false
  private _disclosureDate = new SecureVulnerabilityRuleBundleRuleSeveritiesAndThreatsDisclosureDateOutputReference(this, "disclosure_date");
  public get disclosureDate() {
    return this._disclosureDate;
  }
  public putDisclosureDate(value: SecureVulnerabilityRuleBundleRuleSeveritiesAndThreatsDisclosureDate) {
    this._disclosureDate.internalValue = value;
  }
  public resetDisclosureDate() {
    this._disclosureDate.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disclosureDateInput() {
    return this._disclosureDate.internalValue;
  }
}
export interface SecureVulnerabilityRuleBundleRule {
  /**
  * image_label block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/sysdiglabs/sysdig/3.1.0/docs/resources/secure_vulnerability_rule_bundle#image_label SecureVulnerabilityRuleBundle#image_label}
  */
  readonly imageLabel?: SecureVulnerabilityRuleBundleRuleImageLabel;
  /**
  * severities_and_threats block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/sysdiglabs/sysdig/3.1.0/docs/resources/secure_vulnerability_rule_bundle#severities_and_threats SecureVulnerabilityRuleBundle#severities_and_threats}
  */
  readonly severitiesAndThreats?: SecureVulnerabilityRuleBundleRuleSeveritiesAndThreats;
}

export function secureVulnerabilityRuleBundleRuleToTerraform(struct?: SecureVulnerabilityRuleBundleRule | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    image_label: secureVulnerabilityRuleBundleRuleImageLabelToTerraform(struct!.imageLabel),
    severities_and_threats: secureVulnerabilityRuleBundleRuleSeveritiesAndThreatsToTerraform(struct!.severitiesAndThreats),
  }
}


export function secureVulnerabilityRuleBundleRuleToHclTerraform(struct?: SecureVulnerabilityRuleBundleRule | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    image_label: {
      value: secureVulnerabilityRuleBundleRuleImageLabelToHclTerraform(struct!.imageLabel),
      isBlock: true,
      type: "set",
      storageClassType: "SecureVulnerabilityRuleBundleRuleImageLabelList",
    },
    severities_and_threats: {
      value: secureVulnerabilityRuleBundleRuleSeveritiesAndThreatsToHclTerraform(struct!.severitiesAndThreats),
      isBlock: true,
      type: "set",
      storageClassType: "SecureVulnerabilityRuleBundleRuleSeveritiesAndThreatsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SecureVulnerabilityRuleBundleRuleOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SecureVulnerabilityRuleBundleRule | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._imageLabel?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.imageLabel = this._imageLabel?.internalValue;
    }
    if (this._severitiesAndThreats?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.severitiesAndThreats = this._severitiesAndThreats?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SecureVulnerabilityRuleBundleRule | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._imageLabel.internalValue = undefined;
      this._severitiesAndThreats.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._imageLabel.internalValue = value.imageLabel;
      this._severitiesAndThreats.internalValue = value.severitiesAndThreats;
    }
  }

  // image_label - computed: false, optional: true, required: false
  private _imageLabel = new SecureVulnerabilityRuleBundleRuleImageLabelOutputReference(this, "image_label");
  public get imageLabel() {
    return this._imageLabel;
  }
  public putImageLabel(value: SecureVulnerabilityRuleBundleRuleImageLabel) {
    this._imageLabel.internalValue = value;
  }
  public resetImageLabel() {
    this._imageLabel.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageLabelInput() {
    return this._imageLabel.internalValue;
  }

  // severities_and_threats - computed: false, optional: true, required: false
  private _severitiesAndThreats = new SecureVulnerabilityRuleBundleRuleSeveritiesAndThreatsOutputReference(this, "severities_and_threats");
  public get severitiesAndThreats() {
    return this._severitiesAndThreats;
  }
  public putSeveritiesAndThreats(value: SecureVulnerabilityRuleBundleRuleSeveritiesAndThreats) {
    this._severitiesAndThreats.internalValue = value;
  }
  public resetSeveritiesAndThreats() {
    this._severitiesAndThreats.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get severitiesAndThreatsInput() {
    return this._severitiesAndThreats.internalValue;
  }
}

export class SecureVulnerabilityRuleBundleRuleList extends cdktf.ComplexList {
  public internalValue? : SecureVulnerabilityRuleBundleRule[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SecureVulnerabilityRuleBundleRuleOutputReference {
    return new SecureVulnerabilityRuleBundleRuleOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SecureVulnerabilityRuleBundleTimeouts {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/sysdiglabs/sysdig/3.1.0/docs/resources/secure_vulnerability_rule_bundle#create SecureVulnerabilityRuleBundle#create}
  */
  readonly create?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/sysdiglabs/sysdig/3.1.0/docs/resources/secure_vulnerability_rule_bundle#delete SecureVulnerabilityRuleBundle#delete}
  */
  readonly delete?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/sysdiglabs/sysdig/3.1.0/docs/resources/secure_vulnerability_rule_bundle#read SecureVulnerabilityRuleBundle#read}
  */
  readonly read?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/sysdiglabs/sysdig/3.1.0/docs/resources/secure_vulnerability_rule_bundle#update SecureVulnerabilityRuleBundle#update}
  */
  readonly update?: string;
}

export function secureVulnerabilityRuleBundleTimeoutsToTerraform(struct?: SecureVulnerabilityRuleBundleTimeouts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    create: cdktf.stringToTerraform(struct!.create),
    delete: cdktf.stringToTerraform(struct!.delete),
    read: cdktf.stringToTerraform(struct!.read),
    update: cdktf.stringToTerraform(struct!.update),
  }
}


export function secureVulnerabilityRuleBundleTimeoutsToHclTerraform(struct?: SecureVulnerabilityRuleBundleTimeouts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    create: {
      value: cdktf.stringToHclTerraform(struct!.create),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    delete: {
      value: cdktf.stringToHclTerraform(struct!.delete),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    read: {
      value: cdktf.stringToHclTerraform(struct!.read),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    update: {
      value: cdktf.stringToHclTerraform(struct!.update),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SecureVulnerabilityRuleBundleTimeoutsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SecureVulnerabilityRuleBundleTimeouts | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._create !== undefined) {
      hasAnyValues = true;
      internalValueResult.create = this._create;
    }
    if (this._delete !== undefined) {
      hasAnyValues = true;
      internalValueResult.delete = this._delete;
    }
    if (this._read !== undefined) {
      hasAnyValues = true;
      internalValueResult.read = this._read;
    }
    if (this._update !== undefined) {
      hasAnyValues = true;
      internalValueResult.update = this._update;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SecureVulnerabilityRuleBundleTimeouts | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._create = undefined;
      this._delete = undefined;
      this._read = undefined;
      this._update = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._create = value.create;
      this._delete = value.delete;
      this._read = value.read;
      this._update = value.update;
    }
  }

  // create - computed: false, optional: true, required: false
  private _create?: string; 
  public get create() {
    return this.getStringAttribute('create');
  }
  public set create(value: string) {
    this._create = value;
  }
  public resetCreate() {
    this._create = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get createInput() {
    return this._create;
  }

  // delete - computed: false, optional: true, required: false
  private _delete?: string; 
  public get delete() {
    return this.getStringAttribute('delete');
  }
  public set delete(value: string) {
    this._delete = value;
  }
  public resetDelete() {
    this._delete = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deleteInput() {
    return this._delete;
  }

  // read - computed: false, optional: true, required: false
  private _read?: string; 
  public get read() {
    return this.getStringAttribute('read');
  }
  public set read(value: string) {
    this._read = value;
  }
  public resetRead() {
    this._read = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get readInput() {
    return this._read;
  }

  // update - computed: false, optional: true, required: false
  private _update?: string; 
  public get update() {
    return this.getStringAttribute('update');
  }
  public set update(value: string) {
    this._update = value;
  }
  public resetUpdate() {
    this._update = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get updateInput() {
    return this._update;
  }
}

/**
* Represents a {@link https://registry.terraform.io/providers/sysdiglabs/sysdig/3.1.0/docs/resources/secure_vulnerability_rule_bundle sysdig_secure_vulnerability_rule_bundle}
*/
export class SecureVulnerabilityRuleBundle extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType = "sysdig_secure_vulnerability_rule_bundle";

  // ==============
  // STATIC Methods
  // ==============
  /**
  * Generates CDKTF code for importing a SecureVulnerabilityRuleBundle resource upon running "cdktf plan <stack-name>"
  * @param scope The scope in which to define this construct
  * @param importToId The construct id used in the generated config for the SecureVulnerabilityRuleBundle to import
  * @param importFromId The id of the existing SecureVulnerabilityRuleBundle that should be imported. Refer to the {@link https://registry.terraform.io/providers/sysdiglabs/sysdig/3.1.0/docs/resources/secure_vulnerability_rule_bundle#import import section} in the documentation of this resource for the id to use
  * @param provider? Optional instance of the provider where the SecureVulnerabilityRuleBundle to import is found
  */
  public static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider) {
        return new cdktf.ImportableResource(scope, importToId, { terraformResourceType: "sysdig_secure_vulnerability_rule_bundle", importId: importFromId, provider });
      }

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://registry.terraform.io/providers/sysdiglabs/sysdig/3.1.0/docs/resources/secure_vulnerability_rule_bundle sysdig_secure_vulnerability_rule_bundle} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options SecureVulnerabilityRuleBundleConfig
  */
  public constructor(scope: Construct, id: string, config: SecureVulnerabilityRuleBundleConfig) {
    super(scope, id, {
      terraformResourceType: 'sysdig_secure_vulnerability_rule_bundle',
      terraformGeneratorMetadata: {
        providerName: 'sysdig',
        providerVersion: '3.1.0'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle,
      provisioners: config.provisioners,
      connection: config.connection,
      forEach: config.forEach
    });
    this._description = config.description;
    this._id = config.id;
    this._name = config.name;
    this._rule.internalValue = config.rule;
    this._timeouts.internalValue = config.timeouts;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // id - computed: true, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // identifier - computed: true, optional: false, required: false
  public get identifier() {
    return this.getStringAttribute('identifier');
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // rule - computed: false, optional: false, required: true
  private _rule = new SecureVulnerabilityRuleBundleRuleList(this, "rule", true);
  public get rule() {
    return this._rule;
  }
  public putRule(value: SecureVulnerabilityRuleBundleRule[] | cdktf.IResolvable) {
    this._rule.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get ruleInput() {
    return this._rule.internalValue;
  }

  // timeouts - computed: false, optional: true, required: false
  private _timeouts = new SecureVulnerabilityRuleBundleTimeoutsOutputReference(this, "timeouts");
  public get timeouts() {
    return this._timeouts;
  }
  public putTimeouts(value: SecureVulnerabilityRuleBundleTimeouts) {
    this._timeouts.internalValue = value;
  }
  public resetTimeouts() {
    this._timeouts.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutsInput() {
    return this._timeouts.internalValue;
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      description: cdktf.stringToTerraform(this._description),
      id: cdktf.stringToTerraform(this._id),
      name: cdktf.stringToTerraform(this._name),
      rule: cdktf.listMapper(secureVulnerabilityRuleBundleRuleToTerraform, true)(this._rule.internalValue),
      timeouts: secureVulnerabilityRuleBundleTimeoutsToTerraform(this._timeouts.internalValue),
    };
  }

  protected synthesizeHclAttributes(): { [name: string]: any } {
    const attrs = {
      description: {
        value: cdktf.stringToHclTerraform(this._description),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      id: {
        value: cdktf.stringToHclTerraform(this._id),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      name: {
        value: cdktf.stringToHclTerraform(this._name),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      rule: {
        value: cdktf.listMapperHcl(secureVulnerabilityRuleBundleRuleToHclTerraform, true)(this._rule.internalValue),
        isBlock: true,
        type: "set",
        storageClassType: "SecureVulnerabilityRuleBundleRuleList",
      },
      timeouts: {
        value: secureVulnerabilityRuleBundleTimeoutsToHclTerraform(this._timeouts.internalValue),
        isBlock: true,
        type: "struct",
        storageClassType: "SecureVulnerabilityRuleBundleTimeouts",
      },
    };

    // remove undefined attributes
    return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined ))
  }
}
