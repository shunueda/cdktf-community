import * as cdktf from 'cdktf';
export interface ClusterAddons {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#manifest Cluster#manifest}
  */
  readonly manifest: string;
}

export function clusterAddonsToTerraform(struct?: ClusterAddons | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    manifest: cdktf.stringToTerraform(struct!.manifest),
  }
}


export function clusterAddonsToHclTerraform(struct?: ClusterAddons | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    manifest: {
      value: cdktf.stringToHclTerraform(struct!.manifest),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterAddonsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterAddons | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._manifest !== undefined) {
      hasAnyValues = true;
      internalValueResult.manifest = this._manifest;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterAddons | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._manifest = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._manifest = value.manifest;
    }
  }

  // manifest - computed: false, optional: false, required: true
  private _manifest?: string; 
  public get manifest() {
    return this.getStringAttribute('manifest');
  }
  public set manifest(value: string) {
    this._manifest = value;
  }
  // Temporarily expose input value. Use with caution.
  public get manifestInput() {
    return this._manifest;
  }
}

export class ClusterAddonsList extends cdktf.ComplexList {
  public internalValue? : ClusterAddons[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterAddonsOutputReference {
    return new ClusterAddonsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterApiDns {
}

export function clusterApiDnsToTerraform(struct?: ClusterApiDnsOutputReference | ClusterApiDns): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function clusterApiDnsToHclTerraform(struct?: ClusterApiDnsOutputReference | ClusterApiDns): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class ClusterApiDnsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterApiDns | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterApiDns | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }
}
export interface ClusterApiLoadBalancerAccessLog {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#bucket Cluster#bucket}
  */
  readonly bucket?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#bucket_prefix Cluster#bucket_prefix}
  */
  readonly bucketPrefix?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#interval Cluster#interval}
  */
  readonly interval?: number;
}

export function clusterApiLoadBalancerAccessLogToTerraform(struct?: ClusterApiLoadBalancerAccessLogOutputReference | ClusterApiLoadBalancerAccessLog): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bucket: cdktf.stringToTerraform(struct!.bucket),
    bucket_prefix: cdktf.stringToTerraform(struct!.bucketPrefix),
    interval: cdktf.numberToTerraform(struct!.interval),
  }
}


export function clusterApiLoadBalancerAccessLogToHclTerraform(struct?: ClusterApiLoadBalancerAccessLogOutputReference | ClusterApiLoadBalancerAccessLog): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bucket: {
      value: cdktf.stringToHclTerraform(struct!.bucket),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bucket_prefix: {
      value: cdktf.stringToHclTerraform(struct!.bucketPrefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    interval: {
      value: cdktf.numberToHclTerraform(struct!.interval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterApiLoadBalancerAccessLogOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterApiLoadBalancerAccessLog | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bucket !== undefined) {
      hasAnyValues = true;
      internalValueResult.bucket = this._bucket;
    }
    if (this._bucketPrefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.bucketPrefix = this._bucketPrefix;
    }
    if (this._interval !== undefined) {
      hasAnyValues = true;
      internalValueResult.interval = this._interval;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterApiLoadBalancerAccessLog | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bucket = undefined;
      this._bucketPrefix = undefined;
      this._interval = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bucket = value.bucket;
      this._bucketPrefix = value.bucketPrefix;
      this._interval = value.interval;
    }
  }

  // bucket - computed: false, optional: true, required: false
  private _bucket?: string; 
  public get bucket() {
    return this.getStringAttribute('bucket');
  }
  public set bucket(value: string) {
    this._bucket = value;
  }
  public resetBucket() {
    this._bucket = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bucketInput() {
    return this._bucket;
  }

  // bucket_prefix - computed: false, optional: true, required: false
  private _bucketPrefix?: string; 
  public get bucketPrefix() {
    return this.getStringAttribute('bucket_prefix');
  }
  public set bucketPrefix(value: string) {
    this._bucketPrefix = value;
  }
  public resetBucketPrefix() {
    this._bucketPrefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bucketPrefixInput() {
    return this._bucketPrefix;
  }

  // interval - computed: false, optional: true, required: false
  private _interval?: number; 
  public get interval() {
    return this.getNumberAttribute('interval');
  }
  public set interval(value: number) {
    this._interval = value;
  }
  public resetInterval() {
    this._interval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get intervalInput() {
    return this._interval;
  }
}
export interface ClusterApiLoadBalancerSubnets {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#allocation_id Cluster#allocation_id}
  */
  readonly allocationId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#name Cluster#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#private_ipv4_address Cluster#private_ipv4_address}
  */
  readonly privateIpv4Address?: string;
}

export function clusterApiLoadBalancerSubnetsToTerraform(struct?: ClusterApiLoadBalancerSubnets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allocation_id: cdktf.stringToTerraform(struct!.allocationId),
    name: cdktf.stringToTerraform(struct!.name),
    private_ipv4_address: cdktf.stringToTerraform(struct!.privateIpv4Address),
  }
}


export function clusterApiLoadBalancerSubnetsToHclTerraform(struct?: ClusterApiLoadBalancerSubnets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allocation_id: {
      value: cdktf.stringToHclTerraform(struct!.allocationId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    private_ipv4_address: {
      value: cdktf.stringToHclTerraform(struct!.privateIpv4Address),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterApiLoadBalancerSubnetsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterApiLoadBalancerSubnets | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allocationId !== undefined) {
      hasAnyValues = true;
      internalValueResult.allocationId = this._allocationId;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._privateIpv4Address !== undefined) {
      hasAnyValues = true;
      internalValueResult.privateIpv4Address = this._privateIpv4Address;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterApiLoadBalancerSubnets | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allocationId = undefined;
      this._name = undefined;
      this._privateIpv4Address = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allocationId = value.allocationId;
      this._name = value.name;
      this._privateIpv4Address = value.privateIpv4Address;
    }
  }

  // allocation_id - computed: false, optional: true, required: false
  private _allocationId?: string; 
  public get allocationId() {
    return this.getStringAttribute('allocation_id');
  }
  public set allocationId(value: string) {
    this._allocationId = value;
  }
  public resetAllocationId() {
    this._allocationId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allocationIdInput() {
    return this._allocationId;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // private_ipv4_address - computed: false, optional: true, required: false
  private _privateIpv4Address?: string; 
  public get privateIpv4Address() {
    return this.getStringAttribute('private_ipv4_address');
  }
  public set privateIpv4Address(value: string) {
    this._privateIpv4Address = value;
  }
  public resetPrivateIpv4Address() {
    this._privateIpv4Address = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privateIpv4AddressInput() {
    return this._privateIpv4Address;
  }
}

export class ClusterApiLoadBalancerSubnetsList extends cdktf.ComplexList {
  public internalValue? : ClusterApiLoadBalancerSubnets[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterApiLoadBalancerSubnetsOutputReference {
    return new ClusterApiLoadBalancerSubnetsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterApiLoadBalancer {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#additional_security_groups Cluster#additional_security_groups}
  */
  readonly additionalSecurityGroups?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#class Cluster#class}
  */
  readonly class?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#cross_zone_load_balancing Cluster#cross_zone_load_balancing}
  */
  readonly crossZoneLoadBalancing?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#idle_timeout_seconds Cluster#idle_timeout_seconds}
  */
  readonly idleTimeoutSeconds?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#security_group_override Cluster#security_group_override}
  */
  readonly securityGroupOverride?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#ssl_certificate Cluster#ssl_certificate}
  */
  readonly sslCertificate?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#ssl_policy Cluster#ssl_policy}
  */
  readonly sslPolicy?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#type Cluster#type}
  */
  readonly type: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#use_for_internal_api Cluster#use_for_internal_api}
  */
  readonly useForInternalApi?: boolean | cdktf.IResolvable;
  /**
  * access_log block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#access_log Cluster#access_log}
  */
  readonly accessLog?: ClusterApiLoadBalancerAccessLog;
  /**
  * subnets block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#subnets Cluster#subnets}
  */
  readonly subnets?: ClusterApiLoadBalancerSubnets[] | cdktf.IResolvable;
}

export function clusterApiLoadBalancerToTerraform(struct?: ClusterApiLoadBalancerOutputReference | ClusterApiLoadBalancer): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    additional_security_groups: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.additionalSecurityGroups),
    class: cdktf.stringToTerraform(struct!.class),
    cross_zone_load_balancing: cdktf.booleanToTerraform(struct!.crossZoneLoadBalancing),
    idle_timeout_seconds: cdktf.numberToTerraform(struct!.idleTimeoutSeconds),
    security_group_override: cdktf.stringToTerraform(struct!.securityGroupOverride),
    ssl_certificate: cdktf.stringToTerraform(struct!.sslCertificate),
    ssl_policy: cdktf.stringToTerraform(struct!.sslPolicy),
    type: cdktf.stringToTerraform(struct!.type),
    use_for_internal_api: cdktf.booleanToTerraform(struct!.useForInternalApi),
    access_log: clusterApiLoadBalancerAccessLogToTerraform(struct!.accessLog),
    subnets: cdktf.listMapper(clusterApiLoadBalancerSubnetsToTerraform, true)(struct!.subnets),
  }
}


export function clusterApiLoadBalancerToHclTerraform(struct?: ClusterApiLoadBalancerOutputReference | ClusterApiLoadBalancer): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    additional_security_groups: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.additionalSecurityGroups),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    class: {
      value: cdktf.stringToHclTerraform(struct!.class),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cross_zone_load_balancing: {
      value: cdktf.booleanToHclTerraform(struct!.crossZoneLoadBalancing),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    idle_timeout_seconds: {
      value: cdktf.numberToHclTerraform(struct!.idleTimeoutSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    security_group_override: {
      value: cdktf.stringToHclTerraform(struct!.securityGroupOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ssl_certificate: {
      value: cdktf.stringToHclTerraform(struct!.sslCertificate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ssl_policy: {
      value: cdktf.stringToHclTerraform(struct!.sslPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_for_internal_api: {
      value: cdktf.booleanToHclTerraform(struct!.useForInternalApi),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    access_log: {
      value: clusterApiLoadBalancerAccessLogToHclTerraform(struct!.accessLog),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterApiLoadBalancerAccessLogList",
    },
    subnets: {
      value: cdktf.listMapperHcl(clusterApiLoadBalancerSubnetsToHclTerraform, true)(struct!.subnets),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterApiLoadBalancerSubnetsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterApiLoadBalancerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterApiLoadBalancer | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._additionalSecurityGroups !== undefined) {
      hasAnyValues = true;
      internalValueResult.additionalSecurityGroups = this._additionalSecurityGroups;
    }
    if (this._class !== undefined) {
      hasAnyValues = true;
      internalValueResult.class = this._class;
    }
    if (this._crossZoneLoadBalancing !== undefined) {
      hasAnyValues = true;
      internalValueResult.crossZoneLoadBalancing = this._crossZoneLoadBalancing;
    }
    if (this._idleTimeoutSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.idleTimeoutSeconds = this._idleTimeoutSeconds;
    }
    if (this._securityGroupOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.securityGroupOverride = this._securityGroupOverride;
    }
    if (this._sslCertificate !== undefined) {
      hasAnyValues = true;
      internalValueResult.sslCertificate = this._sslCertificate;
    }
    if (this._sslPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.sslPolicy = this._sslPolicy;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._useForInternalApi !== undefined) {
      hasAnyValues = true;
      internalValueResult.useForInternalApi = this._useForInternalApi;
    }
    if (this._accessLog?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessLog = this._accessLog?.internalValue;
    }
    if (this._subnets?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.subnets = this._subnets?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterApiLoadBalancer | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._additionalSecurityGroups = undefined;
      this._class = undefined;
      this._crossZoneLoadBalancing = undefined;
      this._idleTimeoutSeconds = undefined;
      this._securityGroupOverride = undefined;
      this._sslCertificate = undefined;
      this._sslPolicy = undefined;
      this._type = undefined;
      this._useForInternalApi = undefined;
      this._accessLog.internalValue = undefined;
      this._subnets.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._additionalSecurityGroups = value.additionalSecurityGroups;
      this._class = value.class;
      this._crossZoneLoadBalancing = value.crossZoneLoadBalancing;
      this._idleTimeoutSeconds = value.idleTimeoutSeconds;
      this._securityGroupOverride = value.securityGroupOverride;
      this._sslCertificate = value.sslCertificate;
      this._sslPolicy = value.sslPolicy;
      this._type = value.type;
      this._useForInternalApi = value.useForInternalApi;
      this._accessLog.internalValue = value.accessLog;
      this._subnets.internalValue = value.subnets;
    }
  }

  // additional_security_groups - computed: false, optional: true, required: false
  private _additionalSecurityGroups?: string[]; 
  public get additionalSecurityGroups() {
    return this.getListAttribute('additional_security_groups');
  }
  public set additionalSecurityGroups(value: string[]) {
    this._additionalSecurityGroups = value;
  }
  public resetAdditionalSecurityGroups() {
    this._additionalSecurityGroups = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get additionalSecurityGroupsInput() {
    return this._additionalSecurityGroups;
  }

  // class - computed: false, optional: true, required: false
  private _class?: string; 
  public get class() {
    return this.getStringAttribute('class');
  }
  public set class(value: string) {
    this._class = value;
  }
  public resetClass() {
    this._class = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get classInput() {
    return this._class;
  }

  // cross_zone_load_balancing - computed: false, optional: true, required: false
  private _crossZoneLoadBalancing?: boolean | cdktf.IResolvable; 
  public get crossZoneLoadBalancing() {
    return this.getBooleanAttribute('cross_zone_load_balancing');
  }
  public set crossZoneLoadBalancing(value: boolean | cdktf.IResolvable) {
    this._crossZoneLoadBalancing = value;
  }
  public resetCrossZoneLoadBalancing() {
    this._crossZoneLoadBalancing = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get crossZoneLoadBalancingInput() {
    return this._crossZoneLoadBalancing;
  }

  // idle_timeout_seconds - computed: false, optional: true, required: false
  private _idleTimeoutSeconds?: number; 
  public get idleTimeoutSeconds() {
    return this.getNumberAttribute('idle_timeout_seconds');
  }
  public set idleTimeoutSeconds(value: number) {
    this._idleTimeoutSeconds = value;
  }
  public resetIdleTimeoutSeconds() {
    this._idleTimeoutSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idleTimeoutSecondsInput() {
    return this._idleTimeoutSeconds;
  }

  // security_group_override - computed: false, optional: true, required: false
  private _securityGroupOverride?: string; 
  public get securityGroupOverride() {
    return this.getStringAttribute('security_group_override');
  }
  public set securityGroupOverride(value: string) {
    this._securityGroupOverride = value;
  }
  public resetSecurityGroupOverride() {
    this._securityGroupOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get securityGroupOverrideInput() {
    return this._securityGroupOverride;
  }

  // ssl_certificate - computed: false, optional: true, required: false
  private _sslCertificate?: string; 
  public get sslCertificate() {
    return this.getStringAttribute('ssl_certificate');
  }
  public set sslCertificate(value: string) {
    this._sslCertificate = value;
  }
  public resetSslCertificate() {
    this._sslCertificate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sslCertificateInput() {
    return this._sslCertificate;
  }

  // ssl_policy - computed: false, optional: true, required: false
  private _sslPolicy?: string; 
  public get sslPolicy() {
    return this.getStringAttribute('ssl_policy');
  }
  public set sslPolicy(value: string) {
    this._sslPolicy = value;
  }
  public resetSslPolicy() {
    this._sslPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sslPolicyInput() {
    return this._sslPolicy;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // use_for_internal_api - computed: false, optional: true, required: false
  private _useForInternalApi?: boolean | cdktf.IResolvable; 
  public get useForInternalApi() {
    return this.getBooleanAttribute('use_for_internal_api');
  }
  public set useForInternalApi(value: boolean | cdktf.IResolvable) {
    this._useForInternalApi = value;
  }
  public resetUseForInternalApi() {
    this._useForInternalApi = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useForInternalApiInput() {
    return this._useForInternalApi;
  }

  // access_log - computed: false, optional: true, required: false
  private _accessLog = new ClusterApiLoadBalancerAccessLogOutputReference(this, "access_log");
  public get accessLog() {
    return this._accessLog;
  }
  public putAccessLog(value: ClusterApiLoadBalancerAccessLog) {
    this._accessLog.internalValue = value;
  }
  public resetAccessLog() {
    this._accessLog.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessLogInput() {
    return this._accessLog.internalValue;
  }

  // subnets - computed: false, optional: true, required: false
  private _subnets = new ClusterApiLoadBalancerSubnetsList(this, "subnets", false);
  public get subnets() {
    return this._subnets;
  }
  public putSubnets(value: ClusterApiLoadBalancerSubnets[] | cdktf.IResolvable) {
    this._subnets.internalValue = value;
  }
  public resetSubnets() {
    this._subnets.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subnetsInput() {
    return this._subnets.internalValue;
  }
}
export interface ClusterApi {
  /**
  * dns block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#dns Cluster#dns}
  */
  readonly dns?: ClusterApiDns;
  /**
  * load_balancer block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#load_balancer Cluster#load_balancer}
  */
  readonly loadBalancer?: ClusterApiLoadBalancer;
}

export function clusterApiToTerraform(struct?: ClusterApiOutputReference | ClusterApi): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dns: clusterApiDnsToTerraform(struct!.dns),
    load_balancer: clusterApiLoadBalancerToTerraform(struct!.loadBalancer),
  }
}


export function clusterApiToHclTerraform(struct?: ClusterApiOutputReference | ClusterApi): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dns: {
      value: clusterApiDnsToHclTerraform(struct!.dns),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterApiDnsList",
    },
    load_balancer: {
      value: clusterApiLoadBalancerToHclTerraform(struct!.loadBalancer),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterApiLoadBalancerList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterApiOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterApi | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dns?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dns = this._dns?.internalValue;
    }
    if (this._loadBalancer?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadBalancer = this._loadBalancer?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterApi | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._dns.internalValue = undefined;
      this._loadBalancer.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._dns.internalValue = value.dns;
      this._loadBalancer.internalValue = value.loadBalancer;
    }
  }

  // dns - computed: false, optional: true, required: false
  private _dns = new ClusterApiDnsOutputReference(this, "dns");
  public get dns() {
    return this._dns;
  }
  public putDns(value: ClusterApiDns) {
    this._dns.internalValue = value;
  }
  public resetDns() {
    this._dns.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsInput() {
    return this._dns.internalValue;
  }

  // load_balancer - computed: false, optional: true, required: false
  private _loadBalancer = new ClusterApiLoadBalancerOutputReference(this, "load_balancer");
  public get loadBalancer() {
    return this._loadBalancer;
  }
  public putLoadBalancer(value: ClusterApiLoadBalancer) {
    this._loadBalancer.internalValue = value;
  }
  public resetLoadBalancer() {
    this._loadBalancer.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadBalancerInput() {
    return this._loadBalancer.internalValue;
  }
}
export interface ClusterAssets {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#container_proxy Cluster#container_proxy}
  */
  readonly containerProxy?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#container_registry Cluster#container_registry}
  */
  readonly containerRegistry?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#file_repository Cluster#file_repository}
  */
  readonly fileRepository?: string;
}

export function clusterAssetsToTerraform(struct?: ClusterAssetsOutputReference | ClusterAssets): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    container_proxy: cdktf.stringToTerraform(struct!.containerProxy),
    container_registry: cdktf.stringToTerraform(struct!.containerRegistry),
    file_repository: cdktf.stringToTerraform(struct!.fileRepository),
  }
}


export function clusterAssetsToHclTerraform(struct?: ClusterAssetsOutputReference | ClusterAssets): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    container_proxy: {
      value: cdktf.stringToHclTerraform(struct!.containerProxy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    container_registry: {
      value: cdktf.stringToHclTerraform(struct!.containerRegistry),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    file_repository: {
      value: cdktf.stringToHclTerraform(struct!.fileRepository),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterAssetsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterAssets | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._containerProxy !== undefined) {
      hasAnyValues = true;
      internalValueResult.containerProxy = this._containerProxy;
    }
    if (this._containerRegistry !== undefined) {
      hasAnyValues = true;
      internalValueResult.containerRegistry = this._containerRegistry;
    }
    if (this._fileRepository !== undefined) {
      hasAnyValues = true;
      internalValueResult.fileRepository = this._fileRepository;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterAssets | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._containerProxy = undefined;
      this._containerRegistry = undefined;
      this._fileRepository = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._containerProxy = value.containerProxy;
      this._containerRegistry = value.containerRegistry;
      this._fileRepository = value.fileRepository;
    }
  }

  // container_proxy - computed: false, optional: true, required: false
  private _containerProxy?: string; 
  public get containerProxy() {
    return this.getStringAttribute('container_proxy');
  }
  public set containerProxy(value: string) {
    this._containerProxy = value;
  }
  public resetContainerProxy() {
    this._containerProxy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get containerProxyInput() {
    return this._containerProxy;
  }

  // container_registry - computed: false, optional: true, required: false
  private _containerRegistry?: string; 
  public get containerRegistry() {
    return this.getStringAttribute('container_registry');
  }
  public set containerRegistry(value: string) {
    this._containerRegistry = value;
  }
  public resetContainerRegistry() {
    this._containerRegistry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get containerRegistryInput() {
    return this._containerRegistry;
  }

  // file_repository - computed: false, optional: true, required: false
  private _fileRepository?: string; 
  public get fileRepository() {
    return this.getStringAttribute('file_repository');
  }
  public set fileRepository(value: string) {
    this._fileRepository = value;
  }
  public resetFileRepository() {
    this._fileRepository = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileRepositoryInput() {
    return this._fileRepository;
  }
}
export interface ClusterAuthenticationAwsIdentityMappings {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#arn Cluster#arn}
  */
  readonly arn?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#groups Cluster#groups}
  */
  readonly groups?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#username Cluster#username}
  */
  readonly username?: string;
}

export function clusterAuthenticationAwsIdentityMappingsToTerraform(struct?: ClusterAuthenticationAwsIdentityMappings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    arn: cdktf.stringToTerraform(struct!.arn),
    groups: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.groups),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function clusterAuthenticationAwsIdentityMappingsToHclTerraform(struct?: ClusterAuthenticationAwsIdentityMappings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    arn: {
      value: cdktf.stringToHclTerraform(struct!.arn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    groups: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.groups),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterAuthenticationAwsIdentityMappingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterAuthenticationAwsIdentityMappings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._arn !== undefined) {
      hasAnyValues = true;
      internalValueResult.arn = this._arn;
    }
    if (this._groups !== undefined) {
      hasAnyValues = true;
      internalValueResult.groups = this._groups;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterAuthenticationAwsIdentityMappings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._arn = undefined;
      this._groups = undefined;
      this._username = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._arn = value.arn;
      this._groups = value.groups;
      this._username = value.username;
    }
  }

  // arn - computed: false, optional: true, required: false
  private _arn?: string; 
  public get arn() {
    return this.getStringAttribute('arn');
  }
  public set arn(value: string) {
    this._arn = value;
  }
  public resetArn() {
    this._arn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get arnInput() {
    return this._arn;
  }

  // groups - computed: false, optional: true, required: false
  private _groups?: string[]; 
  public get groups() {
    return this.getListAttribute('groups');
  }
  public set groups(value: string[]) {
    this._groups = value;
  }
  public resetGroups() {
    this._groups = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupsInput() {
    return this._groups;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}

export class ClusterAuthenticationAwsIdentityMappingsList extends cdktf.ComplexList {
  public internalValue? : ClusterAuthenticationAwsIdentityMappings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterAuthenticationAwsIdentityMappingsOutputReference {
    return new ClusterAuthenticationAwsIdentityMappingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterAuthenticationAws {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#backend_mode Cluster#backend_mode}
  */
  readonly backendMode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#cluster_id Cluster#cluster_id}
  */
  readonly clusterId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#cpu_limit Cluster#cpu_limit}
  */
  readonly cpuLimit?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#cpu_request Cluster#cpu_request}
  */
  readonly cpuRequest?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#image Cluster#image}
  */
  readonly image?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#memory_limit Cluster#memory_limit}
  */
  readonly memoryLimit?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#memory_request Cluster#memory_request}
  */
  readonly memoryRequest?: string;
  /**
  * identity_mappings block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#identity_mappings Cluster#identity_mappings}
  */
  readonly identityMappings?: ClusterAuthenticationAwsIdentityMappings[] | cdktf.IResolvable;
}

export function clusterAuthenticationAwsToTerraform(struct?: ClusterAuthenticationAwsOutputReference | ClusterAuthenticationAws): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backend_mode: cdktf.stringToTerraform(struct!.backendMode),
    cluster_id: cdktf.stringToTerraform(struct!.clusterId),
    cpu_limit: cdktf.stringToTerraform(struct!.cpuLimit),
    cpu_request: cdktf.stringToTerraform(struct!.cpuRequest),
    image: cdktf.stringToTerraform(struct!.image),
    memory_limit: cdktf.stringToTerraform(struct!.memoryLimit),
    memory_request: cdktf.stringToTerraform(struct!.memoryRequest),
    identity_mappings: cdktf.listMapper(clusterAuthenticationAwsIdentityMappingsToTerraform, true)(struct!.identityMappings),
  }
}


export function clusterAuthenticationAwsToHclTerraform(struct?: ClusterAuthenticationAwsOutputReference | ClusterAuthenticationAws): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backend_mode: {
      value: cdktf.stringToHclTerraform(struct!.backendMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.clusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cpu_limit: {
      value: cdktf.stringToHclTerraform(struct!.cpuLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cpu_request: {
      value: cdktf.stringToHclTerraform(struct!.cpuRequest),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    image: {
      value: cdktf.stringToHclTerraform(struct!.image),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    memory_limit: {
      value: cdktf.stringToHclTerraform(struct!.memoryLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    memory_request: {
      value: cdktf.stringToHclTerraform(struct!.memoryRequest),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    identity_mappings: {
      value: cdktf.listMapperHcl(clusterAuthenticationAwsIdentityMappingsToHclTerraform, true)(struct!.identityMappings),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterAuthenticationAwsIdentityMappingsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterAuthenticationAwsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterAuthenticationAws | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backendMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.backendMode = this._backendMode;
    }
    if (this._clusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterId = this._clusterId;
    }
    if (this._cpuLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpuLimit = this._cpuLimit;
    }
    if (this._cpuRequest !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpuRequest = this._cpuRequest;
    }
    if (this._image !== undefined) {
      hasAnyValues = true;
      internalValueResult.image = this._image;
    }
    if (this._memoryLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.memoryLimit = this._memoryLimit;
    }
    if (this._memoryRequest !== undefined) {
      hasAnyValues = true;
      internalValueResult.memoryRequest = this._memoryRequest;
    }
    if (this._identityMappings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.identityMappings = this._identityMappings?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterAuthenticationAws | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._backendMode = undefined;
      this._clusterId = undefined;
      this._cpuLimit = undefined;
      this._cpuRequest = undefined;
      this._image = undefined;
      this._memoryLimit = undefined;
      this._memoryRequest = undefined;
      this._identityMappings.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._backendMode = value.backendMode;
      this._clusterId = value.clusterId;
      this._cpuLimit = value.cpuLimit;
      this._cpuRequest = value.cpuRequest;
      this._image = value.image;
      this._memoryLimit = value.memoryLimit;
      this._memoryRequest = value.memoryRequest;
      this._identityMappings.internalValue = value.identityMappings;
    }
  }

  // backend_mode - computed: false, optional: true, required: false
  private _backendMode?: string; 
  public get backendMode() {
    return this.getStringAttribute('backend_mode');
  }
  public set backendMode(value: string) {
    this._backendMode = value;
  }
  public resetBackendMode() {
    this._backendMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backendModeInput() {
    return this._backendMode;
  }

  // cluster_id - computed: false, optional: true, required: false
  private _clusterId?: string; 
  public get clusterId() {
    return this.getStringAttribute('cluster_id');
  }
  public set clusterId(value: string) {
    this._clusterId = value;
  }
  public resetClusterId() {
    this._clusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterIdInput() {
    return this._clusterId;
  }

  // cpu_limit - computed: false, optional: true, required: false
  private _cpuLimit?: string; 
  public get cpuLimit() {
    return this.getStringAttribute('cpu_limit');
  }
  public set cpuLimit(value: string) {
    this._cpuLimit = value;
  }
  public resetCpuLimit() {
    this._cpuLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuLimitInput() {
    return this._cpuLimit;
  }

  // cpu_request - computed: false, optional: true, required: false
  private _cpuRequest?: string; 
  public get cpuRequest() {
    return this.getStringAttribute('cpu_request');
  }
  public set cpuRequest(value: string) {
    this._cpuRequest = value;
  }
  public resetCpuRequest() {
    this._cpuRequest = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuRequestInput() {
    return this._cpuRequest;
  }

  // image - computed: false, optional: true, required: false
  private _image?: string; 
  public get image() {
    return this.getStringAttribute('image');
  }
  public set image(value: string) {
    this._image = value;
  }
  public resetImage() {
    this._image = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageInput() {
    return this._image;
  }

  // memory_limit - computed: false, optional: true, required: false
  private _memoryLimit?: string; 
  public get memoryLimit() {
    return this.getStringAttribute('memory_limit');
  }
  public set memoryLimit(value: string) {
    this._memoryLimit = value;
  }
  public resetMemoryLimit() {
    this._memoryLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryLimitInput() {
    return this._memoryLimit;
  }

  // memory_request - computed: false, optional: true, required: false
  private _memoryRequest?: string; 
  public get memoryRequest() {
    return this.getStringAttribute('memory_request');
  }
  public set memoryRequest(value: string) {
    this._memoryRequest = value;
  }
  public resetMemoryRequest() {
    this._memoryRequest = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryRequestInput() {
    return this._memoryRequest;
  }

  // identity_mappings - computed: false, optional: true, required: false
  private _identityMappings = new ClusterAuthenticationAwsIdentityMappingsList(this, "identity_mappings", false);
  public get identityMappings() {
    return this._identityMappings;
  }
  public putIdentityMappings(value: ClusterAuthenticationAwsIdentityMappings[] | cdktf.IResolvable) {
    this._identityMappings.internalValue = value;
  }
  public resetIdentityMappings() {
    this._identityMappings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get identityMappingsInput() {
    return this._identityMappings.internalValue;
  }
}
export interface ClusterAuthenticationKopeio {
}

export function clusterAuthenticationKopeioToTerraform(struct?: ClusterAuthenticationKopeioOutputReference | ClusterAuthenticationKopeio): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function clusterAuthenticationKopeioToHclTerraform(struct?: ClusterAuthenticationKopeioOutputReference | ClusterAuthenticationKopeio): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class ClusterAuthenticationKopeioOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterAuthenticationKopeio | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterAuthenticationKopeio | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }
}
export interface ClusterAuthentication {
  /**
  * aws block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#aws Cluster#aws}
  */
  readonly aws?: ClusterAuthenticationAws;
  /**
  * kopeio block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#kopeio Cluster#kopeio}
  */
  readonly kopeio?: ClusterAuthenticationKopeio;
}

export function clusterAuthenticationToTerraform(struct?: ClusterAuthenticationOutputReference | ClusterAuthentication): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    aws: clusterAuthenticationAwsToTerraform(struct!.aws),
    kopeio: clusterAuthenticationKopeioToTerraform(struct!.kopeio),
  }
}


export function clusterAuthenticationToHclTerraform(struct?: ClusterAuthenticationOutputReference | ClusterAuthentication): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    aws: {
      value: clusterAuthenticationAwsToHclTerraform(struct!.aws),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterAuthenticationAwsList",
    },
    kopeio: {
      value: clusterAuthenticationKopeioToHclTerraform(struct!.kopeio),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterAuthenticationKopeioList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterAuthenticationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterAuthentication | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._aws?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.aws = this._aws?.internalValue;
    }
    if (this._kopeio?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.kopeio = this._kopeio?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterAuthentication | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._aws.internalValue = undefined;
      this._kopeio.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._aws.internalValue = value.aws;
      this._kopeio.internalValue = value.kopeio;
    }
  }

  // aws - computed: false, optional: true, required: false
  private _aws = new ClusterAuthenticationAwsOutputReference(this, "aws");
  public get aws() {
    return this._aws;
  }
  public putAws(value: ClusterAuthenticationAws) {
    this._aws.internalValue = value;
  }
  public resetAws() {
    this._aws.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsInput() {
    return this._aws.internalValue;
  }

  // kopeio - computed: false, optional: true, required: false
  private _kopeio = new ClusterAuthenticationKopeioOutputReference(this, "kopeio");
  public get kopeio() {
    return this._kopeio;
  }
  public putKopeio(value: ClusterAuthenticationKopeio) {
    this._kopeio.internalValue = value;
  }
  public resetKopeio() {
    this._kopeio.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kopeioInput() {
    return this._kopeio.internalValue;
  }
}
export interface ClusterAuthorizationAlwaysAllow {
}

export function clusterAuthorizationAlwaysAllowToTerraform(struct?: ClusterAuthorizationAlwaysAllowOutputReference | ClusterAuthorizationAlwaysAllow): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function clusterAuthorizationAlwaysAllowToHclTerraform(struct?: ClusterAuthorizationAlwaysAllowOutputReference | ClusterAuthorizationAlwaysAllow): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class ClusterAuthorizationAlwaysAllowOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterAuthorizationAlwaysAllow | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterAuthorizationAlwaysAllow | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }
}
export interface ClusterAuthorizationRbac {
}

export function clusterAuthorizationRbacToTerraform(struct?: ClusterAuthorizationRbacOutputReference | ClusterAuthorizationRbac): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function clusterAuthorizationRbacToHclTerraform(struct?: ClusterAuthorizationRbacOutputReference | ClusterAuthorizationRbac): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class ClusterAuthorizationRbacOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterAuthorizationRbac | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterAuthorizationRbac | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }
}
export interface ClusterAuthorization {
  /**
  * always_allow block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#always_allow Cluster#always_allow}
  */
  readonly alwaysAllow?: ClusterAuthorizationAlwaysAllow;
  /**
  * rbac block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#rbac Cluster#rbac}
  */
  readonly rbac?: ClusterAuthorizationRbac;
}

export function clusterAuthorizationToTerraform(struct?: ClusterAuthorizationOutputReference | ClusterAuthorization): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    always_allow: clusterAuthorizationAlwaysAllowToTerraform(struct!.alwaysAllow),
    rbac: clusterAuthorizationRbacToTerraform(struct!.rbac),
  }
}


export function clusterAuthorizationToHclTerraform(struct?: ClusterAuthorizationOutputReference | ClusterAuthorization): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    always_allow: {
      value: clusterAuthorizationAlwaysAllowToHclTerraform(struct!.alwaysAllow),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterAuthorizationAlwaysAllowList",
    },
    rbac: {
      value: clusterAuthorizationRbacToHclTerraform(struct!.rbac),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterAuthorizationRbacList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterAuthorizationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterAuthorization | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._alwaysAllow?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.alwaysAllow = this._alwaysAllow?.internalValue;
    }
    if (this._rbac?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rbac = this._rbac?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterAuthorization | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._alwaysAllow.internalValue = undefined;
      this._rbac.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._alwaysAllow.internalValue = value.alwaysAllow;
      this._rbac.internalValue = value.rbac;
    }
  }

  // always_allow - computed: false, optional: true, required: false
  private _alwaysAllow = new ClusterAuthorizationAlwaysAllowOutputReference(this, "always_allow");
  public get alwaysAllow() {
    return this._alwaysAllow;
  }
  public putAlwaysAllow(value: ClusterAuthorizationAlwaysAllow) {
    this._alwaysAllow.internalValue = value;
  }
  public resetAlwaysAllow() {
    this._alwaysAllow.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get alwaysAllowInput() {
    return this._alwaysAllow.internalValue;
  }

  // rbac - computed: false, optional: true, required: false
  private _rbac = new ClusterAuthorizationRbacOutputReference(this, "rbac");
  public get rbac() {
    return this._rbac;
  }
  public putRbac(value: ClusterAuthorizationRbac) {
    this._rbac.internalValue = value;
  }
  public resetRbac() {
    this._rbac.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rbacInput() {
    return this._rbac.internalValue;
  }
}
export interface ClusterAwsLoadBalancerController {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#enable_shield Cluster#enable_shield}
  */
  readonly enableShield?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#enable_wa_fv2 Cluster#enable_wa_fv2}
  */
  readonly enableWaFv2?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#enable_waf Cluster#enable_waf}
  */
  readonly enableWaf?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#enabled Cluster#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#version Cluster#version}
  */
  readonly version?: string;
}

export function clusterAwsLoadBalancerControllerToTerraform(struct?: ClusterAwsLoadBalancerControllerOutputReference | ClusterAwsLoadBalancerController): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enable_shield: cdktf.booleanToTerraform(struct!.enableShield),
    enable_wa_fv2: cdktf.booleanToTerraform(struct!.enableWaFv2),
    enable_waf: cdktf.booleanToTerraform(struct!.enableWaf),
    enabled: cdktf.booleanToTerraform(struct!.enabled),
    version: cdktf.stringToTerraform(struct!.version),
  }
}


export function clusterAwsLoadBalancerControllerToHclTerraform(struct?: ClusterAwsLoadBalancerControllerOutputReference | ClusterAwsLoadBalancerController): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enable_shield: {
      value: cdktf.booleanToHclTerraform(struct!.enableShield),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_wa_fv2: {
      value: cdktf.booleanToHclTerraform(struct!.enableWaFv2),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_waf: {
      value: cdktf.booleanToHclTerraform(struct!.enableWaf),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    version: {
      value: cdktf.stringToHclTerraform(struct!.version),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterAwsLoadBalancerControllerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterAwsLoadBalancerController | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enableShield !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableShield = this._enableShield;
    }
    if (this._enableWaFv2 !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableWaFv2 = this._enableWaFv2;
    }
    if (this._enableWaf !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableWaf = this._enableWaf;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._version !== undefined) {
      hasAnyValues = true;
      internalValueResult.version = this._version;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterAwsLoadBalancerController | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._enableShield = undefined;
      this._enableWaFv2 = undefined;
      this._enableWaf = undefined;
      this._enabled = undefined;
      this._version = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._enableShield = value.enableShield;
      this._enableWaFv2 = value.enableWaFv2;
      this._enableWaf = value.enableWaf;
      this._enabled = value.enabled;
      this._version = value.version;
    }
  }

  // enable_shield - computed: false, optional: true, required: false
  private _enableShield?: boolean | cdktf.IResolvable; 
  public get enableShield() {
    return this.getBooleanAttribute('enable_shield');
  }
  public set enableShield(value: boolean | cdktf.IResolvable) {
    this._enableShield = value;
  }
  public resetEnableShield() {
    this._enableShield = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableShieldInput() {
    return this._enableShield;
  }

  // enable_wa_fv2 - computed: false, optional: true, required: false
  private _enableWaFv2?: boolean | cdktf.IResolvable; 
  public get enableWaFv2() {
    return this.getBooleanAttribute('enable_wa_fv2');
  }
  public set enableWaFv2(value: boolean | cdktf.IResolvable) {
    this._enableWaFv2 = value;
  }
  public resetEnableWaFv2() {
    this._enableWaFv2 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableWaFv2Input() {
    return this._enableWaFv2;
  }

  // enable_waf - computed: false, optional: true, required: false
  private _enableWaf?: boolean | cdktf.IResolvable; 
  public get enableWaf() {
    return this.getBooleanAttribute('enable_waf');
  }
  public set enableWaf(value: boolean | cdktf.IResolvable) {
    this._enableWaf = value;
  }
  public resetEnableWaf() {
    this._enableWaf = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableWafInput() {
    return this._enableWaf;
  }

  // enabled - computed: false, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // version - computed: false, optional: true, required: false
  private _version?: string; 
  public get version() {
    return this.getStringAttribute('version');
  }
  public set version(value: string) {
    this._version = value;
  }
  public resetVersion() {
    this._version = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get versionInput() {
    return this._version;
  }
}
export interface ClusterCertManager {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#default_issuer Cluster#default_issuer}
  */
  readonly defaultIssuer?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#enabled Cluster#enabled}
  */
  readonly enabled: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#hosted_zone_ids Cluster#hosted_zone_ids}
  */
  readonly hostedZoneIds?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#image Cluster#image}
  */
  readonly image?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#managed Cluster#managed}
  */
  readonly managed: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#nameservers Cluster#nameservers}
  */
  readonly nameservers?: string[];
}

export function clusterCertManagerToTerraform(struct?: ClusterCertManagerOutputReference | ClusterCertManager): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    default_issuer: cdktf.stringToTerraform(struct!.defaultIssuer),
    enabled: cdktf.booleanToTerraform(struct!.enabled),
    hosted_zone_ids: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.hostedZoneIds),
    image: cdktf.stringToTerraform(struct!.image),
    managed: cdktf.booleanToTerraform(struct!.managed),
    nameservers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.nameservers),
  }
}


export function clusterCertManagerToHclTerraform(struct?: ClusterCertManagerOutputReference | ClusterCertManager): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    default_issuer: {
      value: cdktf.stringToHclTerraform(struct!.defaultIssuer),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    hosted_zone_ids: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.hostedZoneIds),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    image: {
      value: cdktf.stringToHclTerraform(struct!.image),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    managed: {
      value: cdktf.booleanToHclTerraform(struct!.managed),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    nameservers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.nameservers),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterCertManagerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterCertManager | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._defaultIssuer !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultIssuer = this._defaultIssuer;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._hostedZoneIds !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostedZoneIds = this._hostedZoneIds;
    }
    if (this._image !== undefined) {
      hasAnyValues = true;
      internalValueResult.image = this._image;
    }
    if (this._managed !== undefined) {
      hasAnyValues = true;
      internalValueResult.managed = this._managed;
    }
    if (this._nameservers !== undefined) {
      hasAnyValues = true;
      internalValueResult.nameservers = this._nameservers;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterCertManager | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._defaultIssuer = undefined;
      this._enabled = undefined;
      this._hostedZoneIds = undefined;
      this._image = undefined;
      this._managed = undefined;
      this._nameservers = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._defaultIssuer = value.defaultIssuer;
      this._enabled = value.enabled;
      this._hostedZoneIds = value.hostedZoneIds;
      this._image = value.image;
      this._managed = value.managed;
      this._nameservers = value.nameservers;
    }
  }

  // default_issuer - computed: false, optional: true, required: false
  private _defaultIssuer?: string; 
  public get defaultIssuer() {
    return this.getStringAttribute('default_issuer');
  }
  public set defaultIssuer(value: string) {
    this._defaultIssuer = value;
  }
  public resetDefaultIssuer() {
    this._defaultIssuer = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultIssuerInput() {
    return this._defaultIssuer;
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // hosted_zone_ids - computed: false, optional: true, required: false
  private _hostedZoneIds?: string[]; 
  public get hostedZoneIds() {
    return this.getListAttribute('hosted_zone_ids');
  }
  public set hostedZoneIds(value: string[]) {
    this._hostedZoneIds = value;
  }
  public resetHostedZoneIds() {
    this._hostedZoneIds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostedZoneIdsInput() {
    return this._hostedZoneIds;
  }

  // image - computed: false, optional: true, required: false
  private _image?: string; 
  public get image() {
    return this.getStringAttribute('image');
  }
  public set image(value: string) {
    this._image = value;
  }
  public resetImage() {
    this._image = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageInput() {
    return this._image;
  }

  // managed - computed: false, optional: false, required: true
  private _managed?: boolean | cdktf.IResolvable; 
  public get managed() {
    return this.getBooleanAttribute('managed');
  }
  public set managed(value: boolean | cdktf.IResolvable) {
    this._managed = value;
  }
  // Temporarily expose input value. Use with caution.
  public get managedInput() {
    return this._managed;
  }

  // nameservers - computed: false, optional: true, required: false
  private _nameservers?: string[]; 
  public get nameservers() {
    return this.getListAttribute('nameservers');
  }
  public set nameservers(value: string[]) {
    this._nameservers = value;
  }
  public resetNameservers() {
    this._nameservers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameserversInput() {
    return this._nameservers;
  }
}
export interface ClusterCloudConfigAwsEbsCsiDriver {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#enabled Cluster#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#managed Cluster#managed}
  */
  readonly managed?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#pod_annotations Cluster#pod_annotations}
  */
  readonly podAnnotations?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#version Cluster#version}
  */
  readonly version?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#volume_attach_limit Cluster#volume_attach_limit}
  */
  readonly volumeAttachLimit?: number;
}

export function clusterCloudConfigAwsEbsCsiDriverToTerraform(struct?: ClusterCloudConfigAwsEbsCsiDriverOutputReference | ClusterCloudConfigAwsEbsCsiDriver): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.booleanToTerraform(struct!.enabled),
    managed: cdktf.booleanToTerraform(struct!.managed),
    pod_annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.podAnnotations),
    version: cdktf.stringToTerraform(struct!.version),
    volume_attach_limit: cdktf.numberToTerraform(struct!.volumeAttachLimit),
  }
}


export function clusterCloudConfigAwsEbsCsiDriverToHclTerraform(struct?: ClusterCloudConfigAwsEbsCsiDriverOutputReference | ClusterCloudConfigAwsEbsCsiDriver): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    managed: {
      value: cdktf.booleanToHclTerraform(struct!.managed),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    pod_annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.podAnnotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    version: {
      value: cdktf.stringToHclTerraform(struct!.version),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    volume_attach_limit: {
      value: cdktf.numberToHclTerraform(struct!.volumeAttachLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterCloudConfigAwsEbsCsiDriverOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterCloudConfigAwsEbsCsiDriver | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._managed !== undefined) {
      hasAnyValues = true;
      internalValueResult.managed = this._managed;
    }
    if (this._podAnnotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.podAnnotations = this._podAnnotations;
    }
    if (this._version !== undefined) {
      hasAnyValues = true;
      internalValueResult.version = this._version;
    }
    if (this._volumeAttachLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.volumeAttachLimit = this._volumeAttachLimit;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterCloudConfigAwsEbsCsiDriver | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._enabled = undefined;
      this._managed = undefined;
      this._podAnnotations = undefined;
      this._version = undefined;
      this._volumeAttachLimit = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._enabled = value.enabled;
      this._managed = value.managed;
      this._podAnnotations = value.podAnnotations;
      this._version = value.version;
      this._volumeAttachLimit = value.volumeAttachLimit;
    }
  }

  // enabled - computed: false, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // managed - computed: false, optional: true, required: false
  private _managed?: boolean | cdktf.IResolvable; 
  public get managed() {
    return this.getBooleanAttribute('managed');
  }
  public set managed(value: boolean | cdktf.IResolvable) {
    this._managed = value;
  }
  public resetManaged() {
    this._managed = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get managedInput() {
    return this._managed;
  }

  // pod_annotations - computed: false, optional: true, required: false
  private _podAnnotations?: { [key: string]: string }; 
  public get podAnnotations() {
    return this.getStringMapAttribute('pod_annotations');
  }
  public set podAnnotations(value: { [key: string]: string }) {
    this._podAnnotations = value;
  }
  public resetPodAnnotations() {
    this._podAnnotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podAnnotationsInput() {
    return this._podAnnotations;
  }

  // version - computed: false, optional: true, required: false
  private _version?: string; 
  public get version() {
    return this.getStringAttribute('version');
  }
  public set version(value: string) {
    this._version = value;
  }
  public resetVersion() {
    this._version = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get versionInput() {
    return this._version;
  }

  // volume_attach_limit - computed: false, optional: true, required: false
  private _volumeAttachLimit?: number; 
  public get volumeAttachLimit() {
    return this.getNumberAttribute('volume_attach_limit');
  }
  public set volumeAttachLimit(value: number) {
    this._volumeAttachLimit = value;
  }
  public resetVolumeAttachLimit() {
    this._volumeAttachLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get volumeAttachLimitInput() {
    return this._volumeAttachLimit;
  }
}
export interface ClusterCloudConfigGcpPdCsiDriver {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#enabled Cluster#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
}

export function clusterCloudConfigGcpPdCsiDriverToTerraform(struct?: ClusterCloudConfigGcpPdCsiDriverOutputReference | ClusterCloudConfigGcpPdCsiDriver): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.booleanToTerraform(struct!.enabled),
  }
}


export function clusterCloudConfigGcpPdCsiDriverToHclTerraform(struct?: ClusterCloudConfigGcpPdCsiDriverOutputReference | ClusterCloudConfigGcpPdCsiDriver): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterCloudConfigGcpPdCsiDriverOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterCloudConfigGcpPdCsiDriver | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterCloudConfigGcpPdCsiDriver | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._enabled = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._enabled = value.enabled;
    }
  }

  // enabled - computed: false, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }
}
export interface ClusterCloudConfigManageStorageClasses {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#value Cluster#value}
  */
  readonly value?: boolean | cdktf.IResolvable;
}

export function clusterCloudConfigManageStorageClassesToTerraform(struct?: ClusterCloudConfigManageStorageClassesOutputReference | ClusterCloudConfigManageStorageClasses): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value: cdktf.booleanToTerraform(struct!.value),
  }
}


export function clusterCloudConfigManageStorageClassesToHclTerraform(struct?: ClusterCloudConfigManageStorageClassesOutputReference | ClusterCloudConfigManageStorageClasses): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value: {
      value: cdktf.booleanToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterCloudConfigManageStorageClassesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterCloudConfigManageStorageClasses | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterCloudConfigManageStorageClasses | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._value = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._value = value.value;
    }
  }

  // value - computed: false, optional: true, required: false
  private _value?: boolean | cdktf.IResolvable; 
  public get value() {
    return this.getBooleanAttribute('value');
  }
  public set value(value: boolean | cdktf.IResolvable) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface ClusterCloudConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#disable_security_group_ingress Cluster#disable_security_group_ingress}
  */
  readonly disableSecurityGroupIngress?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#elb_security_group Cluster#elb_security_group}
  */
  readonly elbSecurityGroup?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#gce_service_account Cluster#gce_service_account}
  */
  readonly gceServiceAccount?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#multizone Cluster#multizone}
  */
  readonly multizone?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#node_instance_prefix Cluster#node_instance_prefix}
  */
  readonly nodeInstancePrefix?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#node_ip_families Cluster#node_ip_families}
  */
  readonly nodeIpFamilies?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#node_tags Cluster#node_tags}
  */
  readonly nodeTags?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#spotinst_orientation Cluster#spotinst_orientation}
  */
  readonly spotinstOrientation?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#spotinst_product Cluster#spotinst_product}
  */
  readonly spotinstProduct?: string;
  /**
  * aws_ebs_csi_driver block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#aws_ebs_csi_driver Cluster#aws_ebs_csi_driver}
  */
  readonly awsEbsCsiDriver?: ClusterCloudConfigAwsEbsCsiDriver;
  /**
  * gcp_pd_csi_driver block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#gcp_pd_csi_driver Cluster#gcp_pd_csi_driver}
  */
  readonly gcpPdCsiDriver?: ClusterCloudConfigGcpPdCsiDriver;
  /**
  * manage_storage_classes block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#manage_storage_classes Cluster#manage_storage_classes}
  */
  readonly manageStorageClasses?: ClusterCloudConfigManageStorageClasses;
}

export function clusterCloudConfigToTerraform(struct?: ClusterCloudConfigOutputReference | ClusterCloudConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    disable_security_group_ingress: cdktf.booleanToTerraform(struct!.disableSecurityGroupIngress),
    elb_security_group: cdktf.stringToTerraform(struct!.elbSecurityGroup),
    gce_service_account: cdktf.stringToTerraform(struct!.gceServiceAccount),
    multizone: cdktf.booleanToTerraform(struct!.multizone),
    node_instance_prefix: cdktf.stringToTerraform(struct!.nodeInstancePrefix),
    node_ip_families: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.nodeIpFamilies),
    node_tags: cdktf.stringToTerraform(struct!.nodeTags),
    spotinst_orientation: cdktf.stringToTerraform(struct!.spotinstOrientation),
    spotinst_product: cdktf.stringToTerraform(struct!.spotinstProduct),
    aws_ebs_csi_driver: clusterCloudConfigAwsEbsCsiDriverToTerraform(struct!.awsEbsCsiDriver),
    gcp_pd_csi_driver: clusterCloudConfigGcpPdCsiDriverToTerraform(struct!.gcpPdCsiDriver),
    manage_storage_classes: clusterCloudConfigManageStorageClassesToTerraform(struct!.manageStorageClasses),
  }
}


export function clusterCloudConfigToHclTerraform(struct?: ClusterCloudConfigOutputReference | ClusterCloudConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    disable_security_group_ingress: {
      value: cdktf.booleanToHclTerraform(struct!.disableSecurityGroupIngress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    elb_security_group: {
      value: cdktf.stringToHclTerraform(struct!.elbSecurityGroup),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    gce_service_account: {
      value: cdktf.stringToHclTerraform(struct!.gceServiceAccount),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    multizone: {
      value: cdktf.booleanToHclTerraform(struct!.multizone),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    node_instance_prefix: {
      value: cdktf.stringToHclTerraform(struct!.nodeInstancePrefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    node_ip_families: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.nodeIpFamilies),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    node_tags: {
      value: cdktf.stringToHclTerraform(struct!.nodeTags),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    spotinst_orientation: {
      value: cdktf.stringToHclTerraform(struct!.spotinstOrientation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    spotinst_product: {
      value: cdktf.stringToHclTerraform(struct!.spotinstProduct),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_ebs_csi_driver: {
      value: clusterCloudConfigAwsEbsCsiDriverToHclTerraform(struct!.awsEbsCsiDriver),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterCloudConfigAwsEbsCsiDriverList",
    },
    gcp_pd_csi_driver: {
      value: clusterCloudConfigGcpPdCsiDriverToHclTerraform(struct!.gcpPdCsiDriver),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterCloudConfigGcpPdCsiDriverList",
    },
    manage_storage_classes: {
      value: clusterCloudConfigManageStorageClassesToHclTerraform(struct!.manageStorageClasses),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterCloudConfigManageStorageClassesList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterCloudConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterCloudConfig | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._disableSecurityGroupIngress !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableSecurityGroupIngress = this._disableSecurityGroupIngress;
    }
    if (this._elbSecurityGroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.elbSecurityGroup = this._elbSecurityGroup;
    }
    if (this._gceServiceAccount !== undefined) {
      hasAnyValues = true;
      internalValueResult.gceServiceAccount = this._gceServiceAccount;
    }
    if (this._multizone !== undefined) {
      hasAnyValues = true;
      internalValueResult.multizone = this._multizone;
    }
    if (this._nodeInstancePrefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeInstancePrefix = this._nodeInstancePrefix;
    }
    if (this._nodeIpFamilies !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeIpFamilies = this._nodeIpFamilies;
    }
    if (this._nodeTags !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeTags = this._nodeTags;
    }
    if (this._spotinstOrientation !== undefined) {
      hasAnyValues = true;
      internalValueResult.spotinstOrientation = this._spotinstOrientation;
    }
    if (this._spotinstProduct !== undefined) {
      hasAnyValues = true;
      internalValueResult.spotinstProduct = this._spotinstProduct;
    }
    if (this._awsEbsCsiDriver?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsEbsCsiDriver = this._awsEbsCsiDriver?.internalValue;
    }
    if (this._gcpPdCsiDriver?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.gcpPdCsiDriver = this._gcpPdCsiDriver?.internalValue;
    }
    if (this._manageStorageClasses?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.manageStorageClasses = this._manageStorageClasses?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterCloudConfig | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._disableSecurityGroupIngress = undefined;
      this._elbSecurityGroup = undefined;
      this._gceServiceAccount = undefined;
      this._multizone = undefined;
      this._nodeInstancePrefix = undefined;
      this._nodeIpFamilies = undefined;
      this._nodeTags = undefined;
      this._spotinstOrientation = undefined;
      this._spotinstProduct = undefined;
      this._awsEbsCsiDriver.internalValue = undefined;
      this._gcpPdCsiDriver.internalValue = undefined;
      this._manageStorageClasses.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._disableSecurityGroupIngress = value.disableSecurityGroupIngress;
      this._elbSecurityGroup = value.elbSecurityGroup;
      this._gceServiceAccount = value.gceServiceAccount;
      this._multizone = value.multizone;
      this._nodeInstancePrefix = value.nodeInstancePrefix;
      this._nodeIpFamilies = value.nodeIpFamilies;
      this._nodeTags = value.nodeTags;
      this._spotinstOrientation = value.spotinstOrientation;
      this._spotinstProduct = value.spotinstProduct;
      this._awsEbsCsiDriver.internalValue = value.awsEbsCsiDriver;
      this._gcpPdCsiDriver.internalValue = value.gcpPdCsiDriver;
      this._manageStorageClasses.internalValue = value.manageStorageClasses;
    }
  }

  // disable_security_group_ingress - computed: false, optional: true, required: false
  private _disableSecurityGroupIngress?: boolean | cdktf.IResolvable; 
  public get disableSecurityGroupIngress() {
    return this.getBooleanAttribute('disable_security_group_ingress');
  }
  public set disableSecurityGroupIngress(value: boolean | cdktf.IResolvable) {
    this._disableSecurityGroupIngress = value;
  }
  public resetDisableSecurityGroupIngress() {
    this._disableSecurityGroupIngress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableSecurityGroupIngressInput() {
    return this._disableSecurityGroupIngress;
  }

  // elb_security_group - computed: false, optional: true, required: false
  private _elbSecurityGroup?: string; 
  public get elbSecurityGroup() {
    return this.getStringAttribute('elb_security_group');
  }
  public set elbSecurityGroup(value: string) {
    this._elbSecurityGroup = value;
  }
  public resetElbSecurityGroup() {
    this._elbSecurityGroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get elbSecurityGroupInput() {
    return this._elbSecurityGroup;
  }

  // gce_service_account - computed: false, optional: true, required: false
  private _gceServiceAccount?: string; 
  public get gceServiceAccount() {
    return this.getStringAttribute('gce_service_account');
  }
  public set gceServiceAccount(value: string) {
    this._gceServiceAccount = value;
  }
  public resetGceServiceAccount() {
    this._gceServiceAccount = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gceServiceAccountInput() {
    return this._gceServiceAccount;
  }

  // multizone - computed: false, optional: true, required: false
  private _multizone?: boolean | cdktf.IResolvable; 
  public get multizone() {
    return this.getBooleanAttribute('multizone');
  }
  public set multizone(value: boolean | cdktf.IResolvable) {
    this._multizone = value;
  }
  public resetMultizone() {
    this._multizone = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get multizoneInput() {
    return this._multizone;
  }

  // node_instance_prefix - computed: false, optional: true, required: false
  private _nodeInstancePrefix?: string; 
  public get nodeInstancePrefix() {
    return this.getStringAttribute('node_instance_prefix');
  }
  public set nodeInstancePrefix(value: string) {
    this._nodeInstancePrefix = value;
  }
  public resetNodeInstancePrefix() {
    this._nodeInstancePrefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeInstancePrefixInput() {
    return this._nodeInstancePrefix;
  }

  // node_ip_families - computed: false, optional: true, required: false
  private _nodeIpFamilies?: string[]; 
  public get nodeIpFamilies() {
    return this.getListAttribute('node_ip_families');
  }
  public set nodeIpFamilies(value: string[]) {
    this._nodeIpFamilies = value;
  }
  public resetNodeIpFamilies() {
    this._nodeIpFamilies = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeIpFamiliesInput() {
    return this._nodeIpFamilies;
  }

  // node_tags - computed: false, optional: true, required: false
  private _nodeTags?: string; 
  public get nodeTags() {
    return this.getStringAttribute('node_tags');
  }
  public set nodeTags(value: string) {
    this._nodeTags = value;
  }
  public resetNodeTags() {
    this._nodeTags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeTagsInput() {
    return this._nodeTags;
  }

  // spotinst_orientation - computed: false, optional: true, required: false
  private _spotinstOrientation?: string; 
  public get spotinstOrientation() {
    return this.getStringAttribute('spotinst_orientation');
  }
  public set spotinstOrientation(value: string) {
    this._spotinstOrientation = value;
  }
  public resetSpotinstOrientation() {
    this._spotinstOrientation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get spotinstOrientationInput() {
    return this._spotinstOrientation;
  }

  // spotinst_product - computed: false, optional: true, required: false
  private _spotinstProduct?: string; 
  public get spotinstProduct() {
    return this.getStringAttribute('spotinst_product');
  }
  public set spotinstProduct(value: string) {
    this._spotinstProduct = value;
  }
  public resetSpotinstProduct() {
    this._spotinstProduct = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get spotinstProductInput() {
    return this._spotinstProduct;
  }

  // aws_ebs_csi_driver - computed: false, optional: true, required: false
  private _awsEbsCsiDriver = new ClusterCloudConfigAwsEbsCsiDriverOutputReference(this, "aws_ebs_csi_driver");
  public get awsEbsCsiDriver() {
    return this._awsEbsCsiDriver;
  }
  public putAwsEbsCsiDriver(value: ClusterCloudConfigAwsEbsCsiDriver) {
    this._awsEbsCsiDriver.internalValue = value;
  }
  public resetAwsEbsCsiDriver() {
    this._awsEbsCsiDriver.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsEbsCsiDriverInput() {
    return this._awsEbsCsiDriver.internalValue;
  }

  // gcp_pd_csi_driver - computed: false, optional: true, required: false
  private _gcpPdCsiDriver = new ClusterCloudConfigGcpPdCsiDriverOutputReference(this, "gcp_pd_csi_driver");
  public get gcpPdCsiDriver() {
    return this._gcpPdCsiDriver;
  }
  public putGcpPdCsiDriver(value: ClusterCloudConfigGcpPdCsiDriver) {
    this._gcpPdCsiDriver.internalValue = value;
  }
  public resetGcpPdCsiDriver() {
    this._gcpPdCsiDriver.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gcpPdCsiDriverInput() {
    return this._gcpPdCsiDriver.internalValue;
  }

  // manage_storage_classes - computed: false, optional: true, required: false
  private _manageStorageClasses = new ClusterCloudConfigManageStorageClassesOutputReference(this, "manage_storage_classes");
  public get manageStorageClasses() {
    return this._manageStorageClasses;
  }
  public putManageStorageClasses(value: ClusterCloudConfigManageStorageClasses) {
    this._manageStorageClasses.internalValue = value;
  }
  public resetManageStorageClasses() {
    this._manageStorageClasses.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get manageStorageClassesInput() {
    return this._manageStorageClasses.internalValue;
  }
}
export interface ClusterCloudProviderAws {
}

export function clusterCloudProviderAwsToTerraform(struct?: ClusterCloudProviderAwsOutputReference | ClusterCloudProviderAws): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function clusterCloudProviderAwsToHclTerraform(struct?: ClusterCloudProviderAwsOutputReference | ClusterCloudProviderAws): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class ClusterCloudProviderAwsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterCloudProviderAws | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterCloudProviderAws | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }
}
export interface ClusterCloudProviderAzure {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#admin_user Cluster#admin_user}
  */
  readonly adminUser?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#resource_group_name Cluster#resource_group_name}
  */
  readonly resourceGroupName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#route_table_name Cluster#route_table_name}
  */
  readonly routeTableName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#subscription_id Cluster#subscription_id}
  */
  readonly subscriptionId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#tenant_id Cluster#tenant_id}
  */
  readonly tenantId?: string;
}

export function clusterCloudProviderAzureToTerraform(struct?: ClusterCloudProviderAzureOutputReference | ClusterCloudProviderAzure): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    admin_user: cdktf.stringToTerraform(struct!.adminUser),
    resource_group_name: cdktf.stringToTerraform(struct!.resourceGroupName),
    route_table_name: cdktf.stringToTerraform(struct!.routeTableName),
    subscription_id: cdktf.stringToTerraform(struct!.subscriptionId),
    tenant_id: cdktf.stringToTerraform(struct!.tenantId),
  }
}


export function clusterCloudProviderAzureToHclTerraform(struct?: ClusterCloudProviderAzureOutputReference | ClusterCloudProviderAzure): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    admin_user: {
      value: cdktf.stringToHclTerraform(struct!.adminUser),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    resource_group_name: {
      value: cdktf.stringToHclTerraform(struct!.resourceGroupName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    route_table_name: {
      value: cdktf.stringToHclTerraform(struct!.routeTableName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subscription_id: {
      value: cdktf.stringToHclTerraform(struct!.subscriptionId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tenant_id: {
      value: cdktf.stringToHclTerraform(struct!.tenantId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterCloudProviderAzureOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterCloudProviderAzure | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._adminUser !== undefined) {
      hasAnyValues = true;
      internalValueResult.adminUser = this._adminUser;
    }
    if (this._resourceGroupName !== undefined) {
      hasAnyValues = true;
      internalValueResult.resourceGroupName = this._resourceGroupName;
    }
    if (this._routeTableName !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeTableName = this._routeTableName;
    }
    if (this._subscriptionId !== undefined) {
      hasAnyValues = true;
      internalValueResult.subscriptionId = this._subscriptionId;
    }
    if (this._tenantId !== undefined) {
      hasAnyValues = true;
      internalValueResult.tenantId = this._tenantId;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterCloudProviderAzure | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._adminUser = undefined;
      this._resourceGroupName = undefined;
      this._routeTableName = undefined;
      this._subscriptionId = undefined;
      this._tenantId = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._adminUser = value.adminUser;
      this._resourceGroupName = value.resourceGroupName;
      this._routeTableName = value.routeTableName;
      this._subscriptionId = value.subscriptionId;
      this._tenantId = value.tenantId;
    }
  }

  // admin_user - computed: false, optional: true, required: false
  private _adminUser?: string; 
  public get adminUser() {
    return this.getStringAttribute('admin_user');
  }
  public set adminUser(value: string) {
    this._adminUser = value;
  }
  public resetAdminUser() {
    this._adminUser = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get adminUserInput() {
    return this._adminUser;
  }

  // resource_group_name - computed: false, optional: true, required: false
  private _resourceGroupName?: string; 
  public get resourceGroupName() {
    return this.getStringAttribute('resource_group_name');
  }
  public set resourceGroupName(value: string) {
    this._resourceGroupName = value;
  }
  public resetResourceGroupName() {
    this._resourceGroupName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceGroupNameInput() {
    return this._resourceGroupName;
  }

  // route_table_name - computed: false, optional: true, required: false
  private _routeTableName?: string; 
  public get routeTableName() {
    return this.getStringAttribute('route_table_name');
  }
  public set routeTableName(value: string) {
    this._routeTableName = value;
  }
  public resetRouteTableName() {
    this._routeTableName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeTableNameInput() {
    return this._routeTableName;
  }

  // subscription_id - computed: false, optional: true, required: false
  private _subscriptionId?: string; 
  public get subscriptionId() {
    return this.getStringAttribute('subscription_id');
  }
  public set subscriptionId(value: string) {
    this._subscriptionId = value;
  }
  public resetSubscriptionId() {
    this._subscriptionId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subscriptionIdInput() {
    return this._subscriptionId;
  }

  // tenant_id - computed: false, optional: true, required: false
  private _tenantId?: string; 
  public get tenantId() {
    return this.getStringAttribute('tenant_id');
  }
  public set tenantId(value: string) {
    this._tenantId = value;
  }
  public resetTenantId() {
    this._tenantId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tenantIdInput() {
    return this._tenantId;
  }
}
export interface ClusterCloudProviderDo {
}

export function clusterCloudProviderDoToTerraform(struct?: ClusterCloudProviderDoOutputReference | ClusterCloudProviderDo): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function clusterCloudProviderDoToHclTerraform(struct?: ClusterCloudProviderDoOutputReference | ClusterCloudProviderDo): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class ClusterCloudProviderDoOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterCloudProviderDo | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterCloudProviderDo | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }
}
export interface ClusterCloudProviderGce {
}

export function clusterCloudProviderGceToTerraform(struct?: ClusterCloudProviderGceOutputReference | ClusterCloudProviderGce): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function clusterCloudProviderGceToHclTerraform(struct?: ClusterCloudProviderGceOutputReference | ClusterCloudProviderGce): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class ClusterCloudProviderGceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterCloudProviderGce | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterCloudProviderGce | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }
}
export interface ClusterCloudProviderHetzner {
}

export function clusterCloudProviderHetznerToTerraform(struct?: ClusterCloudProviderHetznerOutputReference | ClusterCloudProviderHetzner): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function clusterCloudProviderHetznerToHclTerraform(struct?: ClusterCloudProviderHetznerOutputReference | ClusterCloudProviderHetzner): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class ClusterCloudProviderHetznerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterCloudProviderHetzner | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterCloudProviderHetzner | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }
}
export interface ClusterCloudProviderOpenstackBlockStorage {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#create_storage_class Cluster#create_storage_class}
  */
  readonly createStorageClass?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#csi_plugin_image Cluster#csi_plugin_image}
  */
  readonly csiPluginImage?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#csi_topology_support Cluster#csi_topology_support}
  */
  readonly csiTopologySupport?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#ignore_az Cluster#ignore_az}
  */
  readonly ignoreAz?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#override_az Cluster#override_az}
  */
  readonly overrideAz?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#version Cluster#version}
  */
  readonly version?: string;
}

export function clusterCloudProviderOpenstackBlockStorageToTerraform(struct?: ClusterCloudProviderOpenstackBlockStorageOutputReference | ClusterCloudProviderOpenstackBlockStorage): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    create_storage_class: cdktf.booleanToTerraform(struct!.createStorageClass),
    csi_plugin_image: cdktf.stringToTerraform(struct!.csiPluginImage),
    csi_topology_support: cdktf.booleanToTerraform(struct!.csiTopologySupport),
    ignore_az: cdktf.booleanToTerraform(struct!.ignoreAz),
    override_az: cdktf.stringToTerraform(struct!.overrideAz),
    version: cdktf.stringToTerraform(struct!.version),
  }
}


export function clusterCloudProviderOpenstackBlockStorageToHclTerraform(struct?: ClusterCloudProviderOpenstackBlockStorageOutputReference | ClusterCloudProviderOpenstackBlockStorage): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    create_storage_class: {
      value: cdktf.booleanToHclTerraform(struct!.createStorageClass),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    csi_plugin_image: {
      value: cdktf.stringToHclTerraform(struct!.csiPluginImage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    csi_topology_support: {
      value: cdktf.booleanToHclTerraform(struct!.csiTopologySupport),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    ignore_az: {
      value: cdktf.booleanToHclTerraform(struct!.ignoreAz),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    override_az: {
      value: cdktf.stringToHclTerraform(struct!.overrideAz),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    version: {
      value: cdktf.stringToHclTerraform(struct!.version),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterCloudProviderOpenstackBlockStorageOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterCloudProviderOpenstackBlockStorage | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._createStorageClass !== undefined) {
      hasAnyValues = true;
      internalValueResult.createStorageClass = this._createStorageClass;
    }
    if (this._csiPluginImage !== undefined) {
      hasAnyValues = true;
      internalValueResult.csiPluginImage = this._csiPluginImage;
    }
    if (this._csiTopologySupport !== undefined) {
      hasAnyValues = true;
      internalValueResult.csiTopologySupport = this._csiTopologySupport;
    }
    if (this._ignoreAz !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreAz = this._ignoreAz;
    }
    if (this._overrideAz !== undefined) {
      hasAnyValues = true;
      internalValueResult.overrideAz = this._overrideAz;
    }
    if (this._version !== undefined) {
      hasAnyValues = true;
      internalValueResult.version = this._version;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterCloudProviderOpenstackBlockStorage | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._createStorageClass = undefined;
      this._csiPluginImage = undefined;
      this._csiTopologySupport = undefined;
      this._ignoreAz = undefined;
      this._overrideAz = undefined;
      this._version = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._createStorageClass = value.createStorageClass;
      this._csiPluginImage = value.csiPluginImage;
      this._csiTopologySupport = value.csiTopologySupport;
      this._ignoreAz = value.ignoreAz;
      this._overrideAz = value.overrideAz;
      this._version = value.version;
    }
  }

  // create_storage_class - computed: false, optional: true, required: false
  private _createStorageClass?: boolean | cdktf.IResolvable; 
  public get createStorageClass() {
    return this.getBooleanAttribute('create_storage_class');
  }
  public set createStorageClass(value: boolean | cdktf.IResolvable) {
    this._createStorageClass = value;
  }
  public resetCreateStorageClass() {
    this._createStorageClass = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get createStorageClassInput() {
    return this._createStorageClass;
  }

  // csi_plugin_image - computed: false, optional: true, required: false
  private _csiPluginImage?: string; 
  public get csiPluginImage() {
    return this.getStringAttribute('csi_plugin_image');
  }
  public set csiPluginImage(value: string) {
    this._csiPluginImage = value;
  }
  public resetCsiPluginImage() {
    this._csiPluginImage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get csiPluginImageInput() {
    return this._csiPluginImage;
  }

  // csi_topology_support - computed: false, optional: true, required: false
  private _csiTopologySupport?: boolean | cdktf.IResolvable; 
  public get csiTopologySupport() {
    return this.getBooleanAttribute('csi_topology_support');
  }
  public set csiTopologySupport(value: boolean | cdktf.IResolvable) {
    this._csiTopologySupport = value;
  }
  public resetCsiTopologySupport() {
    this._csiTopologySupport = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get csiTopologySupportInput() {
    return this._csiTopologySupport;
  }

  // ignore_az - computed: false, optional: true, required: false
  private _ignoreAz?: boolean | cdktf.IResolvable; 
  public get ignoreAz() {
    return this.getBooleanAttribute('ignore_az');
  }
  public set ignoreAz(value: boolean | cdktf.IResolvable) {
    this._ignoreAz = value;
  }
  public resetIgnoreAz() {
    this._ignoreAz = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreAzInput() {
    return this._ignoreAz;
  }

  // override_az - computed: false, optional: true, required: false
  private _overrideAz?: string; 
  public get overrideAz() {
    return this.getStringAttribute('override_az');
  }
  public set overrideAz(value: string) {
    this._overrideAz = value;
  }
  public resetOverrideAz() {
    this._overrideAz = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overrideAzInput() {
    return this._overrideAz;
  }

  // version - computed: false, optional: true, required: false
  private _version?: string; 
  public get version() {
    return this.getStringAttribute('version');
  }
  public set version(value: string) {
    this._version = value;
  }
  public resetVersion() {
    this._version = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get versionInput() {
    return this._version;
  }
}
export interface ClusterCloudProviderOpenstackLoadbalancer {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#enable_ingress_hostname Cluster#enable_ingress_hostname}
  */
  readonly enableIngressHostname?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#floating_network Cluster#floating_network}
  */
  readonly floatingNetwork?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#floating_network_id Cluster#floating_network_id}
  */
  readonly floatingNetworkId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#floating_subnet Cluster#floating_subnet}
  */
  readonly floatingSubnet?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#ingress_hostname_suffix Cluster#ingress_hostname_suffix}
  */
  readonly ingressHostnameSuffix?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#manage_sec_groups Cluster#manage_sec_groups}
  */
  readonly manageSecGroups?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#method Cluster#method}
  */
  readonly method?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#provider Cluster#provider}
  */
  readonly provider?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#subnet_id Cluster#subnet_id}
  */
  readonly subnetId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#use_octavia Cluster#use_octavia}
  */
  readonly useOctavia?: boolean | cdktf.IResolvable;
}

export function clusterCloudProviderOpenstackLoadbalancerToTerraform(struct?: ClusterCloudProviderOpenstackLoadbalancerOutputReference | ClusterCloudProviderOpenstackLoadbalancer): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enable_ingress_hostname: cdktf.booleanToTerraform(struct!.enableIngressHostname),
    floating_network: cdktf.stringToTerraform(struct!.floatingNetwork),
    floating_network_id: cdktf.stringToTerraform(struct!.floatingNetworkId),
    floating_subnet: cdktf.stringToTerraform(struct!.floatingSubnet),
    ingress_hostname_suffix: cdktf.stringToTerraform(struct!.ingressHostnameSuffix),
    manage_sec_groups: cdktf.booleanToTerraform(struct!.manageSecGroups),
    method: cdktf.stringToTerraform(struct!.method),
    provider: cdktf.stringToTerraform(struct!.provider),
    subnet_id: cdktf.stringToTerraform(struct!.subnetId),
    use_octavia: cdktf.booleanToTerraform(struct!.useOctavia),
  }
}


export function clusterCloudProviderOpenstackLoadbalancerToHclTerraform(struct?: ClusterCloudProviderOpenstackLoadbalancerOutputReference | ClusterCloudProviderOpenstackLoadbalancer): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enable_ingress_hostname: {
      value: cdktf.booleanToHclTerraform(struct!.enableIngressHostname),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    floating_network: {
      value: cdktf.stringToHclTerraform(struct!.floatingNetwork),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    floating_network_id: {
      value: cdktf.stringToHclTerraform(struct!.floatingNetworkId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    floating_subnet: {
      value: cdktf.stringToHclTerraform(struct!.floatingSubnet),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ingress_hostname_suffix: {
      value: cdktf.stringToHclTerraform(struct!.ingressHostnameSuffix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    manage_sec_groups: {
      value: cdktf.booleanToHclTerraform(struct!.manageSecGroups),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    method: {
      value: cdktf.stringToHclTerraform(struct!.method),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    provider: {
      value: cdktf.stringToHclTerraform(struct!.provider),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subnet_id: {
      value: cdktf.stringToHclTerraform(struct!.subnetId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_octavia: {
      value: cdktf.booleanToHclTerraform(struct!.useOctavia),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterCloudProviderOpenstackLoadbalancerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterCloudProviderOpenstackLoadbalancer | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enableIngressHostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableIngressHostname = this._enableIngressHostname;
    }
    if (this._floatingNetwork !== undefined) {
      hasAnyValues = true;
      internalValueResult.floatingNetwork = this._floatingNetwork;
    }
    if (this._floatingNetworkId !== undefined) {
      hasAnyValues = true;
      internalValueResult.floatingNetworkId = this._floatingNetworkId;
    }
    if (this._floatingSubnet !== undefined) {
      hasAnyValues = true;
      internalValueResult.floatingSubnet = this._floatingSubnet;
    }
    if (this._ingressHostnameSuffix !== undefined) {
      hasAnyValues = true;
      internalValueResult.ingressHostnameSuffix = this._ingressHostnameSuffix;
    }
    if (this._manageSecGroups !== undefined) {
      hasAnyValues = true;
      internalValueResult.manageSecGroups = this._manageSecGroups;
    }
    if (this._method !== undefined) {
      hasAnyValues = true;
      internalValueResult.method = this._method;
    }
    if (this._provider !== undefined) {
      hasAnyValues = true;
      internalValueResult.provider = this._provider;
    }
    if (this._subnetId !== undefined) {
      hasAnyValues = true;
      internalValueResult.subnetId = this._subnetId;
    }
    if (this._useOctavia !== undefined) {
      hasAnyValues = true;
      internalValueResult.useOctavia = this._useOctavia;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterCloudProviderOpenstackLoadbalancer | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._enableIngressHostname = undefined;
      this._floatingNetwork = undefined;
      this._floatingNetworkId = undefined;
      this._floatingSubnet = undefined;
      this._ingressHostnameSuffix = undefined;
      this._manageSecGroups = undefined;
      this._method = undefined;
      this._provider = undefined;
      this._subnetId = undefined;
      this._useOctavia = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._enableIngressHostname = value.enableIngressHostname;
      this._floatingNetwork = value.floatingNetwork;
      this._floatingNetworkId = value.floatingNetworkId;
      this._floatingSubnet = value.floatingSubnet;
      this._ingressHostnameSuffix = value.ingressHostnameSuffix;
      this._manageSecGroups = value.manageSecGroups;
      this._method = value.method;
      this._provider = value.provider;
      this._subnetId = value.subnetId;
      this._useOctavia = value.useOctavia;
    }
  }

  // enable_ingress_hostname - computed: false, optional: true, required: false
  private _enableIngressHostname?: boolean | cdktf.IResolvable; 
  public get enableIngressHostname() {
    return this.getBooleanAttribute('enable_ingress_hostname');
  }
  public set enableIngressHostname(value: boolean | cdktf.IResolvable) {
    this._enableIngressHostname = value;
  }
  public resetEnableIngressHostname() {
    this._enableIngressHostname = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableIngressHostnameInput() {
    return this._enableIngressHostname;
  }

  // floating_network - computed: false, optional: true, required: false
  private _floatingNetwork?: string; 
  public get floatingNetwork() {
    return this.getStringAttribute('floating_network');
  }
  public set floatingNetwork(value: string) {
    this._floatingNetwork = value;
  }
  public resetFloatingNetwork() {
    this._floatingNetwork = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get floatingNetworkInput() {
    return this._floatingNetwork;
  }

  // floating_network_id - computed: false, optional: true, required: false
  private _floatingNetworkId?: string; 
  public get floatingNetworkId() {
    return this.getStringAttribute('floating_network_id');
  }
  public set floatingNetworkId(value: string) {
    this._floatingNetworkId = value;
  }
  public resetFloatingNetworkId() {
    this._floatingNetworkId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get floatingNetworkIdInput() {
    return this._floatingNetworkId;
  }

  // floating_subnet - computed: false, optional: true, required: false
  private _floatingSubnet?: string; 
  public get floatingSubnet() {
    return this.getStringAttribute('floating_subnet');
  }
  public set floatingSubnet(value: string) {
    this._floatingSubnet = value;
  }
  public resetFloatingSubnet() {
    this._floatingSubnet = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get floatingSubnetInput() {
    return this._floatingSubnet;
  }

  // ingress_hostname_suffix - computed: false, optional: true, required: false
  private _ingressHostnameSuffix?: string; 
  public get ingressHostnameSuffix() {
    return this.getStringAttribute('ingress_hostname_suffix');
  }
  public set ingressHostnameSuffix(value: string) {
    this._ingressHostnameSuffix = value;
  }
  public resetIngressHostnameSuffix() {
    this._ingressHostnameSuffix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ingressHostnameSuffixInput() {
    return this._ingressHostnameSuffix;
  }

  // manage_sec_groups - computed: false, optional: true, required: false
  private _manageSecGroups?: boolean | cdktf.IResolvable; 
  public get manageSecGroups() {
    return this.getBooleanAttribute('manage_sec_groups');
  }
  public set manageSecGroups(value: boolean | cdktf.IResolvable) {
    this._manageSecGroups = value;
  }
  public resetManageSecGroups() {
    this._manageSecGroups = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get manageSecGroupsInput() {
    return this._manageSecGroups;
  }

  // method - computed: false, optional: true, required: false
  private _method?: string; 
  public get method() {
    return this.getStringAttribute('method');
  }
  public set method(value: string) {
    this._method = value;
  }
  public resetMethod() {
    this._method = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get methodInput() {
    return this._method;
  }

  // provider - computed: false, optional: true, required: false
  private _provider?: string; 
  public get provider() {
    return this.getStringAttribute('provider');
  }
  public set provider(value: string) {
    this._provider = value;
  }
  public resetProvider() {
    this._provider = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get providerInput() {
    return this._provider;
  }

  // subnet_id - computed: false, optional: true, required: false
  private _subnetId?: string; 
  public get subnetId() {
    return this.getStringAttribute('subnet_id');
  }
  public set subnetId(value: string) {
    this._subnetId = value;
  }
  public resetSubnetId() {
    this._subnetId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subnetIdInput() {
    return this._subnetId;
  }

  // use_octavia - computed: false, optional: true, required: false
  private _useOctavia?: boolean | cdktf.IResolvable; 
  public get useOctavia() {
    return this.getBooleanAttribute('use_octavia');
  }
  public set useOctavia(value: boolean | cdktf.IResolvable) {
    this._useOctavia = value;
  }
  public resetUseOctavia() {
    this._useOctavia = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useOctaviaInput() {
    return this._useOctavia;
  }
}
export interface ClusterCloudProviderOpenstackMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#config_drive Cluster#config_drive}
  */
  readonly configDrive?: boolean | cdktf.IResolvable;
}

export function clusterCloudProviderOpenstackMetadataToTerraform(struct?: ClusterCloudProviderOpenstackMetadataOutputReference | ClusterCloudProviderOpenstackMetadata): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    config_drive: cdktf.booleanToTerraform(struct!.configDrive),
  }
}


export function clusterCloudProviderOpenstackMetadataToHclTerraform(struct?: ClusterCloudProviderOpenstackMetadataOutputReference | ClusterCloudProviderOpenstackMetadata): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    config_drive: {
      value: cdktf.booleanToHclTerraform(struct!.configDrive),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterCloudProviderOpenstackMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterCloudProviderOpenstackMetadata | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._configDrive !== undefined) {
      hasAnyValues = true;
      internalValueResult.configDrive = this._configDrive;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterCloudProviderOpenstackMetadata | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._configDrive = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._configDrive = value.configDrive;
    }
  }

  // config_drive - computed: false, optional: true, required: false
  private _configDrive?: boolean | cdktf.IResolvable; 
  public get configDrive() {
    return this.getBooleanAttribute('config_drive');
  }
  public set configDrive(value: boolean | cdktf.IResolvable) {
    this._configDrive = value;
  }
  public resetConfigDrive() {
    this._configDrive = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configDriveInput() {
    return this._configDrive;
  }
}
export interface ClusterCloudProviderOpenstackMonitor {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#delay Cluster#delay}
  */
  readonly delay?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#max_retries Cluster#max_retries}
  */
  readonly maxRetries?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#timeout Cluster#timeout}
  */
  readonly timeout?: string;
}

export function clusterCloudProviderOpenstackMonitorToTerraform(struct?: ClusterCloudProviderOpenstackMonitorOutputReference | ClusterCloudProviderOpenstackMonitor): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    delay: cdktf.stringToTerraform(struct!.delay),
    max_retries: cdktf.numberToTerraform(struct!.maxRetries),
    timeout: cdktf.stringToTerraform(struct!.timeout),
  }
}


export function clusterCloudProviderOpenstackMonitorToHclTerraform(struct?: ClusterCloudProviderOpenstackMonitorOutputReference | ClusterCloudProviderOpenstackMonitor): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    delay: {
      value: cdktf.stringToHclTerraform(struct!.delay),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_retries: {
      value: cdktf.numberToHclTerraform(struct!.maxRetries),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout: {
      value: cdktf.stringToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterCloudProviderOpenstackMonitorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterCloudProviderOpenstackMonitor | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._delay !== undefined) {
      hasAnyValues = true;
      internalValueResult.delay = this._delay;
    }
    if (this._maxRetries !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRetries = this._maxRetries;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterCloudProviderOpenstackMonitor | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._delay = undefined;
      this._maxRetries = undefined;
      this._timeout = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._delay = value.delay;
      this._maxRetries = value.maxRetries;
      this._timeout = value.timeout;
    }
  }

  // delay - computed: false, optional: true, required: false
  private _delay?: string; 
  public get delay() {
    return this.getStringAttribute('delay');
  }
  public set delay(value: string) {
    this._delay = value;
  }
  public resetDelay() {
    this._delay = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get delayInput() {
    return this._delay;
  }

  // max_retries - computed: false, optional: true, required: false
  private _maxRetries?: number; 
  public get maxRetries() {
    return this.getNumberAttribute('max_retries');
  }
  public set maxRetries(value: number) {
    this._maxRetries = value;
  }
  public resetMaxRetries() {
    this._maxRetries = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRetriesInput() {
    return this._maxRetries;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: string; 
  public get timeout() {
    return this.getStringAttribute('timeout');
  }
  public set timeout(value: string) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface ClusterCloudProviderOpenstackNetwork {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#availability_zone_hints Cluster#availability_zone_hints}
  */
  readonly availabilityZoneHints?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#internal_network_names Cluster#internal_network_names}
  */
  readonly internalNetworkNames?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#ipv6_support_disabled Cluster#ipv6_support_disabled}
  */
  readonly ipv6SupportDisabled?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#public_network_names Cluster#public_network_names}
  */
  readonly publicNetworkNames?: string[];
}

export function clusterCloudProviderOpenstackNetworkToTerraform(struct?: ClusterCloudProviderOpenstackNetworkOutputReference | ClusterCloudProviderOpenstackNetwork): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    availability_zone_hints: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.availabilityZoneHints),
    internal_network_names: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.internalNetworkNames),
    ipv6_support_disabled: cdktf.booleanToTerraform(struct!.ipv6SupportDisabled),
    public_network_names: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.publicNetworkNames),
  }
}


export function clusterCloudProviderOpenstackNetworkToHclTerraform(struct?: ClusterCloudProviderOpenstackNetworkOutputReference | ClusterCloudProviderOpenstackNetwork): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    availability_zone_hints: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.availabilityZoneHints),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    internal_network_names: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.internalNetworkNames),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    ipv6_support_disabled: {
      value: cdktf.booleanToHclTerraform(struct!.ipv6SupportDisabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    public_network_names: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.publicNetworkNames),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterCloudProviderOpenstackNetworkOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterCloudProviderOpenstackNetwork | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._availabilityZoneHints !== undefined) {
      hasAnyValues = true;
      internalValueResult.availabilityZoneHints = this._availabilityZoneHints;
    }
    if (this._internalNetworkNames !== undefined) {
      hasAnyValues = true;
      internalValueResult.internalNetworkNames = this._internalNetworkNames;
    }
    if (this._ipv6SupportDisabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipv6SupportDisabled = this._ipv6SupportDisabled;
    }
    if (this._publicNetworkNames !== undefined) {
      hasAnyValues = true;
      internalValueResult.publicNetworkNames = this._publicNetworkNames;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterCloudProviderOpenstackNetwork | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._availabilityZoneHints = undefined;
      this._internalNetworkNames = undefined;
      this._ipv6SupportDisabled = undefined;
      this._publicNetworkNames = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._availabilityZoneHints = value.availabilityZoneHints;
      this._internalNetworkNames = value.internalNetworkNames;
      this._ipv6SupportDisabled = value.ipv6SupportDisabled;
      this._publicNetworkNames = value.publicNetworkNames;
    }
  }

  // availability_zone_hints - computed: false, optional: true, required: false
  private _availabilityZoneHints?: string[]; 
  public get availabilityZoneHints() {
    return this.getListAttribute('availability_zone_hints');
  }
  public set availabilityZoneHints(value: string[]) {
    this._availabilityZoneHints = value;
  }
  public resetAvailabilityZoneHints() {
    this._availabilityZoneHints = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get availabilityZoneHintsInput() {
    return this._availabilityZoneHints;
  }

  // internal_network_names - computed: false, optional: true, required: false
  private _internalNetworkNames?: string[]; 
  public get internalNetworkNames() {
    return this.getListAttribute('internal_network_names');
  }
  public set internalNetworkNames(value: string[]) {
    this._internalNetworkNames = value;
  }
  public resetInternalNetworkNames() {
    this._internalNetworkNames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get internalNetworkNamesInput() {
    return this._internalNetworkNames;
  }

  // ipv6_support_disabled - computed: false, optional: true, required: false
  private _ipv6SupportDisabled?: boolean | cdktf.IResolvable; 
  public get ipv6SupportDisabled() {
    return this.getBooleanAttribute('ipv6_support_disabled');
  }
  public set ipv6SupportDisabled(value: boolean | cdktf.IResolvable) {
    this._ipv6SupportDisabled = value;
  }
  public resetIpv6SupportDisabled() {
    this._ipv6SupportDisabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipv6SupportDisabledInput() {
    return this._ipv6SupportDisabled;
  }

  // public_network_names - computed: false, optional: true, required: false
  private _publicNetworkNames?: string[]; 
  public get publicNetworkNames() {
    return this.getListAttribute('public_network_names');
  }
  public set publicNetworkNames(value: string[]) {
    this._publicNetworkNames = value;
  }
  public resetPublicNetworkNames() {
    this._publicNetworkNames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get publicNetworkNamesInput() {
    return this._publicNetworkNames;
  }
}
export interface ClusterCloudProviderOpenstackRouter {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#availability_zone_hints Cluster#availability_zone_hints}
  */
  readonly availabilityZoneHints?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#dns_servers Cluster#dns_servers}
  */
  readonly dnsServers?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#external_network Cluster#external_network}
  */
  readonly externalNetwork?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#external_subnet Cluster#external_subnet}
  */
  readonly externalSubnet?: string;
}

export function clusterCloudProviderOpenstackRouterToTerraform(struct?: ClusterCloudProviderOpenstackRouterOutputReference | ClusterCloudProviderOpenstackRouter): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    availability_zone_hints: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.availabilityZoneHints),
    dns_servers: cdktf.stringToTerraform(struct!.dnsServers),
    external_network: cdktf.stringToTerraform(struct!.externalNetwork),
    external_subnet: cdktf.stringToTerraform(struct!.externalSubnet),
  }
}


export function clusterCloudProviderOpenstackRouterToHclTerraform(struct?: ClusterCloudProviderOpenstackRouterOutputReference | ClusterCloudProviderOpenstackRouter): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    availability_zone_hints: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.availabilityZoneHints),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    dns_servers: {
      value: cdktf.stringToHclTerraform(struct!.dnsServers),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    external_network: {
      value: cdktf.stringToHclTerraform(struct!.externalNetwork),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    external_subnet: {
      value: cdktf.stringToHclTerraform(struct!.externalSubnet),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterCloudProviderOpenstackRouterOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterCloudProviderOpenstackRouter | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._availabilityZoneHints !== undefined) {
      hasAnyValues = true;
      internalValueResult.availabilityZoneHints = this._availabilityZoneHints;
    }
    if (this._dnsServers !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsServers = this._dnsServers;
    }
    if (this._externalNetwork !== undefined) {
      hasAnyValues = true;
      internalValueResult.externalNetwork = this._externalNetwork;
    }
    if (this._externalSubnet !== undefined) {
      hasAnyValues = true;
      internalValueResult.externalSubnet = this._externalSubnet;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterCloudProviderOpenstackRouter | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._availabilityZoneHints = undefined;
      this._dnsServers = undefined;
      this._externalNetwork = undefined;
      this._externalSubnet = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._availabilityZoneHints = value.availabilityZoneHints;
      this._dnsServers = value.dnsServers;
      this._externalNetwork = value.externalNetwork;
      this._externalSubnet = value.externalSubnet;
    }
  }

  // availability_zone_hints - computed: false, optional: true, required: false
  private _availabilityZoneHints?: string[]; 
  public get availabilityZoneHints() {
    return this.getListAttribute('availability_zone_hints');
  }
  public set availabilityZoneHints(value: string[]) {
    this._availabilityZoneHints = value;
  }
  public resetAvailabilityZoneHints() {
    this._availabilityZoneHints = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get availabilityZoneHintsInput() {
    return this._availabilityZoneHints;
  }

  // dns_servers - computed: false, optional: true, required: false
  private _dnsServers?: string; 
  public get dnsServers() {
    return this.getStringAttribute('dns_servers');
  }
  public set dnsServers(value: string) {
    this._dnsServers = value;
  }
  public resetDnsServers() {
    this._dnsServers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsServersInput() {
    return this._dnsServers;
  }

  // external_network - computed: false, optional: true, required: false
  private _externalNetwork?: string; 
  public get externalNetwork() {
    return this.getStringAttribute('external_network');
  }
  public set externalNetwork(value: string) {
    this._externalNetwork = value;
  }
  public resetExternalNetwork() {
    this._externalNetwork = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get externalNetworkInput() {
    return this._externalNetwork;
  }

  // external_subnet - computed: false, optional: true, required: false
  private _externalSubnet?: string; 
  public get externalSubnet() {
    return this.getStringAttribute('external_subnet');
  }
  public set externalSubnet(value: string) {
    this._externalSubnet = value;
  }
  public resetExternalSubnet() {
    this._externalSubnet = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get externalSubnetInput() {
    return this._externalSubnet;
  }
}
export interface ClusterCloudProviderOpenstack {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#insecure_skip_verify Cluster#insecure_skip_verify}
  */
  readonly insecureSkipVerify?: boolean | cdktf.IResolvable;
  /**
  * block_storage block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#block_storage Cluster#block_storage}
  */
  readonly blockStorage?: ClusterCloudProviderOpenstackBlockStorage;
  /**
  * loadbalancer block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#loadbalancer Cluster#loadbalancer}
  */
  readonly loadbalancer?: ClusterCloudProviderOpenstackLoadbalancer;
  /**
  * metadata block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#metadata Cluster#metadata}
  */
  readonly metadata?: ClusterCloudProviderOpenstackMetadata;
  /**
  * monitor block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#monitor Cluster#monitor}
  */
  readonly monitor?: ClusterCloudProviderOpenstackMonitor;
  /**
  * network block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#network Cluster#network}
  */
  readonly network?: ClusterCloudProviderOpenstackNetwork;
  /**
  * router block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#router Cluster#router}
  */
  readonly router?: ClusterCloudProviderOpenstackRouter;
}

export function clusterCloudProviderOpenstackToTerraform(struct?: ClusterCloudProviderOpenstackOutputReference | ClusterCloudProviderOpenstack): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    insecure_skip_verify: cdktf.booleanToTerraform(struct!.insecureSkipVerify),
    block_storage: clusterCloudProviderOpenstackBlockStorageToTerraform(struct!.blockStorage),
    loadbalancer: clusterCloudProviderOpenstackLoadbalancerToTerraform(struct!.loadbalancer),
    metadata: clusterCloudProviderOpenstackMetadataToTerraform(struct!.metadata),
    monitor: clusterCloudProviderOpenstackMonitorToTerraform(struct!.monitor),
    network: clusterCloudProviderOpenstackNetworkToTerraform(struct!.network),
    router: clusterCloudProviderOpenstackRouterToTerraform(struct!.router),
  }
}


export function clusterCloudProviderOpenstackToHclTerraform(struct?: ClusterCloudProviderOpenstackOutputReference | ClusterCloudProviderOpenstack): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    insecure_skip_verify: {
      value: cdktf.booleanToHclTerraform(struct!.insecureSkipVerify),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    block_storage: {
      value: clusterCloudProviderOpenstackBlockStorageToHclTerraform(struct!.blockStorage),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterCloudProviderOpenstackBlockStorageList",
    },
    loadbalancer: {
      value: clusterCloudProviderOpenstackLoadbalancerToHclTerraform(struct!.loadbalancer),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterCloudProviderOpenstackLoadbalancerList",
    },
    metadata: {
      value: clusterCloudProviderOpenstackMetadataToHclTerraform(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterCloudProviderOpenstackMetadataList",
    },
    monitor: {
      value: clusterCloudProviderOpenstackMonitorToHclTerraform(struct!.monitor),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterCloudProviderOpenstackMonitorList",
    },
    network: {
      value: clusterCloudProviderOpenstackNetworkToHclTerraform(struct!.network),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterCloudProviderOpenstackNetworkList",
    },
    router: {
      value: clusterCloudProviderOpenstackRouterToHclTerraform(struct!.router),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterCloudProviderOpenstackRouterList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterCloudProviderOpenstackOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterCloudProviderOpenstack | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._insecureSkipVerify !== undefined) {
      hasAnyValues = true;
      internalValueResult.insecureSkipVerify = this._insecureSkipVerify;
    }
    if (this._blockStorage?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.blockStorage = this._blockStorage?.internalValue;
    }
    if (this._loadbalancer?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadbalancer = this._loadbalancer?.internalValue;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._monitor?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitor = this._monitor?.internalValue;
    }
    if (this._network?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.network = this._network?.internalValue;
    }
    if (this._router?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.router = this._router?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterCloudProviderOpenstack | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._insecureSkipVerify = undefined;
      this._blockStorage.internalValue = undefined;
      this._loadbalancer.internalValue = undefined;
      this._metadata.internalValue = undefined;
      this._monitor.internalValue = undefined;
      this._network.internalValue = undefined;
      this._router.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._insecureSkipVerify = value.insecureSkipVerify;
      this._blockStorage.internalValue = value.blockStorage;
      this._loadbalancer.internalValue = value.loadbalancer;
      this._metadata.internalValue = value.metadata;
      this._monitor.internalValue = value.monitor;
      this._network.internalValue = value.network;
      this._router.internalValue = value.router;
    }
  }

  // insecure_skip_verify - computed: false, optional: true, required: false
  private _insecureSkipVerify?: boolean | cdktf.IResolvable; 
  public get insecureSkipVerify() {
    return this.getBooleanAttribute('insecure_skip_verify');
  }
  public set insecureSkipVerify(value: boolean | cdktf.IResolvable) {
    this._insecureSkipVerify = value;
  }
  public resetInsecureSkipVerify() {
    this._insecureSkipVerify = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get insecureSkipVerifyInput() {
    return this._insecureSkipVerify;
  }

  // block_storage - computed: false, optional: true, required: false
  private _blockStorage = new ClusterCloudProviderOpenstackBlockStorageOutputReference(this, "block_storage");
  public get blockStorage() {
    return this._blockStorage;
  }
  public putBlockStorage(value: ClusterCloudProviderOpenstackBlockStorage) {
    this._blockStorage.internalValue = value;
  }
  public resetBlockStorage() {
    this._blockStorage.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get blockStorageInput() {
    return this._blockStorage.internalValue;
  }

  // loadbalancer - computed: false, optional: true, required: false
  private _loadbalancer = new ClusterCloudProviderOpenstackLoadbalancerOutputReference(this, "loadbalancer");
  public get loadbalancer() {
    return this._loadbalancer;
  }
  public putLoadbalancer(value: ClusterCloudProviderOpenstackLoadbalancer) {
    this._loadbalancer.internalValue = value;
  }
  public resetLoadbalancer() {
    this._loadbalancer.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadbalancerInput() {
    return this._loadbalancer.internalValue;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new ClusterCloudProviderOpenstackMetadataOutputReference(this, "metadata");
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: ClusterCloudProviderOpenstackMetadata) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // monitor - computed: false, optional: true, required: false
  private _monitor = new ClusterCloudProviderOpenstackMonitorOutputReference(this, "monitor");
  public get monitor() {
    return this._monitor;
  }
  public putMonitor(value: ClusterCloudProviderOpenstackMonitor) {
    this._monitor.internalValue = value;
  }
  public resetMonitor() {
    this._monitor.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitorInput() {
    return this._monitor.internalValue;
  }

  // network - computed: false, optional: true, required: false
  private _network = new ClusterCloudProviderOpenstackNetworkOutputReference(this, "network");
  public get network() {
    return this._network;
  }
  public putNetwork(value: ClusterCloudProviderOpenstackNetwork) {
    this._network.internalValue = value;
  }
  public resetNetwork() {
    this._network.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get networkInput() {
    return this._network.internalValue;
  }

  // router - computed: false, optional: true, required: false
  private _router = new ClusterCloudProviderOpenstackRouterOutputReference(this, "router");
  public get router() {
    return this._router;
  }
  public putRouter(value: ClusterCloudProviderOpenstackRouter) {
    this._router.internalValue = value;
  }
  public resetRouter() {
    this._router.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routerInput() {
    return this._router.internalValue;
  }
}
export interface ClusterCloudProvider {
  /**
  * aws block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#aws Cluster#aws}
  */
  readonly aws?: ClusterCloudProviderAws;
  /**
  * azure block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#azure Cluster#azure}
  */
  readonly azure?: ClusterCloudProviderAzure;
  /**
  * do block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#do Cluster#do}
  */
  readonly do?: ClusterCloudProviderDo;
  /**
  * gce block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#gce Cluster#gce}
  */
  readonly gce?: ClusterCloudProviderGce;
  /**
  * hetzner block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#hetzner Cluster#hetzner}
  */
  readonly hetzner?: ClusterCloudProviderHetzner;
  /**
  * openstack block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#openstack Cluster#openstack}
  */
  readonly openstack?: ClusterCloudProviderOpenstack;
}

export function clusterCloudProviderToTerraform(struct?: ClusterCloudProviderOutputReference | ClusterCloudProvider): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    aws: clusterCloudProviderAwsToTerraform(struct!.aws),
    azure: clusterCloudProviderAzureToTerraform(struct!.azure),
    do: clusterCloudProviderDoToTerraform(struct!.do),
    gce: clusterCloudProviderGceToTerraform(struct!.gce),
    hetzner: clusterCloudProviderHetznerToTerraform(struct!.hetzner),
    openstack: clusterCloudProviderOpenstackToTerraform(struct!.openstack),
  }
}


export function clusterCloudProviderToHclTerraform(struct?: ClusterCloudProviderOutputReference | ClusterCloudProvider): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    aws: {
      value: clusterCloudProviderAwsToHclTerraform(struct!.aws),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterCloudProviderAwsList",
    },
    azure: {
      value: clusterCloudProviderAzureToHclTerraform(struct!.azure),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterCloudProviderAzureList",
    },
    do: {
      value: clusterCloudProviderDoToHclTerraform(struct!.do),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterCloudProviderDoList",
    },
    gce: {
      value: clusterCloudProviderGceToHclTerraform(struct!.gce),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterCloudProviderGceList",
    },
    hetzner: {
      value: clusterCloudProviderHetznerToHclTerraform(struct!.hetzner),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterCloudProviderHetznerList",
    },
    openstack: {
      value: clusterCloudProviderOpenstackToHclTerraform(struct!.openstack),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterCloudProviderOpenstackList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterCloudProviderOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterCloudProvider | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._aws?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.aws = this._aws?.internalValue;
    }
    if (this._azure?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.azure = this._azure?.internalValue;
    }
    if (this._do?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.do = this._do?.internalValue;
    }
    if (this._gce?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.gce = this._gce?.internalValue;
    }
    if (this._hetzner?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.hetzner = this._hetzner?.internalValue;
    }
    if (this._openstack?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.openstack = this._openstack?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterCloudProvider | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._aws.internalValue = undefined;
      this._azure.internalValue = undefined;
      this._do.internalValue = undefined;
      this._gce.internalValue = undefined;
      this._hetzner.internalValue = undefined;
      this._openstack.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._aws.internalValue = value.aws;
      this._azure.internalValue = value.azure;
      this._do.internalValue = value.do;
      this._gce.internalValue = value.gce;
      this._hetzner.internalValue = value.hetzner;
      this._openstack.internalValue = value.openstack;
    }
  }

  // aws - computed: false, optional: true, required: false
  private _aws = new ClusterCloudProviderAwsOutputReference(this, "aws");
  public get aws() {
    return this._aws;
  }
  public putAws(value: ClusterCloudProviderAws) {
    this._aws.internalValue = value;
  }
  public resetAws() {
    this._aws.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsInput() {
    return this._aws.internalValue;
  }

  // azure - computed: false, optional: true, required: false
  private _azure = new ClusterCloudProviderAzureOutputReference(this, "azure");
  public get azure() {
    return this._azure;
  }
  public putAzure(value: ClusterCloudProviderAzure) {
    this._azure.internalValue = value;
  }
  public resetAzure() {
    this._azure.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get azureInput() {
    return this._azure.internalValue;
  }

  // do - computed: false, optional: true, required: false
  private _do = new ClusterCloudProviderDoOutputReference(this, "do");
  public get do() {
    return this._do;
  }
  public putDo(value: ClusterCloudProviderDo) {
    this._do.internalValue = value;
  }
  public resetDo() {
    this._do.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get doInput() {
    return this._do.internalValue;
  }

  // gce - computed: false, optional: true, required: false
  private _gce = new ClusterCloudProviderGceOutputReference(this, "gce");
  public get gce() {
    return this._gce;
  }
  public putGce(value: ClusterCloudProviderGce) {
    this._gce.internalValue = value;
  }
  public resetGce() {
    this._gce.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gceInput() {
    return this._gce.internalValue;
  }

  // hetzner - computed: false, optional: true, required: false
  private _hetzner = new ClusterCloudProviderHetznerOutputReference(this, "hetzner");
  public get hetzner() {
    return this._hetzner;
  }
  public putHetzner(value: ClusterCloudProviderHetzner) {
    this._hetzner.internalValue = value;
  }
  public resetHetzner() {
    this._hetzner.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hetznerInput() {
    return this._hetzner.internalValue;
  }

  // openstack - computed: false, optional: true, required: false
  private _openstack = new ClusterCloudProviderOpenstackOutputReference(this, "openstack");
  public get openstack() {
    return this._openstack;
  }
  public putOpenstack(value: ClusterCloudProviderOpenstack) {
    this._openstack.internalValue = value;
  }
  public resetOpenstack() {
    this._openstack.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get openstackInput() {
    return this._openstack.internalValue;
  }
}
export interface ClusterClusterAutoscaler {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#aws_use_static_instance_list Cluster#aws_use_static_instance_list}
  */
  readonly awsUseStaticInstanceList?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#balance_similar_node_groups Cluster#balance_similar_node_groups}
  */
  readonly balanceSimilarNodeGroups?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#cordon_node_before_terminating Cluster#cordon_node_before_terminating}
  */
  readonly cordonNodeBeforeTerminating?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#cpu_request Cluster#cpu_request}
  */
  readonly cpuRequest?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#enabled Cluster#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#expander Cluster#expander}
  */
  readonly expander?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#image Cluster#image}
  */
  readonly image?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#max_node_provision_time Cluster#max_node_provision_time}
  */
  readonly maxNodeProvisionTime?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#memory_request Cluster#memory_request}
  */
  readonly memoryRequest?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#new_pod_scale_up_delay Cluster#new_pod_scale_up_delay}
  */
  readonly newPodScaleUpDelay?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#pod_annotations Cluster#pod_annotations}
  */
  readonly podAnnotations?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#scale_down_delay_after_add Cluster#scale_down_delay_after_add}
  */
  readonly scaleDownDelayAfterAdd?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#scale_down_unneeded_time Cluster#scale_down_unneeded_time}
  */
  readonly scaleDownUnneededTime?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#scale_down_unready_time Cluster#scale_down_unready_time}
  */
  readonly scaleDownUnreadyTime?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#scale_down_utilization_threshold Cluster#scale_down_utilization_threshold}
  */
  readonly scaleDownUtilizationThreshold?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#skip_nodes_with_local_storage Cluster#skip_nodes_with_local_storage}
  */
  readonly skipNodesWithLocalStorage: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#skip_nodes_with_system_pods Cluster#skip_nodes_with_system_pods}
  */
  readonly skipNodesWithSystemPods: boolean | cdktf.IResolvable;
}

export function clusterClusterAutoscalerToTerraform(struct?: ClusterClusterAutoscalerOutputReference | ClusterClusterAutoscaler): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    aws_use_static_instance_list: cdktf.booleanToTerraform(struct!.awsUseStaticInstanceList),
    balance_similar_node_groups: cdktf.booleanToTerraform(struct!.balanceSimilarNodeGroups),
    cordon_node_before_terminating: cdktf.booleanToTerraform(struct!.cordonNodeBeforeTerminating),
    cpu_request: cdktf.stringToTerraform(struct!.cpuRequest),
    enabled: cdktf.booleanToTerraform(struct!.enabled),
    expander: cdktf.stringToTerraform(struct!.expander),
    image: cdktf.stringToTerraform(struct!.image),
    max_node_provision_time: cdktf.stringToTerraform(struct!.maxNodeProvisionTime),
    memory_request: cdktf.stringToTerraform(struct!.memoryRequest),
    new_pod_scale_up_delay: cdktf.stringToTerraform(struct!.newPodScaleUpDelay),
    pod_annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.podAnnotations),
    scale_down_delay_after_add: cdktf.stringToTerraform(struct!.scaleDownDelayAfterAdd),
    scale_down_unneeded_time: cdktf.stringToTerraform(struct!.scaleDownUnneededTime),
    scale_down_unready_time: cdktf.stringToTerraform(struct!.scaleDownUnreadyTime),
    scale_down_utilization_threshold: cdktf.stringToTerraform(struct!.scaleDownUtilizationThreshold),
    skip_nodes_with_local_storage: cdktf.booleanToTerraform(struct!.skipNodesWithLocalStorage),
    skip_nodes_with_system_pods: cdktf.booleanToTerraform(struct!.skipNodesWithSystemPods),
  }
}


export function clusterClusterAutoscalerToHclTerraform(struct?: ClusterClusterAutoscalerOutputReference | ClusterClusterAutoscaler): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    aws_use_static_instance_list: {
      value: cdktf.booleanToHclTerraform(struct!.awsUseStaticInstanceList),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    balance_similar_node_groups: {
      value: cdktf.booleanToHclTerraform(struct!.balanceSimilarNodeGroups),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    cordon_node_before_terminating: {
      value: cdktf.booleanToHclTerraform(struct!.cordonNodeBeforeTerminating),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    cpu_request: {
      value: cdktf.stringToHclTerraform(struct!.cpuRequest),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    expander: {
      value: cdktf.stringToHclTerraform(struct!.expander),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    image: {
      value: cdktf.stringToHclTerraform(struct!.image),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_node_provision_time: {
      value: cdktf.stringToHclTerraform(struct!.maxNodeProvisionTime),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    memory_request: {
      value: cdktf.stringToHclTerraform(struct!.memoryRequest),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    new_pod_scale_up_delay: {
      value: cdktf.stringToHclTerraform(struct!.newPodScaleUpDelay),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pod_annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.podAnnotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    scale_down_delay_after_add: {
      value: cdktf.stringToHclTerraform(struct!.scaleDownDelayAfterAdd),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    scale_down_unneeded_time: {
      value: cdktf.stringToHclTerraform(struct!.scaleDownUnneededTime),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    scale_down_unready_time: {
      value: cdktf.stringToHclTerraform(struct!.scaleDownUnreadyTime),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    scale_down_utilization_threshold: {
      value: cdktf.stringToHclTerraform(struct!.scaleDownUtilizationThreshold),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    skip_nodes_with_local_storage: {
      value: cdktf.booleanToHclTerraform(struct!.skipNodesWithLocalStorage),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    skip_nodes_with_system_pods: {
      value: cdktf.booleanToHclTerraform(struct!.skipNodesWithSystemPods),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterClusterAutoscalerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterClusterAutoscaler | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._awsUseStaticInstanceList !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsUseStaticInstanceList = this._awsUseStaticInstanceList;
    }
    if (this._balanceSimilarNodeGroups !== undefined) {
      hasAnyValues = true;
      internalValueResult.balanceSimilarNodeGroups = this._balanceSimilarNodeGroups;
    }
    if (this._cordonNodeBeforeTerminating !== undefined) {
      hasAnyValues = true;
      internalValueResult.cordonNodeBeforeTerminating = this._cordonNodeBeforeTerminating;
    }
    if (this._cpuRequest !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpuRequest = this._cpuRequest;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._expander !== undefined) {
      hasAnyValues = true;
      internalValueResult.expander = this._expander;
    }
    if (this._image !== undefined) {
      hasAnyValues = true;
      internalValueResult.image = this._image;
    }
    if (this._maxNodeProvisionTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxNodeProvisionTime = this._maxNodeProvisionTime;
    }
    if (this._memoryRequest !== undefined) {
      hasAnyValues = true;
      internalValueResult.memoryRequest = this._memoryRequest;
    }
    if (this._newPodScaleUpDelay !== undefined) {
      hasAnyValues = true;
      internalValueResult.newPodScaleUpDelay = this._newPodScaleUpDelay;
    }
    if (this._podAnnotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.podAnnotations = this._podAnnotations;
    }
    if (this._scaleDownDelayAfterAdd !== undefined) {
      hasAnyValues = true;
      internalValueResult.scaleDownDelayAfterAdd = this._scaleDownDelayAfterAdd;
    }
    if (this._scaleDownUnneededTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.scaleDownUnneededTime = this._scaleDownUnneededTime;
    }
    if (this._scaleDownUnreadyTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.scaleDownUnreadyTime = this._scaleDownUnreadyTime;
    }
    if (this._scaleDownUtilizationThreshold !== undefined) {
      hasAnyValues = true;
      internalValueResult.scaleDownUtilizationThreshold = this._scaleDownUtilizationThreshold;
    }
    if (this._skipNodesWithLocalStorage !== undefined) {
      hasAnyValues = true;
      internalValueResult.skipNodesWithLocalStorage = this._skipNodesWithLocalStorage;
    }
    if (this._skipNodesWithSystemPods !== undefined) {
      hasAnyValues = true;
      internalValueResult.skipNodesWithSystemPods = this._skipNodesWithSystemPods;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterClusterAutoscaler | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._awsUseStaticInstanceList = undefined;
      this._balanceSimilarNodeGroups = undefined;
      this._cordonNodeBeforeTerminating = undefined;
      this._cpuRequest = undefined;
      this._enabled = undefined;
      this._expander = undefined;
      this._image = undefined;
      this._maxNodeProvisionTime = undefined;
      this._memoryRequest = undefined;
      this._newPodScaleUpDelay = undefined;
      this._podAnnotations = undefined;
      this._scaleDownDelayAfterAdd = undefined;
      this._scaleDownUnneededTime = undefined;
      this._scaleDownUnreadyTime = undefined;
      this._scaleDownUtilizationThreshold = undefined;
      this._skipNodesWithLocalStorage = undefined;
      this._skipNodesWithSystemPods = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._awsUseStaticInstanceList = value.awsUseStaticInstanceList;
      this._balanceSimilarNodeGroups = value.balanceSimilarNodeGroups;
      this._cordonNodeBeforeTerminating = value.cordonNodeBeforeTerminating;
      this._cpuRequest = value.cpuRequest;
      this._enabled = value.enabled;
      this._expander = value.expander;
      this._image = value.image;
      this._maxNodeProvisionTime = value.maxNodeProvisionTime;
      this._memoryRequest = value.memoryRequest;
      this._newPodScaleUpDelay = value.newPodScaleUpDelay;
      this._podAnnotations = value.podAnnotations;
      this._scaleDownDelayAfterAdd = value.scaleDownDelayAfterAdd;
      this._scaleDownUnneededTime = value.scaleDownUnneededTime;
      this._scaleDownUnreadyTime = value.scaleDownUnreadyTime;
      this._scaleDownUtilizationThreshold = value.scaleDownUtilizationThreshold;
      this._skipNodesWithLocalStorage = value.skipNodesWithLocalStorage;
      this._skipNodesWithSystemPods = value.skipNodesWithSystemPods;
    }
  }

  // aws_use_static_instance_list - computed: false, optional: true, required: false
  private _awsUseStaticInstanceList?: boolean | cdktf.IResolvable; 
  public get awsUseStaticInstanceList() {
    return this.getBooleanAttribute('aws_use_static_instance_list');
  }
  public set awsUseStaticInstanceList(value: boolean | cdktf.IResolvable) {
    this._awsUseStaticInstanceList = value;
  }
  public resetAwsUseStaticInstanceList() {
    this._awsUseStaticInstanceList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsUseStaticInstanceListInput() {
    return this._awsUseStaticInstanceList;
  }

  // balance_similar_node_groups - computed: false, optional: true, required: false
  private _balanceSimilarNodeGroups?: boolean | cdktf.IResolvable; 
  public get balanceSimilarNodeGroups() {
    return this.getBooleanAttribute('balance_similar_node_groups');
  }
  public set balanceSimilarNodeGroups(value: boolean | cdktf.IResolvable) {
    this._balanceSimilarNodeGroups = value;
  }
  public resetBalanceSimilarNodeGroups() {
    this._balanceSimilarNodeGroups = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get balanceSimilarNodeGroupsInput() {
    return this._balanceSimilarNodeGroups;
  }

  // cordon_node_before_terminating - computed: false, optional: true, required: false
  private _cordonNodeBeforeTerminating?: boolean | cdktf.IResolvable; 
  public get cordonNodeBeforeTerminating() {
    return this.getBooleanAttribute('cordon_node_before_terminating');
  }
  public set cordonNodeBeforeTerminating(value: boolean | cdktf.IResolvable) {
    this._cordonNodeBeforeTerminating = value;
  }
  public resetCordonNodeBeforeTerminating() {
    this._cordonNodeBeforeTerminating = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cordonNodeBeforeTerminatingInput() {
    return this._cordonNodeBeforeTerminating;
  }

  // cpu_request - computed: false, optional: true, required: false
  private _cpuRequest?: string; 
  public get cpuRequest() {
    return this.getStringAttribute('cpu_request');
  }
  public set cpuRequest(value: string) {
    this._cpuRequest = value;
  }
  public resetCpuRequest() {
    this._cpuRequest = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuRequestInput() {
    return this._cpuRequest;
  }

  // enabled - computed: false, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // expander - computed: false, optional: true, required: false
  private _expander?: string; 
  public get expander() {
    return this.getStringAttribute('expander');
  }
  public set expander(value: string) {
    this._expander = value;
  }
  public resetExpander() {
    this._expander = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get expanderInput() {
    return this._expander;
  }

  // image - computed: false, optional: true, required: false
  private _image?: string; 
  public get image() {
    return this.getStringAttribute('image');
  }
  public set image(value: string) {
    this._image = value;
  }
  public resetImage() {
    this._image = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageInput() {
    return this._image;
  }

  // max_node_provision_time - computed: false, optional: true, required: false
  private _maxNodeProvisionTime?: string; 
  public get maxNodeProvisionTime() {
    return this.getStringAttribute('max_node_provision_time');
  }
  public set maxNodeProvisionTime(value: string) {
    this._maxNodeProvisionTime = value;
  }
  public resetMaxNodeProvisionTime() {
    this._maxNodeProvisionTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxNodeProvisionTimeInput() {
    return this._maxNodeProvisionTime;
  }

  // memory_request - computed: false, optional: true, required: false
  private _memoryRequest?: string; 
  public get memoryRequest() {
    return this.getStringAttribute('memory_request');
  }
  public set memoryRequest(value: string) {
    this._memoryRequest = value;
  }
  public resetMemoryRequest() {
    this._memoryRequest = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryRequestInput() {
    return this._memoryRequest;
  }

  // new_pod_scale_up_delay - computed: false, optional: true, required: false
  private _newPodScaleUpDelay?: string; 
  public get newPodScaleUpDelay() {
    return this.getStringAttribute('new_pod_scale_up_delay');
  }
  public set newPodScaleUpDelay(value: string) {
    this._newPodScaleUpDelay = value;
  }
  public resetNewPodScaleUpDelay() {
    this._newPodScaleUpDelay = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get newPodScaleUpDelayInput() {
    return this._newPodScaleUpDelay;
  }

  // pod_annotations - computed: false, optional: true, required: false
  private _podAnnotations?: { [key: string]: string }; 
  public get podAnnotations() {
    return this.getStringMapAttribute('pod_annotations');
  }
  public set podAnnotations(value: { [key: string]: string }) {
    this._podAnnotations = value;
  }
  public resetPodAnnotations() {
    this._podAnnotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podAnnotationsInput() {
    return this._podAnnotations;
  }

  // scale_down_delay_after_add - computed: false, optional: true, required: false
  private _scaleDownDelayAfterAdd?: string; 
  public get scaleDownDelayAfterAdd() {
    return this.getStringAttribute('scale_down_delay_after_add');
  }
  public set scaleDownDelayAfterAdd(value: string) {
    this._scaleDownDelayAfterAdd = value;
  }
  public resetScaleDownDelayAfterAdd() {
    this._scaleDownDelayAfterAdd = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scaleDownDelayAfterAddInput() {
    return this._scaleDownDelayAfterAdd;
  }

  // scale_down_unneeded_time - computed: false, optional: true, required: false
  private _scaleDownUnneededTime?: string; 
  public get scaleDownUnneededTime() {
    return this.getStringAttribute('scale_down_unneeded_time');
  }
  public set scaleDownUnneededTime(value: string) {
    this._scaleDownUnneededTime = value;
  }
  public resetScaleDownUnneededTime() {
    this._scaleDownUnneededTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scaleDownUnneededTimeInput() {
    return this._scaleDownUnneededTime;
  }

  // scale_down_unready_time - computed: false, optional: true, required: false
  private _scaleDownUnreadyTime?: string; 
  public get scaleDownUnreadyTime() {
    return this.getStringAttribute('scale_down_unready_time');
  }
  public set scaleDownUnreadyTime(value: string) {
    this._scaleDownUnreadyTime = value;
  }
  public resetScaleDownUnreadyTime() {
    this._scaleDownUnreadyTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scaleDownUnreadyTimeInput() {
    return this._scaleDownUnreadyTime;
  }

  // scale_down_utilization_threshold - computed: false, optional: true, required: false
  private _scaleDownUtilizationThreshold?: string; 
  public get scaleDownUtilizationThreshold() {
    return this.getStringAttribute('scale_down_utilization_threshold');
  }
  public set scaleDownUtilizationThreshold(value: string) {
    this._scaleDownUtilizationThreshold = value;
  }
  public resetScaleDownUtilizationThreshold() {
    this._scaleDownUtilizationThreshold = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scaleDownUtilizationThresholdInput() {
    return this._scaleDownUtilizationThreshold;
  }

  // skip_nodes_with_local_storage - computed: false, optional: false, required: true
  private _skipNodesWithLocalStorage?: boolean | cdktf.IResolvable; 
  public get skipNodesWithLocalStorage() {
    return this.getBooleanAttribute('skip_nodes_with_local_storage');
  }
  public set skipNodesWithLocalStorage(value: boolean | cdktf.IResolvable) {
    this._skipNodesWithLocalStorage = value;
  }
  // Temporarily expose input value. Use with caution.
  public get skipNodesWithLocalStorageInput() {
    return this._skipNodesWithLocalStorage;
  }

  // skip_nodes_with_system_pods - computed: false, optional: false, required: true
  private _skipNodesWithSystemPods?: boolean | cdktf.IResolvable; 
  public get skipNodesWithSystemPods() {
    return this.getBooleanAttribute('skip_nodes_with_system_pods');
  }
  public set skipNodesWithSystemPods(value: boolean | cdktf.IResolvable) {
    this._skipNodesWithSystemPods = value;
  }
  // Temporarily expose input value. Use with caution.
  public get skipNodesWithSystemPodsInput() {
    return this._skipNodesWithSystemPods;
  }
}
export interface ClusterContainerdNvidiaGpu {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#driver_package Cluster#driver_package}
  */
  readonly driverPackage?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#enabled Cluster#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
}

export function clusterContainerdNvidiaGpuToTerraform(struct?: ClusterContainerdNvidiaGpuOutputReference | ClusterContainerdNvidiaGpu): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    driver_package: cdktf.stringToTerraform(struct!.driverPackage),
    enabled: cdktf.booleanToTerraform(struct!.enabled),
  }
}


export function clusterContainerdNvidiaGpuToHclTerraform(struct?: ClusterContainerdNvidiaGpuOutputReference | ClusterContainerdNvidiaGpu): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    driver_package: {
      value: cdktf.stringToHclTerraform(struct!.driverPackage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterContainerdNvidiaGpuOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterContainerdNvidiaGpu | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._driverPackage !== undefined) {
      hasAnyValues = true;
      internalValueResult.driverPackage = this._driverPackage;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterContainerdNvidiaGpu | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._driverPackage = undefined;
      this._enabled = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._driverPackage = value.driverPackage;
      this._enabled = value.enabled;
    }
  }

  // driver_package - computed: false, optional: true, required: false
  private _driverPackage?: string; 
  public get driverPackage() {
    return this.getStringAttribute('driver_package');
  }
  public set driverPackage(value: string) {
    this._driverPackage = value;
  }
  public resetDriverPackage() {
    this._driverPackage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get driverPackageInput() {
    return this._driverPackage;
  }

  // enabled - computed: false, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }
}
export interface ClusterContainerdPackages {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#hash_amd64 Cluster#hash_amd64}
  */
  readonly hashAmd64?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#hash_arm64 Cluster#hash_arm64}
  */
  readonly hashArm64?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#url_amd64 Cluster#url_amd64}
  */
  readonly urlAmd64?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#url_arm64 Cluster#url_arm64}
  */
  readonly urlArm64?: string;
}

export function clusterContainerdPackagesToTerraform(struct?: ClusterContainerdPackagesOutputReference | ClusterContainerdPackages): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    hash_amd64: cdktf.stringToTerraform(struct!.hashAmd64),
    hash_arm64: cdktf.stringToTerraform(struct!.hashArm64),
    url_amd64: cdktf.stringToTerraform(struct!.urlAmd64),
    url_arm64: cdktf.stringToTerraform(struct!.urlArm64),
  }
}


export function clusterContainerdPackagesToHclTerraform(struct?: ClusterContainerdPackagesOutputReference | ClusterContainerdPackages): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    hash_amd64: {
      value: cdktf.stringToHclTerraform(struct!.hashAmd64),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hash_arm64: {
      value: cdktf.stringToHclTerraform(struct!.hashArm64),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url_amd64: {
      value: cdktf.stringToHclTerraform(struct!.urlAmd64),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url_arm64: {
      value: cdktf.stringToHclTerraform(struct!.urlArm64),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterContainerdPackagesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterContainerdPackages | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._hashAmd64 !== undefined) {
      hasAnyValues = true;
      internalValueResult.hashAmd64 = this._hashAmd64;
    }
    if (this._hashArm64 !== undefined) {
      hasAnyValues = true;
      internalValueResult.hashArm64 = this._hashArm64;
    }
    if (this._urlAmd64 !== undefined) {
      hasAnyValues = true;
      internalValueResult.urlAmd64 = this._urlAmd64;
    }
    if (this._urlArm64 !== undefined) {
      hasAnyValues = true;
      internalValueResult.urlArm64 = this._urlArm64;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterContainerdPackages | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._hashAmd64 = undefined;
      this._hashArm64 = undefined;
      this._urlAmd64 = undefined;
      this._urlArm64 = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._hashAmd64 = value.hashAmd64;
      this._hashArm64 = value.hashArm64;
      this._urlAmd64 = value.urlAmd64;
      this._urlArm64 = value.urlArm64;
    }
  }

  // hash_amd64 - computed: false, optional: true, required: false
  private _hashAmd64?: string; 
  public get hashAmd64() {
    return this.getStringAttribute('hash_amd64');
  }
  public set hashAmd64(value: string) {
    this._hashAmd64 = value;
  }
  public resetHashAmd64() {
    this._hashAmd64 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hashAmd64Input() {
    return this._hashAmd64;
  }

  // hash_arm64 - computed: false, optional: true, required: false
  private _hashArm64?: string; 
  public get hashArm64() {
    return this.getStringAttribute('hash_arm64');
  }
  public set hashArm64(value: string) {
    this._hashArm64 = value;
  }
  public resetHashArm64() {
    this._hashArm64 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hashArm64Input() {
    return this._hashArm64;
  }

  // url_amd64 - computed: false, optional: true, required: false
  private _urlAmd64?: string; 
  public get urlAmd64() {
    return this.getStringAttribute('url_amd64');
  }
  public set urlAmd64(value: string) {
    this._urlAmd64 = value;
  }
  public resetUrlAmd64() {
    this._urlAmd64 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlAmd64Input() {
    return this._urlAmd64;
  }

  // url_arm64 - computed: false, optional: true, required: false
  private _urlArm64?: string; 
  public get urlArm64() {
    return this.getStringAttribute('url_arm64');
  }
  public set urlArm64(value: string) {
    this._urlArm64 = value;
  }
  public resetUrlArm64() {
    this._urlArm64 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlArm64Input() {
    return this._urlArm64;
  }
}
export interface ClusterContainerdRegistryMirrors {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#key Cluster#key}
  */
  readonly key: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#value Cluster#value}
  */
  readonly value: string[];
}

export function clusterContainerdRegistryMirrorsToTerraform(struct?: ClusterContainerdRegistryMirrors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.value),
  }
}


export function clusterContainerdRegistryMirrorsToHclTerraform(struct?: ClusterContainerdRegistryMirrors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.value),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterContainerdRegistryMirrorsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterContainerdRegistryMirrors | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterContainerdRegistryMirrors | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value = value.value;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string[]; 
  public get value() {
    return this.getListAttribute('value');
  }
  public set value(value: string[]) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class ClusterContainerdRegistryMirrorsList extends cdktf.ComplexList {
  public internalValue? : ClusterContainerdRegistryMirrors[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterContainerdRegistryMirrorsOutputReference {
    return new ClusterContainerdRegistryMirrorsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterContainerdRuncPackages {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#hash_amd64 Cluster#hash_amd64}
  */
  readonly hashAmd64?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#hash_arm64 Cluster#hash_arm64}
  */
  readonly hashArm64?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#url_amd64 Cluster#url_amd64}
  */
  readonly urlAmd64?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#url_arm64 Cluster#url_arm64}
  */
  readonly urlArm64?: string;
}

export function clusterContainerdRuncPackagesToTerraform(struct?: ClusterContainerdRuncPackagesOutputReference | ClusterContainerdRuncPackages): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    hash_amd64: cdktf.stringToTerraform(struct!.hashAmd64),
    hash_arm64: cdktf.stringToTerraform(struct!.hashArm64),
    url_amd64: cdktf.stringToTerraform(struct!.urlAmd64),
    url_arm64: cdktf.stringToTerraform(struct!.urlArm64),
  }
}


export function clusterContainerdRuncPackagesToHclTerraform(struct?: ClusterContainerdRuncPackagesOutputReference | ClusterContainerdRuncPackages): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    hash_amd64: {
      value: cdktf.stringToHclTerraform(struct!.hashAmd64),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hash_arm64: {
      value: cdktf.stringToHclTerraform(struct!.hashArm64),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url_amd64: {
      value: cdktf.stringToHclTerraform(struct!.urlAmd64),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url_arm64: {
      value: cdktf.stringToHclTerraform(struct!.urlArm64),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterContainerdRuncPackagesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterContainerdRuncPackages | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._hashAmd64 !== undefined) {
      hasAnyValues = true;
      internalValueResult.hashAmd64 = this._hashAmd64;
    }
    if (this._hashArm64 !== undefined) {
      hasAnyValues = true;
      internalValueResult.hashArm64 = this._hashArm64;
    }
    if (this._urlAmd64 !== undefined) {
      hasAnyValues = true;
      internalValueResult.urlAmd64 = this._urlAmd64;
    }
    if (this._urlArm64 !== undefined) {
      hasAnyValues = true;
      internalValueResult.urlArm64 = this._urlArm64;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterContainerdRuncPackages | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._hashAmd64 = undefined;
      this._hashArm64 = undefined;
      this._urlAmd64 = undefined;
      this._urlArm64 = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._hashAmd64 = value.hashAmd64;
      this._hashArm64 = value.hashArm64;
      this._urlAmd64 = value.urlAmd64;
      this._urlArm64 = value.urlArm64;
    }
  }

  // hash_amd64 - computed: false, optional: true, required: false
  private _hashAmd64?: string; 
  public get hashAmd64() {
    return this.getStringAttribute('hash_amd64');
  }
  public set hashAmd64(value: string) {
    this._hashAmd64 = value;
  }
  public resetHashAmd64() {
    this._hashAmd64 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hashAmd64Input() {
    return this._hashAmd64;
  }

  // hash_arm64 - computed: false, optional: true, required: false
  private _hashArm64?: string; 
  public get hashArm64() {
    return this.getStringAttribute('hash_arm64');
  }
  public set hashArm64(value: string) {
    this._hashArm64 = value;
  }
  public resetHashArm64() {
    this._hashArm64 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hashArm64Input() {
    return this._hashArm64;
  }

  // url_amd64 - computed: false, optional: true, required: false
  private _urlAmd64?: string; 
  public get urlAmd64() {
    return this.getStringAttribute('url_amd64');
  }
  public set urlAmd64(value: string) {
    this._urlAmd64 = value;
  }
  public resetUrlAmd64() {
    this._urlAmd64 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlAmd64Input() {
    return this._urlAmd64;
  }

  // url_arm64 - computed: false, optional: true, required: false
  private _urlArm64?: string; 
  public get urlArm64() {
    return this.getStringAttribute('url_arm64');
  }
  public set urlArm64(value: string) {
    this._urlArm64 = value;
  }
  public resetUrlArm64() {
    this._urlArm64 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlArm64Input() {
    return this._urlArm64;
  }
}
export interface ClusterContainerdRunc {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#version Cluster#version}
  */
  readonly version?: string;
  /**
  * packages block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#packages Cluster#packages}
  */
  readonly packages?: ClusterContainerdRuncPackages;
}

export function clusterContainerdRuncToTerraform(struct?: ClusterContainerdRuncOutputReference | ClusterContainerdRunc): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    version: cdktf.stringToTerraform(struct!.version),
    packages: clusterContainerdRuncPackagesToTerraform(struct!.packages),
  }
}


export function clusterContainerdRuncToHclTerraform(struct?: ClusterContainerdRuncOutputReference | ClusterContainerdRunc): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    version: {
      value: cdktf.stringToHclTerraform(struct!.version),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    packages: {
      value: clusterContainerdRuncPackagesToHclTerraform(struct!.packages),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterContainerdRuncPackagesList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterContainerdRuncOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterContainerdRunc | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._version !== undefined) {
      hasAnyValues = true;
      internalValueResult.version = this._version;
    }
    if (this._packages?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.packages = this._packages?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterContainerdRunc | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._version = undefined;
      this._packages.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._version = value.version;
      this._packages.internalValue = value.packages;
    }
  }

  // version - computed: false, optional: true, required: false
  private _version?: string; 
  public get version() {
    return this.getStringAttribute('version');
  }
  public set version(value: string) {
    this._version = value;
  }
  public resetVersion() {
    this._version = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get versionInput() {
    return this._version;
  }

  // packages - computed: false, optional: true, required: false
  private _packages = new ClusterContainerdRuncPackagesOutputReference(this, "packages");
  public get packages() {
    return this._packages;
  }
  public putPackages(value: ClusterContainerdRuncPackages) {
    this._packages.internalValue = value;
  }
  public resetPackages() {
    this._packages.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get packagesInput() {
    return this._packages.internalValue;
  }
}
export interface ClusterContainerd {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#address Cluster#address}
  */
  readonly address?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#config_override Cluster#config_override}
  */
  readonly configOverride?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#log_level Cluster#log_level}
  */
  readonly logLevel?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#root Cluster#root}
  */
  readonly root?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#skip_install Cluster#skip_install}
  */
  readonly skipInstall?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#state Cluster#state}
  */
  readonly state?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#version Cluster#version}
  */
  readonly version?: string;
  /**
  * nvidia_gpu block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#nvidia_gpu Cluster#nvidia_gpu}
  */
  readonly nvidiaGpu?: ClusterContainerdNvidiaGpu;
  /**
  * packages block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#packages Cluster#packages}
  */
  readonly packages?: ClusterContainerdPackages;
  /**
  * registry_mirrors block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#registry_mirrors Cluster#registry_mirrors}
  */
  readonly registryMirrors?: ClusterContainerdRegistryMirrors[] | cdktf.IResolvable;
  /**
  * runc block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#runc Cluster#runc}
  */
  readonly runc?: ClusterContainerdRunc;
}

export function clusterContainerdToTerraform(struct?: ClusterContainerdOutputReference | ClusterContainerd): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: cdktf.stringToTerraform(struct!.address),
    config_override: cdktf.stringToTerraform(struct!.configOverride),
    log_level: cdktf.stringToTerraform(struct!.logLevel),
    root: cdktf.stringToTerraform(struct!.root),
    skip_install: cdktf.booleanToTerraform(struct!.skipInstall),
    state: cdktf.stringToTerraform(struct!.state),
    version: cdktf.stringToTerraform(struct!.version),
    nvidia_gpu: clusterContainerdNvidiaGpuToTerraform(struct!.nvidiaGpu),
    packages: clusterContainerdPackagesToTerraform(struct!.packages),
    registry_mirrors: cdktf.listMapper(clusterContainerdRegistryMirrorsToTerraform, true)(struct!.registryMirrors),
    runc: clusterContainerdRuncToTerraform(struct!.runc),
  }
}


export function clusterContainerdToHclTerraform(struct?: ClusterContainerdOutputReference | ClusterContainerd): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: cdktf.stringToHclTerraform(struct!.address),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    config_override: {
      value: cdktf.stringToHclTerraform(struct!.configOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_level: {
      value: cdktf.stringToHclTerraform(struct!.logLevel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    root: {
      value: cdktf.stringToHclTerraform(struct!.root),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    skip_install: {
      value: cdktf.booleanToHclTerraform(struct!.skipInstall),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    state: {
      value: cdktf.stringToHclTerraform(struct!.state),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    version: {
      value: cdktf.stringToHclTerraform(struct!.version),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    nvidia_gpu: {
      value: clusterContainerdNvidiaGpuToHclTerraform(struct!.nvidiaGpu),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterContainerdNvidiaGpuList",
    },
    packages: {
      value: clusterContainerdPackagesToHclTerraform(struct!.packages),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterContainerdPackagesList",
    },
    registry_mirrors: {
      value: cdktf.listMapperHcl(clusterContainerdRegistryMirrorsToHclTerraform, true)(struct!.registryMirrors),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterContainerdRegistryMirrorsList",
    },
    runc: {
      value: clusterContainerdRuncToHclTerraform(struct!.runc),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterContainerdRuncList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterContainerdOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterContainerd | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address;
    }
    if (this._configOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.configOverride = this._configOverride;
    }
    if (this._logLevel !== undefined) {
      hasAnyValues = true;
      internalValueResult.logLevel = this._logLevel;
    }
    if (this._root !== undefined) {
      hasAnyValues = true;
      internalValueResult.root = this._root;
    }
    if (this._skipInstall !== undefined) {
      hasAnyValues = true;
      internalValueResult.skipInstall = this._skipInstall;
    }
    if (this._state !== undefined) {
      hasAnyValues = true;
      internalValueResult.state = this._state;
    }
    if (this._version !== undefined) {
      hasAnyValues = true;
      internalValueResult.version = this._version;
    }
    if (this._nvidiaGpu?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nvidiaGpu = this._nvidiaGpu?.internalValue;
    }
    if (this._packages?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.packages = this._packages?.internalValue;
    }
    if (this._registryMirrors?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.registryMirrors = this._registryMirrors?.internalValue;
    }
    if (this._runc?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.runc = this._runc?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterContainerd | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._address = undefined;
      this._configOverride = undefined;
      this._logLevel = undefined;
      this._root = undefined;
      this._skipInstall = undefined;
      this._state = undefined;
      this._version = undefined;
      this._nvidiaGpu.internalValue = undefined;
      this._packages.internalValue = undefined;
      this._registryMirrors.internalValue = undefined;
      this._runc.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._address = value.address;
      this._configOverride = value.configOverride;
      this._logLevel = value.logLevel;
      this._root = value.root;
      this._skipInstall = value.skipInstall;
      this._state = value.state;
      this._version = value.version;
      this._nvidiaGpu.internalValue = value.nvidiaGpu;
      this._packages.internalValue = value.packages;
      this._registryMirrors.internalValue = value.registryMirrors;
      this._runc.internalValue = value.runc;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address?: string; 
  public get address() {
    return this.getStringAttribute('address');
  }
  public set address(value: string) {
    this._address = value;
  }
  public resetAddress() {
    this._address = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address;
  }

  // config_override - computed: false, optional: true, required: false
  private _configOverride?: string; 
  public get configOverride() {
    return this.getStringAttribute('config_override');
  }
  public set configOverride(value: string) {
    this._configOverride = value;
  }
  public resetConfigOverride() {
    this._configOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configOverrideInput() {
    return this._configOverride;
  }

  // log_level - computed: false, optional: true, required: false
  private _logLevel?: string; 
  public get logLevel() {
    return this.getStringAttribute('log_level');
  }
  public set logLevel(value: string) {
    this._logLevel = value;
  }
  public resetLogLevel() {
    this._logLevel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logLevelInput() {
    return this._logLevel;
  }

  // root - computed: false, optional: true, required: false
  private _root?: string; 
  public get root() {
    return this.getStringAttribute('root');
  }
  public set root(value: string) {
    this._root = value;
  }
  public resetRoot() {
    this._root = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rootInput() {
    return this._root;
  }

  // skip_install - computed: false, optional: true, required: false
  private _skipInstall?: boolean | cdktf.IResolvable; 
  public get skipInstall() {
    return this.getBooleanAttribute('skip_install');
  }
  public set skipInstall(value: boolean | cdktf.IResolvable) {
    this._skipInstall = value;
  }
  public resetSkipInstall() {
    this._skipInstall = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get skipInstallInput() {
    return this._skipInstall;
  }

  // state - computed: false, optional: true, required: false
  private _state?: string; 
  public get state() {
    return this.getStringAttribute('state');
  }
  public set state(value: string) {
    this._state = value;
  }
  public resetState() {
    this._state = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateInput() {
    return this._state;
  }

  // version - computed: false, optional: true, required: false
  private _version?: string; 
  public get version() {
    return this.getStringAttribute('version');
  }
  public set version(value: string) {
    this._version = value;
  }
  public resetVersion() {
    this._version = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get versionInput() {
    return this._version;
  }

  // nvidia_gpu - computed: false, optional: true, required: false
  private _nvidiaGpu = new ClusterContainerdNvidiaGpuOutputReference(this, "nvidia_gpu");
  public get nvidiaGpu() {
    return this._nvidiaGpu;
  }
  public putNvidiaGpu(value: ClusterContainerdNvidiaGpu) {
    this._nvidiaGpu.internalValue = value;
  }
  public resetNvidiaGpu() {
    this._nvidiaGpu.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nvidiaGpuInput() {
    return this._nvidiaGpu.internalValue;
  }

  // packages - computed: false, optional: true, required: false
  private _packages = new ClusterContainerdPackagesOutputReference(this, "packages");
  public get packages() {
    return this._packages;
  }
  public putPackages(value: ClusterContainerdPackages) {
    this._packages.internalValue = value;
  }
  public resetPackages() {
    this._packages.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get packagesInput() {
    return this._packages.internalValue;
  }

  // registry_mirrors - computed: false, optional: true, required: false
  private _registryMirrors = new ClusterContainerdRegistryMirrorsList(this, "registry_mirrors", false);
  public get registryMirrors() {
    return this._registryMirrors;
  }
  public putRegistryMirrors(value: ClusterContainerdRegistryMirrors[] | cdktf.IResolvable) {
    this._registryMirrors.internalValue = value;
  }
  public resetRegistryMirrors() {
    this._registryMirrors.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get registryMirrorsInput() {
    return this._registryMirrors.internalValue;
  }

  // runc - computed: false, optional: true, required: false
  private _runc = new ClusterContainerdRuncOutputReference(this, "runc");
  public get runc() {
    return this._runc;
  }
  public putRunc(value: ClusterContainerdRunc) {
    this._runc.internalValue = value;
  }
  public resetRunc() {
    this._runc.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get runcInput() {
    return this._runc.internalValue;
  }
}
export interface ClusterDockerPackages {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#hash_amd64 Cluster#hash_amd64}
  */
  readonly hashAmd64?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#hash_arm64 Cluster#hash_arm64}
  */
  readonly hashArm64?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#url_amd64 Cluster#url_amd64}
  */
  readonly urlAmd64?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#url_arm64 Cluster#url_arm64}
  */
  readonly urlArm64?: string;
}

export function clusterDockerPackagesToTerraform(struct?: ClusterDockerPackagesOutputReference | ClusterDockerPackages): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    hash_amd64: cdktf.stringToTerraform(struct!.hashAmd64),
    hash_arm64: cdktf.stringToTerraform(struct!.hashArm64),
    url_amd64: cdktf.stringToTerraform(struct!.urlAmd64),
    url_arm64: cdktf.stringToTerraform(struct!.urlArm64),
  }
}


export function clusterDockerPackagesToHclTerraform(struct?: ClusterDockerPackagesOutputReference | ClusterDockerPackages): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    hash_amd64: {
      value: cdktf.stringToHclTerraform(struct!.hashAmd64),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hash_arm64: {
      value: cdktf.stringToHclTerraform(struct!.hashArm64),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url_amd64: {
      value: cdktf.stringToHclTerraform(struct!.urlAmd64),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url_arm64: {
      value: cdktf.stringToHclTerraform(struct!.urlArm64),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterDockerPackagesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterDockerPackages | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._hashAmd64 !== undefined) {
      hasAnyValues = true;
      internalValueResult.hashAmd64 = this._hashAmd64;
    }
    if (this._hashArm64 !== undefined) {
      hasAnyValues = true;
      internalValueResult.hashArm64 = this._hashArm64;
    }
    if (this._urlAmd64 !== undefined) {
      hasAnyValues = true;
      internalValueResult.urlAmd64 = this._urlAmd64;
    }
    if (this._urlArm64 !== undefined) {
      hasAnyValues = true;
      internalValueResult.urlArm64 = this._urlArm64;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterDockerPackages | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._hashAmd64 = undefined;
      this._hashArm64 = undefined;
      this._urlAmd64 = undefined;
      this._urlArm64 = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._hashAmd64 = value.hashAmd64;
      this._hashArm64 = value.hashArm64;
      this._urlAmd64 = value.urlAmd64;
      this._urlArm64 = value.urlArm64;
    }
  }

  // hash_amd64 - computed: false, optional: true, required: false
  private _hashAmd64?: string; 
  public get hashAmd64() {
    return this.getStringAttribute('hash_amd64');
  }
  public set hashAmd64(value: string) {
    this._hashAmd64 = value;
  }
  public resetHashAmd64() {
    this._hashAmd64 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hashAmd64Input() {
    return this._hashAmd64;
  }

  // hash_arm64 - computed: false, optional: true, required: false
  private _hashArm64?: string; 
  public get hashArm64() {
    return this.getStringAttribute('hash_arm64');
  }
  public set hashArm64(value: string) {
    this._hashArm64 = value;
  }
  public resetHashArm64() {
    this._hashArm64 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hashArm64Input() {
    return this._hashArm64;
  }

  // url_amd64 - computed: false, optional: true, required: false
  private _urlAmd64?: string; 
  public get urlAmd64() {
    return this.getStringAttribute('url_amd64');
  }
  public set urlAmd64(value: string) {
    this._urlAmd64 = value;
  }
  public resetUrlAmd64() {
    this._urlAmd64 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlAmd64Input() {
    return this._urlAmd64;
  }

  // url_arm64 - computed: false, optional: true, required: false
  private _urlArm64?: string; 
  public get urlArm64() {
    return this.getStringAttribute('url_arm64');
  }
  public set urlArm64(value: string) {
    this._urlArm64 = value;
  }
  public resetUrlArm64() {
    this._urlArm64 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlArm64Input() {
    return this._urlArm64;
  }
}
export interface ClusterDocker {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#authorization_plugins Cluster#authorization_plugins}
  */
  readonly authorizationPlugins?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#bridge Cluster#bridge}
  */
  readonly bridge?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#bridge_ip Cluster#bridge_ip}
  */
  readonly bridgeIp?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#data_root Cluster#data_root}
  */
  readonly dataRoot?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#default_runtime Cluster#default_runtime}
  */
  readonly defaultRuntime?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#default_ulimit Cluster#default_ulimit}
  */
  readonly defaultUlimit?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#dns Cluster#dns}
  */
  readonly dns?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#exec_opt Cluster#exec_opt}
  */
  readonly execOpt?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#exec_root Cluster#exec_root}
  */
  readonly execRoot?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#experimental Cluster#experimental}
  */
  readonly experimental?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#health_check Cluster#health_check}
  */
  readonly healthCheck?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#hosts Cluster#hosts}
  */
  readonly hosts?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#insecure_registries Cluster#insecure_registries}
  */
  readonly insecureRegistries?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#insecure_registry Cluster#insecure_registry}
  */
  readonly insecureRegistry?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#ip_masq Cluster#ip_masq}
  */
  readonly ipMasq?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#ip_tables Cluster#ip_tables}
  */
  readonly ipTables?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#live_restore Cluster#live_restore}
  */
  readonly liveRestore?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#log_driver Cluster#log_driver}
  */
  readonly logDriver?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#log_level Cluster#log_level}
  */
  readonly logLevel?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#log_opt Cluster#log_opt}
  */
  readonly logOpt?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#max_concurrent_downloads Cluster#max_concurrent_downloads}
  */
  readonly maxConcurrentDownloads?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#max_concurrent_uploads Cluster#max_concurrent_uploads}
  */
  readonly maxConcurrentUploads?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#max_download_attempts Cluster#max_download_attempts}
  */
  readonly maxDownloadAttempts?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#metrics_address Cluster#metrics_address}
  */
  readonly metricsAddress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#mtu Cluster#mtu}
  */
  readonly mtu?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#registry_mirrors Cluster#registry_mirrors}
  */
  readonly registryMirrors?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#runtimes Cluster#runtimes}
  */
  readonly runtimes?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#selinux_enabled Cluster#selinux_enabled}
  */
  readonly selinuxEnabled?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#skip_install Cluster#skip_install}
  */
  readonly skipInstall?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#storage Cluster#storage}
  */
  readonly storage?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#storage_opts Cluster#storage_opts}
  */
  readonly storageOpts?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#user_namespace_remap Cluster#user_namespace_remap}
  */
  readonly userNamespaceRemap?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#version Cluster#version}
  */
  readonly version?: string;
  /**
  * packages block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#packages Cluster#packages}
  */
  readonly packages?: ClusterDockerPackages;
}

export function clusterDockerToTerraform(struct?: ClusterDockerOutputReference | ClusterDocker): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    authorization_plugins: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.authorizationPlugins),
    bridge: cdktf.stringToTerraform(struct!.bridge),
    bridge_ip: cdktf.stringToTerraform(struct!.bridgeIp),
    data_root: cdktf.stringToTerraform(struct!.dataRoot),
    default_runtime: cdktf.stringToTerraform(struct!.defaultRuntime),
    default_ulimit: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.defaultUlimit),
    dns: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.dns),
    exec_opt: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.execOpt),
    exec_root: cdktf.stringToTerraform(struct!.execRoot),
    experimental: cdktf.booleanToTerraform(struct!.experimental),
    health_check: cdktf.booleanToTerraform(struct!.healthCheck),
    hosts: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.hosts),
    insecure_registries: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.insecureRegistries),
    insecure_registry: cdktf.stringToTerraform(struct!.insecureRegistry),
    ip_masq: cdktf.booleanToTerraform(struct!.ipMasq),
    ip_tables: cdktf.booleanToTerraform(struct!.ipTables),
    live_restore: cdktf.booleanToTerraform(struct!.liveRestore),
    log_driver: cdktf.stringToTerraform(struct!.logDriver),
    log_level: cdktf.stringToTerraform(struct!.logLevel),
    log_opt: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.logOpt),
    max_concurrent_downloads: cdktf.numberToTerraform(struct!.maxConcurrentDownloads),
    max_concurrent_uploads: cdktf.numberToTerraform(struct!.maxConcurrentUploads),
    max_download_attempts: cdktf.numberToTerraform(struct!.maxDownloadAttempts),
    metrics_address: cdktf.stringToTerraform(struct!.metricsAddress),
    mtu: cdktf.numberToTerraform(struct!.mtu),
    registry_mirrors: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.registryMirrors),
    runtimes: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.runtimes),
    selinux_enabled: cdktf.booleanToTerraform(struct!.selinuxEnabled),
    skip_install: cdktf.booleanToTerraform(struct!.skipInstall),
    storage: cdktf.stringToTerraform(struct!.storage),
    storage_opts: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.storageOpts),
    user_namespace_remap: cdktf.stringToTerraform(struct!.userNamespaceRemap),
    version: cdktf.stringToTerraform(struct!.version),
    packages: clusterDockerPackagesToTerraform(struct!.packages),
  }
}


export function clusterDockerToHclTerraform(struct?: ClusterDockerOutputReference | ClusterDocker): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    authorization_plugins: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.authorizationPlugins),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    bridge: {
      value: cdktf.stringToHclTerraform(struct!.bridge),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bridge_ip: {
      value: cdktf.stringToHclTerraform(struct!.bridgeIp),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    data_root: {
      value: cdktf.stringToHclTerraform(struct!.dataRoot),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    default_runtime: {
      value: cdktf.stringToHclTerraform(struct!.defaultRuntime),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    default_ulimit: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.defaultUlimit),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    dns: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.dns),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    exec_opt: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.execOpt),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    exec_root: {
      value: cdktf.stringToHclTerraform(struct!.execRoot),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    experimental: {
      value: cdktf.booleanToHclTerraform(struct!.experimental),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    health_check: {
      value: cdktf.booleanToHclTerraform(struct!.healthCheck),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    hosts: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.hosts),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    insecure_registries: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.insecureRegistries),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    insecure_registry: {
      value: cdktf.stringToHclTerraform(struct!.insecureRegistry),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_masq: {
      value: cdktf.booleanToHclTerraform(struct!.ipMasq),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    ip_tables: {
      value: cdktf.booleanToHclTerraform(struct!.ipTables),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    live_restore: {
      value: cdktf.booleanToHclTerraform(struct!.liveRestore),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    log_driver: {
      value: cdktf.stringToHclTerraform(struct!.logDriver),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_level: {
      value: cdktf.stringToHclTerraform(struct!.logLevel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_opt: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.logOpt),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    max_concurrent_downloads: {
      value: cdktf.numberToHclTerraform(struct!.maxConcurrentDownloads),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_concurrent_uploads: {
      value: cdktf.numberToHclTerraform(struct!.maxConcurrentUploads),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_download_attempts: {
      value: cdktf.numberToHclTerraform(struct!.maxDownloadAttempts),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metrics_address: {
      value: cdktf.stringToHclTerraform(struct!.metricsAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mtu: {
      value: cdktf.numberToHclTerraform(struct!.mtu),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    registry_mirrors: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.registryMirrors),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    runtimes: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.runtimes),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    selinux_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.selinuxEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    skip_install: {
      value: cdktf.booleanToHclTerraform(struct!.skipInstall),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    storage: {
      value: cdktf.stringToHclTerraform(struct!.storage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    storage_opts: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.storageOpts),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    user_namespace_remap: {
      value: cdktf.stringToHclTerraform(struct!.userNamespaceRemap),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    version: {
      value: cdktf.stringToHclTerraform(struct!.version),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    packages: {
      value: clusterDockerPackagesToHclTerraform(struct!.packages),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterDockerPackagesList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterDockerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterDocker | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authorizationPlugins !== undefined) {
      hasAnyValues = true;
      internalValueResult.authorizationPlugins = this._authorizationPlugins;
    }
    if (this._bridge !== undefined) {
      hasAnyValues = true;
      internalValueResult.bridge = this._bridge;
    }
    if (this._bridgeIp !== undefined) {
      hasAnyValues = true;
      internalValueResult.bridgeIp = this._bridgeIp;
    }
    if (this._dataRoot !== undefined) {
      hasAnyValues = true;
      internalValueResult.dataRoot = this._dataRoot;
    }
    if (this._defaultRuntime !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultRuntime = this._defaultRuntime;
    }
    if (this._defaultUlimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultUlimit = this._defaultUlimit;
    }
    if (this._dns !== undefined) {
      hasAnyValues = true;
      internalValueResult.dns = this._dns;
    }
    if (this._execOpt !== undefined) {
      hasAnyValues = true;
      internalValueResult.execOpt = this._execOpt;
    }
    if (this._execRoot !== undefined) {
      hasAnyValues = true;
      internalValueResult.execRoot = this._execRoot;
    }
    if (this._experimental !== undefined) {
      hasAnyValues = true;
      internalValueResult.experimental = this._experimental;
    }
    if (this._healthCheck !== undefined) {
      hasAnyValues = true;
      internalValueResult.healthCheck = this._healthCheck;
    }
    if (this._hosts !== undefined) {
      hasAnyValues = true;
      internalValueResult.hosts = this._hosts;
    }
    if (this._insecureRegistries !== undefined) {
      hasAnyValues = true;
      internalValueResult.insecureRegistries = this._insecureRegistries;
    }
    if (this._insecureRegistry !== undefined) {
      hasAnyValues = true;
      internalValueResult.insecureRegistry = this._insecureRegistry;
    }
    if (this._ipMasq !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipMasq = this._ipMasq;
    }
    if (this._ipTables !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipTables = this._ipTables;
    }
    if (this._liveRestore !== undefined) {
      hasAnyValues = true;
      internalValueResult.liveRestore = this._liveRestore;
    }
    if (this._logDriver !== undefined) {
      hasAnyValues = true;
      internalValueResult.logDriver = this._logDriver;
    }
    if (this._logLevel !== undefined) {
      hasAnyValues = true;
      internalValueResult.logLevel = this._logLevel;
    }
    if (this._logOpt !== undefined) {
      hasAnyValues = true;
      internalValueResult.logOpt = this._logOpt;
    }
    if (this._maxConcurrentDownloads !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxConcurrentDownloads = this._maxConcurrentDownloads;
    }
    if (this._maxConcurrentUploads !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxConcurrentUploads = this._maxConcurrentUploads;
    }
    if (this._maxDownloadAttempts !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxDownloadAttempts = this._maxDownloadAttempts;
    }
    if (this._metricsAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.metricsAddress = this._metricsAddress;
    }
    if (this._mtu !== undefined) {
      hasAnyValues = true;
      internalValueResult.mtu = this._mtu;
    }
    if (this._registryMirrors !== undefined) {
      hasAnyValues = true;
      internalValueResult.registryMirrors = this._registryMirrors;
    }
    if (this._runtimes !== undefined) {
      hasAnyValues = true;
      internalValueResult.runtimes = this._runtimes;
    }
    if (this._selinuxEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.selinuxEnabled = this._selinuxEnabled;
    }
    if (this._skipInstall !== undefined) {
      hasAnyValues = true;
      internalValueResult.skipInstall = this._skipInstall;
    }
    if (this._storage !== undefined) {
      hasAnyValues = true;
      internalValueResult.storage = this._storage;
    }
    if (this._storageOpts !== undefined) {
      hasAnyValues = true;
      internalValueResult.storageOpts = this._storageOpts;
    }
    if (this._userNamespaceRemap !== undefined) {
      hasAnyValues = true;
      internalValueResult.userNamespaceRemap = this._userNamespaceRemap;
    }
    if (this._version !== undefined) {
      hasAnyValues = true;
      internalValueResult.version = this._version;
    }
    if (this._packages?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.packages = this._packages?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterDocker | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._authorizationPlugins = undefined;
      this._bridge = undefined;
      this._bridgeIp = undefined;
      this._dataRoot = undefined;
      this._defaultRuntime = undefined;
      this._defaultUlimit = undefined;
      this._dns = undefined;
      this._execOpt = undefined;
      this._execRoot = undefined;
      this._experimental = undefined;
      this._healthCheck = undefined;
      this._hosts = undefined;
      this._insecureRegistries = undefined;
      this._insecureRegistry = undefined;
      this._ipMasq = undefined;
      this._ipTables = undefined;
      this._liveRestore = undefined;
      this._logDriver = undefined;
      this._logLevel = undefined;
      this._logOpt = undefined;
      this._maxConcurrentDownloads = undefined;
      this._maxConcurrentUploads = undefined;
      this._maxDownloadAttempts = undefined;
      this._metricsAddress = undefined;
      this._mtu = undefined;
      this._registryMirrors = undefined;
      this._runtimes = undefined;
      this._selinuxEnabled = undefined;
      this._skipInstall = undefined;
      this._storage = undefined;
      this._storageOpts = undefined;
      this._userNamespaceRemap = undefined;
      this._version = undefined;
      this._packages.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._authorizationPlugins = value.authorizationPlugins;
      this._bridge = value.bridge;
      this._bridgeIp = value.bridgeIp;
      this._dataRoot = value.dataRoot;
      this._defaultRuntime = value.defaultRuntime;
      this._defaultUlimit = value.defaultUlimit;
      this._dns = value.dns;
      this._execOpt = value.execOpt;
      this._execRoot = value.execRoot;
      this._experimental = value.experimental;
      this._healthCheck = value.healthCheck;
      this._hosts = value.hosts;
      this._insecureRegistries = value.insecureRegistries;
      this._insecureRegistry = value.insecureRegistry;
      this._ipMasq = value.ipMasq;
      this._ipTables = value.ipTables;
      this._liveRestore = value.liveRestore;
      this._logDriver = value.logDriver;
      this._logLevel = value.logLevel;
      this._logOpt = value.logOpt;
      this._maxConcurrentDownloads = value.maxConcurrentDownloads;
      this._maxConcurrentUploads = value.maxConcurrentUploads;
      this._maxDownloadAttempts = value.maxDownloadAttempts;
      this._metricsAddress = value.metricsAddress;
      this._mtu = value.mtu;
      this._registryMirrors = value.registryMirrors;
      this._runtimes = value.runtimes;
      this._selinuxEnabled = value.selinuxEnabled;
      this._skipInstall = value.skipInstall;
      this._storage = value.storage;
      this._storageOpts = value.storageOpts;
      this._userNamespaceRemap = value.userNamespaceRemap;
      this._version = value.version;
      this._packages.internalValue = value.packages;
    }
  }

  // authorization_plugins - computed: false, optional: true, required: false
  private _authorizationPlugins?: string[]; 
  public get authorizationPlugins() {
    return this.getListAttribute('authorization_plugins');
  }
  public set authorizationPlugins(value: string[]) {
    this._authorizationPlugins = value;
  }
  public resetAuthorizationPlugins() {
    this._authorizationPlugins = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authorizationPluginsInput() {
    return this._authorizationPlugins;
  }

  // bridge - computed: false, optional: true, required: false
  private _bridge?: string; 
  public get bridge() {
    return this.getStringAttribute('bridge');
  }
  public set bridge(value: string) {
    this._bridge = value;
  }
  public resetBridge() {
    this._bridge = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bridgeInput() {
    return this._bridge;
  }

  // bridge_ip - computed: false, optional: true, required: false
  private _bridgeIp?: string; 
  public get bridgeIp() {
    return this.getStringAttribute('bridge_ip');
  }
  public set bridgeIp(value: string) {
    this._bridgeIp = value;
  }
  public resetBridgeIp() {
    this._bridgeIp = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bridgeIpInput() {
    return this._bridgeIp;
  }

  // data_root - computed: false, optional: true, required: false
  private _dataRoot?: string; 
  public get dataRoot() {
    return this.getStringAttribute('data_root');
  }
  public set dataRoot(value: string) {
    this._dataRoot = value;
  }
  public resetDataRoot() {
    this._dataRoot = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dataRootInput() {
    return this._dataRoot;
  }

  // default_runtime - computed: false, optional: true, required: false
  private _defaultRuntime?: string; 
  public get defaultRuntime() {
    return this.getStringAttribute('default_runtime');
  }
  public set defaultRuntime(value: string) {
    this._defaultRuntime = value;
  }
  public resetDefaultRuntime() {
    this._defaultRuntime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultRuntimeInput() {
    return this._defaultRuntime;
  }

  // default_ulimit - computed: false, optional: true, required: false
  private _defaultUlimit?: string[]; 
  public get defaultUlimit() {
    return this.getListAttribute('default_ulimit');
  }
  public set defaultUlimit(value: string[]) {
    this._defaultUlimit = value;
  }
  public resetDefaultUlimit() {
    this._defaultUlimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultUlimitInput() {
    return this._defaultUlimit;
  }

  // dns - computed: false, optional: true, required: false
  private _dns?: string[]; 
  public get dns() {
    return this.getListAttribute('dns');
  }
  public set dns(value: string[]) {
    this._dns = value;
  }
  public resetDns() {
    this._dns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsInput() {
    return this._dns;
  }

  // exec_opt - computed: false, optional: true, required: false
  private _execOpt?: string[]; 
  public get execOpt() {
    return this.getListAttribute('exec_opt');
  }
  public set execOpt(value: string[]) {
    this._execOpt = value;
  }
  public resetExecOpt() {
    this._execOpt = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get execOptInput() {
    return this._execOpt;
  }

  // exec_root - computed: false, optional: true, required: false
  private _execRoot?: string; 
  public get execRoot() {
    return this.getStringAttribute('exec_root');
  }
  public set execRoot(value: string) {
    this._execRoot = value;
  }
  public resetExecRoot() {
    this._execRoot = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get execRootInput() {
    return this._execRoot;
  }

  // experimental - computed: false, optional: true, required: false
  private _experimental?: boolean | cdktf.IResolvable; 
  public get experimental() {
    return this.getBooleanAttribute('experimental');
  }
  public set experimental(value: boolean | cdktf.IResolvable) {
    this._experimental = value;
  }
  public resetExperimental() {
    this._experimental = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get experimentalInput() {
    return this._experimental;
  }

  // health_check - computed: false, optional: true, required: false
  private _healthCheck?: boolean | cdktf.IResolvable; 
  public get healthCheck() {
    return this.getBooleanAttribute('health_check');
  }
  public set healthCheck(value: boolean | cdktf.IResolvable) {
    this._healthCheck = value;
  }
  public resetHealthCheck() {
    this._healthCheck = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get healthCheckInput() {
    return this._healthCheck;
  }

  // hosts - computed: false, optional: true, required: false
  private _hosts?: string[]; 
  public get hosts() {
    return this.getListAttribute('hosts');
  }
  public set hosts(value: string[]) {
    this._hosts = value;
  }
  public resetHosts() {
    this._hosts = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostsInput() {
    return this._hosts;
  }

  // insecure_registries - computed: false, optional: true, required: false
  private _insecureRegistries?: string[]; 
  public get insecureRegistries() {
    return this.getListAttribute('insecure_registries');
  }
  public set insecureRegistries(value: string[]) {
    this._insecureRegistries = value;
  }
  public resetInsecureRegistries() {
    this._insecureRegistries = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get insecureRegistriesInput() {
    return this._insecureRegistries;
  }

  // insecure_registry - computed: false, optional: true, required: false
  private _insecureRegistry?: string; 
  public get insecureRegistry() {
    return this.getStringAttribute('insecure_registry');
  }
  public set insecureRegistry(value: string) {
    this._insecureRegistry = value;
  }
  public resetInsecureRegistry() {
    this._insecureRegistry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get insecureRegistryInput() {
    return this._insecureRegistry;
  }

  // ip_masq - computed: false, optional: true, required: false
  private _ipMasq?: boolean | cdktf.IResolvable; 
  public get ipMasq() {
    return this.getBooleanAttribute('ip_masq');
  }
  public set ipMasq(value: boolean | cdktf.IResolvable) {
    this._ipMasq = value;
  }
  public resetIpMasq() {
    this._ipMasq = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipMasqInput() {
    return this._ipMasq;
  }

  // ip_tables - computed: false, optional: true, required: false
  private _ipTables?: boolean | cdktf.IResolvable; 
  public get ipTables() {
    return this.getBooleanAttribute('ip_tables');
  }
  public set ipTables(value: boolean | cdktf.IResolvable) {
    this._ipTables = value;
  }
  public resetIpTables() {
    this._ipTables = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipTablesInput() {
    return this._ipTables;
  }

  // live_restore - computed: false, optional: true, required: false
  private _liveRestore?: boolean | cdktf.IResolvable; 
  public get liveRestore() {
    return this.getBooleanAttribute('live_restore');
  }
  public set liveRestore(value: boolean | cdktf.IResolvable) {
    this._liveRestore = value;
  }
  public resetLiveRestore() {
    this._liveRestore = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get liveRestoreInput() {
    return this._liveRestore;
  }

  // log_driver - computed: false, optional: true, required: false
  private _logDriver?: string; 
  public get logDriver() {
    return this.getStringAttribute('log_driver');
  }
  public set logDriver(value: string) {
    this._logDriver = value;
  }
  public resetLogDriver() {
    this._logDriver = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logDriverInput() {
    return this._logDriver;
  }

  // log_level - computed: false, optional: true, required: false
  private _logLevel?: string; 
  public get logLevel() {
    return this.getStringAttribute('log_level');
  }
  public set logLevel(value: string) {
    this._logLevel = value;
  }
  public resetLogLevel() {
    this._logLevel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logLevelInput() {
    return this._logLevel;
  }

  // log_opt - computed: false, optional: true, required: false
  private _logOpt?: string[]; 
  public get logOpt() {
    return this.getListAttribute('log_opt');
  }
  public set logOpt(value: string[]) {
    this._logOpt = value;
  }
  public resetLogOpt() {
    this._logOpt = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logOptInput() {
    return this._logOpt;
  }

  // max_concurrent_downloads - computed: false, optional: true, required: false
  private _maxConcurrentDownloads?: number; 
  public get maxConcurrentDownloads() {
    return this.getNumberAttribute('max_concurrent_downloads');
  }
  public set maxConcurrentDownloads(value: number) {
    this._maxConcurrentDownloads = value;
  }
  public resetMaxConcurrentDownloads() {
    this._maxConcurrentDownloads = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxConcurrentDownloadsInput() {
    return this._maxConcurrentDownloads;
  }

  // max_concurrent_uploads - computed: false, optional: true, required: false
  private _maxConcurrentUploads?: number; 
  public get maxConcurrentUploads() {
    return this.getNumberAttribute('max_concurrent_uploads');
  }
  public set maxConcurrentUploads(value: number) {
    this._maxConcurrentUploads = value;
  }
  public resetMaxConcurrentUploads() {
    this._maxConcurrentUploads = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxConcurrentUploadsInput() {
    return this._maxConcurrentUploads;
  }

  // max_download_attempts - computed: false, optional: true, required: false
  private _maxDownloadAttempts?: number; 
  public get maxDownloadAttempts() {
    return this.getNumberAttribute('max_download_attempts');
  }
  public set maxDownloadAttempts(value: number) {
    this._maxDownloadAttempts = value;
  }
  public resetMaxDownloadAttempts() {
    this._maxDownloadAttempts = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxDownloadAttemptsInput() {
    return this._maxDownloadAttempts;
  }

  // metrics_address - computed: false, optional: true, required: false
  private _metricsAddress?: string; 
  public get metricsAddress() {
    return this.getStringAttribute('metrics_address');
  }
  public set metricsAddress(value: string) {
    this._metricsAddress = value;
  }
  public resetMetricsAddress() {
    this._metricsAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricsAddressInput() {
    return this._metricsAddress;
  }

  // mtu - computed: false, optional: true, required: false
  private _mtu?: number; 
  public get mtu() {
    return this.getNumberAttribute('mtu');
  }
  public set mtu(value: number) {
    this._mtu = value;
  }
  public resetMtu() {
    this._mtu = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mtuInput() {
    return this._mtu;
  }

  // registry_mirrors - computed: false, optional: true, required: false
  private _registryMirrors?: string[]; 
  public get registryMirrors() {
    return this.getListAttribute('registry_mirrors');
  }
  public set registryMirrors(value: string[]) {
    this._registryMirrors = value;
  }
  public resetRegistryMirrors() {
    this._registryMirrors = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get registryMirrorsInput() {
    return this._registryMirrors;
  }

  // runtimes - computed: false, optional: true, required: false
  private _runtimes?: string[]; 
  public get runtimes() {
    return this.getListAttribute('runtimes');
  }
  public set runtimes(value: string[]) {
    this._runtimes = value;
  }
  public resetRuntimes() {
    this._runtimes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get runtimesInput() {
    return this._runtimes;
  }

  // selinux_enabled - computed: false, optional: true, required: false
  private _selinuxEnabled?: boolean | cdktf.IResolvable; 
  public get selinuxEnabled() {
    return this.getBooleanAttribute('selinux_enabled');
  }
  public set selinuxEnabled(value: boolean | cdktf.IResolvable) {
    this._selinuxEnabled = value;
  }
  public resetSelinuxEnabled() {
    this._selinuxEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selinuxEnabledInput() {
    return this._selinuxEnabled;
  }

  // skip_install - computed: false, optional: true, required: false
  private _skipInstall?: boolean | cdktf.IResolvable; 
  public get skipInstall() {
    return this.getBooleanAttribute('skip_install');
  }
  public set skipInstall(value: boolean | cdktf.IResolvable) {
    this._skipInstall = value;
  }
  public resetSkipInstall() {
    this._skipInstall = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get skipInstallInput() {
    return this._skipInstall;
  }

  // storage - computed: false, optional: true, required: false
  private _storage?: string; 
  public get storage() {
    return this.getStringAttribute('storage');
  }
  public set storage(value: string) {
    this._storage = value;
  }
  public resetStorage() {
    this._storage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get storageInput() {
    return this._storage;
  }

  // storage_opts - computed: false, optional: true, required: false
  private _storageOpts?: string[]; 
  public get storageOpts() {
    return this.getListAttribute('storage_opts');
  }
  public set storageOpts(value: string[]) {
    this._storageOpts = value;
  }
  public resetStorageOpts() {
    this._storageOpts = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get storageOptsInput() {
    return this._storageOpts;
  }

  // user_namespace_remap - computed: false, optional: true, required: false
  private _userNamespaceRemap?: string; 
  public get userNamespaceRemap() {
    return this.getStringAttribute('user_namespace_remap');
  }
  public set userNamespaceRemap(value: string) {
    this._userNamespaceRemap = value;
  }
  public resetUserNamespaceRemap() {
    this._userNamespaceRemap = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get userNamespaceRemapInput() {
    return this._userNamespaceRemap;
  }

  // version - computed: false, optional: true, required: false
  private _version?: string; 
  public get version() {
    return this.getStringAttribute('version');
  }
  public set version(value: string) {
    this._version = value;
  }
  public resetVersion() {
    this._version = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get versionInput() {
    return this._version;
  }

  // packages - computed: false, optional: true, required: false
  private _packages = new ClusterDockerPackagesOutputReference(this, "packages");
  public get packages() {
    return this._packages;
  }
  public putPackages(value: ClusterDockerPackages) {
    this._packages.internalValue = value;
  }
  public resetPackages() {
    this._packages.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get packagesInput() {
    return this._packages.internalValue;
  }
}
export interface ClusterEgressProxyHttpProxy {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#host Cluster#host}
  */
  readonly host: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#port Cluster#port}
  */
  readonly port: number;
}

export function clusterEgressProxyHttpProxyToTerraform(struct?: ClusterEgressProxyHttpProxyOutputReference | ClusterEgressProxyHttpProxy): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    host: cdktf.stringToTerraform(struct!.host),
    port: cdktf.numberToTerraform(struct!.port),
  }
}


export function clusterEgressProxyHttpProxyToHclTerraform(struct?: ClusterEgressProxyHttpProxyOutputReference | ClusterEgressProxyHttpProxy): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterEgressProxyHttpProxyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterEgressProxyHttpProxy | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterEgressProxyHttpProxy | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._host = undefined;
      this._port = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._host = value.host;
      this._port = value.port;
    }
  }

  // host - computed: false, optional: false, required: true
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }
}
export interface ClusterEgressProxy {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#proxy_excludes Cluster#proxy_excludes}
  */
  readonly proxyExcludes?: string;
  /**
  * http_proxy block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#http_proxy Cluster#http_proxy}
  */
  readonly httpProxy: ClusterEgressProxyHttpProxy;
}

export function clusterEgressProxyToTerraform(struct?: ClusterEgressProxyOutputReference | ClusterEgressProxy): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    proxy_excludes: cdktf.stringToTerraform(struct!.proxyExcludes),
    http_proxy: clusterEgressProxyHttpProxyToTerraform(struct!.httpProxy),
  }
}


export function clusterEgressProxyToHclTerraform(struct?: ClusterEgressProxyOutputReference | ClusterEgressProxy): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    proxy_excludes: {
      value: cdktf.stringToHclTerraform(struct!.proxyExcludes),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    http_proxy: {
      value: clusterEgressProxyHttpProxyToHclTerraform(struct!.httpProxy),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterEgressProxyHttpProxyList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterEgressProxyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterEgressProxy | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._proxyExcludes !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyExcludes = this._proxyExcludes;
    }
    if (this._httpProxy?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpProxy = this._httpProxy?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterEgressProxy | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._proxyExcludes = undefined;
      this._httpProxy.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._proxyExcludes = value.proxyExcludes;
      this._httpProxy.internalValue = value.httpProxy;
    }
  }

  // proxy_excludes - computed: false, optional: true, required: false
  private _proxyExcludes?: string; 
  public get proxyExcludes() {
    return this.getStringAttribute('proxy_excludes');
  }
  public set proxyExcludes(value: string) {
    this._proxyExcludes = value;
  }
  public resetProxyExcludes() {
    this._proxyExcludes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyExcludesInput() {
    return this._proxyExcludes;
  }

  // http_proxy - computed: false, optional: false, required: true
  private _httpProxy = new ClusterEgressProxyHttpProxyOutputReference(this, "http_proxy");
  public get httpProxy() {
    return this._httpProxy;
  }
  public putHttpProxy(value: ClusterEgressProxyHttpProxy) {
    this._httpProxy.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpProxyInput() {
    return this._httpProxy.internalValue;
  }
}
export interface ClusterEtcdClusterBackups {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#backup_store Cluster#backup_store}
  */
  readonly backupStore: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#image Cluster#image}
  */
  readonly image: string;
}

export function clusterEtcdClusterBackupsToTerraform(struct?: ClusterEtcdClusterBackupsOutputReference | ClusterEtcdClusterBackups): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backup_store: cdktf.stringToTerraform(struct!.backupStore),
    image: cdktf.stringToTerraform(struct!.image),
  }
}


export function clusterEtcdClusterBackupsToHclTerraform(struct?: ClusterEtcdClusterBackupsOutputReference | ClusterEtcdClusterBackups): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backup_store: {
      value: cdktf.stringToHclTerraform(struct!.backupStore),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    image: {
      value: cdktf.stringToHclTerraform(struct!.image),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterEtcdClusterBackupsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterEtcdClusterBackups | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backupStore !== undefined) {
      hasAnyValues = true;
      internalValueResult.backupStore = this._backupStore;
    }
    if (this._image !== undefined) {
      hasAnyValues = true;
      internalValueResult.image = this._image;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterEtcdClusterBackups | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._backupStore = undefined;
      this._image = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._backupStore = value.backupStore;
      this._image = value.image;
    }
  }

  // backup_store - computed: false, optional: false, required: true
  private _backupStore?: string; 
  public get backupStore() {
    return this.getStringAttribute('backup_store');
  }
  public set backupStore(value: string) {
    this._backupStore = value;
  }
  // Temporarily expose input value. Use with caution.
  public get backupStoreInput() {
    return this._backupStore;
  }

  // image - computed: false, optional: false, required: true
  private _image?: string; 
  public get image() {
    return this.getStringAttribute('image');
  }
  public set image(value: string) {
    this._image = value;
  }
  // Temporarily expose input value. Use with caution.
  public get imageInput() {
    return this._image;
  }
}
export interface ClusterEtcdClusterManagerEnv {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#name Cluster#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#value Cluster#value}
  */
  readonly value?: string;
}

export function clusterEtcdClusterManagerEnvToTerraform(struct?: ClusterEtcdClusterManagerEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function clusterEtcdClusterManagerEnvToHclTerraform(struct?: ClusterEtcdClusterManagerEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterEtcdClusterManagerEnvOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterEtcdClusterManagerEnv | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterEtcdClusterManagerEnv | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class ClusterEtcdClusterManagerEnvList extends cdktf.ComplexList {
  public internalValue? : ClusterEtcdClusterManagerEnv[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterEtcdClusterManagerEnvOutputReference {
    return new ClusterEtcdClusterManagerEnvOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterEtcdClusterManager {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#backup_interval Cluster#backup_interval}
  */
  readonly backupInterval?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#discovery_poll_interval Cluster#discovery_poll_interval}
  */
  readonly discoveryPollInterval?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#image Cluster#image}
  */
  readonly image?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#log_level Cluster#log_level}
  */
  readonly logLevel?: number;
  /**
  * env block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#env Cluster#env}
  */
  readonly env?: ClusterEtcdClusterManagerEnv[] | cdktf.IResolvable;
}

export function clusterEtcdClusterManagerToTerraform(struct?: ClusterEtcdClusterManagerOutputReference | ClusterEtcdClusterManager): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backup_interval: cdktf.stringToTerraform(struct!.backupInterval),
    discovery_poll_interval: cdktf.stringToTerraform(struct!.discoveryPollInterval),
    image: cdktf.stringToTerraform(struct!.image),
    log_level: cdktf.numberToTerraform(struct!.logLevel),
    env: cdktf.listMapper(clusterEtcdClusterManagerEnvToTerraform, true)(struct!.env),
  }
}


export function clusterEtcdClusterManagerToHclTerraform(struct?: ClusterEtcdClusterManagerOutputReference | ClusterEtcdClusterManager): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backup_interval: {
      value: cdktf.stringToHclTerraform(struct!.backupInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    discovery_poll_interval: {
      value: cdktf.stringToHclTerraform(struct!.discoveryPollInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    image: {
      value: cdktf.stringToHclTerraform(struct!.image),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_level: {
      value: cdktf.numberToHclTerraform(struct!.logLevel),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    env: {
      value: cdktf.listMapperHcl(clusterEtcdClusterManagerEnvToHclTerraform, true)(struct!.env),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterEtcdClusterManagerEnvList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterEtcdClusterManagerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterEtcdClusterManager | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backupInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.backupInterval = this._backupInterval;
    }
    if (this._discoveryPollInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.discoveryPollInterval = this._discoveryPollInterval;
    }
    if (this._image !== undefined) {
      hasAnyValues = true;
      internalValueResult.image = this._image;
    }
    if (this._logLevel !== undefined) {
      hasAnyValues = true;
      internalValueResult.logLevel = this._logLevel;
    }
    if (this._env?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.env = this._env?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterEtcdClusterManager | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._backupInterval = undefined;
      this._discoveryPollInterval = undefined;
      this._image = undefined;
      this._logLevel = undefined;
      this._env.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._backupInterval = value.backupInterval;
      this._discoveryPollInterval = value.discoveryPollInterval;
      this._image = value.image;
      this._logLevel = value.logLevel;
      this._env.internalValue = value.env;
    }
  }

  // backup_interval - computed: false, optional: true, required: false
  private _backupInterval?: string; 
  public get backupInterval() {
    return this.getStringAttribute('backup_interval');
  }
  public set backupInterval(value: string) {
    this._backupInterval = value;
  }
  public resetBackupInterval() {
    this._backupInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backupIntervalInput() {
    return this._backupInterval;
  }

  // discovery_poll_interval - computed: false, optional: true, required: false
  private _discoveryPollInterval?: string; 
  public get discoveryPollInterval() {
    return this.getStringAttribute('discovery_poll_interval');
  }
  public set discoveryPollInterval(value: string) {
    this._discoveryPollInterval = value;
  }
  public resetDiscoveryPollInterval() {
    this._discoveryPollInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get discoveryPollIntervalInput() {
    return this._discoveryPollInterval;
  }

  // image - computed: false, optional: true, required: false
  private _image?: string; 
  public get image() {
    return this.getStringAttribute('image');
  }
  public set image(value: string) {
    this._image = value;
  }
  public resetImage() {
    this._image = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageInput() {
    return this._image;
  }

  // log_level - computed: false, optional: true, required: false
  private _logLevel?: number; 
  public get logLevel() {
    return this.getNumberAttribute('log_level');
  }
  public set logLevel(value: number) {
    this._logLevel = value;
  }
  public resetLogLevel() {
    this._logLevel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logLevelInput() {
    return this._logLevel;
  }

  // env - computed: false, optional: true, required: false
  private _env = new ClusterEtcdClusterManagerEnvList(this, "env", false);
  public get env() {
    return this._env;
  }
  public putEnv(value: ClusterEtcdClusterManagerEnv[] | cdktf.IResolvable) {
    this._env.internalValue = value;
  }
  public resetEnv() {
    this._env.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get envInput() {
    return this._env.internalValue;
  }
}
export interface ClusterEtcdClusterMember {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#encrypted_volume Cluster#encrypted_volume}
  */
  readonly encryptedVolume?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#instance_group Cluster#instance_group}
  */
  readonly instanceGroup: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#kms_key_id Cluster#kms_key_id}
  */
  readonly kmsKeyId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#name Cluster#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#volume_iops Cluster#volume_iops}
  */
  readonly volumeIops?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#volume_size Cluster#volume_size}
  */
  readonly volumeSize?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#volume_throughput Cluster#volume_throughput}
  */
  readonly volumeThroughput?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#volume_type Cluster#volume_type}
  */
  readonly volumeType?: string;
}

export function clusterEtcdClusterMemberToTerraform(struct?: ClusterEtcdClusterMember | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    encrypted_volume: cdktf.booleanToTerraform(struct!.encryptedVolume),
    instance_group: cdktf.stringToTerraform(struct!.instanceGroup),
    kms_key_id: cdktf.stringToTerraform(struct!.kmsKeyId),
    name: cdktf.stringToTerraform(struct!.name),
    volume_iops: cdktf.numberToTerraform(struct!.volumeIops),
    volume_size: cdktf.numberToTerraform(struct!.volumeSize),
    volume_throughput: cdktf.numberToTerraform(struct!.volumeThroughput),
    volume_type: cdktf.stringToTerraform(struct!.volumeType),
  }
}


export function clusterEtcdClusterMemberToHclTerraform(struct?: ClusterEtcdClusterMember | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    encrypted_volume: {
      value: cdktf.booleanToHclTerraform(struct!.encryptedVolume),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    instance_group: {
      value: cdktf.stringToHclTerraform(struct!.instanceGroup),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kms_key_id: {
      value: cdktf.stringToHclTerraform(struct!.kmsKeyId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    volume_iops: {
      value: cdktf.numberToHclTerraform(struct!.volumeIops),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    volume_size: {
      value: cdktf.numberToHclTerraform(struct!.volumeSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    volume_throughput: {
      value: cdktf.numberToHclTerraform(struct!.volumeThroughput),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    volume_type: {
      value: cdktf.stringToHclTerraform(struct!.volumeType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterEtcdClusterMemberOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterEtcdClusterMember | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._encryptedVolume !== undefined) {
      hasAnyValues = true;
      internalValueResult.encryptedVolume = this._encryptedVolume;
    }
    if (this._instanceGroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.instanceGroup = this._instanceGroup;
    }
    if (this._kmsKeyId !== undefined) {
      hasAnyValues = true;
      internalValueResult.kmsKeyId = this._kmsKeyId;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._volumeIops !== undefined) {
      hasAnyValues = true;
      internalValueResult.volumeIops = this._volumeIops;
    }
    if (this._volumeSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.volumeSize = this._volumeSize;
    }
    if (this._volumeThroughput !== undefined) {
      hasAnyValues = true;
      internalValueResult.volumeThroughput = this._volumeThroughput;
    }
    if (this._volumeType !== undefined) {
      hasAnyValues = true;
      internalValueResult.volumeType = this._volumeType;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterEtcdClusterMember | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._encryptedVolume = undefined;
      this._instanceGroup = undefined;
      this._kmsKeyId = undefined;
      this._name = undefined;
      this._volumeIops = undefined;
      this._volumeSize = undefined;
      this._volumeThroughput = undefined;
      this._volumeType = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._encryptedVolume = value.encryptedVolume;
      this._instanceGroup = value.instanceGroup;
      this._kmsKeyId = value.kmsKeyId;
      this._name = value.name;
      this._volumeIops = value.volumeIops;
      this._volumeSize = value.volumeSize;
      this._volumeThroughput = value.volumeThroughput;
      this._volumeType = value.volumeType;
    }
  }

  // encrypted_volume - computed: false, optional: true, required: false
  private _encryptedVolume?: boolean | cdktf.IResolvable; 
  public get encryptedVolume() {
    return this.getBooleanAttribute('encrypted_volume');
  }
  public set encryptedVolume(value: boolean | cdktf.IResolvable) {
    this._encryptedVolume = value;
  }
  public resetEncryptedVolume() {
    this._encryptedVolume = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get encryptedVolumeInput() {
    return this._encryptedVolume;
  }

  // instance_group - computed: false, optional: false, required: true
  private _instanceGroup?: string; 
  public get instanceGroup() {
    return this.getStringAttribute('instance_group');
  }
  public set instanceGroup(value: string) {
    this._instanceGroup = value;
  }
  // Temporarily expose input value. Use with caution.
  public get instanceGroupInput() {
    return this._instanceGroup;
  }

  // kms_key_id - computed: false, optional: true, required: false
  private _kmsKeyId?: string; 
  public get kmsKeyId() {
    return this.getStringAttribute('kms_key_id');
  }
  public set kmsKeyId(value: string) {
    this._kmsKeyId = value;
  }
  public resetKmsKeyId() {
    this._kmsKeyId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kmsKeyIdInput() {
    return this._kmsKeyId;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // volume_iops - computed: false, optional: true, required: false
  private _volumeIops?: number; 
  public get volumeIops() {
    return this.getNumberAttribute('volume_iops');
  }
  public set volumeIops(value: number) {
    this._volumeIops = value;
  }
  public resetVolumeIops() {
    this._volumeIops = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get volumeIopsInput() {
    return this._volumeIops;
  }

  // volume_size - computed: false, optional: true, required: false
  private _volumeSize?: number; 
  public get volumeSize() {
    return this.getNumberAttribute('volume_size');
  }
  public set volumeSize(value: number) {
    this._volumeSize = value;
  }
  public resetVolumeSize() {
    this._volumeSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get volumeSizeInput() {
    return this._volumeSize;
  }

  // volume_throughput - computed: false, optional: true, required: false
  private _volumeThroughput?: number; 
  public get volumeThroughput() {
    return this.getNumberAttribute('volume_throughput');
  }
  public set volumeThroughput(value: number) {
    this._volumeThroughput = value;
  }
  public resetVolumeThroughput() {
    this._volumeThroughput = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get volumeThroughputInput() {
    return this._volumeThroughput;
  }

  // volume_type - computed: false, optional: true, required: false
  private _volumeType?: string; 
  public get volumeType() {
    return this.getStringAttribute('volume_type');
  }
  public set volumeType(value: string) {
    this._volumeType = value;
  }
  public resetVolumeType() {
    this._volumeType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get volumeTypeInput() {
    return this._volumeType;
  }
}

export class ClusterEtcdClusterMemberList extends cdktf.ComplexList {
  public internalValue? : ClusterEtcdClusterMember[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterEtcdClusterMemberOutputReference {
    return new ClusterEtcdClusterMemberOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterEtcdCluster {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#cpu_request Cluster#cpu_request}
  */
  readonly cpuRequest?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#heartbeat_interval Cluster#heartbeat_interval}
  */
  readonly heartbeatInterval?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#image Cluster#image}
  */
  readonly image?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#leader_election_timeout Cluster#leader_election_timeout}
  */
  readonly leaderElectionTimeout?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#memory_request Cluster#memory_request}
  */
  readonly memoryRequest?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#name Cluster#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#provider Cluster#provider}
  */
  readonly provider?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#version Cluster#version}
  */
  readonly version?: string;
  /**
  * backups block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#backups Cluster#backups}
  */
  readonly backups?: ClusterEtcdClusterBackups;
  /**
  * manager block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#manager Cluster#manager}
  */
  readonly manager?: ClusterEtcdClusterManager;
  /**
  * member block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#member Cluster#member}
  */
  readonly member: ClusterEtcdClusterMember[] | cdktf.IResolvable;
}

export function clusterEtcdClusterToTerraform(struct?: ClusterEtcdCluster | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cpu_request: cdktf.stringToTerraform(struct!.cpuRequest),
    heartbeat_interval: cdktf.stringToTerraform(struct!.heartbeatInterval),
    image: cdktf.stringToTerraform(struct!.image),
    leader_election_timeout: cdktf.stringToTerraform(struct!.leaderElectionTimeout),
    memory_request: cdktf.stringToTerraform(struct!.memoryRequest),
    name: cdktf.stringToTerraform(struct!.name),
    provider: cdktf.stringToTerraform(struct!.provider),
    version: cdktf.stringToTerraform(struct!.version),
    backups: clusterEtcdClusterBackupsToTerraform(struct!.backups),
    manager: clusterEtcdClusterManagerToTerraform(struct!.manager),
    member: cdktf.listMapper(clusterEtcdClusterMemberToTerraform, true)(struct!.member),
  }
}


export function clusterEtcdClusterToHclTerraform(struct?: ClusterEtcdCluster | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cpu_request: {
      value: cdktf.stringToHclTerraform(struct!.cpuRequest),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    heartbeat_interval: {
      value: cdktf.stringToHclTerraform(struct!.heartbeatInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    image: {
      value: cdktf.stringToHclTerraform(struct!.image),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    leader_election_timeout: {
      value: cdktf.stringToHclTerraform(struct!.leaderElectionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    memory_request: {
      value: cdktf.stringToHclTerraform(struct!.memoryRequest),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    provider: {
      value: cdktf.stringToHclTerraform(struct!.provider),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    version: {
      value: cdktf.stringToHclTerraform(struct!.version),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    backups: {
      value: clusterEtcdClusterBackupsToHclTerraform(struct!.backups),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterEtcdClusterBackupsList",
    },
    manager: {
      value: clusterEtcdClusterManagerToHclTerraform(struct!.manager),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterEtcdClusterManagerList",
    },
    member: {
      value: cdktf.listMapperHcl(clusterEtcdClusterMemberToHclTerraform, true)(struct!.member),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterEtcdClusterMemberList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterEtcdClusterOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterEtcdCluster | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cpuRequest !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpuRequest = this._cpuRequest;
    }
    if (this._heartbeatInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.heartbeatInterval = this._heartbeatInterval;
    }
    if (this._image !== undefined) {
      hasAnyValues = true;
      internalValueResult.image = this._image;
    }
    if (this._leaderElectionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.leaderElectionTimeout = this._leaderElectionTimeout;
    }
    if (this._memoryRequest !== undefined) {
      hasAnyValues = true;
      internalValueResult.memoryRequest = this._memoryRequest;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._provider !== undefined) {
      hasAnyValues = true;
      internalValueResult.provider = this._provider;
    }
    if (this._version !== undefined) {
      hasAnyValues = true;
      internalValueResult.version = this._version;
    }
    if (this._backups?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.backups = this._backups?.internalValue;
    }
    if (this._manager?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.manager = this._manager?.internalValue;
    }
    if (this._member?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.member = this._member?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterEtcdCluster | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cpuRequest = undefined;
      this._heartbeatInterval = undefined;
      this._image = undefined;
      this._leaderElectionTimeout = undefined;
      this._memoryRequest = undefined;
      this._name = undefined;
      this._provider = undefined;
      this._version = undefined;
      this._backups.internalValue = undefined;
      this._manager.internalValue = undefined;
      this._member.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cpuRequest = value.cpuRequest;
      this._heartbeatInterval = value.heartbeatInterval;
      this._image = value.image;
      this._leaderElectionTimeout = value.leaderElectionTimeout;
      this._memoryRequest = value.memoryRequest;
      this._name = value.name;
      this._provider = value.provider;
      this._version = value.version;
      this._backups.internalValue = value.backups;
      this._manager.internalValue = value.manager;
      this._member.internalValue = value.member;
    }
  }

  // cpu_request - computed: false, optional: true, required: false
  private _cpuRequest?: string; 
  public get cpuRequest() {
    return this.getStringAttribute('cpu_request');
  }
  public set cpuRequest(value: string) {
    this._cpuRequest = value;
  }
  public resetCpuRequest() {
    this._cpuRequest = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuRequestInput() {
    return this._cpuRequest;
  }

  // heartbeat_interval - computed: false, optional: true, required: false
  private _heartbeatInterval?: string; 
  public get heartbeatInterval() {
    return this.getStringAttribute('heartbeat_interval');
  }
  public set heartbeatInterval(value: string) {
    this._heartbeatInterval = value;
  }
  public resetHeartbeatInterval() {
    this._heartbeatInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get heartbeatIntervalInput() {
    return this._heartbeatInterval;
  }

  // image - computed: false, optional: true, required: false
  private _image?: string; 
  public get image() {
    return this.getStringAttribute('image');
  }
  public set image(value: string) {
    this._image = value;
  }
  public resetImage() {
    this._image = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageInput() {
    return this._image;
  }

  // leader_election_timeout - computed: false, optional: true, required: false
  private _leaderElectionTimeout?: string; 
  public get leaderElectionTimeout() {
    return this.getStringAttribute('leader_election_timeout');
  }
  public set leaderElectionTimeout(value: string) {
    this._leaderElectionTimeout = value;
  }
  public resetLeaderElectionTimeout() {
    this._leaderElectionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get leaderElectionTimeoutInput() {
    return this._leaderElectionTimeout;
  }

  // memory_request - computed: false, optional: true, required: false
  private _memoryRequest?: string; 
  public get memoryRequest() {
    return this.getStringAttribute('memory_request');
  }
  public set memoryRequest(value: string) {
    this._memoryRequest = value;
  }
  public resetMemoryRequest() {
    this._memoryRequest = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryRequestInput() {
    return this._memoryRequest;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // provider - computed: false, optional: true, required: false
  private _provider?: string; 
  public get provider() {
    return this.getStringAttribute('provider');
  }
  public set provider(value: string) {
    this._provider = value;
  }
  public resetProvider() {
    this._provider = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get providerInput() {
    return this._provider;
  }

  // version - computed: false, optional: true, required: false
  private _version?: string; 
  public get version() {
    return this.getStringAttribute('version');
  }
  public set version(value: string) {
    this._version = value;
  }
  public resetVersion() {
    this._version = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get versionInput() {
    return this._version;
  }

  // backups - computed: false, optional: true, required: false
  private _backups = new ClusterEtcdClusterBackupsOutputReference(this, "backups");
  public get backups() {
    return this._backups;
  }
  public putBackups(value: ClusterEtcdClusterBackups) {
    this._backups.internalValue = value;
  }
  public resetBackups() {
    this._backups.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backupsInput() {
    return this._backups.internalValue;
  }

  // manager - computed: false, optional: true, required: false
  private _manager = new ClusterEtcdClusterManagerOutputReference(this, "manager");
  public get manager() {
    return this._manager;
  }
  public putManager(value: ClusterEtcdClusterManager) {
    this._manager.internalValue = value;
  }
  public resetManager() {
    this._manager.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get managerInput() {
    return this._manager.internalValue;
  }

  // member - computed: false, optional: false, required: true
  private _member = new ClusterEtcdClusterMemberList(this, "member", false);
  public get member() {
    return this._member;
  }
  public putMember(value: ClusterEtcdClusterMember[] | cdktf.IResolvable) {
    this._member.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get memberInput() {
    return this._member.internalValue;
  }
}

export class ClusterEtcdClusterList extends cdktf.ComplexList {
  public internalValue? : ClusterEtcdCluster[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterEtcdClusterOutputReference {
    return new ClusterEtcdClusterOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterExternalCloudControllerManagerLeaderElection {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#leader_elect Cluster#leader_elect}
  */
  readonly leaderElect?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#leader_elect_lease_duration Cluster#leader_elect_lease_duration}
  */
  readonly leaderElectLeaseDuration?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#leader_elect_renew_deadline_duration Cluster#leader_elect_renew_deadline_duration}
  */
  readonly leaderElectRenewDeadlineDuration?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#leader_elect_resource_lock Cluster#leader_elect_resource_lock}
  */
  readonly leaderElectResourceLock?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#leader_elect_resource_name Cluster#leader_elect_resource_name}
  */
  readonly leaderElectResourceName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#leader_elect_resource_namespace Cluster#leader_elect_resource_namespace}
  */
  readonly leaderElectResourceNamespace?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#leader_elect_retry_period Cluster#leader_elect_retry_period}
  */
  readonly leaderElectRetryPeriod?: string;
}

export function clusterExternalCloudControllerManagerLeaderElectionToTerraform(struct?: ClusterExternalCloudControllerManagerLeaderElectionOutputReference | ClusterExternalCloudControllerManagerLeaderElection): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    leader_elect: cdktf.booleanToTerraform(struct!.leaderElect),
    leader_elect_lease_duration: cdktf.stringToTerraform(struct!.leaderElectLeaseDuration),
    leader_elect_renew_deadline_duration: cdktf.stringToTerraform(struct!.leaderElectRenewDeadlineDuration),
    leader_elect_resource_lock: cdktf.stringToTerraform(struct!.leaderElectResourceLock),
    leader_elect_resource_name: cdktf.stringToTerraform(struct!.leaderElectResourceName),
    leader_elect_resource_namespace: cdktf.stringToTerraform(struct!.leaderElectResourceNamespace),
    leader_elect_retry_period: cdktf.stringToTerraform(struct!.leaderElectRetryPeriod),
  }
}


export function clusterExternalCloudControllerManagerLeaderElectionToHclTerraform(struct?: ClusterExternalCloudControllerManagerLeaderElectionOutputReference | ClusterExternalCloudControllerManagerLeaderElection): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    leader_elect: {
      value: cdktf.booleanToHclTerraform(struct!.leaderElect),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    leader_elect_lease_duration: {
      value: cdktf.stringToHclTerraform(struct!.leaderElectLeaseDuration),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    leader_elect_renew_deadline_duration: {
      value: cdktf.stringToHclTerraform(struct!.leaderElectRenewDeadlineDuration),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    leader_elect_resource_lock: {
      value: cdktf.stringToHclTerraform(struct!.leaderElectResourceLock),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    leader_elect_resource_name: {
      value: cdktf.stringToHclTerraform(struct!.leaderElectResourceName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    leader_elect_resource_namespace: {
      value: cdktf.stringToHclTerraform(struct!.leaderElectResourceNamespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    leader_elect_retry_period: {
      value: cdktf.stringToHclTerraform(struct!.leaderElectRetryPeriod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterExternalCloudControllerManagerLeaderElectionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterExternalCloudControllerManagerLeaderElection | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._leaderElect !== undefined) {
      hasAnyValues = true;
      internalValueResult.leaderElect = this._leaderElect;
    }
    if (this._leaderElectLeaseDuration !== undefined) {
      hasAnyValues = true;
      internalValueResult.leaderElectLeaseDuration = this._leaderElectLeaseDuration;
    }
    if (this._leaderElectRenewDeadlineDuration !== undefined) {
      hasAnyValues = true;
      internalValueResult.leaderElectRenewDeadlineDuration = this._leaderElectRenewDeadlineDuration;
    }
    if (this._leaderElectResourceLock !== undefined) {
      hasAnyValues = true;
      internalValueResult.leaderElectResourceLock = this._leaderElectResourceLock;
    }
    if (this._leaderElectResourceName !== undefined) {
      hasAnyValues = true;
      internalValueResult.leaderElectResourceName = this._leaderElectResourceName;
    }
    if (this._leaderElectResourceNamespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.leaderElectResourceNamespace = this._leaderElectResourceNamespace;
    }
    if (this._leaderElectRetryPeriod !== undefined) {
      hasAnyValues = true;
      internalValueResult.leaderElectRetryPeriod = this._leaderElectRetryPeriod;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterExternalCloudControllerManagerLeaderElection | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._leaderElect = undefined;
      this._leaderElectLeaseDuration = undefined;
      this._leaderElectRenewDeadlineDuration = undefined;
      this._leaderElectResourceLock = undefined;
      this._leaderElectResourceName = undefined;
      this._leaderElectResourceNamespace = undefined;
      this._leaderElectRetryPeriod = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._leaderElect = value.leaderElect;
      this._leaderElectLeaseDuration = value.leaderElectLeaseDuration;
      this._leaderElectRenewDeadlineDuration = value.leaderElectRenewDeadlineDuration;
      this._leaderElectResourceLock = value.leaderElectResourceLock;
      this._leaderElectResourceName = value.leaderElectResourceName;
      this._leaderElectResourceNamespace = value.leaderElectResourceNamespace;
      this._leaderElectRetryPeriod = value.leaderElectRetryPeriod;
    }
  }

  // leader_elect - computed: false, optional: true, required: false
  private _leaderElect?: boolean | cdktf.IResolvable; 
  public get leaderElect() {
    return this.getBooleanAttribute('leader_elect');
  }
  public set leaderElect(value: boolean | cdktf.IResolvable) {
    this._leaderElect = value;
  }
  public resetLeaderElect() {
    this._leaderElect = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get leaderElectInput() {
    return this._leaderElect;
  }

  // leader_elect_lease_duration - computed: false, optional: true, required: false
  private _leaderElectLeaseDuration?: string; 
  public get leaderElectLeaseDuration() {
    return this.getStringAttribute('leader_elect_lease_duration');
  }
  public set leaderElectLeaseDuration(value: string) {
    this._leaderElectLeaseDuration = value;
  }
  public resetLeaderElectLeaseDuration() {
    this._leaderElectLeaseDuration = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get leaderElectLeaseDurationInput() {
    return this._leaderElectLeaseDuration;
  }

  // leader_elect_renew_deadline_duration - computed: false, optional: true, required: false
  private _leaderElectRenewDeadlineDuration?: string; 
  public get leaderElectRenewDeadlineDuration() {
    return this.getStringAttribute('leader_elect_renew_deadline_duration');
  }
  public set leaderElectRenewDeadlineDuration(value: string) {
    this._leaderElectRenewDeadlineDuration = value;
  }
  public resetLeaderElectRenewDeadlineDuration() {
    this._leaderElectRenewDeadlineDuration = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get leaderElectRenewDeadlineDurationInput() {
    return this._leaderElectRenewDeadlineDuration;
  }

  // leader_elect_resource_lock - computed: false, optional: true, required: false
  private _leaderElectResourceLock?: string; 
  public get leaderElectResourceLock() {
    return this.getStringAttribute('leader_elect_resource_lock');
  }
  public set leaderElectResourceLock(value: string) {
    this._leaderElectResourceLock = value;
  }
  public resetLeaderElectResourceLock() {
    this._leaderElectResourceLock = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get leaderElectResourceLockInput() {
    return this._leaderElectResourceLock;
  }

  // leader_elect_resource_name - computed: false, optional: true, required: false
  private _leaderElectResourceName?: string; 
  public get leaderElectResourceName() {
    return this.getStringAttribute('leader_elect_resource_name');
  }
  public set leaderElectResourceName(value: string) {
    this._leaderElectResourceName = value;
  }
  public resetLeaderElectResourceName() {
    this._leaderElectResourceName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get leaderElectResourceNameInput() {
    return this._leaderElectResourceName;
  }

  // leader_elect_resource_namespace - computed: false, optional: true, required: false
  private _leaderElectResourceNamespace?: string; 
  public get leaderElectResourceNamespace() {
    return this.getStringAttribute('leader_elect_resource_namespace');
  }
  public set leaderElectResourceNamespace(value: string) {
    this._leaderElectResourceNamespace = value;
  }
  public resetLeaderElectResourceNamespace() {
    this._leaderElectResourceNamespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get leaderElectResourceNamespaceInput() {
    return this._leaderElectResourceNamespace;
  }

  // leader_elect_retry_period - computed: false, optional: true, required: false
  private _leaderElectRetryPeriod?: string; 
  public get leaderElectRetryPeriod() {
    return this.getStringAttribute('leader_elect_retry_period');
  }
  public set leaderElectRetryPeriod(value: string) {
    this._leaderElectRetryPeriod = value;
  }
  public resetLeaderElectRetryPeriod() {
    this._leaderElectRetryPeriod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get leaderElectRetryPeriodInput() {
    return this._leaderElectRetryPeriod;
  }
}
export interface ClusterExternalCloudControllerManager {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#allocate_node_cidrs Cluster#allocate_node_cidrs}
  */
  readonly allocateNodeCidrs?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#allow_untagged_cloud Cluster#allow_untagged_cloud}
  */
  readonly allowUntaggedCloud?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#cidr_allocator_type Cluster#cidr_allocator_type}
  */
  readonly cidrAllocatorType?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#cloud_provider Cluster#cloud_provider}
  */
  readonly cloudProvider?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#cluster_cidr Cluster#cluster_cidr}
  */
  readonly clusterCidr?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#cluster_name Cluster#cluster_name}
  */
  readonly clusterName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#configure_cloud_routes Cluster#configure_cloud_routes}
  */
  readonly configureCloudRoutes?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#controllers Cluster#controllers}
  */
  readonly controllers?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#cpu_request Cluster#cpu_request}
  */
  readonly cpuRequest?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#enable_leader_migration Cluster#enable_leader_migration}
  */
  readonly enableLeaderMigration?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#image Cluster#image}
  */
  readonly image?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#log_level Cluster#log_level}
  */
  readonly logLevel?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#master Cluster#master}
  */
  readonly master?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#use_service_account_credentials Cluster#use_service_account_credentials}
  */
  readonly useServiceAccountCredentials?: boolean | cdktf.IResolvable;
  /**
  * leader_election block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#leader_election Cluster#leader_election}
  */
  readonly leaderElection?: ClusterExternalCloudControllerManagerLeaderElection;
}

export function clusterExternalCloudControllerManagerToTerraform(struct?: ClusterExternalCloudControllerManagerOutputReference | ClusterExternalCloudControllerManager): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allocate_node_cidrs: cdktf.booleanToTerraform(struct!.allocateNodeCidrs),
    allow_untagged_cloud: cdktf.booleanToTerraform(struct!.allowUntaggedCloud),
    cidr_allocator_type: cdktf.stringToTerraform(struct!.cidrAllocatorType),
    cloud_provider: cdktf.stringToTerraform(struct!.cloudProvider),
    cluster_cidr: cdktf.stringToTerraform(struct!.clusterCidr),
    cluster_name: cdktf.stringToTerraform(struct!.clusterName),
    configure_cloud_routes: cdktf.booleanToTerraform(struct!.configureCloudRoutes),
    controllers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.controllers),
    cpu_request: cdktf.stringToTerraform(struct!.cpuRequest),
    enable_leader_migration: cdktf.booleanToTerraform(struct!.enableLeaderMigration),
    image: cdktf.stringToTerraform(struct!.image),
    log_level: cdktf.numberToTerraform(struct!.logLevel),
    master: cdktf.stringToTerraform(struct!.master),
    use_service_account_credentials: cdktf.booleanToTerraform(struct!.useServiceAccountCredentials),
    leader_election: clusterExternalCloudControllerManagerLeaderElectionToTerraform(struct!.leaderElection),
  }
}


export function clusterExternalCloudControllerManagerToHclTerraform(struct?: ClusterExternalCloudControllerManagerOutputReference | ClusterExternalCloudControllerManager): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allocate_node_cidrs: {
      value: cdktf.booleanToHclTerraform(struct!.allocateNodeCidrs),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    allow_untagged_cloud: {
      value: cdktf.booleanToHclTerraform(struct!.allowUntaggedCloud),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    cidr_allocator_type: {
      value: cdktf.stringToHclTerraform(struct!.cidrAllocatorType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cloud_provider: {
      value: cdktf.stringToHclTerraform(struct!.cloudProvider),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cluster_cidr: {
      value: cdktf.stringToHclTerraform(struct!.clusterCidr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cluster_name: {
      value: cdktf.stringToHclTerraform(struct!.clusterName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    configure_cloud_routes: {
      value: cdktf.booleanToHclTerraform(struct!.configureCloudRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    controllers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.controllers),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    cpu_request: {
      value: cdktf.stringToHclTerraform(struct!.cpuRequest),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enable_leader_migration: {
      value: cdktf.booleanToHclTerraform(struct!.enableLeaderMigration),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    image: {
      value: cdktf.stringToHclTerraform(struct!.image),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_level: {
      value: cdktf.numberToHclTerraform(struct!.logLevel),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    master: {
      value: cdktf.stringToHclTerraform(struct!.master),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_service_account_credentials: {
      value: cdktf.booleanToHclTerraform(struct!.useServiceAccountCredentials),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    leader_election: {
      value: clusterExternalCloudControllerManagerLeaderElectionToHclTerraform(struct!.leaderElection),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterExternalCloudControllerManagerLeaderElectionList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterExternalCloudControllerManagerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterExternalCloudControllerManager | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allocateNodeCidrs !== undefined) {
      hasAnyValues = true;
      internalValueResult.allocateNodeCidrs = this._allocateNodeCidrs;
    }
    if (this._allowUntaggedCloud !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowUntaggedCloud = this._allowUntaggedCloud;
    }
    if (this._cidrAllocatorType !== undefined) {
      hasAnyValues = true;
      internalValueResult.cidrAllocatorType = this._cidrAllocatorType;
    }
    if (this._cloudProvider !== undefined) {
      hasAnyValues = true;
      internalValueResult.cloudProvider = this._cloudProvider;
    }
    if (this._clusterCidr !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterCidr = this._clusterCidr;
    }
    if (this._clusterName !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterName = this._clusterName;
    }
    if (this._configureCloudRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.configureCloudRoutes = this._configureCloudRoutes;
    }
    if (this._controllers !== undefined) {
      hasAnyValues = true;
      internalValueResult.controllers = this._controllers;
    }
    if (this._cpuRequest !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpuRequest = this._cpuRequest;
    }
    if (this._enableLeaderMigration !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableLeaderMigration = this._enableLeaderMigration;
    }
    if (this._image !== undefined) {
      hasAnyValues = true;
      internalValueResult.image = this._image;
    }
    if (this._logLevel !== undefined) {
      hasAnyValues = true;
      internalValueResult.logLevel = this._logLevel;
    }
    if (this._master !== undefined) {
      hasAnyValues = true;
      internalValueResult.master = this._master;
    }
    if (this._useServiceAccountCredentials !== undefined) {
      hasAnyValues = true;
      internalValueResult.useServiceAccountCredentials = this._useServiceAccountCredentials;
    }
    if (this._leaderElection?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.leaderElection = this._leaderElection?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterExternalCloudControllerManager | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._allocateNodeCidrs = undefined;
      this._allowUntaggedCloud = undefined;
      this._cidrAllocatorType = undefined;
      this._cloudProvider = undefined;
      this._clusterCidr = undefined;
      this._clusterName = undefined;
      this._configureCloudRoutes = undefined;
      this._controllers = undefined;
      this._cpuRequest = undefined;
      this._enableLeaderMigration = undefined;
      this._image = undefined;
      this._logLevel = undefined;
      this._master = undefined;
      this._useServiceAccountCredentials = undefined;
      this._leaderElection.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._allocateNodeCidrs = value.allocateNodeCidrs;
      this._allowUntaggedCloud = value.allowUntaggedCloud;
      this._cidrAllocatorType = value.cidrAllocatorType;
      this._cloudProvider = value.cloudProvider;
      this._clusterCidr = value.clusterCidr;
      this._clusterName = value.clusterName;
      this._configureCloudRoutes = value.configureCloudRoutes;
      this._controllers = value.controllers;
      this._cpuRequest = value.cpuRequest;
      this._enableLeaderMigration = value.enableLeaderMigration;
      this._image = value.image;
      this._logLevel = value.logLevel;
      this._master = value.master;
      this._useServiceAccountCredentials = value.useServiceAccountCredentials;
      this._leaderElection.internalValue = value.leaderElection;
    }
  }

  // allocate_node_cidrs - computed: false, optional: true, required: false
  private _allocateNodeCidrs?: boolean | cdktf.IResolvable; 
  public get allocateNodeCidrs() {
    return this.getBooleanAttribute('allocate_node_cidrs');
  }
  public set allocateNodeCidrs(value: boolean | cdktf.IResolvable) {
    this._allocateNodeCidrs = value;
  }
  public resetAllocateNodeCidrs() {
    this._allocateNodeCidrs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allocateNodeCidrsInput() {
    return this._allocateNodeCidrs;
  }

  // allow_untagged_cloud - computed: false, optional: true, required: false
  private _allowUntaggedCloud?: boolean | cdktf.IResolvable; 
  public get allowUntaggedCloud() {
    return this.getBooleanAttribute('allow_untagged_cloud');
  }
  public set allowUntaggedCloud(value: boolean | cdktf.IResolvable) {
    this._allowUntaggedCloud = value;
  }
  public resetAllowUntaggedCloud() {
    this._allowUntaggedCloud = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowUntaggedCloudInput() {
    return this._allowUntaggedCloud;
  }

  // cidr_allocator_type - computed: false, optional: true, required: false
  private _cidrAllocatorType?: string; 
  public get cidrAllocatorType() {
    return this.getStringAttribute('cidr_allocator_type');
  }
  public set cidrAllocatorType(value: string) {
    this._cidrAllocatorType = value;
  }
  public resetCidrAllocatorType() {
    this._cidrAllocatorType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cidrAllocatorTypeInput() {
    return this._cidrAllocatorType;
  }

  // cloud_provider - computed: false, optional: true, required: false
  private _cloudProvider?: string; 
  public get cloudProvider() {
    return this.getStringAttribute('cloud_provider');
  }
  public set cloudProvider(value: string) {
    this._cloudProvider = value;
  }
  public resetCloudProvider() {
    this._cloudProvider = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cloudProviderInput() {
    return this._cloudProvider;
  }

  // cluster_cidr - computed: false, optional: true, required: false
  private _clusterCidr?: string; 
  public get clusterCidr() {
    return this.getStringAttribute('cluster_cidr');
  }
  public set clusterCidr(value: string) {
    this._clusterCidr = value;
  }
  public resetClusterCidr() {
    this._clusterCidr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterCidrInput() {
    return this._clusterCidr;
  }

  // cluster_name - computed: false, optional: true, required: false
  private _clusterName?: string; 
  public get clusterName() {
    return this.getStringAttribute('cluster_name');
  }
  public set clusterName(value: string) {
    this._clusterName = value;
  }
  public resetClusterName() {
    this._clusterName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterNameInput() {
    return this._clusterName;
  }

  // configure_cloud_routes - computed: false, optional: true, required: false
  private _configureCloudRoutes?: boolean | cdktf.IResolvable; 
  public get configureCloudRoutes() {
    return this.getBooleanAttribute('configure_cloud_routes');
  }
  public set configureCloudRoutes(value: boolean | cdktf.IResolvable) {
    this._configureCloudRoutes = value;
  }
  public resetConfigureCloudRoutes() {
    this._configureCloudRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configureCloudRoutesInput() {
    return this._configureCloudRoutes;
  }

  // controllers - computed: false, optional: true, required: false
  private _controllers?: string[]; 
  public get controllers() {
    return this.getListAttribute('controllers');
  }
  public set controllers(value: string[]) {
    this._controllers = value;
  }
  public resetControllers() {
    this._controllers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get controllersInput() {
    return this._controllers;
  }

  // cpu_request - computed: false, optional: true, required: false
  private _cpuRequest?: string; 
  public get cpuRequest() {
    return this.getStringAttribute('cpu_request');
  }
  public set cpuRequest(value: string) {
    this._cpuRequest = value;
  }
  public resetCpuRequest() {
    this._cpuRequest = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuRequestInput() {
    return this._cpuRequest;
  }

  // enable_leader_migration - computed: false, optional: true, required: false
  private _enableLeaderMigration?: boolean | cdktf.IResolvable; 
  public get enableLeaderMigration() {
    return this.getBooleanAttribute('enable_leader_migration');
  }
  public set enableLeaderMigration(value: boolean | cdktf.IResolvable) {
    this._enableLeaderMigration = value;
  }
  public resetEnableLeaderMigration() {
    this._enableLeaderMigration = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableLeaderMigrationInput() {
    return this._enableLeaderMigration;
  }

  // image - computed: false, optional: true, required: false
  private _image?: string; 
  public get image() {
    return this.getStringAttribute('image');
  }
  public set image(value: string) {
    this._image = value;
  }
  public resetImage() {
    this._image = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageInput() {
    return this._image;
  }

  // log_level - computed: false, optional: true, required: false
  private _logLevel?: number; 
  public get logLevel() {
    return this.getNumberAttribute('log_level');
  }
  public set logLevel(value: number) {
    this._logLevel = value;
  }
  public resetLogLevel() {
    this._logLevel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logLevelInput() {
    return this._logLevel;
  }

  // master - computed: false, optional: true, required: false
  private _master?: string; 
  public get master() {
    return this.getStringAttribute('master');
  }
  public set master(value: string) {
    this._master = value;
  }
  public resetMaster() {
    this._master = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get masterInput() {
    return this._master;
  }

  // use_service_account_credentials - computed: false, optional: true, required: false
  private _useServiceAccountCredentials?: boolean | cdktf.IResolvable; 
  public get useServiceAccountCredentials() {
    return this.getBooleanAttribute('use_service_account_credentials');
  }
  public set useServiceAccountCredentials(value: boolean | cdktf.IResolvable) {
    this._useServiceAccountCredentials = value;
  }
  public resetUseServiceAccountCredentials() {
    this._useServiceAccountCredentials = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useServiceAccountCredentialsInput() {
    return this._useServiceAccountCredentials;
  }

  // leader_election - computed: false, optional: true, required: false
  private _leaderElection = new ClusterExternalCloudControllerManagerLeaderElectionOutputReference(this, "leader_election");
  public get leaderElection() {
    return this._leaderElection;
  }
  public putLeaderElection(value: ClusterExternalCloudControllerManagerLeaderElection) {
    this._leaderElection.internalValue = value;
  }
  public resetLeaderElection() {
    this._leaderElection.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get leaderElectionInput() {
    return this._leaderElection.internalValue;
  }
}
export interface ClusterExternalDns {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#provider Cluster#provider}
  */
  readonly provider?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#watch_ingress Cluster#watch_ingress}
  */
  readonly watchIngress?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#watch_namespace Cluster#watch_namespace}
  */
  readonly watchNamespace?: string;
}

export function clusterExternalDnsToTerraform(struct?: ClusterExternalDnsOutputReference | ClusterExternalDns): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    provider: cdktf.stringToTerraform(struct!.provider),
    watch_ingress: cdktf.booleanToTerraform(struct!.watchIngress),
    watch_namespace: cdktf.stringToTerraform(struct!.watchNamespace),
  }
}


export function clusterExternalDnsToHclTerraform(struct?: ClusterExternalDnsOutputReference | ClusterExternalDns): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    provider: {
      value: cdktf.stringToHclTerraform(struct!.provider),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    watch_ingress: {
      value: cdktf.booleanToHclTerraform(struct!.watchIngress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    watch_namespace: {
      value: cdktf.stringToHclTerraform(struct!.watchNamespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterExternalDnsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterExternalDns | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._provider !== undefined) {
      hasAnyValues = true;
      internalValueResult.provider = this._provider;
    }
    if (this._watchIngress !== undefined) {
      hasAnyValues = true;
      internalValueResult.watchIngress = this._watchIngress;
    }
    if (this._watchNamespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.watchNamespace = this._watchNamespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterExternalDns | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._provider = undefined;
      this._watchIngress = undefined;
      this._watchNamespace = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._provider = value.provider;
      this._watchIngress = value.watchIngress;
      this._watchNamespace = value.watchNamespace;
    }
  }

  // provider - computed: false, optional: true, required: false
  private _provider?: string; 
  public get provider() {
    return this.getStringAttribute('provider');
  }
  public set provider(value: string) {
    this._provider = value;
  }
  public resetProvider() {
    this._provider = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get providerInput() {
    return this._provider;
  }

  // watch_ingress - computed: false, optional: true, required: false
  private _watchIngress?: boolean | cdktf.IResolvable; 
  public get watchIngress() {
    return this.getBooleanAttribute('watch_ingress');
  }
  public set watchIngress(value: boolean | cdktf.IResolvable) {
    this._watchIngress = value;
  }
  public resetWatchIngress() {
    this._watchIngress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get watchIngressInput() {
    return this._watchIngress;
  }

  // watch_namespace - computed: false, optional: true, required: false
  private _watchNamespace?: string; 
  public get watchNamespace() {
    return this.getStringAttribute('watch_namespace');
  }
  public set watchNamespace(value: string) {
    this._watchNamespace = value;
  }
  public resetWatchNamespace() {
    this._watchNamespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get watchNamespaceInput() {
    return this._watchNamespace;
  }
}
export interface ClusterExternalPolicies {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#key Cluster#key}
  */
  readonly key: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#value Cluster#value}
  */
  readonly value: string[];
}

export function clusterExternalPoliciesToTerraform(struct?: ClusterExternalPolicies | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.value),
  }
}


export function clusterExternalPoliciesToHclTerraform(struct?: ClusterExternalPolicies | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.value),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterExternalPoliciesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterExternalPolicies | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterExternalPolicies | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value = value.value;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string[]; 
  public get value() {
    return this.getListAttribute('value');
  }
  public set value(value: string[]) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class ClusterExternalPoliciesList extends cdktf.ComplexList {
  public internalValue? : ClusterExternalPolicies[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterExternalPoliciesOutputReference {
    return new ClusterExternalPoliciesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterFileAssets {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#content Cluster#content}
  */
  readonly content: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#is_base64 Cluster#is_base64}
  */
  readonly isBase64?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#mode Cluster#mode}
  */
  readonly mode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#name Cluster#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#path Cluster#path}
  */
  readonly path: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#roles Cluster#roles}
  */
  readonly roles?: string[];
}

export function clusterFileAssetsToTerraform(struct?: ClusterFileAssets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    content: cdktf.stringToTerraform(struct!.content),
    is_base64: cdktf.booleanToTerraform(struct!.isBase64),
    mode: cdktf.stringToTerraform(struct!.mode),
    name: cdktf.stringToTerraform(struct!.name),
    path: cdktf.stringToTerraform(struct!.path),
    roles: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.roles),
  }
}


export function clusterFileAssetsToHclTerraform(struct?: ClusterFileAssets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    content: {
      value: cdktf.stringToHclTerraform(struct!.content),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    is_base64: {
      value: cdktf.booleanToHclTerraform(struct!.isBase64),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    roles: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.roles),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterFileAssetsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterFileAssets | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._content !== undefined) {
      hasAnyValues = true;
      internalValueResult.content = this._content;
    }
    if (this._isBase64 !== undefined) {
      hasAnyValues = true;
      internalValueResult.isBase64 = this._isBase64;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._roles !== undefined) {
      hasAnyValues = true;
      internalValueResult.roles = this._roles;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterFileAssets | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._content = undefined;
      this._isBase64 = undefined;
      this._mode = undefined;
      this._name = undefined;
      this._path = undefined;
      this._roles = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._content = value.content;
      this._isBase64 = value.isBase64;
      this._mode = value.mode;
      this._name = value.name;
      this._path = value.path;
      this._roles = value.roles;
    }
  }

  // content - computed: false, optional: false, required: true
  private _content?: string; 
  public get content() {
    return this.getStringAttribute('content');
  }
  public set content(value: string) {
    this._content = value;
  }
  // Temporarily expose input value. Use with caution.
  public get contentInput() {
    return this._content;
  }

  // is_base64 - computed: false, optional: true, required: false
  private _isBase64?: boolean | cdktf.IResolvable; 
  public get isBase64() {
    return this.getBooleanAttribute('is_base64');
  }
  public set isBase64(value: boolean | cdktf.IResolvable) {
    this._isBase64 = value;
  }
  public resetIsBase64() {
    this._isBase64 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get isBase64Input() {
    return this._isBase64;
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // roles - computed: false, optional: true, required: false
  private _roles?: string[]; 
  public get roles() {
    return this.getListAttribute('roles');
  }
  public set roles(value: string[]) {
    this._roles = value;
  }
  public resetRoles() {
    this._roles = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rolesInput() {
    return this._roles;
  }
}

export class ClusterFileAssetsList extends cdktf.ComplexList {
  public internalValue? : ClusterFileAssets[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterFileAssetsOutputReference {
    return new ClusterFileAssetsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterHooksExecContainer {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#command Cluster#command}
  */
  readonly command?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#environment Cluster#environment}
  */
  readonly environment?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#image Cluster#image}
  */
  readonly image: string;
}

export function clusterHooksExecContainerToTerraform(struct?: ClusterHooksExecContainerOutputReference | ClusterHooksExecContainer): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    command: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.command),
    environment: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.environment),
    image: cdktf.stringToTerraform(struct!.image),
  }
}


export function clusterHooksExecContainerToHclTerraform(struct?: ClusterHooksExecContainerOutputReference | ClusterHooksExecContainer): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    command: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.command),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    environment: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.environment),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    image: {
      value: cdktf.stringToHclTerraform(struct!.image),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterHooksExecContainerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterHooksExecContainer | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._command !== undefined) {
      hasAnyValues = true;
      internalValueResult.command = this._command;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._image !== undefined) {
      hasAnyValues = true;
      internalValueResult.image = this._image;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterHooksExecContainer | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._command = undefined;
      this._environment = undefined;
      this._image = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._command = value.command;
      this._environment = value.environment;
      this._image = value.image;
    }
  }

  // command - computed: false, optional: true, required: false
  private _command?: string[]; 
  public get command() {
    return this.getListAttribute('command');
  }
  public set command(value: string[]) {
    this._command = value;
  }
  public resetCommand() {
    this._command = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commandInput() {
    return this._command;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: { [key: string]: string }; 
  public get environment() {
    return this.getStringMapAttribute('environment');
  }
  public set environment(value: { [key: string]: string }) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // image - computed: false, optional: false, required: true
  private _image?: string; 
  public get image() {
    return this.getStringAttribute('image');
  }
  public set image(value: string) {
    this._image = value;
  }
  // Temporarily expose input value. Use with caution.
  public get imageInput() {
    return this._image;
  }
}
export interface ClusterHooks {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#before Cluster#before}
  */
  readonly before?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#enabled Cluster#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#manifest Cluster#manifest}
  */
  readonly manifest?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#name Cluster#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#requires Cluster#requires}
  */
  readonly requires?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#roles Cluster#roles}
  */
  readonly roles?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#use_raw_manifest Cluster#use_raw_manifest}
  */
  readonly useRawManifest?: boolean | cdktf.IResolvable;
  /**
  * exec_container block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#exec_container Cluster#exec_container}
  */
  readonly execContainer?: ClusterHooksExecContainer;
}

export function clusterHooksToTerraform(struct?: ClusterHooks | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    before: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.before),
    enabled: cdktf.booleanToTerraform(struct!.enabled),
    manifest: cdktf.stringToTerraform(struct!.manifest),
    name: cdktf.stringToTerraform(struct!.name),
    requires: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.requires),
    roles: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.roles),
    use_raw_manifest: cdktf.booleanToTerraform(struct!.useRawManifest),
    exec_container: clusterHooksExecContainerToTerraform(struct!.execContainer),
  }
}


export function clusterHooksToHclTerraform(struct?: ClusterHooks | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    before: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.before),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    manifest: {
      value: cdktf.stringToHclTerraform(struct!.manifest),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    requires: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.requires),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    roles: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.roles),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    use_raw_manifest: {
      value: cdktf.booleanToHclTerraform(struct!.useRawManifest),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    exec_container: {
      value: clusterHooksExecContainerToHclTerraform(struct!.execContainer),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterHooksExecContainerList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterHooksOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterHooks | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._before !== undefined) {
      hasAnyValues = true;
      internalValueResult.before = this._before;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._manifest !== undefined) {
      hasAnyValues = true;
      internalValueResult.manifest = this._manifest;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._requires !== undefined) {
      hasAnyValues = true;
      internalValueResult.requires = this._requires;
    }
    if (this._roles !== undefined) {
      hasAnyValues = true;
      internalValueResult.roles = this._roles;
    }
    if (this._useRawManifest !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRawManifest = this._useRawManifest;
    }
    if (this._execContainer?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.execContainer = this._execContainer?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterHooks | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._before = undefined;
      this._enabled = undefined;
      this._manifest = undefined;
      this._name = undefined;
      this._requires = undefined;
      this._roles = undefined;
      this._useRawManifest = undefined;
      this._execContainer.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._before = value.before;
      this._enabled = value.enabled;
      this._manifest = value.manifest;
      this._name = value.name;
      this._requires = value.requires;
      this._roles = value.roles;
      this._useRawManifest = value.useRawManifest;
      this._execContainer.internalValue = value.execContainer;
    }
  }

  // before - computed: false, optional: true, required: false
  private _before?: string[]; 
  public get before() {
    return this.getListAttribute('before');
  }
  public set before(value: string[]) {
    this._before = value;
  }
  public resetBefore() {
    this._before = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get beforeInput() {
    return this._before;
  }

  // enabled - computed: false, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // manifest - computed: false, optional: true, required: false
  private _manifest?: string; 
  public get manifest() {
    return this.getStringAttribute('manifest');
  }
  public set manifest(value: string) {
    this._manifest = value;
  }
  public resetManifest() {
    this._manifest = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get manifestInput() {
    return this._manifest;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // requires - computed: false, optional: true, required: false
  private _requires?: string[]; 
  public get requires() {
    return this.getListAttribute('requires');
  }
  public set requires(value: string[]) {
    this._requires = value;
  }
  public resetRequires() {
    this._requires = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requiresInput() {
    return this._requires;
  }

  // roles - computed: false, optional: true, required: false
  private _roles?: string[]; 
  public get roles() {
    return this.getListAttribute('roles');
  }
  public set roles(value: string[]) {
    this._roles = value;
  }
  public resetRoles() {
    this._roles = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rolesInput() {
    return this._roles;
  }

  // use_raw_manifest - computed: false, optional: true, required: false
  private _useRawManifest?: boolean | cdktf.IResolvable; 
  public get useRawManifest() {
    return this.getBooleanAttribute('use_raw_manifest');
  }
  public set useRawManifest(value: boolean | cdktf.IResolvable) {
    this._useRawManifest = value;
  }
  public resetUseRawManifest() {
    this._useRawManifest = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRawManifestInput() {
    return this._useRawManifest;
  }

  // exec_container - computed: false, optional: true, required: false
  private _execContainer = new ClusterHooksExecContainerOutputReference(this, "exec_container");
  public get execContainer() {
    return this._execContainer;
  }
  public putExecContainer(value: ClusterHooksExecContainer) {
    this._execContainer.internalValue = value;
  }
  public resetExecContainer() {
    this._execContainer.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get execContainerInput() {
    return this._execContainer.internalValue;
  }
}

export class ClusterHooksList extends cdktf.ComplexList {
  public internalValue? : ClusterHooks[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterHooksOutputReference {
    return new ClusterHooksOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterIamServiceAccountExternalPermissionsAws {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#inline_policy Cluster#inline_policy}
  */
  readonly inlinePolicy?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#policy_ar_ns Cluster#policy_ar_ns}
  */
  readonly policyArNs?: string[];
}

export function clusterIamServiceAccountExternalPermissionsAwsToTerraform(struct?: ClusterIamServiceAccountExternalPermissionsAwsOutputReference | ClusterIamServiceAccountExternalPermissionsAws): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    inline_policy: cdktf.stringToTerraform(struct!.inlinePolicy),
    policy_ar_ns: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.policyArNs),
  }
}


export function clusterIamServiceAccountExternalPermissionsAwsToHclTerraform(struct?: ClusterIamServiceAccountExternalPermissionsAwsOutputReference | ClusterIamServiceAccountExternalPermissionsAws): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    inline_policy: {
      value: cdktf.stringToHclTerraform(struct!.inlinePolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    policy_ar_ns: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.policyArNs),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterIamServiceAccountExternalPermissionsAwsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterIamServiceAccountExternalPermissionsAws | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._inlinePolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.inlinePolicy = this._inlinePolicy;
    }
    if (this._policyArNs !== undefined) {
      hasAnyValues = true;
      internalValueResult.policyArNs = this._policyArNs;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterIamServiceAccountExternalPermissionsAws | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._inlinePolicy = undefined;
      this._policyArNs = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._inlinePolicy = value.inlinePolicy;
      this._policyArNs = value.policyArNs;
    }
  }

  // inline_policy - computed: false, optional: true, required: false
  private _inlinePolicy?: string; 
  public get inlinePolicy() {
    return this.getStringAttribute('inline_policy');
  }
  public set inlinePolicy(value: string) {
    this._inlinePolicy = value;
  }
  public resetInlinePolicy() {
    this._inlinePolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inlinePolicyInput() {
    return this._inlinePolicy;
  }

  // policy_ar_ns - computed: false, optional: true, required: false
  private _policyArNs?: string[]; 
  public get policyArNs() {
    return this.getListAttribute('policy_ar_ns');
  }
  public set policyArNs(value: string[]) {
    this._policyArNs = value;
  }
  public resetPolicyArNs() {
    this._policyArNs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get policyArNsInput() {
    return this._policyArNs;
  }
}
export interface ClusterIamServiceAccountExternalPermissions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#name Cluster#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#namespace Cluster#namespace}
  */
  readonly namespace?: string;
  /**
  * aws block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#aws Cluster#aws}
  */
  readonly aws?: ClusterIamServiceAccountExternalPermissionsAws;
}

export function clusterIamServiceAccountExternalPermissionsToTerraform(struct?: ClusterIamServiceAccountExternalPermissions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    aws: clusterIamServiceAccountExternalPermissionsAwsToTerraform(struct!.aws),
  }
}


export function clusterIamServiceAccountExternalPermissionsToHclTerraform(struct?: ClusterIamServiceAccountExternalPermissions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws: {
      value: clusterIamServiceAccountExternalPermissionsAwsToHclTerraform(struct!.aws),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterIamServiceAccountExternalPermissionsAwsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterIamServiceAccountExternalPermissionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterIamServiceAccountExternalPermissions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._aws?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.aws = this._aws?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterIamServiceAccountExternalPermissions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
      this._aws.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
      this._aws.internalValue = value.aws;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // aws - computed: false, optional: true, required: false
  private _aws = new ClusterIamServiceAccountExternalPermissionsAwsOutputReference(this, "aws");
  public get aws() {
    return this._aws;
  }
  public putAws(value: ClusterIamServiceAccountExternalPermissionsAws) {
    this._aws.internalValue = value;
  }
  public resetAws() {
    this._aws.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsInput() {
    return this._aws.internalValue;
  }
}

export class ClusterIamServiceAccountExternalPermissionsList extends cdktf.ComplexList {
  public internalValue? : ClusterIamServiceAccountExternalPermissions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterIamServiceAccountExternalPermissionsOutputReference {
    return new ClusterIamServiceAccountExternalPermissionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterIam {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#allow_container_registry Cluster#allow_container_registry}
  */
  readonly allowContainerRegistry?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#legacy Cluster#legacy}
  */
  readonly legacy?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#permissions_boundary Cluster#permissions_boundary}
  */
  readonly permissionsBoundary?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#use_service_account_external_permissions Cluster#use_service_account_external_permissions}
  */
  readonly useServiceAccountExternalPermissions?: boolean | cdktf.IResolvable;
  /**
  * service_account_external_permissions block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#service_account_external_permissions Cluster#service_account_external_permissions}
  */
  readonly serviceAccountExternalPermissions?: ClusterIamServiceAccountExternalPermissions[] | cdktf.IResolvable;
}

export function clusterIamToTerraform(struct?: ClusterIamOutputReference | ClusterIam): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_container_registry: cdktf.booleanToTerraform(struct!.allowContainerRegistry),
    legacy: cdktf.booleanToTerraform(struct!.legacy),
    permissions_boundary: cdktf.stringToTerraform(struct!.permissionsBoundary),
    use_service_account_external_permissions: cdktf.booleanToTerraform(struct!.useServiceAccountExternalPermissions),
    service_account_external_permissions: cdktf.listMapper(clusterIamServiceAccountExternalPermissionsToTerraform, true)(struct!.serviceAccountExternalPermissions),
  }
}


export function clusterIamToHclTerraform(struct?: ClusterIamOutputReference | ClusterIam): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_container_registry: {
      value: cdktf.booleanToHclTerraform(struct!.allowContainerRegistry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    legacy: {
      value: cdktf.booleanToHclTerraform(struct!.legacy),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    permissions_boundary: {
      value: cdktf.stringToHclTerraform(struct!.permissionsBoundary),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_service_account_external_permissions: {
      value: cdktf.booleanToHclTerraform(struct!.useServiceAccountExternalPermissions),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    service_account_external_permissions: {
      value: cdktf.listMapperHcl(clusterIamServiceAccountExternalPermissionsToHclTerraform, true)(struct!.serviceAccountExternalPermissions),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterIamServiceAccountExternalPermissionsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterIamOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterIam | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowContainerRegistry !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowContainerRegistry = this._allowContainerRegistry;
    }
    if (this._legacy !== undefined) {
      hasAnyValues = true;
      internalValueResult.legacy = this._legacy;
    }
    if (this._permissionsBoundary !== undefined) {
      hasAnyValues = true;
      internalValueResult.permissionsBoundary = this._permissionsBoundary;
    }
    if (this._useServiceAccountExternalPermissions !== undefined) {
      hasAnyValues = true;
      internalValueResult.useServiceAccountExternalPermissions = this._useServiceAccountExternalPermissions;
    }
    if (this._serviceAccountExternalPermissions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccountExternalPermissions = this._serviceAccountExternalPermissions?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterIam | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._allowContainerRegistry = undefined;
      this._legacy = undefined;
      this._permissionsBoundary = undefined;
      this._useServiceAccountExternalPermissions = undefined;
      this._serviceAccountExternalPermissions.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._allowContainerRegistry = value.allowContainerRegistry;
      this._legacy = value.legacy;
      this._permissionsBoundary = value.permissionsBoundary;
      this._useServiceAccountExternalPermissions = value.useServiceAccountExternalPermissions;
      this._serviceAccountExternalPermissions.internalValue = value.serviceAccountExternalPermissions;
    }
  }

  // allow_container_registry - computed: false, optional: true, required: false
  private _allowContainerRegistry?: boolean | cdktf.IResolvable; 
  public get allowContainerRegistry() {
    return this.getBooleanAttribute('allow_container_registry');
  }
  public set allowContainerRegistry(value: boolean | cdktf.IResolvable) {
    this._allowContainerRegistry = value;
  }
  public resetAllowContainerRegistry() {
    this._allowContainerRegistry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowContainerRegistryInput() {
    return this._allowContainerRegistry;
  }

  // legacy - computed: false, optional: true, required: false
  private _legacy?: boolean | cdktf.IResolvable; 
  public get legacy() {
    return this.getBooleanAttribute('legacy');
  }
  public set legacy(value: boolean | cdktf.IResolvable) {
    this._legacy = value;
  }
  public resetLegacy() {
    this._legacy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get legacyInput() {
    return this._legacy;
  }

  // permissions_boundary - computed: false, optional: true, required: false
  private _permissionsBoundary?: string; 
  public get permissionsBoundary() {
    return this.getStringAttribute('permissions_boundary');
  }
  public set permissionsBoundary(value: string) {
    this._permissionsBoundary = value;
  }
  public resetPermissionsBoundary() {
    this._permissionsBoundary = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get permissionsBoundaryInput() {
    return this._permissionsBoundary;
  }

  // use_service_account_external_permissions - computed: false, optional: true, required: false
  private _useServiceAccountExternalPermissions?: boolean | cdktf.IResolvable; 
  public get useServiceAccountExternalPermissions() {
    return this.getBooleanAttribute('use_service_account_external_permissions');
  }
  public set useServiceAccountExternalPermissions(value: boolean | cdktf.IResolvable) {
    this._useServiceAccountExternalPermissions = value;
  }
  public resetUseServiceAccountExternalPermissions() {
    this._useServiceAccountExternalPermissions = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useServiceAccountExternalPermissionsInput() {
    return this._useServiceAccountExternalPermissions;
  }

  // service_account_external_permissions - computed: false, optional: true, required: false
  private _serviceAccountExternalPermissions = new ClusterIamServiceAccountExternalPermissionsList(this, "service_account_external_permissions", false);
  public get serviceAccountExternalPermissions() {
    return this._serviceAccountExternalPermissions;
  }
  public putServiceAccountExternalPermissions(value: ClusterIamServiceAccountExternalPermissions[] | cdktf.IResolvable) {
    this._serviceAccountExternalPermissions.internalValue = value;
  }
  public resetServiceAccountExternalPermissions() {
    this._serviceAccountExternalPermissions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountExternalPermissionsInput() {
    return this._serviceAccountExternalPermissions.internalValue;
  }
}
export interface ClusterKarpenter {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#enabled Cluster#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
}

export function clusterKarpenterToTerraform(struct?: ClusterKarpenterOutputReference | ClusterKarpenter): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.booleanToTerraform(struct!.enabled),
  }
}


export function clusterKarpenterToHclTerraform(struct?: ClusterKarpenterOutputReference | ClusterKarpenter): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterKarpenterOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterKarpenter | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterKarpenter | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._enabled = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._enabled = value.enabled;
    }
  }

  // enabled - computed: false, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }
}
export interface ClusterKubeApiServerAnonymousAuth {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#value Cluster#value}
  */
  readonly value?: boolean | cdktf.IResolvable;
}

export function clusterKubeApiServerAnonymousAuthToTerraform(struct?: ClusterKubeApiServerAnonymousAuthOutputReference | ClusterKubeApiServerAnonymousAuth): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value: cdktf.booleanToTerraform(struct!.value),
  }
}


export function clusterKubeApiServerAnonymousAuthToHclTerraform(struct?: ClusterKubeApiServerAnonymousAuthOutputReference | ClusterKubeApiServerAnonymousAuth): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value: {
      value: cdktf.booleanToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterKubeApiServerAnonymousAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterKubeApiServerAnonymousAuth | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterKubeApiServerAnonymousAuth | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._value = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._value = value.value;
    }
  }

  // value - computed: false, optional: true, required: false
  private _value?: boolean | cdktf.IResolvable; 
  public get value() {
    return this.getBooleanAttribute('value');
  }
  public set value(value: boolean | cdktf.IResolvable) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface ClusterKubeApiServer {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#address Cluster#address}
  */
  readonly address?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#admission_control Cluster#admission_control}
  */
  readonly admissionControl?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#admission_control_config_file Cluster#admission_control_config_file}
  */
  readonly admissionControlConfigFile?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#advertise_address Cluster#advertise_address}
  */
  readonly advertiseAddress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#allow_privileged Cluster#allow_privileged}
  */
  readonly allowPrivileged?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#api_audiences Cluster#api_audiences}
  */
  readonly apiAudiences?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#api_server_count Cluster#api_server_count}
  */
  readonly apiServerCount?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#append_admission_plugins Cluster#append_admission_plugins}
  */
  readonly appendAdmissionPlugins?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#audit_dynamic_configuration Cluster#audit_dynamic_configuration}
  */
  readonly auditDynamicConfiguration?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#audit_log_format Cluster#audit_log_format}
  */
  readonly auditLogFormat?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#audit_log_max_age Cluster#audit_log_max_age}
  */
  readonly auditLogMaxAge?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#audit_log_max_backups Cluster#audit_log_max_backups}
  */
  readonly auditLogMaxBackups?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#audit_log_max_size Cluster#audit_log_max_size}
  */
  readonly auditLogMaxSize?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#audit_log_path Cluster#audit_log_path}
  */
  readonly auditLogPath?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#audit_policy_file Cluster#audit_policy_file}
  */
  readonly auditPolicyFile?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#audit_webhook_batch_buffer_size Cluster#audit_webhook_batch_buffer_size}
  */
  readonly auditWebhookBatchBufferSize?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#audit_webhook_batch_max_size Cluster#audit_webhook_batch_max_size}
  */
  readonly auditWebhookBatchMaxSize?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#audit_webhook_batch_max_wait Cluster#audit_webhook_batch_max_wait}
  */
  readonly auditWebhookBatchMaxWait?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#audit_webhook_batch_throttle_burst Cluster#audit_webhook_batch_throttle_burst}
  */
  readonly auditWebhookBatchThrottleBurst?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#audit_webhook_batch_throttle_enable Cluster#audit_webhook_batch_throttle_enable}
  */
  readonly auditWebhookBatchThrottleEnable?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#audit_webhook_batch_throttle_qps Cluster#audit_webhook_batch_throttle_qps}
  */
  readonly auditWebhookBatchThrottleQps?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#audit_webhook_config_file Cluster#audit_webhook_config_file}
  */
  readonly auditWebhookConfigFile?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#audit_webhook_initial_backoff Cluster#audit_webhook_initial_backoff}
  */
  readonly auditWebhookInitialBackoff?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#audit_webhook_mode Cluster#audit_webhook_mode}
  */
  readonly auditWebhookMode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#authentication_token_webhook_cache_ttl Cluster#authentication_token_webhook_cache_ttl}
  */
  readonly authenticationTokenWebhookCacheTtl?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#authentication_token_webhook_config_file Cluster#authentication_token_webhook_config_file}
  */
  readonly authenticationTokenWebhookConfigFile?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#authorization_mode Cluster#authorization_mode}
  */
  readonly authorizationMode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#authorization_rbac_super_user Cluster#authorization_rbac_super_user}
  */
  readonly authorizationRbacSuperUser?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#authorization_webhook_cache_authorized_ttl Cluster#authorization_webhook_cache_authorized_ttl}
  */
  readonly authorizationWebhookCacheAuthorizedTtl?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#authorization_webhook_cache_unauthorized_ttl Cluster#authorization_webhook_cache_unauthorized_ttl}
  */
  readonly authorizationWebhookCacheUnauthorizedTtl?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#authorization_webhook_config_file Cluster#authorization_webhook_config_file}
  */
  readonly authorizationWebhookConfigFile?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#basic_auth_file Cluster#basic_auth_file}
  */
  readonly basicAuthFile?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#bind_address Cluster#bind_address}
  */
  readonly bindAddress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#client_ca_file Cluster#client_ca_file}
  */
  readonly clientCaFile?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#cloud_provider Cluster#cloud_provider}
  */
  readonly cloudProvider?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#cors_allowed_origins Cluster#cors_allowed_origins}
  */
  readonly corsAllowedOrigins?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#cpu_limit Cluster#cpu_limit}
  */
  readonly cpuLimit?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#cpu_request Cluster#cpu_request}
  */
  readonly cpuRequest?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#default_not_ready_toleration_seconds Cluster#default_not_ready_toleration_seconds}
  */
  readonly defaultNotReadyTolerationSeconds?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#default_unreachable_toleration_seconds Cluster#default_unreachable_toleration_seconds}
  */
  readonly defaultUnreachableTolerationSeconds?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#disable_admission_plugins Cluster#disable_admission_plugins}
  */
  readonly disableAdmissionPlugins?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#disable_basic_auth Cluster#disable_basic_auth}
  */
  readonly disableBasicAuth?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#enable_admission_plugins Cluster#enable_admission_plugins}
  */
  readonly enableAdmissionPlugins?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#enable_aggregator_routing Cluster#enable_aggregator_routing}
  */
  readonly enableAggregatorRouting?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#enable_bootstrap_auth_token Cluster#enable_bootstrap_auth_token}
  */
  readonly enableBootstrapAuthToken?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#enable_profiling Cluster#enable_profiling}
  */
  readonly enableProfiling?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#encryption_provider_config Cluster#encryption_provider_config}
  */
  readonly encryptionProviderConfig?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#etcd_ca_file Cluster#etcd_ca_file}
  */
  readonly etcdCaFile?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#etcd_cert_file Cluster#etcd_cert_file}
  */
  readonly etcdCertFile?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#etcd_key_file Cluster#etcd_key_file}
  */
  readonly etcdKeyFile?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#etcd_quorum_read Cluster#etcd_quorum_read}
  */
  readonly etcdQuorumRead?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#etcd_servers Cluster#etcd_servers}
  */
  readonly etcdServers?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#etcd_servers_overrides Cluster#etcd_servers_overrides}
  */
  readonly etcdServersOverrides?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#event_ttl Cluster#event_ttl}
  */
  readonly eventTtl?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#experimental_encryption_provider_config Cluster#experimental_encryption_provider_config}
  */
  readonly experimentalEncryptionProviderConfig?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#feature_gates Cluster#feature_gates}
  */
  readonly featureGates?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#http2_max_streams_per_connection Cluster#http2_max_streams_per_connection}
  */
  readonly http2MaxStreamsPerConnection?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#image Cluster#image}
  */
  readonly image?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#insecure_bind_address Cluster#insecure_bind_address}
  */
  readonly insecureBindAddress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#insecure_port Cluster#insecure_port}
  */
  readonly insecurePort?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#kubelet_certificate_authority Cluster#kubelet_certificate_authority}
  */
  readonly kubeletCertificateAuthority?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#kubelet_client_certificate Cluster#kubelet_client_certificate}
  */
  readonly kubeletClientCertificate?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#kubelet_client_key Cluster#kubelet_client_key}
  */
  readonly kubeletClientKey?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#kubelet_preferred_address_types Cluster#kubelet_preferred_address_types}
  */
  readonly kubeletPreferredAddressTypes?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#log_format Cluster#log_format}
  */
  readonly logFormat?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#log_level Cluster#log_level}
  */
  readonly logLevel?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#max_mutating_requests_inflight Cluster#max_mutating_requests_inflight}
  */
  readonly maxMutatingRequestsInflight?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#max_requests_inflight Cluster#max_requests_inflight}
  */
  readonly maxRequestsInflight?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#memory_limit Cluster#memory_limit}
  */
  readonly memoryLimit?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#memory_request Cluster#memory_request}
  */
  readonly memoryRequest?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#min_request_timeout Cluster#min_request_timeout}
  */
  readonly minRequestTimeout?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#oidc_ca_file Cluster#oidc_ca_file}
  */
  readonly oidcCaFile?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#oidc_client_id Cluster#oidc_client_id}
  */
  readonly oidcClientId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#oidc_groups_claim Cluster#oidc_groups_claim}
  */
  readonly oidcGroupsClaim?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#oidc_groups_prefix Cluster#oidc_groups_prefix}
  */
  readonly oidcGroupsPrefix?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#oidc_issuer_url Cluster#oidc_issuer_url}
  */
  readonly oidcIssuerUrl?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#oidc_required_claim Cluster#oidc_required_claim}
  */
  readonly oidcRequiredClaim?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#oidc_username_claim Cluster#oidc_username_claim}
  */
  readonly oidcUsernameClaim?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#oidc_username_prefix Cluster#oidc_username_prefix}
  */
  readonly oidcUsernamePrefix?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#proxy_client_cert_file Cluster#proxy_client_cert_file}
  */
  readonly proxyClientCertFile?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#proxy_client_key_file Cluster#proxy_client_key_file}
  */
  readonly proxyClientKeyFile?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#request_timeout Cluster#request_timeout}
  */
  readonly requestTimeout?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#requestheader_allowed_names Cluster#requestheader_allowed_names}
  */
  readonly requestheaderAllowedNames?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#requestheader_client_ca_file Cluster#requestheader_client_ca_file}
  */
  readonly requestheaderClientCaFile?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#requestheader_extra_header_prefixes Cluster#requestheader_extra_header_prefixes}
  */
  readonly requestheaderExtraHeaderPrefixes?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#requestheader_group_headers Cluster#requestheader_group_headers}
  */
  readonly requestheaderGroupHeaders?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#requestheader_username_headers Cluster#requestheader_username_headers}
  */
  readonly requestheaderUsernameHeaders?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#runtime_config Cluster#runtime_config}
  */
  readonly runtimeConfig?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#secure_port Cluster#secure_port}
  */
  readonly securePort?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#service_account_issuer Cluster#service_account_issuer}
  */
  readonly serviceAccountIssuer?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#service_account_jwksuri Cluster#service_account_jwksuri}
  */
  readonly serviceAccountJwksuri?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#service_account_key_file Cluster#service_account_key_file}
  */
  readonly serviceAccountKeyFile?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#service_account_signing_key_file Cluster#service_account_signing_key_file}
  */
  readonly serviceAccountSigningKeyFile?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#service_cluster_ip_range Cluster#service_cluster_ip_range}
  */
  readonly serviceClusterIpRange?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#service_node_port_range Cluster#service_node_port_range}
  */
  readonly serviceNodePortRange?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#storage_backend Cluster#storage_backend}
  */
  readonly storageBackend?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#target_ram_mb Cluster#target_ram_mb}
  */
  readonly targetRamMb?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#tls_cert_file Cluster#tls_cert_file}
  */
  readonly tlsCertFile?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#tls_cipher_suites Cluster#tls_cipher_suites}
  */
  readonly tlsCipherSuites?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#tls_min_version Cluster#tls_min_version}
  */
  readonly tlsMinVersion?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#tls_private_key_file Cluster#tls_private_key_file}
  */
  readonly tlsPrivateKeyFile?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#token_auth_file Cluster#token_auth_file}
  */
  readonly tokenAuthFile?: string;
  /**
  * anonymous_auth block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#anonymous_auth Cluster#anonymous_auth}
  */
  readonly anonymousAuth?: ClusterKubeApiServerAnonymousAuth;
}

export function clusterKubeApiServerToTerraform(struct?: ClusterKubeApiServerOutputReference | ClusterKubeApiServer): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: cdktf.stringToTerraform(struct!.address),
    admission_control: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.admissionControl),
    admission_control_config_file: cdktf.stringToTerraform(struct!.admissionControlConfigFile),
    advertise_address: cdktf.stringToTerraform(struct!.advertiseAddress),
    allow_privileged: cdktf.booleanToTerraform(struct!.allowPrivileged),
    api_audiences: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.apiAudiences),
    api_server_count: cdktf.numberToTerraform(struct!.apiServerCount),
    append_admission_plugins: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.appendAdmissionPlugins),
    audit_dynamic_configuration: cdktf.booleanToTerraform(struct!.auditDynamicConfiguration),
    audit_log_format: cdktf.stringToTerraform(struct!.auditLogFormat),
    audit_log_max_age: cdktf.numberToTerraform(struct!.auditLogMaxAge),
    audit_log_max_backups: cdktf.numberToTerraform(struct!.auditLogMaxBackups),
    audit_log_max_size: cdktf.numberToTerraform(struct!.auditLogMaxSize),
    audit_log_path: cdktf.stringToTerraform(struct!.auditLogPath),
    audit_policy_file: cdktf.stringToTerraform(struct!.auditPolicyFile),
    audit_webhook_batch_buffer_size: cdktf.numberToTerraform(struct!.auditWebhookBatchBufferSize),
    audit_webhook_batch_max_size: cdktf.numberToTerraform(struct!.auditWebhookBatchMaxSize),
    audit_webhook_batch_max_wait: cdktf.stringToTerraform(struct!.auditWebhookBatchMaxWait),
    audit_webhook_batch_throttle_burst: cdktf.numberToTerraform(struct!.auditWebhookBatchThrottleBurst),
    audit_webhook_batch_throttle_enable: cdktf.booleanToTerraform(struct!.auditWebhookBatchThrottleEnable),
    audit_webhook_batch_throttle_qps: cdktf.stringToTerraform(struct!.auditWebhookBatchThrottleQps),
    audit_webhook_config_file: cdktf.stringToTerraform(struct!.auditWebhookConfigFile),
    audit_webhook_initial_backoff: cdktf.stringToTerraform(struct!.auditWebhookInitialBackoff),
    audit_webhook_mode: cdktf.stringToTerraform(struct!.auditWebhookMode),
    authentication_token_webhook_cache_ttl: cdktf.stringToTerraform(struct!.authenticationTokenWebhookCacheTtl),
    authentication_token_webhook_config_file: cdktf.stringToTerraform(struct!.authenticationTokenWebhookConfigFile),
    authorization_mode: cdktf.stringToTerraform(struct!.authorizationMode),
    authorization_rbac_super_user: cdktf.stringToTerraform(struct!.authorizationRbacSuperUser),
    authorization_webhook_cache_authorized_ttl: cdktf.stringToTerraform(struct!.authorizationWebhookCacheAuthorizedTtl),
    authorization_webhook_cache_unauthorized_ttl: cdktf.stringToTerraform(struct!.authorizationWebhookCacheUnauthorizedTtl),
    authorization_webhook_config_file: cdktf.stringToTerraform(struct!.authorizationWebhookConfigFile),
    basic_auth_file: cdktf.stringToTerraform(struct!.basicAuthFile),
    bind_address: cdktf.stringToTerraform(struct!.bindAddress),
    client_ca_file: cdktf.stringToTerraform(struct!.clientCaFile),
    cloud_provider: cdktf.stringToTerraform(struct!.cloudProvider),
    cors_allowed_origins: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.corsAllowedOrigins),
    cpu_limit: cdktf.stringToTerraform(struct!.cpuLimit),
    cpu_request: cdktf.stringToTerraform(struct!.cpuRequest),
    default_not_ready_toleration_seconds: cdktf.numberToTerraform(struct!.defaultNotReadyTolerationSeconds),
    default_unreachable_toleration_seconds: cdktf.numberToTerraform(struct!.defaultUnreachableTolerationSeconds),
    disable_admission_plugins: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.disableAdmissionPlugins),
    disable_basic_auth: cdktf.booleanToTerraform(struct!.disableBasicAuth),
    enable_admission_plugins: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.enableAdmissionPlugins),
    enable_aggregator_routing: cdktf.booleanToTerraform(struct!.enableAggregatorRouting),
    enable_bootstrap_auth_token: cdktf.booleanToTerraform(struct!.enableBootstrapAuthToken),
    enable_profiling: cdktf.booleanToTerraform(struct!.enableProfiling),
    encryption_provider_config: cdktf.stringToTerraform(struct!.encryptionProviderConfig),
    etcd_ca_file: cdktf.stringToTerraform(struct!.etcdCaFile),
    etcd_cert_file: cdktf.stringToTerraform(struct!.etcdCertFile),
    etcd_key_file: cdktf.stringToTerraform(struct!.etcdKeyFile),
    etcd_quorum_read: cdktf.booleanToTerraform(struct!.etcdQuorumRead),
    etcd_servers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.etcdServers),
    etcd_servers_overrides: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.etcdServersOverrides),
    event_ttl: cdktf.stringToTerraform(struct!.eventTtl),
    experimental_encryption_provider_config: cdktf.stringToTerraform(struct!.experimentalEncryptionProviderConfig),
    feature_gates: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.featureGates),
    http2_max_streams_per_connection: cdktf.numberToTerraform(struct!.http2MaxStreamsPerConnection),
    image: cdktf.stringToTerraform(struct!.image),
    insecure_bind_address: cdktf.stringToTerraform(struct!.insecureBindAddress),
    insecure_port: cdktf.numberToTerraform(struct!.insecurePort),
    kubelet_certificate_authority: cdktf.stringToTerraform(struct!.kubeletCertificateAuthority),
    kubelet_client_certificate: cdktf.stringToTerraform(struct!.kubeletClientCertificate),
    kubelet_client_key: cdktf.stringToTerraform(struct!.kubeletClientKey),
    kubelet_preferred_address_types: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.kubeletPreferredAddressTypes),
    log_format: cdktf.stringToTerraform(struct!.logFormat),
    log_level: cdktf.numberToTerraform(struct!.logLevel),
    max_mutating_requests_inflight: cdktf.numberToTerraform(struct!.maxMutatingRequestsInflight),
    max_requests_inflight: cdktf.numberToTerraform(struct!.maxRequestsInflight),
    memory_limit: cdktf.stringToTerraform(struct!.memoryLimit),
    memory_request: cdktf.stringToTerraform(struct!.memoryRequest),
    min_request_timeout: cdktf.numberToTerraform(struct!.minRequestTimeout),
    oidc_ca_file: cdktf.stringToTerraform(struct!.oidcCaFile),
    oidc_client_id: cdktf.stringToTerraform(struct!.oidcClientId),
    oidc_groups_claim: cdktf.stringToTerraform(struct!.oidcGroupsClaim),
    oidc_groups_prefix: cdktf.stringToTerraform(struct!.oidcGroupsPrefix),
    oidc_issuer_url: cdktf.stringToTerraform(struct!.oidcIssuerUrl),
    oidc_required_claim: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.oidcRequiredClaim),
    oidc_username_claim: cdktf.stringToTerraform(struct!.oidcUsernameClaim),
    oidc_username_prefix: cdktf.stringToTerraform(struct!.oidcUsernamePrefix),
    proxy_client_cert_file: cdktf.stringToTerraform(struct!.proxyClientCertFile),
    proxy_client_key_file: cdktf.stringToTerraform(struct!.proxyClientKeyFile),
    request_timeout: cdktf.stringToTerraform(struct!.requestTimeout),
    requestheader_allowed_names: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.requestheaderAllowedNames),
    requestheader_client_ca_file: cdktf.stringToTerraform(struct!.requestheaderClientCaFile),
    requestheader_extra_header_prefixes: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.requestheaderExtraHeaderPrefixes),
    requestheader_group_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.requestheaderGroupHeaders),
    requestheader_username_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.requestheaderUsernameHeaders),
    runtime_config: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.runtimeConfig),
    secure_port: cdktf.numberToTerraform(struct!.securePort),
    service_account_issuer: cdktf.stringToTerraform(struct!.serviceAccountIssuer),
    service_account_jwksuri: cdktf.stringToTerraform(struct!.serviceAccountJwksuri),
    service_account_key_file: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.serviceAccountKeyFile),
    service_account_signing_key_file: cdktf.stringToTerraform(struct!.serviceAccountSigningKeyFile),
    service_cluster_ip_range: cdktf.stringToTerraform(struct!.serviceClusterIpRange),
    service_node_port_range: cdktf.stringToTerraform(struct!.serviceNodePortRange),
    storage_backend: cdktf.stringToTerraform(struct!.storageBackend),
    target_ram_mb: cdktf.numberToTerraform(struct!.targetRamMb),
    tls_cert_file: cdktf.stringToTerraform(struct!.tlsCertFile),
    tls_cipher_suites: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.tlsCipherSuites),
    tls_min_version: cdktf.stringToTerraform(struct!.tlsMinVersion),
    tls_private_key_file: cdktf.stringToTerraform(struct!.tlsPrivateKeyFile),
    token_auth_file: cdktf.stringToTerraform(struct!.tokenAuthFile),
    anonymous_auth: clusterKubeApiServerAnonymousAuthToTerraform(struct!.anonymousAuth),
  }
}


export function clusterKubeApiServerToHclTerraform(struct?: ClusterKubeApiServerOutputReference | ClusterKubeApiServer): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: cdktf.stringToHclTerraform(struct!.address),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    admission_control: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.admissionControl),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    admission_control_config_file: {
      value: cdktf.stringToHclTerraform(struct!.admissionControlConfigFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    advertise_address: {
      value: cdktf.stringToHclTerraform(struct!.advertiseAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    allow_privileged: {
      value: cdktf.booleanToHclTerraform(struct!.allowPrivileged),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    api_audiences: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.apiAudiences),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    api_server_count: {
      value: cdktf.numberToHclTerraform(struct!.apiServerCount),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    append_admission_plugins: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.appendAdmissionPlugins),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    audit_dynamic_configuration: {
      value: cdktf.booleanToHclTerraform(struct!.auditDynamicConfiguration),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    audit_log_format: {
      value: cdktf.stringToHclTerraform(struct!.auditLogFormat),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    audit_log_max_age: {
      value: cdktf.numberToHclTerraform(struct!.auditLogMaxAge),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    audit_log_max_backups: {
      value: cdktf.numberToHclTerraform(struct!.auditLogMaxBackups),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    audit_log_max_size: {
      value: cdktf.numberToHclTerraform(struct!.auditLogMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    audit_log_path: {
      value: cdktf.stringToHclTerraform(struct!.auditLogPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    audit_policy_file: {
      value: cdktf.stringToHclTerraform(struct!.auditPolicyFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    audit_webhook_batch_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.auditWebhookBatchBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    audit_webhook_batch_max_size: {
      value: cdktf.numberToHclTerraform(struct!.auditWebhookBatchMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    audit_webhook_batch_max_wait: {
      value: cdktf.stringToHclTerraform(struct!.auditWebhookBatchMaxWait),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    audit_webhook_batch_throttle_burst: {
      value: cdktf.numberToHclTerraform(struct!.auditWebhookBatchThrottleBurst),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    audit_webhook_batch_throttle_enable: {
      value: cdktf.booleanToHclTerraform(struct!.auditWebhookBatchThrottleEnable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    audit_webhook_batch_throttle_qps: {
      value: cdktf.stringToHclTerraform(struct!.auditWebhookBatchThrottleQps),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    audit_webhook_config_file: {
      value: cdktf.stringToHclTerraform(struct!.auditWebhookConfigFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    audit_webhook_initial_backoff: {
      value: cdktf.stringToHclTerraform(struct!.auditWebhookInitialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    audit_webhook_mode: {
      value: cdktf.stringToHclTerraform(struct!.auditWebhookMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    authentication_token_webhook_cache_ttl: {
      value: cdktf.stringToHclTerraform(struct!.authenticationTokenWebhookCacheTtl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    authentication_token_webhook_config_file: {
      value: cdktf.stringToHclTerraform(struct!.authenticationTokenWebhookConfigFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    authorization_mode: {
      value: cdktf.stringToHclTerraform(struct!.authorizationMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    authorization_rbac_super_user: {
      value: cdktf.stringToHclTerraform(struct!.authorizationRbacSuperUser),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    authorization_webhook_cache_authorized_ttl: {
      value: cdktf.stringToHclTerraform(struct!.authorizationWebhookCacheAuthorizedTtl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    authorization_webhook_cache_unauthorized_ttl: {
      value: cdktf.stringToHclTerraform(struct!.authorizationWebhookCacheUnauthorizedTtl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    authorization_webhook_config_file: {
      value: cdktf.stringToHclTerraform(struct!.authorizationWebhookConfigFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    basic_auth_file: {
      value: cdktf.stringToHclTerraform(struct!.basicAuthFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bind_address: {
      value: cdktf.stringToHclTerraform(struct!.bindAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_ca_file: {
      value: cdktf.stringToHclTerraform(struct!.clientCaFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cloud_provider: {
      value: cdktf.stringToHclTerraform(struct!.cloudProvider),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cors_allowed_origins: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.corsAllowedOrigins),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    cpu_limit: {
      value: cdktf.stringToHclTerraform(struct!.cpuLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cpu_request: {
      value: cdktf.stringToHclTerraform(struct!.cpuRequest),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    default_not_ready_toleration_seconds: {
      value: cdktf.numberToHclTerraform(struct!.defaultNotReadyTolerationSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    default_unreachable_toleration_seconds: {
      value: cdktf.numberToHclTerraform(struct!.defaultUnreachableTolerationSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    disable_admission_plugins: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.disableAdmissionPlugins),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    disable_basic_auth: {
      value: cdktf.booleanToHclTerraform(struct!.disableBasicAuth),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_admission_plugins: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.enableAdmissionPlugins),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    enable_aggregator_routing: {
      value: cdktf.booleanToHclTerraform(struct!.enableAggregatorRouting),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_bootstrap_auth_token: {
      value: cdktf.booleanToHclTerraform(struct!.enableBootstrapAuthToken),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_profiling: {
      value: cdktf.booleanToHclTerraform(struct!.enableProfiling),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    encryption_provider_config: {
      value: cdktf.stringToHclTerraform(struct!.encryptionProviderConfig),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    etcd_ca_file: {
      value: cdktf.stringToHclTerraform(struct!.etcdCaFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    etcd_cert_file: {
      value: cdktf.stringToHclTerraform(struct!.etcdCertFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    etcd_key_file: {
      value: cdktf.stringToHclTerraform(struct!.etcdKeyFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    etcd_quorum_read: {
      value: cdktf.booleanToHclTerraform(struct!.etcdQuorumRead),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    etcd_servers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.etcdServers),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    etcd_servers_overrides: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.etcdServersOverrides),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    event_ttl: {
      value: cdktf.stringToHclTerraform(struct!.eventTtl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    experimental_encryption_provider_config: {
      value: cdktf.stringToHclTerraform(struct!.experimentalEncryptionProviderConfig),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    feature_gates: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.featureGates),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    http2_max_streams_per_connection: {
      value: cdktf.numberToHclTerraform(struct!.http2MaxStreamsPerConnection),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    image: {
      value: cdktf.stringToHclTerraform(struct!.image),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    insecure_bind_address: {
      value: cdktf.stringToHclTerraform(struct!.insecureBindAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    insecure_port: {
      value: cdktf.numberToHclTerraform(struct!.insecurePort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    kubelet_certificate_authority: {
      value: cdktf.stringToHclTerraform(struct!.kubeletCertificateAuthority),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kubelet_client_certificate: {
      value: cdktf.stringToHclTerraform(struct!.kubeletClientCertificate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kubelet_client_key: {
      value: cdktf.stringToHclTerraform(struct!.kubeletClientKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kubelet_preferred_address_types: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.kubeletPreferredAddressTypes),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    log_format: {
      value: cdktf.stringToHclTerraform(struct!.logFormat),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_level: {
      value: cdktf.numberToHclTerraform(struct!.logLevel),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_mutating_requests_inflight: {
      value: cdktf.numberToHclTerraform(struct!.maxMutatingRequestsInflight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_requests_inflight: {
      value: cdktf.numberToHclTerraform(struct!.maxRequestsInflight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    memory_limit: {
      value: cdktf.stringToHclTerraform(struct!.memoryLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    memory_request: {
      value: cdktf.stringToHclTerraform(struct!.memoryRequest),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_request_timeout: {
      value: cdktf.numberToHclTerraform(struct!.minRequestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    oidc_ca_file: {
      value: cdktf.stringToHclTerraform(struct!.oidcCaFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    oidc_client_id: {
      value: cdktf.stringToHclTerraform(struct!.oidcClientId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    oidc_groups_claim: {
      value: cdktf.stringToHclTerraform(struct!.oidcGroupsClaim),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    oidc_groups_prefix: {
      value: cdktf.stringToHclTerraform(struct!.oidcGroupsPrefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    oidc_issuer_url: {
      value: cdktf.stringToHclTerraform(struct!.oidcIssuerUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    oidc_required_claim: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.oidcRequiredClaim),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    oidc_username_claim: {
      value: cdktf.stringToHclTerraform(struct!.oidcUsernameClaim),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    oidc_username_prefix: {
      value: cdktf.stringToHclTerraform(struct!.oidcUsernamePrefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    proxy_client_cert_file: {
      value: cdktf.stringToHclTerraform(struct!.proxyClientCertFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    proxy_client_key_file: {
      value: cdktf.stringToHclTerraform(struct!.proxyClientKeyFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_timeout: {
      value: cdktf.stringToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    requestheader_allowed_names: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.requestheaderAllowedNames),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    requestheader_client_ca_file: {
      value: cdktf.stringToHclTerraform(struct!.requestheaderClientCaFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    requestheader_extra_header_prefixes: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.requestheaderExtraHeaderPrefixes),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    requestheader_group_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.requestheaderGroupHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    requestheader_username_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.requestheaderUsernameHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    runtime_config: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.runtimeConfig),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    secure_port: {
      value: cdktf.numberToHclTerraform(struct!.securePort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    service_account_issuer: {
      value: cdktf.stringToHclTerraform(struct!.serviceAccountIssuer),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    service_account_jwksuri: {
      value: cdktf.stringToHclTerraform(struct!.serviceAccountJwksuri),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    service_account_key_file: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.serviceAccountKeyFile),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    service_account_signing_key_file: {
      value: cdktf.stringToHclTerraform(struct!.serviceAccountSigningKeyFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    service_cluster_ip_range: {
      value: cdktf.stringToHclTerraform(struct!.serviceClusterIpRange),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    service_node_port_range: {
      value: cdktf.stringToHclTerraform(struct!.serviceNodePortRange),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    storage_backend: {
      value: cdktf.stringToHclTerraform(struct!.storageBackend),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    target_ram_mb: {
      value: cdktf.numberToHclTerraform(struct!.targetRamMb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    tls_cert_file: {
      value: cdktf.stringToHclTerraform(struct!.tlsCertFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls_cipher_suites: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.tlsCipherSuites),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tls_min_version: {
      value: cdktf.stringToHclTerraform(struct!.tlsMinVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls_private_key_file: {
      value: cdktf.stringToHclTerraform(struct!.tlsPrivateKeyFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_auth_file: {
      value: cdktf.stringToHclTerraform(struct!.tokenAuthFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    anonymous_auth: {
      value: clusterKubeApiServerAnonymousAuthToHclTerraform(struct!.anonymousAuth),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterKubeApiServerAnonymousAuthList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterKubeApiServerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterKubeApiServer | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address;
    }
    if (this._admissionControl !== undefined) {
      hasAnyValues = true;
      internalValueResult.admissionControl = this._admissionControl;
    }
    if (this._admissionControlConfigFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.admissionControlConfigFile = this._admissionControlConfigFile;
    }
    if (this._advertiseAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.advertiseAddress = this._advertiseAddress;
    }
    if (this._allowPrivileged !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowPrivileged = this._allowPrivileged;
    }
    if (this._apiAudiences !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiAudiences = this._apiAudiences;
    }
    if (this._apiServerCount !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiServerCount = this._apiServerCount;
    }
    if (this._appendAdmissionPlugins !== undefined) {
      hasAnyValues = true;
      internalValueResult.appendAdmissionPlugins = this._appendAdmissionPlugins;
    }
    if (this._auditDynamicConfiguration !== undefined) {
      hasAnyValues = true;
      internalValueResult.auditDynamicConfiguration = this._auditDynamicConfiguration;
    }
    if (this._auditLogFormat !== undefined) {
      hasAnyValues = true;
      internalValueResult.auditLogFormat = this._auditLogFormat;
    }
    if (this._auditLogMaxAge !== undefined) {
      hasAnyValues = true;
      internalValueResult.auditLogMaxAge = this._auditLogMaxAge;
    }
    if (this._auditLogMaxBackups !== undefined) {
      hasAnyValues = true;
      internalValueResult.auditLogMaxBackups = this._auditLogMaxBackups;
    }
    if (this._auditLogMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.auditLogMaxSize = this._auditLogMaxSize;
    }
    if (this._auditLogPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.auditLogPath = this._auditLogPath;
    }
    if (this._auditPolicyFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.auditPolicyFile = this._auditPolicyFile;
    }
    if (this._auditWebhookBatchBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.auditWebhookBatchBufferSize = this._auditWebhookBatchBufferSize;
    }
    if (this._auditWebhookBatchMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.auditWebhookBatchMaxSize = this._auditWebhookBatchMaxSize;
    }
    if (this._auditWebhookBatchMaxWait !== undefined) {
      hasAnyValues = true;
      internalValueResult.auditWebhookBatchMaxWait = this._auditWebhookBatchMaxWait;
    }
    if (this._auditWebhookBatchThrottleBurst !== undefined) {
      hasAnyValues = true;
      internalValueResult.auditWebhookBatchThrottleBurst = this._auditWebhookBatchThrottleBurst;
    }
    if (this._auditWebhookBatchThrottleEnable !== undefined) {
      hasAnyValues = true;
      internalValueResult.auditWebhookBatchThrottleEnable = this._auditWebhookBatchThrottleEnable;
    }
    if (this._auditWebhookBatchThrottleQps !== undefined) {
      hasAnyValues = true;
      internalValueResult.auditWebhookBatchThrottleQps = this._auditWebhookBatchThrottleQps;
    }
    if (this._auditWebhookConfigFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.auditWebhookConfigFile = this._auditWebhookConfigFile;
    }
    if (this._auditWebhookInitialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.auditWebhookInitialBackoff = this._auditWebhookInitialBackoff;
    }
    if (this._auditWebhookMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.auditWebhookMode = this._auditWebhookMode;
    }
    if (this._authenticationTokenWebhookCacheTtl !== undefined) {
      hasAnyValues = true;
      internalValueResult.authenticationTokenWebhookCacheTtl = this._authenticationTokenWebhookCacheTtl;
    }
    if (this._authenticationTokenWebhookConfigFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.authenticationTokenWebhookConfigFile = this._authenticationTokenWebhookConfigFile;
    }
    if (this._authorizationMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.authorizationMode = this._authorizationMode;
    }
    if (this._authorizationRbacSuperUser !== undefined) {
      hasAnyValues = true;
      internalValueResult.authorizationRbacSuperUser = this._authorizationRbacSuperUser;
    }
    if (this._authorizationWebhookCacheAuthorizedTtl !== undefined) {
      hasAnyValues = true;
      internalValueResult.authorizationWebhookCacheAuthorizedTtl = this._authorizationWebhookCacheAuthorizedTtl;
    }
    if (this._authorizationWebhookCacheUnauthorizedTtl !== undefined) {
      hasAnyValues = true;
      internalValueResult.authorizationWebhookCacheUnauthorizedTtl = this._authorizationWebhookCacheUnauthorizedTtl;
    }
    if (this._authorizationWebhookConfigFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.authorizationWebhookConfigFile = this._authorizationWebhookConfigFile;
    }
    if (this._basicAuthFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.basicAuthFile = this._basicAuthFile;
    }
    if (this._bindAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindAddress = this._bindAddress;
    }
    if (this._clientCaFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientCaFile = this._clientCaFile;
    }
    if (this._cloudProvider !== undefined) {
      hasAnyValues = true;
      internalValueResult.cloudProvider = this._cloudProvider;
    }
    if (this._corsAllowedOrigins !== undefined) {
      hasAnyValues = true;
      internalValueResult.corsAllowedOrigins = this._corsAllowedOrigins;
    }
    if (this._cpuLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpuLimit = this._cpuLimit;
    }
    if (this._cpuRequest !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpuRequest = this._cpuRequest;
    }
    if (this._defaultNotReadyTolerationSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultNotReadyTolerationSeconds = this._defaultNotReadyTolerationSeconds;
    }
    if (this._defaultUnreachableTolerationSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultUnreachableTolerationSeconds = this._defaultUnreachableTolerationSeconds;
    }
    if (this._disableAdmissionPlugins !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableAdmissionPlugins = this._disableAdmissionPlugins;
    }
    if (this._disableBasicAuth !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableBasicAuth = this._disableBasicAuth;
    }
    if (this._enableAdmissionPlugins !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableAdmissionPlugins = this._enableAdmissionPlugins;
    }
    if (this._enableAggregatorRouting !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableAggregatorRouting = this._enableAggregatorRouting;
    }
    if (this._enableBootstrapAuthToken !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableBootstrapAuthToken = this._enableBootstrapAuthToken;
    }
    if (this._enableProfiling !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableProfiling = this._enableProfiling;
    }
    if (this._encryptionProviderConfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.encryptionProviderConfig = this._encryptionProviderConfig;
    }
    if (this._etcdCaFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.etcdCaFile = this._etcdCaFile;
    }
    if (this._etcdCertFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.etcdCertFile = this._etcdCertFile;
    }
    if (this._etcdKeyFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.etcdKeyFile = this._etcdKeyFile;
    }
    if (this._etcdQuorumRead !== undefined) {
      hasAnyValues = true;
      internalValueResult.etcdQuorumRead = this._etcdQuorumRead;
    }
    if (this._etcdServers !== undefined) {
      hasAnyValues = true;
      internalValueResult.etcdServers = this._etcdServers;
    }
    if (this._etcdServersOverrides !== undefined) {
      hasAnyValues = true;
      internalValueResult.etcdServersOverrides = this._etcdServersOverrides;
    }
    if (this._eventTtl !== undefined) {
      hasAnyValues = true;
      internalValueResult.eventTtl = this._eventTtl;
    }
    if (this._experimentalEncryptionProviderConfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.experimentalEncryptionProviderConfig = this._experimentalEncryptionProviderConfig;
    }
    if (this._featureGates !== undefined) {
      hasAnyValues = true;
      internalValueResult.featureGates = this._featureGates;
    }
    if (this._http2MaxStreamsPerConnection !== undefined) {
      hasAnyValues = true;
      internalValueResult.http2MaxStreamsPerConnection = this._http2MaxStreamsPerConnection;
    }
    if (this._image !== undefined) {
      hasAnyValues = true;
      internalValueResult.image = this._image;
    }
    if (this._insecureBindAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.insecureBindAddress = this._insecureBindAddress;
    }
    if (this._insecurePort !== undefined) {
      hasAnyValues = true;
      internalValueResult.insecurePort = this._insecurePort;
    }
    if (this._kubeletCertificateAuthority !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubeletCertificateAuthority = this._kubeletCertificateAuthority;
    }
    if (this._kubeletClientCertificate !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubeletClientCertificate = this._kubeletClientCertificate;
    }
    if (this._kubeletClientKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubeletClientKey = this._kubeletClientKey;
    }
    if (this._kubeletPreferredAddressTypes !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubeletPreferredAddressTypes = this._kubeletPreferredAddressTypes;
    }
    if (this._logFormat !== undefined) {
      hasAnyValues = true;
      internalValueResult.logFormat = this._logFormat;
    }
    if (this._logLevel !== undefined) {
      hasAnyValues = true;
      internalValueResult.logLevel = this._logLevel;
    }
    if (this._maxMutatingRequestsInflight !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxMutatingRequestsInflight = this._maxMutatingRequestsInflight;
    }
    if (this._maxRequestsInflight !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRequestsInflight = this._maxRequestsInflight;
    }
    if (this._memoryLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.memoryLimit = this._memoryLimit;
    }
    if (this._memoryRequest !== undefined) {
      hasAnyValues = true;
      internalValueResult.memoryRequest = this._memoryRequest;
    }
    if (this._minRequestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.minRequestTimeout = this._minRequestTimeout;
    }
    if (this._oidcCaFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.oidcCaFile = this._oidcCaFile;
    }
    if (this._oidcClientId !== undefined) {
      hasAnyValues = true;
      internalValueResult.oidcClientId = this._oidcClientId;
    }
    if (this._oidcGroupsClaim !== undefined) {
      hasAnyValues = true;
      internalValueResult.oidcGroupsClaim = this._oidcGroupsClaim;
    }
    if (this._oidcGroupsPrefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.oidcGroupsPrefix = this._oidcGroupsPrefix;
    }
    if (this._oidcIssuerUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.oidcIssuerUrl = this._oidcIssuerUrl;
    }
    if (this._oidcRequiredClaim !== undefined) {
      hasAnyValues = true;
      internalValueResult.oidcRequiredClaim = this._oidcRequiredClaim;
    }
    if (this._oidcUsernameClaim !== undefined) {
      hasAnyValues = true;
      internalValueResult.oidcUsernameClaim = this._oidcUsernameClaim;
    }
    if (this._oidcUsernamePrefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.oidcUsernamePrefix = this._oidcUsernamePrefix;
    }
    if (this._proxyClientCertFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClientCertFile = this._proxyClientCertFile;
    }
    if (this._proxyClientKeyFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClientKeyFile = this._proxyClientKeyFile;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    if (this._requestheaderAllowedNames !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestheaderAllowedNames = this._requestheaderAllowedNames;
    }
    if (this._requestheaderClientCaFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestheaderClientCaFile = this._requestheaderClientCaFile;
    }
    if (this._requestheaderExtraHeaderPrefixes !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestheaderExtraHeaderPrefixes = this._requestheaderExtraHeaderPrefixes;
    }
    if (this._requestheaderGroupHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestheaderGroupHeaders = this._requestheaderGroupHeaders;
    }
    if (this._requestheaderUsernameHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestheaderUsernameHeaders = this._requestheaderUsernameHeaders;
    }
    if (this._runtimeConfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.runtimeConfig = this._runtimeConfig;
    }
    if (this._securePort !== undefined) {
      hasAnyValues = true;
      internalValueResult.securePort = this._securePort;
    }
    if (this._serviceAccountIssuer !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccountIssuer = this._serviceAccountIssuer;
    }
    if (this._serviceAccountJwksuri !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccountJwksuri = this._serviceAccountJwksuri;
    }
    if (this._serviceAccountKeyFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccountKeyFile = this._serviceAccountKeyFile;
    }
    if (this._serviceAccountSigningKeyFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccountSigningKeyFile = this._serviceAccountSigningKeyFile;
    }
    if (this._serviceClusterIpRange !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceClusterIpRange = this._serviceClusterIpRange;
    }
    if (this._serviceNodePortRange !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceNodePortRange = this._serviceNodePortRange;
    }
    if (this._storageBackend !== undefined) {
      hasAnyValues = true;
      internalValueResult.storageBackend = this._storageBackend;
    }
    if (this._targetRamMb !== undefined) {
      hasAnyValues = true;
      internalValueResult.targetRamMb = this._targetRamMb;
    }
    if (this._tlsCertFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsCertFile = this._tlsCertFile;
    }
    if (this._tlsCipherSuites !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsCipherSuites = this._tlsCipherSuites;
    }
    if (this._tlsMinVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsMinVersion = this._tlsMinVersion;
    }
    if (this._tlsPrivateKeyFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsPrivateKeyFile = this._tlsPrivateKeyFile;
    }
    if (this._tokenAuthFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenAuthFile = this._tokenAuthFile;
    }
    if (this._anonymousAuth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.anonymousAuth = this._anonymousAuth?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterKubeApiServer | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._address = undefined;
      this._admissionControl = undefined;
      this._admissionControlConfigFile = undefined;
      this._advertiseAddress = undefined;
      this._allowPrivileged = undefined;
      this._apiAudiences = undefined;
      this._apiServerCount = undefined;
      this._appendAdmissionPlugins = undefined;
      this._auditDynamicConfiguration = undefined;
      this._auditLogFormat = undefined;
      this._auditLogMaxAge = undefined;
      this._auditLogMaxBackups = undefined;
      this._auditLogMaxSize = undefined;
      this._auditLogPath = undefined;
      this._auditPolicyFile = undefined;
      this._auditWebhookBatchBufferSize = undefined;
      this._auditWebhookBatchMaxSize = undefined;
      this._auditWebhookBatchMaxWait = undefined;
      this._auditWebhookBatchThrottleBurst = undefined;
      this._auditWebhookBatchThrottleEnable = undefined;
      this._auditWebhookBatchThrottleQps = undefined;
      this._auditWebhookConfigFile = undefined;
      this._auditWebhookInitialBackoff = undefined;
      this._auditWebhookMode = undefined;
      this._authenticationTokenWebhookCacheTtl = undefined;
      this._authenticationTokenWebhookConfigFile = undefined;
      this._authorizationMode = undefined;
      this._authorizationRbacSuperUser = undefined;
      this._authorizationWebhookCacheAuthorizedTtl = undefined;
      this._authorizationWebhookCacheUnauthorizedTtl = undefined;
      this._authorizationWebhookConfigFile = undefined;
      this._basicAuthFile = undefined;
      this._bindAddress = undefined;
      this._clientCaFile = undefined;
      this._cloudProvider = undefined;
      this._corsAllowedOrigins = undefined;
      this._cpuLimit = undefined;
      this._cpuRequest = undefined;
      this._defaultNotReadyTolerationSeconds = undefined;
      this._defaultUnreachableTolerationSeconds = undefined;
      this._disableAdmissionPlugins = undefined;
      this._disableBasicAuth = undefined;
      this._enableAdmissionPlugins = undefined;
      this._enableAggregatorRouting = undefined;
      this._enableBootstrapAuthToken = undefined;
      this._enableProfiling = undefined;
      this._encryptionProviderConfig = undefined;
      this._etcdCaFile = undefined;
      this._etcdCertFile = undefined;
      this._etcdKeyFile = undefined;
      this._etcdQuorumRead = undefined;
      this._etcdServers = undefined;
      this._etcdServersOverrides = undefined;
      this._eventTtl = undefined;
      this._experimentalEncryptionProviderConfig = undefined;
      this._featureGates = undefined;
      this._http2MaxStreamsPerConnection = undefined;
      this._image = undefined;
      this._insecureBindAddress = undefined;
      this._insecurePort = undefined;
      this._kubeletCertificateAuthority = undefined;
      this._kubeletClientCertificate = undefined;
      this._kubeletClientKey = undefined;
      this._kubeletPreferredAddressTypes = undefined;
      this._logFormat = undefined;
      this._logLevel = undefined;
      this._maxMutatingRequestsInflight = undefined;
      this._maxRequestsInflight = undefined;
      this._memoryLimit = undefined;
      this._memoryRequest = undefined;
      this._minRequestTimeout = undefined;
      this._oidcCaFile = undefined;
      this._oidcClientId = undefined;
      this._oidcGroupsClaim = undefined;
      this._oidcGroupsPrefix = undefined;
      this._oidcIssuerUrl = undefined;
      this._oidcRequiredClaim = undefined;
      this._oidcUsernameClaim = undefined;
      this._oidcUsernamePrefix = undefined;
      this._proxyClientCertFile = undefined;
      this._proxyClientKeyFile = undefined;
      this._requestTimeout = undefined;
      this._requestheaderAllowedNames = undefined;
      this._requestheaderClientCaFile = undefined;
      this._requestheaderExtraHeaderPrefixes = undefined;
      this._requestheaderGroupHeaders = undefined;
      this._requestheaderUsernameHeaders = undefined;
      this._runtimeConfig = undefined;
      this._securePort = undefined;
      this._serviceAccountIssuer = undefined;
      this._serviceAccountJwksuri = undefined;
      this._serviceAccountKeyFile = undefined;
      this._serviceAccountSigningKeyFile = undefined;
      this._serviceClusterIpRange = undefined;
      this._serviceNodePortRange = undefined;
      this._storageBackend = undefined;
      this._targetRamMb = undefined;
      this._tlsCertFile = undefined;
      this._tlsCipherSuites = undefined;
      this._tlsMinVersion = undefined;
      this._tlsPrivateKeyFile = undefined;
      this._tokenAuthFile = undefined;
      this._anonymousAuth.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._address = value.address;
      this._admissionControl = value.admissionControl;
      this._admissionControlConfigFile = value.admissionControlConfigFile;
      this._advertiseAddress = value.advertiseAddress;
      this._allowPrivileged = value.allowPrivileged;
      this._apiAudiences = value.apiAudiences;
      this._apiServerCount = value.apiServerCount;
      this._appendAdmissionPlugins = value.appendAdmissionPlugins;
      this._auditDynamicConfiguration = value.auditDynamicConfiguration;
      this._auditLogFormat = value.auditLogFormat;
      this._auditLogMaxAge = value.auditLogMaxAge;
      this._auditLogMaxBackups = value.auditLogMaxBackups;
      this._auditLogMaxSize = value.auditLogMaxSize;
      this._auditLogPath = value.auditLogPath;
      this._auditPolicyFile = value.auditPolicyFile;
      this._auditWebhookBatchBufferSize = value.auditWebhookBatchBufferSize;
      this._auditWebhookBatchMaxSize = value.auditWebhookBatchMaxSize;
      this._auditWebhookBatchMaxWait = value.auditWebhookBatchMaxWait;
      this._auditWebhookBatchThrottleBurst = value.auditWebhookBatchThrottleBurst;
      this._auditWebhookBatchThrottleEnable = value.auditWebhookBatchThrottleEnable;
      this._auditWebhookBatchThrottleQps = value.auditWebhookBatchThrottleQps;
      this._auditWebhookConfigFile = value.auditWebhookConfigFile;
      this._auditWebhookInitialBackoff = value.auditWebhookInitialBackoff;
      this._auditWebhookMode = value.auditWebhookMode;
      this._authenticationTokenWebhookCacheTtl = value.authenticationTokenWebhookCacheTtl;
      this._authenticationTokenWebhookConfigFile = value.authenticationTokenWebhookConfigFile;
      this._authorizationMode = value.authorizationMode;
      this._authorizationRbacSuperUser = value.authorizationRbacSuperUser;
      this._authorizationWebhookCacheAuthorizedTtl = value.authorizationWebhookCacheAuthorizedTtl;
      this._authorizationWebhookCacheUnauthorizedTtl = value.authorizationWebhookCacheUnauthorizedTtl;
      this._authorizationWebhookConfigFile = value.authorizationWebhookConfigFile;
      this._basicAuthFile = value.basicAuthFile;
      this._bindAddress = value.bindAddress;
      this._clientCaFile = value.clientCaFile;
      this._cloudProvider = value.cloudProvider;
      this._corsAllowedOrigins = value.corsAllowedOrigins;
      this._cpuLimit = value.cpuLimit;
      this._cpuRequest = value.cpuRequest;
      this._defaultNotReadyTolerationSeconds = value.defaultNotReadyTolerationSeconds;
      this._defaultUnreachableTolerationSeconds = value.defaultUnreachableTolerationSeconds;
      this._disableAdmissionPlugins = value.disableAdmissionPlugins;
      this._disableBasicAuth = value.disableBasicAuth;
      this._enableAdmissionPlugins = value.enableAdmissionPlugins;
      this._enableAggregatorRouting = value.enableAggregatorRouting;
      this._enableBootstrapAuthToken = value.enableBootstrapAuthToken;
      this._enableProfiling = value.enableProfiling;
      this._encryptionProviderConfig = value.encryptionProviderConfig;
      this._etcdCaFile = value.etcdCaFile;
      this._etcdCertFile = value.etcdCertFile;
      this._etcdKeyFile = value.etcdKeyFile;
      this._etcdQuorumRead = value.etcdQuorumRead;
      this._etcdServers = value.etcdServers;
      this._etcdServersOverrides = value.etcdServersOverrides;
      this._eventTtl = value.eventTtl;
      this._experimentalEncryptionProviderConfig = value.experimentalEncryptionProviderConfig;
      this._featureGates = value.featureGates;
      this._http2MaxStreamsPerConnection = value.http2MaxStreamsPerConnection;
      this._image = value.image;
      this._insecureBindAddress = value.insecureBindAddress;
      this._insecurePort = value.insecurePort;
      this._kubeletCertificateAuthority = value.kubeletCertificateAuthority;
      this._kubeletClientCertificate = value.kubeletClientCertificate;
      this._kubeletClientKey = value.kubeletClientKey;
      this._kubeletPreferredAddressTypes = value.kubeletPreferredAddressTypes;
      this._logFormat = value.logFormat;
      this._logLevel = value.logLevel;
      this._maxMutatingRequestsInflight = value.maxMutatingRequestsInflight;
      this._maxRequestsInflight = value.maxRequestsInflight;
      this._memoryLimit = value.memoryLimit;
      this._memoryRequest = value.memoryRequest;
      this._minRequestTimeout = value.minRequestTimeout;
      this._oidcCaFile = value.oidcCaFile;
      this._oidcClientId = value.oidcClientId;
      this._oidcGroupsClaim = value.oidcGroupsClaim;
      this._oidcGroupsPrefix = value.oidcGroupsPrefix;
      this._oidcIssuerUrl = value.oidcIssuerUrl;
      this._oidcRequiredClaim = value.oidcRequiredClaim;
      this._oidcUsernameClaim = value.oidcUsernameClaim;
      this._oidcUsernamePrefix = value.oidcUsernamePrefix;
      this._proxyClientCertFile = value.proxyClientCertFile;
      this._proxyClientKeyFile = value.proxyClientKeyFile;
      this._requestTimeout = value.requestTimeout;
      this._requestheaderAllowedNames = value.requestheaderAllowedNames;
      this._requestheaderClientCaFile = value.requestheaderClientCaFile;
      this._requestheaderExtraHeaderPrefixes = value.requestheaderExtraHeaderPrefixes;
      this._requestheaderGroupHeaders = value.requestheaderGroupHeaders;
      this._requestheaderUsernameHeaders = value.requestheaderUsernameHeaders;
      this._runtimeConfig = value.runtimeConfig;
      this._securePort = value.securePort;
      this._serviceAccountIssuer = value.serviceAccountIssuer;
      this._serviceAccountJwksuri = value.serviceAccountJwksuri;
      this._serviceAccountKeyFile = value.serviceAccountKeyFile;
      this._serviceAccountSigningKeyFile = value.serviceAccountSigningKeyFile;
      this._serviceClusterIpRange = value.serviceClusterIpRange;
      this._serviceNodePortRange = value.serviceNodePortRange;
      this._storageBackend = value.storageBackend;
      this._targetRamMb = value.targetRamMb;
      this._tlsCertFile = value.tlsCertFile;
      this._tlsCipherSuites = value.tlsCipherSuites;
      this._tlsMinVersion = value.tlsMinVersion;
      this._tlsPrivateKeyFile = value.tlsPrivateKeyFile;
      this._tokenAuthFile = value.tokenAuthFile;
      this._anonymousAuth.internalValue = value.anonymousAuth;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address?: string; 
  public get address() {
    return this.getStringAttribute('address');
  }
  public set address(value: string) {
    this._address = value;
  }
  public resetAddress() {
    this._address = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address;
  }

  // admission_control - computed: false, optional: true, required: false
  private _admissionControl?: string[]; 
  public get admissionControl() {
    return this.getListAttribute('admission_control');
  }
  public set admissionControl(value: string[]) {
    this._admissionControl = value;
  }
  public resetAdmissionControl() {
    this._admissionControl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get admissionControlInput() {
    return this._admissionControl;
  }

  // admission_control_config_file - computed: false, optional: true, required: false
  private _admissionControlConfigFile?: string; 
  public get admissionControlConfigFile() {
    return this.getStringAttribute('admission_control_config_file');
  }
  public set admissionControlConfigFile(value: string) {
    this._admissionControlConfigFile = value;
  }
  public resetAdmissionControlConfigFile() {
    this._admissionControlConfigFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get admissionControlConfigFileInput() {
    return this._admissionControlConfigFile;
  }

  // advertise_address - computed: false, optional: true, required: false
  private _advertiseAddress?: string; 
  public get advertiseAddress() {
    return this.getStringAttribute('advertise_address');
  }
  public set advertiseAddress(value: string) {
    this._advertiseAddress = value;
  }
  public resetAdvertiseAddress() {
    this._advertiseAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get advertiseAddressInput() {
    return this._advertiseAddress;
  }

  // allow_privileged - computed: false, optional: true, required: false
  private _allowPrivileged?: boolean | cdktf.IResolvable; 
  public get allowPrivileged() {
    return this.getBooleanAttribute('allow_privileged');
  }
  public set allowPrivileged(value: boolean | cdktf.IResolvable) {
    this._allowPrivileged = value;
  }
  public resetAllowPrivileged() {
    this._allowPrivileged = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowPrivilegedInput() {
    return this._allowPrivileged;
  }

  // api_audiences - computed: false, optional: true, required: false
  private _apiAudiences?: string[]; 
  public get apiAudiences() {
    return this.getListAttribute('api_audiences');
  }
  public set apiAudiences(value: string[]) {
    this._apiAudiences = value;
  }
  public resetApiAudiences() {
    this._apiAudiences = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiAudiencesInput() {
    return this._apiAudiences;
  }

  // api_server_count - computed: false, optional: true, required: false
  private _apiServerCount?: number; 
  public get apiServerCount() {
    return this.getNumberAttribute('api_server_count');
  }
  public set apiServerCount(value: number) {
    this._apiServerCount = value;
  }
  public resetApiServerCount() {
    this._apiServerCount = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiServerCountInput() {
    return this._apiServerCount;
  }

  // append_admission_plugins - computed: false, optional: true, required: false
  private _appendAdmissionPlugins?: string[]; 
  public get appendAdmissionPlugins() {
    return this.getListAttribute('append_admission_plugins');
  }
  public set appendAdmissionPlugins(value: string[]) {
    this._appendAdmissionPlugins = value;
  }
  public resetAppendAdmissionPlugins() {
    this._appendAdmissionPlugins = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appendAdmissionPluginsInput() {
    return this._appendAdmissionPlugins;
  }

  // audit_dynamic_configuration - computed: false, optional: true, required: false
  private _auditDynamicConfiguration?: boolean | cdktf.IResolvable; 
  public get auditDynamicConfiguration() {
    return this.getBooleanAttribute('audit_dynamic_configuration');
  }
  public set auditDynamicConfiguration(value: boolean | cdktf.IResolvable) {
    this._auditDynamicConfiguration = value;
  }
  public resetAuditDynamicConfiguration() {
    this._auditDynamicConfiguration = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get auditDynamicConfigurationInput() {
    return this._auditDynamicConfiguration;
  }

  // audit_log_format - computed: false, optional: true, required: false
  private _auditLogFormat?: string; 
  public get auditLogFormat() {
    return this.getStringAttribute('audit_log_format');
  }
  public set auditLogFormat(value: string) {
    this._auditLogFormat = value;
  }
  public resetAuditLogFormat() {
    this._auditLogFormat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get auditLogFormatInput() {
    return this._auditLogFormat;
  }

  // audit_log_max_age - computed: false, optional: true, required: false
  private _auditLogMaxAge?: number; 
  public get auditLogMaxAge() {
    return this.getNumberAttribute('audit_log_max_age');
  }
  public set auditLogMaxAge(value: number) {
    this._auditLogMaxAge = value;
  }
  public resetAuditLogMaxAge() {
    this._auditLogMaxAge = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get auditLogMaxAgeInput() {
    return this._auditLogMaxAge;
  }

  // audit_log_max_backups - computed: false, optional: true, required: false
  private _auditLogMaxBackups?: number; 
  public get auditLogMaxBackups() {
    return this.getNumberAttribute('audit_log_max_backups');
  }
  public set auditLogMaxBackups(value: number) {
    this._auditLogMaxBackups = value;
  }
  public resetAuditLogMaxBackups() {
    this._auditLogMaxBackups = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get auditLogMaxBackupsInput() {
    return this._auditLogMaxBackups;
  }

  // audit_log_max_size - computed: false, optional: true, required: false
  private _auditLogMaxSize?: number; 
  public get auditLogMaxSize() {
    return this.getNumberAttribute('audit_log_max_size');
  }
  public set auditLogMaxSize(value: number) {
    this._auditLogMaxSize = value;
  }
  public resetAuditLogMaxSize() {
    this._auditLogMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get auditLogMaxSizeInput() {
    return this._auditLogMaxSize;
  }

  // audit_log_path - computed: false, optional: true, required: false
  private _auditLogPath?: string; 
  public get auditLogPath() {
    return this.getStringAttribute('audit_log_path');
  }
  public set auditLogPath(value: string) {
    this._auditLogPath = value;
  }
  public resetAuditLogPath() {
    this._auditLogPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get auditLogPathInput() {
    return this._auditLogPath;
  }

  // audit_policy_file - computed: false, optional: true, required: false
  private _auditPolicyFile?: string; 
  public get auditPolicyFile() {
    return this.getStringAttribute('audit_policy_file');
  }
  public set auditPolicyFile(value: string) {
    this._auditPolicyFile = value;
  }
  public resetAuditPolicyFile() {
    this._auditPolicyFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get auditPolicyFileInput() {
    return this._auditPolicyFile;
  }

  // audit_webhook_batch_buffer_size - computed: false, optional: true, required: false
  private _auditWebhookBatchBufferSize?: number; 
  public get auditWebhookBatchBufferSize() {
    return this.getNumberAttribute('audit_webhook_batch_buffer_size');
  }
  public set auditWebhookBatchBufferSize(value: number) {
    this._auditWebhookBatchBufferSize = value;
  }
  public resetAuditWebhookBatchBufferSize() {
    this._auditWebhookBatchBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get auditWebhookBatchBufferSizeInput() {
    return this._auditWebhookBatchBufferSize;
  }

  // audit_webhook_batch_max_size - computed: false, optional: true, required: false
  private _auditWebhookBatchMaxSize?: number; 
  public get auditWebhookBatchMaxSize() {
    return this.getNumberAttribute('audit_webhook_batch_max_size');
  }
  public set auditWebhookBatchMaxSize(value: number) {
    this._auditWebhookBatchMaxSize = value;
  }
  public resetAuditWebhookBatchMaxSize() {
    this._auditWebhookBatchMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get auditWebhookBatchMaxSizeInput() {
    return this._auditWebhookBatchMaxSize;
  }

  // audit_webhook_batch_max_wait - computed: false, optional: true, required: false
  private _auditWebhookBatchMaxWait?: string; 
  public get auditWebhookBatchMaxWait() {
    return this.getStringAttribute('audit_webhook_batch_max_wait');
  }
  public set auditWebhookBatchMaxWait(value: string) {
    this._auditWebhookBatchMaxWait = value;
  }
  public resetAuditWebhookBatchMaxWait() {
    this._auditWebhookBatchMaxWait = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get auditWebhookBatchMaxWaitInput() {
    return this._auditWebhookBatchMaxWait;
  }

  // audit_webhook_batch_throttle_burst - computed: false, optional: true, required: false
  private _auditWebhookBatchThrottleBurst?: number; 
  public get auditWebhookBatchThrottleBurst() {
    return this.getNumberAttribute('audit_webhook_batch_throttle_burst');
  }
  public set auditWebhookBatchThrottleBurst(value: number) {
    this._auditWebhookBatchThrottleBurst = value;
  }
  public resetAuditWebhookBatchThrottleBurst() {
    this._auditWebhookBatchThrottleBurst = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get auditWebhookBatchThrottleBurstInput() {
    return this._auditWebhookBatchThrottleBurst;
  }

  // audit_webhook_batch_throttle_enable - computed: false, optional: true, required: false
  private _auditWebhookBatchThrottleEnable?: boolean | cdktf.IResolvable; 
  public get auditWebhookBatchThrottleEnable() {
    return this.getBooleanAttribute('audit_webhook_batch_throttle_enable');
  }
  public set auditWebhookBatchThrottleEnable(value: boolean | cdktf.IResolvable) {
    this._auditWebhookBatchThrottleEnable = value;
  }
  public resetAuditWebhookBatchThrottleEnable() {
    this._auditWebhookBatchThrottleEnable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get auditWebhookBatchThrottleEnableInput() {
    return this._auditWebhookBatchThrottleEnable;
  }

  // audit_webhook_batch_throttle_qps - computed: false, optional: true, required: false
  private _auditWebhookBatchThrottleQps?: string; 
  public get auditWebhookBatchThrottleQps() {
    return this.getStringAttribute('audit_webhook_batch_throttle_qps');
  }
  public set auditWebhookBatchThrottleQps(value: string) {
    this._auditWebhookBatchThrottleQps = value;
  }
  public resetAuditWebhookBatchThrottleQps() {
    this._auditWebhookBatchThrottleQps = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get auditWebhookBatchThrottleQpsInput() {
    return this._auditWebhookBatchThrottleQps;
  }

  // audit_webhook_config_file - computed: false, optional: true, required: false
  private _auditWebhookConfigFile?: string; 
  public get auditWebhookConfigFile() {
    return this.getStringAttribute('audit_webhook_config_file');
  }
  public set auditWebhookConfigFile(value: string) {
    this._auditWebhookConfigFile = value;
  }
  public resetAuditWebhookConfigFile() {
    this._auditWebhookConfigFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get auditWebhookConfigFileInput() {
    return this._auditWebhookConfigFile;
  }

  // audit_webhook_initial_backoff - computed: false, optional: true, required: false
  private _auditWebhookInitialBackoff?: string; 
  public get auditWebhookInitialBackoff() {
    return this.getStringAttribute('audit_webhook_initial_backoff');
  }
  public set auditWebhookInitialBackoff(value: string) {
    this._auditWebhookInitialBackoff = value;
  }
  public resetAuditWebhookInitialBackoff() {
    this._auditWebhookInitialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get auditWebhookInitialBackoffInput() {
    return this._auditWebhookInitialBackoff;
  }

  // audit_webhook_mode - computed: false, optional: true, required: false
  private _auditWebhookMode?: string; 
  public get auditWebhookMode() {
    return this.getStringAttribute('audit_webhook_mode');
  }
  public set auditWebhookMode(value: string) {
    this._auditWebhookMode = value;
  }
  public resetAuditWebhookMode() {
    this._auditWebhookMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get auditWebhookModeInput() {
    return this._auditWebhookMode;
  }

  // authentication_token_webhook_cache_ttl - computed: false, optional: true, required: false
  private _authenticationTokenWebhookCacheTtl?: string; 
  public get authenticationTokenWebhookCacheTtl() {
    return this.getStringAttribute('authentication_token_webhook_cache_ttl');
  }
  public set authenticationTokenWebhookCacheTtl(value: string) {
    this._authenticationTokenWebhookCacheTtl = value;
  }
  public resetAuthenticationTokenWebhookCacheTtl() {
    this._authenticationTokenWebhookCacheTtl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authenticationTokenWebhookCacheTtlInput() {
    return this._authenticationTokenWebhookCacheTtl;
  }

  // authentication_token_webhook_config_file - computed: false, optional: true, required: false
  private _authenticationTokenWebhookConfigFile?: string; 
  public get authenticationTokenWebhookConfigFile() {
    return this.getStringAttribute('authentication_token_webhook_config_file');
  }
  public set authenticationTokenWebhookConfigFile(value: string) {
    this._authenticationTokenWebhookConfigFile = value;
  }
  public resetAuthenticationTokenWebhookConfigFile() {
    this._authenticationTokenWebhookConfigFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authenticationTokenWebhookConfigFileInput() {
    return this._authenticationTokenWebhookConfigFile;
  }

  // authorization_mode - computed: false, optional: true, required: false
  private _authorizationMode?: string; 
  public get authorizationMode() {
    return this.getStringAttribute('authorization_mode');
  }
  public set authorizationMode(value: string) {
    this._authorizationMode = value;
  }
  public resetAuthorizationMode() {
    this._authorizationMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authorizationModeInput() {
    return this._authorizationMode;
  }

  // authorization_rbac_super_user - computed: false, optional: true, required: false
  private _authorizationRbacSuperUser?: string; 
  public get authorizationRbacSuperUser() {
    return this.getStringAttribute('authorization_rbac_super_user');
  }
  public set authorizationRbacSuperUser(value: string) {
    this._authorizationRbacSuperUser = value;
  }
  public resetAuthorizationRbacSuperUser() {
    this._authorizationRbacSuperUser = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authorizationRbacSuperUserInput() {
    return this._authorizationRbacSuperUser;
  }

  // authorization_webhook_cache_authorized_ttl - computed: false, optional: true, required: false
  private _authorizationWebhookCacheAuthorizedTtl?: string; 
  public get authorizationWebhookCacheAuthorizedTtl() {
    return this.getStringAttribute('authorization_webhook_cache_authorized_ttl');
  }
  public set authorizationWebhookCacheAuthorizedTtl(value: string) {
    this._authorizationWebhookCacheAuthorizedTtl = value;
  }
  public resetAuthorizationWebhookCacheAuthorizedTtl() {
    this._authorizationWebhookCacheAuthorizedTtl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authorizationWebhookCacheAuthorizedTtlInput() {
    return this._authorizationWebhookCacheAuthorizedTtl;
  }

  // authorization_webhook_cache_unauthorized_ttl - computed: false, optional: true, required: false
  private _authorizationWebhookCacheUnauthorizedTtl?: string; 
  public get authorizationWebhookCacheUnauthorizedTtl() {
    return this.getStringAttribute('authorization_webhook_cache_unauthorized_ttl');
  }
  public set authorizationWebhookCacheUnauthorizedTtl(value: string) {
    this._authorizationWebhookCacheUnauthorizedTtl = value;
  }
  public resetAuthorizationWebhookCacheUnauthorizedTtl() {
    this._authorizationWebhookCacheUnauthorizedTtl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authorizationWebhookCacheUnauthorizedTtlInput() {
    return this._authorizationWebhookCacheUnauthorizedTtl;
  }

  // authorization_webhook_config_file - computed: false, optional: true, required: false
  private _authorizationWebhookConfigFile?: string; 
  public get authorizationWebhookConfigFile() {
    return this.getStringAttribute('authorization_webhook_config_file');
  }
  public set authorizationWebhookConfigFile(value: string) {
    this._authorizationWebhookConfigFile = value;
  }
  public resetAuthorizationWebhookConfigFile() {
    this._authorizationWebhookConfigFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authorizationWebhookConfigFileInput() {
    return this._authorizationWebhookConfigFile;
  }

  // basic_auth_file - computed: false, optional: true, required: false
  private _basicAuthFile?: string; 
  public get basicAuthFile() {
    return this.getStringAttribute('basic_auth_file');
  }
  public set basicAuthFile(value: string) {
    this._basicAuthFile = value;
  }
  public resetBasicAuthFile() {
    this._basicAuthFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get basicAuthFileInput() {
    return this._basicAuthFile;
  }

  // bind_address - computed: false, optional: true, required: false
  private _bindAddress?: string; 
  public get bindAddress() {
    return this.getStringAttribute('bind_address');
  }
  public set bindAddress(value: string) {
    this._bindAddress = value;
  }
  public resetBindAddress() {
    this._bindAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindAddressInput() {
    return this._bindAddress;
  }

  // client_ca_file - computed: false, optional: true, required: false
  private _clientCaFile?: string; 
  public get clientCaFile() {
    return this.getStringAttribute('client_ca_file');
  }
  public set clientCaFile(value: string) {
    this._clientCaFile = value;
  }
  public resetClientCaFile() {
    this._clientCaFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientCaFileInput() {
    return this._clientCaFile;
  }

  // cloud_provider - computed: false, optional: true, required: false
  private _cloudProvider?: string; 
  public get cloudProvider() {
    return this.getStringAttribute('cloud_provider');
  }
  public set cloudProvider(value: string) {
    this._cloudProvider = value;
  }
  public resetCloudProvider() {
    this._cloudProvider = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cloudProviderInput() {
    return this._cloudProvider;
  }

  // cors_allowed_origins - computed: false, optional: true, required: false
  private _corsAllowedOrigins?: string[]; 
  public get corsAllowedOrigins() {
    return this.getListAttribute('cors_allowed_origins');
  }
  public set corsAllowedOrigins(value: string[]) {
    this._corsAllowedOrigins = value;
  }
  public resetCorsAllowedOrigins() {
    this._corsAllowedOrigins = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get corsAllowedOriginsInput() {
    return this._corsAllowedOrigins;
  }

  // cpu_limit - computed: false, optional: true, required: false
  private _cpuLimit?: string; 
  public get cpuLimit() {
    return this.getStringAttribute('cpu_limit');
  }
  public set cpuLimit(value: string) {
    this._cpuLimit = value;
  }
  public resetCpuLimit() {
    this._cpuLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuLimitInput() {
    return this._cpuLimit;
  }

  // cpu_request - computed: false, optional: true, required: false
  private _cpuRequest?: string; 
  public get cpuRequest() {
    return this.getStringAttribute('cpu_request');
  }
  public set cpuRequest(value: string) {
    this._cpuRequest = value;
  }
  public resetCpuRequest() {
    this._cpuRequest = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuRequestInput() {
    return this._cpuRequest;
  }

  // default_not_ready_toleration_seconds - computed: false, optional: true, required: false
  private _defaultNotReadyTolerationSeconds?: number; 
  public get defaultNotReadyTolerationSeconds() {
    return this.getNumberAttribute('default_not_ready_toleration_seconds');
  }
  public set defaultNotReadyTolerationSeconds(value: number) {
    this._defaultNotReadyTolerationSeconds = value;
  }
  public resetDefaultNotReadyTolerationSeconds() {
    this._defaultNotReadyTolerationSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultNotReadyTolerationSecondsInput() {
    return this._defaultNotReadyTolerationSeconds;
  }

  // default_unreachable_toleration_seconds - computed: false, optional: true, required: false
  private _defaultUnreachableTolerationSeconds?: number; 
  public get defaultUnreachableTolerationSeconds() {
    return this.getNumberAttribute('default_unreachable_toleration_seconds');
  }
  public set defaultUnreachableTolerationSeconds(value: number) {
    this._defaultUnreachableTolerationSeconds = value;
  }
  public resetDefaultUnreachableTolerationSeconds() {
    this._defaultUnreachableTolerationSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultUnreachableTolerationSecondsInput() {
    return this._defaultUnreachableTolerationSeconds;
  }

  // disable_admission_plugins - computed: false, optional: true, required: false
  private _disableAdmissionPlugins?: string[]; 
  public get disableAdmissionPlugins() {
    return this.getListAttribute('disable_admission_plugins');
  }
  public set disableAdmissionPlugins(value: string[]) {
    this._disableAdmissionPlugins = value;
  }
  public resetDisableAdmissionPlugins() {
    this._disableAdmissionPlugins = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableAdmissionPluginsInput() {
    return this._disableAdmissionPlugins;
  }

  // disable_basic_auth - computed: false, optional: true, required: false
  private _disableBasicAuth?: boolean | cdktf.IResolvable; 
  public get disableBasicAuth() {
    return this.getBooleanAttribute('disable_basic_auth');
  }
  public set disableBasicAuth(value: boolean | cdktf.IResolvable) {
    this._disableBasicAuth = value;
  }
  public resetDisableBasicAuth() {
    this._disableBasicAuth = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableBasicAuthInput() {
    return this._disableBasicAuth;
  }

  // enable_admission_plugins - computed: false, optional: true, required: false
  private _enableAdmissionPlugins?: string[]; 
  public get enableAdmissionPlugins() {
    return this.getListAttribute('enable_admission_plugins');
  }
  public set enableAdmissionPlugins(value: string[]) {
    this._enableAdmissionPlugins = value;
  }
  public resetEnableAdmissionPlugins() {
    this._enableAdmissionPlugins = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableAdmissionPluginsInput() {
    return this._enableAdmissionPlugins;
  }

  // enable_aggregator_routing - computed: false, optional: true, required: false
  private _enableAggregatorRouting?: boolean | cdktf.IResolvable; 
  public get enableAggregatorRouting() {
    return this.getBooleanAttribute('enable_aggregator_routing');
  }
  public set enableAggregatorRouting(value: boolean | cdktf.IResolvable) {
    this._enableAggregatorRouting = value;
  }
  public resetEnableAggregatorRouting() {
    this._enableAggregatorRouting = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableAggregatorRoutingInput() {
    return this._enableAggregatorRouting;
  }

  // enable_bootstrap_auth_token - computed: false, optional: true, required: false
  private _enableBootstrapAuthToken?: boolean | cdktf.IResolvable; 
  public get enableBootstrapAuthToken() {
    return this.getBooleanAttribute('enable_bootstrap_auth_token');
  }
  public set enableBootstrapAuthToken(value: boolean | cdktf.IResolvable) {
    this._enableBootstrapAuthToken = value;
  }
  public resetEnableBootstrapAuthToken() {
    this._enableBootstrapAuthToken = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableBootstrapAuthTokenInput() {
    return this._enableBootstrapAuthToken;
  }

  // enable_profiling - computed: false, optional: true, required: false
  private _enableProfiling?: boolean | cdktf.IResolvable; 
  public get enableProfiling() {
    return this.getBooleanAttribute('enable_profiling');
  }
  public set enableProfiling(value: boolean | cdktf.IResolvable) {
    this._enableProfiling = value;
  }
  public resetEnableProfiling() {
    this._enableProfiling = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableProfilingInput() {
    return this._enableProfiling;
  }

  // encryption_provider_config - computed: false, optional: true, required: false
  private _encryptionProviderConfig?: string; 
  public get encryptionProviderConfig() {
    return this.getStringAttribute('encryption_provider_config');
  }
  public set encryptionProviderConfig(value: string) {
    this._encryptionProviderConfig = value;
  }
  public resetEncryptionProviderConfig() {
    this._encryptionProviderConfig = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get encryptionProviderConfigInput() {
    return this._encryptionProviderConfig;
  }

  // etcd_ca_file - computed: false, optional: true, required: false
  private _etcdCaFile?: string; 
  public get etcdCaFile() {
    return this.getStringAttribute('etcd_ca_file');
  }
  public set etcdCaFile(value: string) {
    this._etcdCaFile = value;
  }
  public resetEtcdCaFile() {
    this._etcdCaFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get etcdCaFileInput() {
    return this._etcdCaFile;
  }

  // etcd_cert_file - computed: false, optional: true, required: false
  private _etcdCertFile?: string; 
  public get etcdCertFile() {
    return this.getStringAttribute('etcd_cert_file');
  }
  public set etcdCertFile(value: string) {
    this._etcdCertFile = value;
  }
  public resetEtcdCertFile() {
    this._etcdCertFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get etcdCertFileInput() {
    return this._etcdCertFile;
  }

  // etcd_key_file - computed: false, optional: true, required: false
  private _etcdKeyFile?: string; 
  public get etcdKeyFile() {
    return this.getStringAttribute('etcd_key_file');
  }
  public set etcdKeyFile(value: string) {
    this._etcdKeyFile = value;
  }
  public resetEtcdKeyFile() {
    this._etcdKeyFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get etcdKeyFileInput() {
    return this._etcdKeyFile;
  }

  // etcd_quorum_read - computed: false, optional: true, required: false
  private _etcdQuorumRead?: boolean | cdktf.IResolvable; 
  public get etcdQuorumRead() {
    return this.getBooleanAttribute('etcd_quorum_read');
  }
  public set etcdQuorumRead(value: boolean | cdktf.IResolvable) {
    this._etcdQuorumRead = value;
  }
  public resetEtcdQuorumRead() {
    this._etcdQuorumRead = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get etcdQuorumReadInput() {
    return this._etcdQuorumRead;
  }

  // etcd_servers - computed: false, optional: true, required: false
  private _etcdServers?: string[]; 
  public get etcdServers() {
    return this.getListAttribute('etcd_servers');
  }
  public set etcdServers(value: string[]) {
    this._etcdServers = value;
  }
  public resetEtcdServers() {
    this._etcdServers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get etcdServersInput() {
    return this._etcdServers;
  }

  // etcd_servers_overrides - computed: false, optional: true, required: false
  private _etcdServersOverrides?: string[]; 
  public get etcdServersOverrides() {
    return this.getListAttribute('etcd_servers_overrides');
  }
  public set etcdServersOverrides(value: string[]) {
    this._etcdServersOverrides = value;
  }
  public resetEtcdServersOverrides() {
    this._etcdServersOverrides = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get etcdServersOverridesInput() {
    return this._etcdServersOverrides;
  }

  // event_ttl - computed: false, optional: true, required: false
  private _eventTtl?: string; 
  public get eventTtl() {
    return this.getStringAttribute('event_ttl');
  }
  public set eventTtl(value: string) {
    this._eventTtl = value;
  }
  public resetEventTtl() {
    this._eventTtl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get eventTtlInput() {
    return this._eventTtl;
  }

  // experimental_encryption_provider_config - computed: false, optional: true, required: false
  private _experimentalEncryptionProviderConfig?: string; 
  public get experimentalEncryptionProviderConfig() {
    return this.getStringAttribute('experimental_encryption_provider_config');
  }
  public set experimentalEncryptionProviderConfig(value: string) {
    this._experimentalEncryptionProviderConfig = value;
  }
  public resetExperimentalEncryptionProviderConfig() {
    this._experimentalEncryptionProviderConfig = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get experimentalEncryptionProviderConfigInput() {
    return this._experimentalEncryptionProviderConfig;
  }

  // feature_gates - computed: false, optional: true, required: false
  private _featureGates?: { [key: string]: string }; 
  public get featureGates() {
    return this.getStringMapAttribute('feature_gates');
  }
  public set featureGates(value: { [key: string]: string }) {
    this._featureGates = value;
  }
  public resetFeatureGates() {
    this._featureGates = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get featureGatesInput() {
    return this._featureGates;
  }

  // http2_max_streams_per_connection - computed: false, optional: true, required: false
  private _http2MaxStreamsPerConnection?: number; 
  public get http2MaxStreamsPerConnection() {
    return this.getNumberAttribute('http2_max_streams_per_connection');
  }
  public set http2MaxStreamsPerConnection(value: number) {
    this._http2MaxStreamsPerConnection = value;
  }
  public resetHttp2MaxStreamsPerConnection() {
    this._http2MaxStreamsPerConnection = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get http2MaxStreamsPerConnectionInput() {
    return this._http2MaxStreamsPerConnection;
  }

  // image - computed: false, optional: true, required: false
  private _image?: string; 
  public get image() {
    return this.getStringAttribute('image');
  }
  public set image(value: string) {
    this._image = value;
  }
  public resetImage() {
    this._image = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageInput() {
    return this._image;
  }

  // insecure_bind_address - computed: false, optional: true, required: false
  private _insecureBindAddress?: string; 
  public get insecureBindAddress() {
    return this.getStringAttribute('insecure_bind_address');
  }
  public set insecureBindAddress(value: string) {
    this._insecureBindAddress = value;
  }
  public resetInsecureBindAddress() {
    this._insecureBindAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get insecureBindAddressInput() {
    return this._insecureBindAddress;
  }

  // insecure_port - computed: false, optional: true, required: false
  private _insecurePort?: number; 
  public get insecurePort() {
    return this.getNumberAttribute('insecure_port');
  }
  public set insecurePort(value: number) {
    this._insecurePort = value;
  }
  public resetInsecurePort() {
    this._insecurePort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get insecurePortInput() {
    return this._insecurePort;
  }

  // kubelet_certificate_authority - computed: false, optional: true, required: false
  private _kubeletCertificateAuthority?: string; 
  public get kubeletCertificateAuthority() {
    return this.getStringAttribute('kubelet_certificate_authority');
  }
  public set kubeletCertificateAuthority(value: string) {
    this._kubeletCertificateAuthority = value;
  }
  public resetKubeletCertificateAuthority() {
    this._kubeletCertificateAuthority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeletCertificateAuthorityInput() {
    return this._kubeletCertificateAuthority;
  }

  // kubelet_client_certificate - computed: false, optional: true, required: false
  private _kubeletClientCertificate?: string; 
  public get kubeletClientCertificate() {
    return this.getStringAttribute('kubelet_client_certificate');
  }
  public set kubeletClientCertificate(value: string) {
    this._kubeletClientCertificate = value;
  }
  public resetKubeletClientCertificate() {
    this._kubeletClientCertificate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeletClientCertificateInput() {
    return this._kubeletClientCertificate;
  }

  // kubelet_client_key - computed: false, optional: true, required: false
  private _kubeletClientKey?: string; 
  public get kubeletClientKey() {
    return this.getStringAttribute('kubelet_client_key');
  }
  public set kubeletClientKey(value: string) {
    this._kubeletClientKey = value;
  }
  public resetKubeletClientKey() {
    this._kubeletClientKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeletClientKeyInput() {
    return this._kubeletClientKey;
  }

  // kubelet_preferred_address_types - computed: false, optional: true, required: false
  private _kubeletPreferredAddressTypes?: string[]; 
  public get kubeletPreferredAddressTypes() {
    return this.getListAttribute('kubelet_preferred_address_types');
  }
  public set kubeletPreferredAddressTypes(value: string[]) {
    this._kubeletPreferredAddressTypes = value;
  }
  public resetKubeletPreferredAddressTypes() {
    this._kubeletPreferredAddressTypes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeletPreferredAddressTypesInput() {
    return this._kubeletPreferredAddressTypes;
  }

  // log_format - computed: false, optional: true, required: false
  private _logFormat?: string; 
  public get logFormat() {
    return this.getStringAttribute('log_format');
  }
  public set logFormat(value: string) {
    this._logFormat = value;
  }
  public resetLogFormat() {
    this._logFormat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logFormatInput() {
    return this._logFormat;
  }

  // log_level - computed: false, optional: true, required: false
  private _logLevel?: number; 
  public get logLevel() {
    return this.getNumberAttribute('log_level');
  }
  public set logLevel(value: number) {
    this._logLevel = value;
  }
  public resetLogLevel() {
    this._logLevel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logLevelInput() {
    return this._logLevel;
  }

  // max_mutating_requests_inflight - computed: false, optional: true, required: false
  private _maxMutatingRequestsInflight?: number; 
  public get maxMutatingRequestsInflight() {
    return this.getNumberAttribute('max_mutating_requests_inflight');
  }
  public set maxMutatingRequestsInflight(value: number) {
    this._maxMutatingRequestsInflight = value;
  }
  public resetMaxMutatingRequestsInflight() {
    this._maxMutatingRequestsInflight = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxMutatingRequestsInflightInput() {
    return this._maxMutatingRequestsInflight;
  }

  // max_requests_inflight - computed: false, optional: true, required: false
  private _maxRequestsInflight?: number; 
  public get maxRequestsInflight() {
    return this.getNumberAttribute('max_requests_inflight');
  }
  public set maxRequestsInflight(value: number) {
    this._maxRequestsInflight = value;
  }
  public resetMaxRequestsInflight() {
    this._maxRequestsInflight = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRequestsInflightInput() {
    return this._maxRequestsInflight;
  }

  // memory_limit - computed: false, optional: true, required: false
  private _memoryLimit?: string; 
  public get memoryLimit() {
    return this.getStringAttribute('memory_limit');
  }
  public set memoryLimit(value: string) {
    this._memoryLimit = value;
  }
  public resetMemoryLimit() {
    this._memoryLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryLimitInput() {
    return this._memoryLimit;
  }

  // memory_request - computed: false, optional: true, required: false
  private _memoryRequest?: string; 
  public get memoryRequest() {
    return this.getStringAttribute('memory_request');
  }
  public set memoryRequest(value: string) {
    this._memoryRequest = value;
  }
  public resetMemoryRequest() {
    this._memoryRequest = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryRequestInput() {
    return this._memoryRequest;
  }

  // min_request_timeout - computed: false, optional: true, required: false
  private _minRequestTimeout?: number; 
  public get minRequestTimeout() {
    return this.getNumberAttribute('min_request_timeout');
  }
  public set minRequestTimeout(value: number) {
    this._minRequestTimeout = value;
  }
  public resetMinRequestTimeout() {
    this._minRequestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minRequestTimeoutInput() {
    return this._minRequestTimeout;
  }

  // oidc_ca_file - computed: false, optional: true, required: false
  private _oidcCaFile?: string; 
  public get oidcCaFile() {
    return this.getStringAttribute('oidc_ca_file');
  }
  public set oidcCaFile(value: string) {
    this._oidcCaFile = value;
  }
  public resetOidcCaFile() {
    this._oidcCaFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oidcCaFileInput() {
    return this._oidcCaFile;
  }

  // oidc_client_id - computed: false, optional: true, required: false
  private _oidcClientId?: string; 
  public get oidcClientId() {
    return this.getStringAttribute('oidc_client_id');
  }
  public set oidcClientId(value: string) {
    this._oidcClientId = value;
  }
  public resetOidcClientId() {
    this._oidcClientId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oidcClientIdInput() {
    return this._oidcClientId;
  }

  // oidc_groups_claim - computed: false, optional: true, required: false
  private _oidcGroupsClaim?: string; 
  public get oidcGroupsClaim() {
    return this.getStringAttribute('oidc_groups_claim');
  }
  public set oidcGroupsClaim(value: string) {
    this._oidcGroupsClaim = value;
  }
  public resetOidcGroupsClaim() {
    this._oidcGroupsClaim = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oidcGroupsClaimInput() {
    return this._oidcGroupsClaim;
  }

  // oidc_groups_prefix - computed: false, optional: true, required: false
  private _oidcGroupsPrefix?: string; 
  public get oidcGroupsPrefix() {
    return this.getStringAttribute('oidc_groups_prefix');
  }
  public set oidcGroupsPrefix(value: string) {
    this._oidcGroupsPrefix = value;
  }
  public resetOidcGroupsPrefix() {
    this._oidcGroupsPrefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oidcGroupsPrefixInput() {
    return this._oidcGroupsPrefix;
  }

  // oidc_issuer_url - computed: false, optional: true, required: false
  private _oidcIssuerUrl?: string; 
  public get oidcIssuerUrl() {
    return this.getStringAttribute('oidc_issuer_url');
  }
  public set oidcIssuerUrl(value: string) {
    this._oidcIssuerUrl = value;
  }
  public resetOidcIssuerUrl() {
    this._oidcIssuerUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oidcIssuerUrlInput() {
    return this._oidcIssuerUrl;
  }

  // oidc_required_claim - computed: false, optional: true, required: false
  private _oidcRequiredClaim?: string[]; 
  public get oidcRequiredClaim() {
    return this.getListAttribute('oidc_required_claim');
  }
  public set oidcRequiredClaim(value: string[]) {
    this._oidcRequiredClaim = value;
  }
  public resetOidcRequiredClaim() {
    this._oidcRequiredClaim = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oidcRequiredClaimInput() {
    return this._oidcRequiredClaim;
  }

  // oidc_username_claim - computed: false, optional: true, required: false
  private _oidcUsernameClaim?: string; 
  public get oidcUsernameClaim() {
    return this.getStringAttribute('oidc_username_claim');
  }
  public set oidcUsernameClaim(value: string) {
    this._oidcUsernameClaim = value;
  }
  public resetOidcUsernameClaim() {
    this._oidcUsernameClaim = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oidcUsernameClaimInput() {
    return this._oidcUsernameClaim;
  }

  // oidc_username_prefix - computed: false, optional: true, required: false
  private _oidcUsernamePrefix?: string; 
  public get oidcUsernamePrefix() {
    return this.getStringAttribute('oidc_username_prefix');
  }
  public set oidcUsernamePrefix(value: string) {
    this._oidcUsernamePrefix = value;
  }
  public resetOidcUsernamePrefix() {
    this._oidcUsernamePrefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oidcUsernamePrefixInput() {
    return this._oidcUsernamePrefix;
  }

  // proxy_client_cert_file - computed: false, optional: true, required: false
  private _proxyClientCertFile?: string; 
  public get proxyClientCertFile() {
    return this.getStringAttribute('proxy_client_cert_file');
  }
  public set proxyClientCertFile(value: string) {
    this._proxyClientCertFile = value;
  }
  public resetProxyClientCertFile() {
    this._proxyClientCertFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClientCertFileInput() {
    return this._proxyClientCertFile;
  }

  // proxy_client_key_file - computed: false, optional: true, required: false
  private _proxyClientKeyFile?: string; 
  public get proxyClientKeyFile() {
    return this.getStringAttribute('proxy_client_key_file');
  }
  public set proxyClientKeyFile(value: string) {
    this._proxyClientKeyFile = value;
  }
  public resetProxyClientKeyFile() {
    this._proxyClientKeyFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClientKeyFileInput() {
    return this._proxyClientKeyFile;
  }

  // request_timeout - computed: false, optional: true, required: false
  private _requestTimeout?: string; 
  public get requestTimeout() {
    return this.getStringAttribute('request_timeout');
  }
  public set requestTimeout(value: string) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }

  // requestheader_allowed_names - computed: false, optional: true, required: false
  private _requestheaderAllowedNames?: string[]; 
  public get requestheaderAllowedNames() {
    return this.getListAttribute('requestheader_allowed_names');
  }
  public set requestheaderAllowedNames(value: string[]) {
    this._requestheaderAllowedNames = value;
  }
  public resetRequestheaderAllowedNames() {
    this._requestheaderAllowedNames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestheaderAllowedNamesInput() {
    return this._requestheaderAllowedNames;
  }

  // requestheader_client_ca_file - computed: false, optional: true, required: false
  private _requestheaderClientCaFile?: string; 
  public get requestheaderClientCaFile() {
    return this.getStringAttribute('requestheader_client_ca_file');
  }
  public set requestheaderClientCaFile(value: string) {
    this._requestheaderClientCaFile = value;
  }
  public resetRequestheaderClientCaFile() {
    this._requestheaderClientCaFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestheaderClientCaFileInput() {
    return this._requestheaderClientCaFile;
  }

  // requestheader_extra_header_prefixes - computed: false, optional: true, required: false
  private _requestheaderExtraHeaderPrefixes?: string[]; 
  public get requestheaderExtraHeaderPrefixes() {
    return this.getListAttribute('requestheader_extra_header_prefixes');
  }
  public set requestheaderExtraHeaderPrefixes(value: string[]) {
    this._requestheaderExtraHeaderPrefixes = value;
  }
  public resetRequestheaderExtraHeaderPrefixes() {
    this._requestheaderExtraHeaderPrefixes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestheaderExtraHeaderPrefixesInput() {
    return this._requestheaderExtraHeaderPrefixes;
  }

  // requestheader_group_headers - computed: false, optional: true, required: false
  private _requestheaderGroupHeaders?: string[]; 
  public get requestheaderGroupHeaders() {
    return this.getListAttribute('requestheader_group_headers');
  }
  public set requestheaderGroupHeaders(value: string[]) {
    this._requestheaderGroupHeaders = value;
  }
  public resetRequestheaderGroupHeaders() {
    this._requestheaderGroupHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestheaderGroupHeadersInput() {
    return this._requestheaderGroupHeaders;
  }

  // requestheader_username_headers - computed: false, optional: true, required: false
  private _requestheaderUsernameHeaders?: string[]; 
  public get requestheaderUsernameHeaders() {
    return this.getListAttribute('requestheader_username_headers');
  }
  public set requestheaderUsernameHeaders(value: string[]) {
    this._requestheaderUsernameHeaders = value;
  }
  public resetRequestheaderUsernameHeaders() {
    this._requestheaderUsernameHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestheaderUsernameHeadersInput() {
    return this._requestheaderUsernameHeaders;
  }

  // runtime_config - computed: false, optional: true, required: false
  private _runtimeConfig?: { [key: string]: string }; 
  public get runtimeConfig() {
    return this.getStringMapAttribute('runtime_config');
  }
  public set runtimeConfig(value: { [key: string]: string }) {
    this._runtimeConfig = value;
  }
  public resetRuntimeConfig() {
    this._runtimeConfig = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get runtimeConfigInput() {
    return this._runtimeConfig;
  }

  // secure_port - computed: false, optional: true, required: false
  private _securePort?: number; 
  public get securePort() {
    return this.getNumberAttribute('secure_port');
  }
  public set securePort(value: number) {
    this._securePort = value;
  }
  public resetSecurePort() {
    this._securePort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get securePortInput() {
    return this._securePort;
  }

  // service_account_issuer - computed: false, optional: true, required: false
  private _serviceAccountIssuer?: string; 
  public get serviceAccountIssuer() {
    return this.getStringAttribute('service_account_issuer');
  }
  public set serviceAccountIssuer(value: string) {
    this._serviceAccountIssuer = value;
  }
  public resetServiceAccountIssuer() {
    this._serviceAccountIssuer = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountIssuerInput() {
    return this._serviceAccountIssuer;
  }

  // service_account_jwksuri - computed: false, optional: true, required: false
  private _serviceAccountJwksuri?: string; 
  public get serviceAccountJwksuri() {
    return this.getStringAttribute('service_account_jwksuri');
  }
  public set serviceAccountJwksuri(value: string) {
    this._serviceAccountJwksuri = value;
  }
  public resetServiceAccountJwksuri() {
    this._serviceAccountJwksuri = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountJwksuriInput() {
    return this._serviceAccountJwksuri;
  }

  // service_account_key_file - computed: false, optional: true, required: false
  private _serviceAccountKeyFile?: string[]; 
  public get serviceAccountKeyFile() {
    return this.getListAttribute('service_account_key_file');
  }
  public set serviceAccountKeyFile(value: string[]) {
    this._serviceAccountKeyFile = value;
  }
  public resetServiceAccountKeyFile() {
    this._serviceAccountKeyFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountKeyFileInput() {
    return this._serviceAccountKeyFile;
  }

  // service_account_signing_key_file - computed: false, optional: true, required: false
  private _serviceAccountSigningKeyFile?: string; 
  public get serviceAccountSigningKeyFile() {
    return this.getStringAttribute('service_account_signing_key_file');
  }
  public set serviceAccountSigningKeyFile(value: string) {
    this._serviceAccountSigningKeyFile = value;
  }
  public resetServiceAccountSigningKeyFile() {
    this._serviceAccountSigningKeyFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountSigningKeyFileInput() {
    return this._serviceAccountSigningKeyFile;
  }

  // service_cluster_ip_range - computed: false, optional: true, required: false
  private _serviceClusterIpRange?: string; 
  public get serviceClusterIpRange() {
    return this.getStringAttribute('service_cluster_ip_range');
  }
  public set serviceClusterIpRange(value: string) {
    this._serviceClusterIpRange = value;
  }
  public resetServiceClusterIpRange() {
    this._serviceClusterIpRange = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceClusterIpRangeInput() {
    return this._serviceClusterIpRange;
  }

  // service_node_port_range - computed: false, optional: true, required: false
  private _serviceNodePortRange?: string; 
  public get serviceNodePortRange() {
    return this.getStringAttribute('service_node_port_range');
  }
  public set serviceNodePortRange(value: string) {
    this._serviceNodePortRange = value;
  }
  public resetServiceNodePortRange() {
    this._serviceNodePortRange = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceNodePortRangeInput() {
    return this._serviceNodePortRange;
  }

  // storage_backend - computed: false, optional: true, required: false
  private _storageBackend?: string; 
  public get storageBackend() {
    return this.getStringAttribute('storage_backend');
  }
  public set storageBackend(value: string) {
    this._storageBackend = value;
  }
  public resetStorageBackend() {
    this._storageBackend = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get storageBackendInput() {
    return this._storageBackend;
  }

  // target_ram_mb - computed: false, optional: true, required: false
  private _targetRamMb?: number; 
  public get targetRamMb() {
    return this.getNumberAttribute('target_ram_mb');
  }
  public set targetRamMb(value: number) {
    this._targetRamMb = value;
  }
  public resetTargetRamMb() {
    this._targetRamMb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetRamMbInput() {
    return this._targetRamMb;
  }

  // tls_cert_file - computed: false, optional: true, required: false
  private _tlsCertFile?: string; 
  public get tlsCertFile() {
    return this.getStringAttribute('tls_cert_file');
  }
  public set tlsCertFile(value: string) {
    this._tlsCertFile = value;
  }
  public resetTlsCertFile() {
    this._tlsCertFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsCertFileInput() {
    return this._tlsCertFile;
  }

  // tls_cipher_suites - computed: false, optional: true, required: false
  private _tlsCipherSuites?: string[]; 
  public get tlsCipherSuites() {
    return this.getListAttribute('tls_cipher_suites');
  }
  public set tlsCipherSuites(value: string[]) {
    this._tlsCipherSuites = value;
  }
  public resetTlsCipherSuites() {
    this._tlsCipherSuites = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsCipherSuitesInput() {
    return this._tlsCipherSuites;
  }

  // tls_min_version - computed: false, optional: true, required: false
  private _tlsMinVersion?: string; 
  public get tlsMinVersion() {
    return this.getStringAttribute('tls_min_version');
  }
  public set tlsMinVersion(value: string) {
    this._tlsMinVersion = value;
  }
  public resetTlsMinVersion() {
    this._tlsMinVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsMinVersionInput() {
    return this._tlsMinVersion;
  }

  // tls_private_key_file - computed: false, optional: true, required: false
  private _tlsPrivateKeyFile?: string; 
  public get tlsPrivateKeyFile() {
    return this.getStringAttribute('tls_private_key_file');
  }
  public set tlsPrivateKeyFile(value: string) {
    this._tlsPrivateKeyFile = value;
  }
  public resetTlsPrivateKeyFile() {
    this._tlsPrivateKeyFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsPrivateKeyFileInput() {
    return this._tlsPrivateKeyFile;
  }

  // token_auth_file - computed: false, optional: true, required: false
  private _tokenAuthFile?: string; 
  public get tokenAuthFile() {
    return this.getStringAttribute('token_auth_file');
  }
  public set tokenAuthFile(value: string) {
    this._tokenAuthFile = value;
  }
  public resetTokenAuthFile() {
    this._tokenAuthFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenAuthFileInput() {
    return this._tokenAuthFile;
  }

  // anonymous_auth - computed: false, optional: true, required: false
  private _anonymousAuth = new ClusterKubeApiServerAnonymousAuthOutputReference(this, "anonymous_auth");
  public get anonymousAuth() {
    return this._anonymousAuth;
  }
  public putAnonymousAuth(value: ClusterKubeApiServerAnonymousAuth) {
    this._anonymousAuth.internalValue = value;
  }
  public resetAnonymousAuth() {
    this._anonymousAuth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get anonymousAuthInput() {
    return this._anonymousAuth.internalValue;
  }
}
export interface ClusterKubeControllerManagerLeaderElection {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#leader_elect Cluster#leader_elect}
  */
  readonly leaderElect?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#leader_elect_lease_duration Cluster#leader_elect_lease_duration}
  */
  readonly leaderElectLeaseDuration?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#leader_elect_renew_deadline_duration Cluster#leader_elect_renew_deadline_duration}
  */
  readonly leaderElectRenewDeadlineDuration?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#leader_elect_resource_lock Cluster#leader_elect_resource_lock}
  */
  readonly leaderElectResourceLock?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#leader_elect_resource_name Cluster#leader_elect_resource_name}
  */
  readonly leaderElectResourceName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#leader_elect_resource_namespace Cluster#leader_elect_resource_namespace}
  */
  readonly leaderElectResourceNamespace?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#leader_elect_retry_period Cluster#leader_elect_retry_period}
  */
  readonly leaderElectRetryPeriod?: string;
}

export function clusterKubeControllerManagerLeaderElectionToTerraform(struct?: ClusterKubeControllerManagerLeaderElectionOutputReference | ClusterKubeControllerManagerLeaderElection): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    leader_elect: cdktf.booleanToTerraform(struct!.leaderElect),
    leader_elect_lease_duration: cdktf.stringToTerraform(struct!.leaderElectLeaseDuration),
    leader_elect_renew_deadline_duration: cdktf.stringToTerraform(struct!.leaderElectRenewDeadlineDuration),
    leader_elect_resource_lock: cdktf.stringToTerraform(struct!.leaderElectResourceLock),
    leader_elect_resource_name: cdktf.stringToTerraform(struct!.leaderElectResourceName),
    leader_elect_resource_namespace: cdktf.stringToTerraform(struct!.leaderElectResourceNamespace),
    leader_elect_retry_period: cdktf.stringToTerraform(struct!.leaderElectRetryPeriod),
  }
}


export function clusterKubeControllerManagerLeaderElectionToHclTerraform(struct?: ClusterKubeControllerManagerLeaderElectionOutputReference | ClusterKubeControllerManagerLeaderElection): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    leader_elect: {
      value: cdktf.booleanToHclTerraform(struct!.leaderElect),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    leader_elect_lease_duration: {
      value: cdktf.stringToHclTerraform(struct!.leaderElectLeaseDuration),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    leader_elect_renew_deadline_duration: {
      value: cdktf.stringToHclTerraform(struct!.leaderElectRenewDeadlineDuration),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    leader_elect_resource_lock: {
      value: cdktf.stringToHclTerraform(struct!.leaderElectResourceLock),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    leader_elect_resource_name: {
      value: cdktf.stringToHclTerraform(struct!.leaderElectResourceName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    leader_elect_resource_namespace: {
      value: cdktf.stringToHclTerraform(struct!.leaderElectResourceNamespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    leader_elect_retry_period: {
      value: cdktf.stringToHclTerraform(struct!.leaderElectRetryPeriod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterKubeControllerManagerLeaderElectionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterKubeControllerManagerLeaderElection | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._leaderElect !== undefined) {
      hasAnyValues = true;
      internalValueResult.leaderElect = this._leaderElect;
    }
    if (this._leaderElectLeaseDuration !== undefined) {
      hasAnyValues = true;
      internalValueResult.leaderElectLeaseDuration = this._leaderElectLeaseDuration;
    }
    if (this._leaderElectRenewDeadlineDuration !== undefined) {
      hasAnyValues = true;
      internalValueResult.leaderElectRenewDeadlineDuration = this._leaderElectRenewDeadlineDuration;
    }
    if (this._leaderElectResourceLock !== undefined) {
      hasAnyValues = true;
      internalValueResult.leaderElectResourceLock = this._leaderElectResourceLock;
    }
    if (this._leaderElectResourceName !== undefined) {
      hasAnyValues = true;
      internalValueResult.leaderElectResourceName = this._leaderElectResourceName;
    }
    if (this._leaderElectResourceNamespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.leaderElectResourceNamespace = this._leaderElectResourceNamespace;
    }
    if (this._leaderElectRetryPeriod !== undefined) {
      hasAnyValues = true;
      internalValueResult.leaderElectRetryPeriod = this._leaderElectRetryPeriod;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterKubeControllerManagerLeaderElection | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._leaderElect = undefined;
      this._leaderElectLeaseDuration = undefined;
      this._leaderElectRenewDeadlineDuration = undefined;
      this._leaderElectResourceLock = undefined;
      this._leaderElectResourceName = undefined;
      this._leaderElectResourceNamespace = undefined;
      this._leaderElectRetryPeriod = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._leaderElect = value.leaderElect;
      this._leaderElectLeaseDuration = value.leaderElectLeaseDuration;
      this._leaderElectRenewDeadlineDuration = value.leaderElectRenewDeadlineDuration;
      this._leaderElectResourceLock = value.leaderElectResourceLock;
      this._leaderElectResourceName = value.leaderElectResourceName;
      this._leaderElectResourceNamespace = value.leaderElectResourceNamespace;
      this._leaderElectRetryPeriod = value.leaderElectRetryPeriod;
    }
  }

  // leader_elect - computed: false, optional: true, required: false
  private _leaderElect?: boolean | cdktf.IResolvable; 
  public get leaderElect() {
    return this.getBooleanAttribute('leader_elect');
  }
  public set leaderElect(value: boolean | cdktf.IResolvable) {
    this._leaderElect = value;
  }
  public resetLeaderElect() {
    this._leaderElect = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get leaderElectInput() {
    return this._leaderElect;
  }

  // leader_elect_lease_duration - computed: false, optional: true, required: false
  private _leaderElectLeaseDuration?: string; 
  public get leaderElectLeaseDuration() {
    return this.getStringAttribute('leader_elect_lease_duration');
  }
  public set leaderElectLeaseDuration(value: string) {
    this._leaderElectLeaseDuration = value;
  }
  public resetLeaderElectLeaseDuration() {
    this._leaderElectLeaseDuration = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get leaderElectLeaseDurationInput() {
    return this._leaderElectLeaseDuration;
  }

  // leader_elect_renew_deadline_duration - computed: false, optional: true, required: false
  private _leaderElectRenewDeadlineDuration?: string; 
  public get leaderElectRenewDeadlineDuration() {
    return this.getStringAttribute('leader_elect_renew_deadline_duration');
  }
  public set leaderElectRenewDeadlineDuration(value: string) {
    this._leaderElectRenewDeadlineDuration = value;
  }
  public resetLeaderElectRenewDeadlineDuration() {
    this._leaderElectRenewDeadlineDuration = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get leaderElectRenewDeadlineDurationInput() {
    return this._leaderElectRenewDeadlineDuration;
  }

  // leader_elect_resource_lock - computed: false, optional: true, required: false
  private _leaderElectResourceLock?: string; 
  public get leaderElectResourceLock() {
    return this.getStringAttribute('leader_elect_resource_lock');
  }
  public set leaderElectResourceLock(value: string) {
    this._leaderElectResourceLock = value;
  }
  public resetLeaderElectResourceLock() {
    this._leaderElectResourceLock = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get leaderElectResourceLockInput() {
    return this._leaderElectResourceLock;
  }

  // leader_elect_resource_name - computed: false, optional: true, required: false
  private _leaderElectResourceName?: string; 
  public get leaderElectResourceName() {
    return this.getStringAttribute('leader_elect_resource_name');
  }
  public set leaderElectResourceName(value: string) {
    this._leaderElectResourceName = value;
  }
  public resetLeaderElectResourceName() {
    this._leaderElectResourceName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get leaderElectResourceNameInput() {
    return this._leaderElectResourceName;
  }

  // leader_elect_resource_namespace - computed: false, optional: true, required: false
  private _leaderElectResourceNamespace?: string; 
  public get leaderElectResourceNamespace() {
    return this.getStringAttribute('leader_elect_resource_namespace');
  }
  public set leaderElectResourceNamespace(value: string) {
    this._leaderElectResourceNamespace = value;
  }
  public resetLeaderElectResourceNamespace() {
    this._leaderElectResourceNamespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get leaderElectResourceNamespaceInput() {
    return this._leaderElectResourceNamespace;
  }

  // leader_elect_retry_period - computed: false, optional: true, required: false
  private _leaderElectRetryPeriod?: string; 
  public get leaderElectRetryPeriod() {
    return this.getStringAttribute('leader_elect_retry_period');
  }
  public set leaderElectRetryPeriod(value: string) {
    this._leaderElectRetryPeriod = value;
  }
  public resetLeaderElectRetryPeriod() {
    this._leaderElectRetryPeriod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get leaderElectRetryPeriodInput() {
    return this._leaderElectRetryPeriod;
  }
}
export interface ClusterKubeControllerManager {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#allocate_node_cidrs Cluster#allocate_node_cidrs}
  */
  readonly allocateNodeCidrs?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#attach_detach_reconcile_sync_period Cluster#attach_detach_reconcile_sync_period}
  */
  readonly attachDetachReconcileSyncPeriod?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#authentication_kubeconfig Cluster#authentication_kubeconfig}
  */
  readonly authenticationKubeconfig?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#authorization_always_allow_paths Cluster#authorization_always_allow_paths}
  */
  readonly authorizationAlwaysAllowPaths?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#authorization_kubeconfig Cluster#authorization_kubeconfig}
  */
  readonly authorizationKubeconfig?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#cidr_allocator_type Cluster#cidr_allocator_type}
  */
  readonly cidrAllocatorType?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#cloud_provider Cluster#cloud_provider}
  */
  readonly cloudProvider?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#cluster_cidr Cluster#cluster_cidr}
  */
  readonly clusterCidr?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#cluster_name Cluster#cluster_name}
  */
  readonly clusterName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#concurrent_deployment_syncs Cluster#concurrent_deployment_syncs}
  */
  readonly concurrentDeploymentSyncs?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#concurrent_endpoint_syncs Cluster#concurrent_endpoint_syncs}
  */
  readonly concurrentEndpointSyncs?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#concurrent_namespace_syncs Cluster#concurrent_namespace_syncs}
  */
  readonly concurrentNamespaceSyncs?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#concurrent_rc_syncs Cluster#concurrent_rc_syncs}
  */
  readonly concurrentRcSyncs?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#concurrent_replicaset_syncs Cluster#concurrent_replicaset_syncs}
  */
  readonly concurrentReplicasetSyncs?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#concurrent_resource_quota_syncs Cluster#concurrent_resource_quota_syncs}
  */
  readonly concurrentResourceQuotaSyncs?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#concurrent_service_syncs Cluster#concurrent_service_syncs}
  */
  readonly concurrentServiceSyncs?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#concurrent_serviceaccount_token_syncs Cluster#concurrent_serviceaccount_token_syncs}
  */
  readonly concurrentServiceaccountTokenSyncs?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#configure_cloud_routes Cluster#configure_cloud_routes}
  */
  readonly configureCloudRoutes?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#controllers Cluster#controllers}
  */
  readonly controllers?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#disable_attach_detach_reconcile_sync Cluster#disable_attach_detach_reconcile_sync}
  */
  readonly disableAttachDetachReconcileSync?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#enable_leader_migration Cluster#enable_leader_migration}
  */
  readonly enableLeaderMigration?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#enable_profiling Cluster#enable_profiling}
  */
  readonly enableProfiling?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#experimental_cluster_signing_duration Cluster#experimental_cluster_signing_duration}
  */
  readonly experimentalClusterSigningDuration?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#external_cloud_volume_plugin Cluster#external_cloud_volume_plugin}
  */
  readonly externalCloudVolumePlugin?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#feature_gates Cluster#feature_gates}
  */
  readonly featureGates?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#horizontal_pod_autoscaler_cpu_initialization_period Cluster#horizontal_pod_autoscaler_cpu_initialization_period}
  */
  readonly horizontalPodAutoscalerCpuInitializationPeriod?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#horizontal_pod_autoscaler_downscale_delay Cluster#horizontal_pod_autoscaler_downscale_delay}
  */
  readonly horizontalPodAutoscalerDownscaleDelay?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#horizontal_pod_autoscaler_downscale_stabilization Cluster#horizontal_pod_autoscaler_downscale_stabilization}
  */
  readonly horizontalPodAutoscalerDownscaleStabilization?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#horizontal_pod_autoscaler_initial_readiness_delay Cluster#horizontal_pod_autoscaler_initial_readiness_delay}
  */
  readonly horizontalPodAutoscalerInitialReadinessDelay?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#horizontal_pod_autoscaler_sync_period Cluster#horizontal_pod_autoscaler_sync_period}
  */
  readonly horizontalPodAutoscalerSyncPeriod?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#horizontal_pod_autoscaler_tolerance Cluster#horizontal_pod_autoscaler_tolerance}
  */
  readonly horizontalPodAutoscalerTolerance?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#horizontal_pod_autoscaler_upscale_delay Cluster#horizontal_pod_autoscaler_upscale_delay}
  */
  readonly horizontalPodAutoscalerUpscaleDelay?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#horizontal_pod_autoscaler_use_rest_clients Cluster#horizontal_pod_autoscaler_use_rest_clients}
  */
  readonly horizontalPodAutoscalerUseRestClients?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#image Cluster#image}
  */
  readonly image?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#kube_api_burst Cluster#kube_api_burst}
  */
  readonly kubeApiBurst?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#kube_api_qps Cluster#kube_api_qps}
  */
  readonly kubeApiQps?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#log_format Cluster#log_format}
  */
  readonly logFormat?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#log_level Cluster#log_level}
  */
  readonly logLevel?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#master Cluster#master}
  */
  readonly master?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#min_resync_period Cluster#min_resync_period}
  */
  readonly minResyncPeriod?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#node_cidr_mask_size Cluster#node_cidr_mask_size}
  */
  readonly nodeCidrMaskSize?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#node_monitor_grace_period Cluster#node_monitor_grace_period}
  */
  readonly nodeMonitorGracePeriod?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#node_monitor_period Cluster#node_monitor_period}
  */
  readonly nodeMonitorPeriod?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#pod_eviction_timeout Cluster#pod_eviction_timeout}
  */
  readonly podEvictionTimeout?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#root_ca_file Cluster#root_ca_file}
  */
  readonly rootCaFile?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#service_account_private_key_file Cluster#service_account_private_key_file}
  */
  readonly serviceAccountPrivateKeyFile?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#terminated_pod_gc_threshold Cluster#terminated_pod_gc_threshold}
  */
  readonly terminatedPodGcThreshold?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#tls_cert_file Cluster#tls_cert_file}
  */
  readonly tlsCertFile?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#tls_cipher_suites Cluster#tls_cipher_suites}
  */
  readonly tlsCipherSuites?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#tls_min_version Cluster#tls_min_version}
  */
  readonly tlsMinVersion?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#tls_private_key_file Cluster#tls_private_key_file}
  */
  readonly tlsPrivateKeyFile?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#use_service_account_credentials Cluster#use_service_account_credentials}
  */
  readonly useServiceAccountCredentials?: boolean | cdktf.IResolvable;
  /**
  * leader_election block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#leader_election Cluster#leader_election}
  */
  readonly leaderElection?: ClusterKubeControllerManagerLeaderElection;
}

export function clusterKubeControllerManagerToTerraform(struct?: ClusterKubeControllerManagerOutputReference | ClusterKubeControllerManager): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allocate_node_cidrs: cdktf.booleanToTerraform(struct!.allocateNodeCidrs),
    attach_detach_reconcile_sync_period: cdktf.stringToTerraform(struct!.attachDetachReconcileSyncPeriod),
    authentication_kubeconfig: cdktf.stringToTerraform(struct!.authenticationKubeconfig),
    authorization_always_allow_paths: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.authorizationAlwaysAllowPaths),
    authorization_kubeconfig: cdktf.stringToTerraform(struct!.authorizationKubeconfig),
    cidr_allocator_type: cdktf.stringToTerraform(struct!.cidrAllocatorType),
    cloud_provider: cdktf.stringToTerraform(struct!.cloudProvider),
    cluster_cidr: cdktf.stringToTerraform(struct!.clusterCidr),
    cluster_name: cdktf.stringToTerraform(struct!.clusterName),
    concurrent_deployment_syncs: cdktf.numberToTerraform(struct!.concurrentDeploymentSyncs),
    concurrent_endpoint_syncs: cdktf.numberToTerraform(struct!.concurrentEndpointSyncs),
    concurrent_namespace_syncs: cdktf.numberToTerraform(struct!.concurrentNamespaceSyncs),
    concurrent_rc_syncs: cdktf.numberToTerraform(struct!.concurrentRcSyncs),
    concurrent_replicaset_syncs: cdktf.numberToTerraform(struct!.concurrentReplicasetSyncs),
    concurrent_resource_quota_syncs: cdktf.numberToTerraform(struct!.concurrentResourceQuotaSyncs),
    concurrent_service_syncs: cdktf.numberToTerraform(struct!.concurrentServiceSyncs),
    concurrent_serviceaccount_token_syncs: cdktf.numberToTerraform(struct!.concurrentServiceaccountTokenSyncs),
    configure_cloud_routes: cdktf.booleanToTerraform(struct!.configureCloudRoutes),
    controllers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.controllers),
    disable_attach_detach_reconcile_sync: cdktf.booleanToTerraform(struct!.disableAttachDetachReconcileSync),
    enable_leader_migration: cdktf.booleanToTerraform(struct!.enableLeaderMigration),
    enable_profiling: cdktf.booleanToTerraform(struct!.enableProfiling),
    experimental_cluster_signing_duration: cdktf.stringToTerraform(struct!.experimentalClusterSigningDuration),
    external_cloud_volume_plugin: cdktf.stringToTerraform(struct!.externalCloudVolumePlugin),
    feature_gates: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.featureGates),
    horizontal_pod_autoscaler_cpu_initialization_period: cdktf.stringToTerraform(struct!.horizontalPodAutoscalerCpuInitializationPeriod),
    horizontal_pod_autoscaler_downscale_delay: cdktf.stringToTerraform(struct!.horizontalPodAutoscalerDownscaleDelay),
    horizontal_pod_autoscaler_downscale_stabilization: cdktf.stringToTerraform(struct!.horizontalPodAutoscalerDownscaleStabilization),
    horizontal_pod_autoscaler_initial_readiness_delay: cdktf.stringToTerraform(struct!.horizontalPodAutoscalerInitialReadinessDelay),
    horizontal_pod_autoscaler_sync_period: cdktf.stringToTerraform(struct!.horizontalPodAutoscalerSyncPeriod),
    horizontal_pod_autoscaler_tolerance: cdktf.stringToTerraform(struct!.horizontalPodAutoscalerTolerance),
    horizontal_pod_autoscaler_upscale_delay: cdktf.stringToTerraform(struct!.horizontalPodAutoscalerUpscaleDelay),
    horizontal_pod_autoscaler_use_rest_clients: cdktf.booleanToTerraform(struct!.horizontalPodAutoscalerUseRestClients),
    image: cdktf.stringToTerraform(struct!.image),
    kube_api_burst: cdktf.numberToTerraform(struct!.kubeApiBurst),
    kube_api_qps: cdktf.stringToTerraform(struct!.kubeApiQps),
    log_format: cdktf.stringToTerraform(struct!.logFormat),
    log_level: cdktf.numberToTerraform(struct!.logLevel),
    master: cdktf.stringToTerraform(struct!.master),
    min_resync_period: cdktf.stringToTerraform(struct!.minResyncPeriod),
    node_cidr_mask_size: cdktf.numberToTerraform(struct!.nodeCidrMaskSize),
    node_monitor_grace_period: cdktf.stringToTerraform(struct!.nodeMonitorGracePeriod),
    node_monitor_period: cdktf.stringToTerraform(struct!.nodeMonitorPeriod),
    pod_eviction_timeout: cdktf.stringToTerraform(struct!.podEvictionTimeout),
    root_ca_file: cdktf.stringToTerraform(struct!.rootCaFile),
    service_account_private_key_file: cdktf.stringToTerraform(struct!.serviceAccountPrivateKeyFile),
    terminated_pod_gc_threshold: cdktf.numberToTerraform(struct!.terminatedPodGcThreshold),
    tls_cert_file: cdktf.stringToTerraform(struct!.tlsCertFile),
    tls_cipher_suites: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.tlsCipherSuites),
    tls_min_version: cdktf.stringToTerraform(struct!.tlsMinVersion),
    tls_private_key_file: cdktf.stringToTerraform(struct!.tlsPrivateKeyFile),
    use_service_account_credentials: cdktf.booleanToTerraform(struct!.useServiceAccountCredentials),
    leader_election: clusterKubeControllerManagerLeaderElectionToTerraform(struct!.leaderElection),
  }
}


export function clusterKubeControllerManagerToHclTerraform(struct?: ClusterKubeControllerManagerOutputReference | ClusterKubeControllerManager): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allocate_node_cidrs: {
      value: cdktf.booleanToHclTerraform(struct!.allocateNodeCidrs),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    attach_detach_reconcile_sync_period: {
      value: cdktf.stringToHclTerraform(struct!.attachDetachReconcileSyncPeriod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    authentication_kubeconfig: {
      value: cdktf.stringToHclTerraform(struct!.authenticationKubeconfig),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    authorization_always_allow_paths: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.authorizationAlwaysAllowPaths),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    authorization_kubeconfig: {
      value: cdktf.stringToHclTerraform(struct!.authorizationKubeconfig),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cidr_allocator_type: {
      value: cdktf.stringToHclTerraform(struct!.cidrAllocatorType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cloud_provider: {
      value: cdktf.stringToHclTerraform(struct!.cloudProvider),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cluster_cidr: {
      value: cdktf.stringToHclTerraform(struct!.clusterCidr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cluster_name: {
      value: cdktf.stringToHclTerraform(struct!.clusterName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    concurrent_deployment_syncs: {
      value: cdktf.numberToHclTerraform(struct!.concurrentDeploymentSyncs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    concurrent_endpoint_syncs: {
      value: cdktf.numberToHclTerraform(struct!.concurrentEndpointSyncs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    concurrent_namespace_syncs: {
      value: cdktf.numberToHclTerraform(struct!.concurrentNamespaceSyncs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    concurrent_rc_syncs: {
      value: cdktf.numberToHclTerraform(struct!.concurrentRcSyncs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    concurrent_replicaset_syncs: {
      value: cdktf.numberToHclTerraform(struct!.concurrentReplicasetSyncs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    concurrent_resource_quota_syncs: {
      value: cdktf.numberToHclTerraform(struct!.concurrentResourceQuotaSyncs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    concurrent_service_syncs: {
      value: cdktf.numberToHclTerraform(struct!.concurrentServiceSyncs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    concurrent_serviceaccount_token_syncs: {
      value: cdktf.numberToHclTerraform(struct!.concurrentServiceaccountTokenSyncs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    configure_cloud_routes: {
      value: cdktf.booleanToHclTerraform(struct!.configureCloudRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    controllers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.controllers),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    disable_attach_detach_reconcile_sync: {
      value: cdktf.booleanToHclTerraform(struct!.disableAttachDetachReconcileSync),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_leader_migration: {
      value: cdktf.booleanToHclTerraform(struct!.enableLeaderMigration),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_profiling: {
      value: cdktf.booleanToHclTerraform(struct!.enableProfiling),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    experimental_cluster_signing_duration: {
      value: cdktf.stringToHclTerraform(struct!.experimentalClusterSigningDuration),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    external_cloud_volume_plugin: {
      value: cdktf.stringToHclTerraform(struct!.externalCloudVolumePlugin),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    feature_gates: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.featureGates),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    horizontal_pod_autoscaler_cpu_initialization_period: {
      value: cdktf.stringToHclTerraform(struct!.horizontalPodAutoscalerCpuInitializationPeriod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    horizontal_pod_autoscaler_downscale_delay: {
      value: cdktf.stringToHclTerraform(struct!.horizontalPodAutoscalerDownscaleDelay),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    horizontal_pod_autoscaler_downscale_stabilization: {
      value: cdktf.stringToHclTerraform(struct!.horizontalPodAutoscalerDownscaleStabilization),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    horizontal_pod_autoscaler_initial_readiness_delay: {
      value: cdktf.stringToHclTerraform(struct!.horizontalPodAutoscalerInitialReadinessDelay),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    horizontal_pod_autoscaler_sync_period: {
      value: cdktf.stringToHclTerraform(struct!.horizontalPodAutoscalerSyncPeriod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    horizontal_pod_autoscaler_tolerance: {
      value: cdktf.stringToHclTerraform(struct!.horizontalPodAutoscalerTolerance),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    horizontal_pod_autoscaler_upscale_delay: {
      value: cdktf.stringToHclTerraform(struct!.horizontalPodAutoscalerUpscaleDelay),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    horizontal_pod_autoscaler_use_rest_clients: {
      value: cdktf.booleanToHclTerraform(struct!.horizontalPodAutoscalerUseRestClients),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    image: {
      value: cdktf.stringToHclTerraform(struct!.image),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kube_api_burst: {
      value: cdktf.numberToHclTerraform(struct!.kubeApiBurst),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    kube_api_qps: {
      value: cdktf.stringToHclTerraform(struct!.kubeApiQps),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_format: {
      value: cdktf.stringToHclTerraform(struct!.logFormat),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_level: {
      value: cdktf.numberToHclTerraform(struct!.logLevel),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    master: {
      value: cdktf.stringToHclTerraform(struct!.master),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_resync_period: {
      value: cdktf.stringToHclTerraform(struct!.minResyncPeriod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    node_cidr_mask_size: {
      value: cdktf.numberToHclTerraform(struct!.nodeCidrMaskSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    node_monitor_grace_period: {
      value: cdktf.stringToHclTerraform(struct!.nodeMonitorGracePeriod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    node_monitor_period: {
      value: cdktf.stringToHclTerraform(struct!.nodeMonitorPeriod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pod_eviction_timeout: {
      value: cdktf.stringToHclTerraform(struct!.podEvictionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    root_ca_file: {
      value: cdktf.stringToHclTerraform(struct!.rootCaFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    service_account_private_key_file: {
      value: cdktf.stringToHclTerraform(struct!.serviceAccountPrivateKeyFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    terminated_pod_gc_threshold: {
      value: cdktf.numberToHclTerraform(struct!.terminatedPodGcThreshold),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    tls_cert_file: {
      value: cdktf.stringToHclTerraform(struct!.tlsCertFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls_cipher_suites: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.tlsCipherSuites),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tls_min_version: {
      value: cdktf.stringToHclTerraform(struct!.tlsMinVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls_private_key_file: {
      value: cdktf.stringToHclTerraform(struct!.tlsPrivateKeyFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_service_account_credentials: {
      value: cdktf.booleanToHclTerraform(struct!.useServiceAccountCredentials),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    leader_election: {
      value: clusterKubeControllerManagerLeaderElectionToHclTerraform(struct!.leaderElection),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterKubeControllerManagerLeaderElectionList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterKubeControllerManagerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterKubeControllerManager | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allocateNodeCidrs !== undefined) {
      hasAnyValues = true;
      internalValueResult.allocateNodeCidrs = this._allocateNodeCidrs;
    }
    if (this._attachDetachReconcileSyncPeriod !== undefined) {
      hasAnyValues = true;
      internalValueResult.attachDetachReconcileSyncPeriod = this._attachDetachReconcileSyncPeriod;
    }
    if (this._authenticationKubeconfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.authenticationKubeconfig = this._authenticationKubeconfig;
    }
    if (this._authorizationAlwaysAllowPaths !== undefined) {
      hasAnyValues = true;
      internalValueResult.authorizationAlwaysAllowPaths = this._authorizationAlwaysAllowPaths;
    }
    if (this._authorizationKubeconfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.authorizationKubeconfig = this._authorizationKubeconfig;
    }
    if (this._cidrAllocatorType !== undefined) {
      hasAnyValues = true;
      internalValueResult.cidrAllocatorType = this._cidrAllocatorType;
    }
    if (this._cloudProvider !== undefined) {
      hasAnyValues = true;
      internalValueResult.cloudProvider = this._cloudProvider;
    }
    if (this._clusterCidr !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterCidr = this._clusterCidr;
    }
    if (this._clusterName !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterName = this._clusterName;
    }
    if (this._concurrentDeploymentSyncs !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrentDeploymentSyncs = this._concurrentDeploymentSyncs;
    }
    if (this._concurrentEndpointSyncs !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrentEndpointSyncs = this._concurrentEndpointSyncs;
    }
    if (this._concurrentNamespaceSyncs !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrentNamespaceSyncs = this._concurrentNamespaceSyncs;
    }
    if (this._concurrentRcSyncs !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrentRcSyncs = this._concurrentRcSyncs;
    }
    if (this._concurrentReplicasetSyncs !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrentReplicasetSyncs = this._concurrentReplicasetSyncs;
    }
    if (this._concurrentResourceQuotaSyncs !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrentResourceQuotaSyncs = this._concurrentResourceQuotaSyncs;
    }
    if (this._concurrentServiceSyncs !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrentServiceSyncs = this._concurrentServiceSyncs;
    }
    if (this._concurrentServiceaccountTokenSyncs !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrentServiceaccountTokenSyncs = this._concurrentServiceaccountTokenSyncs;
    }
    if (this._configureCloudRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.configureCloudRoutes = this._configureCloudRoutes;
    }
    if (this._controllers !== undefined) {
      hasAnyValues = true;
      internalValueResult.controllers = this._controllers;
    }
    if (this._disableAttachDetachReconcileSync !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableAttachDetachReconcileSync = this._disableAttachDetachReconcileSync;
    }
    if (this._enableLeaderMigration !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableLeaderMigration = this._enableLeaderMigration;
    }
    if (this._enableProfiling !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableProfiling = this._enableProfiling;
    }
    if (this._experimentalClusterSigningDuration !== undefined) {
      hasAnyValues = true;
      internalValueResult.experimentalClusterSigningDuration = this._experimentalClusterSigningDuration;
    }
    if (this._externalCloudVolumePlugin !== undefined) {
      hasAnyValues = true;
      internalValueResult.externalCloudVolumePlugin = this._externalCloudVolumePlugin;
    }
    if (this._featureGates !== undefined) {
      hasAnyValues = true;
      internalValueResult.featureGates = this._featureGates;
    }
    if (this._horizontalPodAutoscalerCpuInitializationPeriod !== undefined) {
      hasAnyValues = true;
      internalValueResult.horizontalPodAutoscalerCpuInitializationPeriod = this._horizontalPodAutoscalerCpuInitializationPeriod;
    }
    if (this._horizontalPodAutoscalerDownscaleDelay !== undefined) {
      hasAnyValues = true;
      internalValueResult.horizontalPodAutoscalerDownscaleDelay = this._horizontalPodAutoscalerDownscaleDelay;
    }
    if (this._horizontalPodAutoscalerDownscaleStabilization !== undefined) {
      hasAnyValues = true;
      internalValueResult.horizontalPodAutoscalerDownscaleStabilization = this._horizontalPodAutoscalerDownscaleStabilization;
    }
    if (this._horizontalPodAutoscalerInitialReadinessDelay !== undefined) {
      hasAnyValues = true;
      internalValueResult.horizontalPodAutoscalerInitialReadinessDelay = this._horizontalPodAutoscalerInitialReadinessDelay;
    }
    if (this._horizontalPodAutoscalerSyncPeriod !== undefined) {
      hasAnyValues = true;
      internalValueResult.horizontalPodAutoscalerSyncPeriod = this._horizontalPodAutoscalerSyncPeriod;
    }
    if (this._horizontalPodAutoscalerTolerance !== undefined) {
      hasAnyValues = true;
      internalValueResult.horizontalPodAutoscalerTolerance = this._horizontalPodAutoscalerTolerance;
    }
    if (this._horizontalPodAutoscalerUpscaleDelay !== undefined) {
      hasAnyValues = true;
      internalValueResult.horizontalPodAutoscalerUpscaleDelay = this._horizontalPodAutoscalerUpscaleDelay;
    }
    if (this._horizontalPodAutoscalerUseRestClients !== undefined) {
      hasAnyValues = true;
      internalValueResult.horizontalPodAutoscalerUseRestClients = this._horizontalPodAutoscalerUseRestClients;
    }
    if (this._image !== undefined) {
      hasAnyValues = true;
      internalValueResult.image = this._image;
    }
    if (this._kubeApiBurst !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubeApiBurst = this._kubeApiBurst;
    }
    if (this._kubeApiQps !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubeApiQps = this._kubeApiQps;
    }
    if (this._logFormat !== undefined) {
      hasAnyValues = true;
      internalValueResult.logFormat = this._logFormat;
    }
    if (this._logLevel !== undefined) {
      hasAnyValues = true;
      internalValueResult.logLevel = this._logLevel;
    }
    if (this._master !== undefined) {
      hasAnyValues = true;
      internalValueResult.master = this._master;
    }
    if (this._minResyncPeriod !== undefined) {
      hasAnyValues = true;
      internalValueResult.minResyncPeriod = this._minResyncPeriod;
    }
    if (this._nodeCidrMaskSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeCidrMaskSize = this._nodeCidrMaskSize;
    }
    if (this._nodeMonitorGracePeriod !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeMonitorGracePeriod = this._nodeMonitorGracePeriod;
    }
    if (this._nodeMonitorPeriod !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeMonitorPeriod = this._nodeMonitorPeriod;
    }
    if (this._podEvictionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.podEvictionTimeout = this._podEvictionTimeout;
    }
    if (this._rootCaFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.rootCaFile = this._rootCaFile;
    }
    if (this._serviceAccountPrivateKeyFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccountPrivateKeyFile = this._serviceAccountPrivateKeyFile;
    }
    if (this._terminatedPodGcThreshold !== undefined) {
      hasAnyValues = true;
      internalValueResult.terminatedPodGcThreshold = this._terminatedPodGcThreshold;
    }
    if (this._tlsCertFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsCertFile = this._tlsCertFile;
    }
    if (this._tlsCipherSuites !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsCipherSuites = this._tlsCipherSuites;
    }
    if (this._tlsMinVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsMinVersion = this._tlsMinVersion;
    }
    if (this._tlsPrivateKeyFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsPrivateKeyFile = this._tlsPrivateKeyFile;
    }
    if (this._useServiceAccountCredentials !== undefined) {
      hasAnyValues = true;
      internalValueResult.useServiceAccountCredentials = this._useServiceAccountCredentials;
    }
    if (this._leaderElection?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.leaderElection = this._leaderElection?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterKubeControllerManager | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._allocateNodeCidrs = undefined;
      this._attachDetachReconcileSyncPeriod = undefined;
      this._authenticationKubeconfig = undefined;
      this._authorizationAlwaysAllowPaths = undefined;
      this._authorizationKubeconfig = undefined;
      this._cidrAllocatorType = undefined;
      this._cloudProvider = undefined;
      this._clusterCidr = undefined;
      this._clusterName = undefined;
      this._concurrentDeploymentSyncs = undefined;
      this._concurrentEndpointSyncs = undefined;
      this._concurrentNamespaceSyncs = undefined;
      this._concurrentRcSyncs = undefined;
      this._concurrentReplicasetSyncs = undefined;
      this._concurrentResourceQuotaSyncs = undefined;
      this._concurrentServiceSyncs = undefined;
      this._concurrentServiceaccountTokenSyncs = undefined;
      this._configureCloudRoutes = undefined;
      this._controllers = undefined;
      this._disableAttachDetachReconcileSync = undefined;
      this._enableLeaderMigration = undefined;
      this._enableProfiling = undefined;
      this._experimentalClusterSigningDuration = undefined;
      this._externalCloudVolumePlugin = undefined;
      this._featureGates = undefined;
      this._horizontalPodAutoscalerCpuInitializationPeriod = undefined;
      this._horizontalPodAutoscalerDownscaleDelay = undefined;
      this._horizontalPodAutoscalerDownscaleStabilization = undefined;
      this._horizontalPodAutoscalerInitialReadinessDelay = undefined;
      this._horizontalPodAutoscalerSyncPeriod = undefined;
      this._horizontalPodAutoscalerTolerance = undefined;
      this._horizontalPodAutoscalerUpscaleDelay = undefined;
      this._horizontalPodAutoscalerUseRestClients = undefined;
      this._image = undefined;
      this._kubeApiBurst = undefined;
      this._kubeApiQps = undefined;
      this._logFormat = undefined;
      this._logLevel = undefined;
      this._master = undefined;
      this._minResyncPeriod = undefined;
      this._nodeCidrMaskSize = undefined;
      this._nodeMonitorGracePeriod = undefined;
      this._nodeMonitorPeriod = undefined;
      this._podEvictionTimeout = undefined;
      this._rootCaFile = undefined;
      this._serviceAccountPrivateKeyFile = undefined;
      this._terminatedPodGcThreshold = undefined;
      this._tlsCertFile = undefined;
      this._tlsCipherSuites = undefined;
      this._tlsMinVersion = undefined;
      this._tlsPrivateKeyFile = undefined;
      this._useServiceAccountCredentials = undefined;
      this._leaderElection.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._allocateNodeCidrs = value.allocateNodeCidrs;
      this._attachDetachReconcileSyncPeriod = value.attachDetachReconcileSyncPeriod;
      this._authenticationKubeconfig = value.authenticationKubeconfig;
      this._authorizationAlwaysAllowPaths = value.authorizationAlwaysAllowPaths;
      this._authorizationKubeconfig = value.authorizationKubeconfig;
      this._cidrAllocatorType = value.cidrAllocatorType;
      this._cloudProvider = value.cloudProvider;
      this._clusterCidr = value.clusterCidr;
      this._clusterName = value.clusterName;
      this._concurrentDeploymentSyncs = value.concurrentDeploymentSyncs;
      this._concurrentEndpointSyncs = value.concurrentEndpointSyncs;
      this._concurrentNamespaceSyncs = value.concurrentNamespaceSyncs;
      this._concurrentRcSyncs = value.concurrentRcSyncs;
      this._concurrentReplicasetSyncs = value.concurrentReplicasetSyncs;
      this._concurrentResourceQuotaSyncs = value.concurrentResourceQuotaSyncs;
      this._concurrentServiceSyncs = value.concurrentServiceSyncs;
      this._concurrentServiceaccountTokenSyncs = value.concurrentServiceaccountTokenSyncs;
      this._configureCloudRoutes = value.configureCloudRoutes;
      this._controllers = value.controllers;
      this._disableAttachDetachReconcileSync = value.disableAttachDetachReconcileSync;
      this._enableLeaderMigration = value.enableLeaderMigration;
      this._enableProfiling = value.enableProfiling;
      this._experimentalClusterSigningDuration = value.experimentalClusterSigningDuration;
      this._externalCloudVolumePlugin = value.externalCloudVolumePlugin;
      this._featureGates = value.featureGates;
      this._horizontalPodAutoscalerCpuInitializationPeriod = value.horizontalPodAutoscalerCpuInitializationPeriod;
      this._horizontalPodAutoscalerDownscaleDelay = value.horizontalPodAutoscalerDownscaleDelay;
      this._horizontalPodAutoscalerDownscaleStabilization = value.horizontalPodAutoscalerDownscaleStabilization;
      this._horizontalPodAutoscalerInitialReadinessDelay = value.horizontalPodAutoscalerInitialReadinessDelay;
      this._horizontalPodAutoscalerSyncPeriod = value.horizontalPodAutoscalerSyncPeriod;
      this._horizontalPodAutoscalerTolerance = value.horizontalPodAutoscalerTolerance;
      this._horizontalPodAutoscalerUpscaleDelay = value.horizontalPodAutoscalerUpscaleDelay;
      this._horizontalPodAutoscalerUseRestClients = value.horizontalPodAutoscalerUseRestClients;
      this._image = value.image;
      this._kubeApiBurst = value.kubeApiBurst;
      this._kubeApiQps = value.kubeApiQps;
      this._logFormat = value.logFormat;
      this._logLevel = value.logLevel;
      this._master = value.master;
      this._minResyncPeriod = value.minResyncPeriod;
      this._nodeCidrMaskSize = value.nodeCidrMaskSize;
      this._nodeMonitorGracePeriod = value.nodeMonitorGracePeriod;
      this._nodeMonitorPeriod = value.nodeMonitorPeriod;
      this._podEvictionTimeout = value.podEvictionTimeout;
      this._rootCaFile = value.rootCaFile;
      this._serviceAccountPrivateKeyFile = value.serviceAccountPrivateKeyFile;
      this._terminatedPodGcThreshold = value.terminatedPodGcThreshold;
      this._tlsCertFile = value.tlsCertFile;
      this._tlsCipherSuites = value.tlsCipherSuites;
      this._tlsMinVersion = value.tlsMinVersion;
      this._tlsPrivateKeyFile = value.tlsPrivateKeyFile;
      this._useServiceAccountCredentials = value.useServiceAccountCredentials;
      this._leaderElection.internalValue = value.leaderElection;
    }
  }

  // allocate_node_cidrs - computed: false, optional: true, required: false
  private _allocateNodeCidrs?: boolean | cdktf.IResolvable; 
  public get allocateNodeCidrs() {
    return this.getBooleanAttribute('allocate_node_cidrs');
  }
  public set allocateNodeCidrs(value: boolean | cdktf.IResolvable) {
    this._allocateNodeCidrs = value;
  }
  public resetAllocateNodeCidrs() {
    this._allocateNodeCidrs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allocateNodeCidrsInput() {
    return this._allocateNodeCidrs;
  }

  // attach_detach_reconcile_sync_period - computed: false, optional: true, required: false
  private _attachDetachReconcileSyncPeriod?: string; 
  public get attachDetachReconcileSyncPeriod() {
    return this.getStringAttribute('attach_detach_reconcile_sync_period');
  }
  public set attachDetachReconcileSyncPeriod(value: string) {
    this._attachDetachReconcileSyncPeriod = value;
  }
  public resetAttachDetachReconcileSyncPeriod() {
    this._attachDetachReconcileSyncPeriod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get attachDetachReconcileSyncPeriodInput() {
    return this._attachDetachReconcileSyncPeriod;
  }

  // authentication_kubeconfig - computed: false, optional: true, required: false
  private _authenticationKubeconfig?: string; 
  public get authenticationKubeconfig() {
    return this.getStringAttribute('authentication_kubeconfig');
  }
  public set authenticationKubeconfig(value: string) {
    this._authenticationKubeconfig = value;
  }
  public resetAuthenticationKubeconfig() {
    this._authenticationKubeconfig = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authenticationKubeconfigInput() {
    return this._authenticationKubeconfig;
  }

  // authorization_always_allow_paths - computed: false, optional: true, required: false
  private _authorizationAlwaysAllowPaths?: string[]; 
  public get authorizationAlwaysAllowPaths() {
    return this.getListAttribute('authorization_always_allow_paths');
  }
  public set authorizationAlwaysAllowPaths(value: string[]) {
    this._authorizationAlwaysAllowPaths = value;
  }
  public resetAuthorizationAlwaysAllowPaths() {
    this._authorizationAlwaysAllowPaths = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authorizationAlwaysAllowPathsInput() {
    return this._authorizationAlwaysAllowPaths;
  }

  // authorization_kubeconfig - computed: false, optional: true, required: false
  private _authorizationKubeconfig?: string; 
  public get authorizationKubeconfig() {
    return this.getStringAttribute('authorization_kubeconfig');
  }
  public set authorizationKubeconfig(value: string) {
    this._authorizationKubeconfig = value;
  }
  public resetAuthorizationKubeconfig() {
    this._authorizationKubeconfig = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authorizationKubeconfigInput() {
    return this._authorizationKubeconfig;
  }

  // cidr_allocator_type - computed: false, optional: true, required: false
  private _cidrAllocatorType?: string; 
  public get cidrAllocatorType() {
    return this.getStringAttribute('cidr_allocator_type');
  }
  public set cidrAllocatorType(value: string) {
    this._cidrAllocatorType = value;
  }
  public resetCidrAllocatorType() {
    this._cidrAllocatorType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cidrAllocatorTypeInput() {
    return this._cidrAllocatorType;
  }

  // cloud_provider - computed: false, optional: true, required: false
  private _cloudProvider?: string; 
  public get cloudProvider() {
    return this.getStringAttribute('cloud_provider');
  }
  public set cloudProvider(value: string) {
    this._cloudProvider = value;
  }
  public resetCloudProvider() {
    this._cloudProvider = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cloudProviderInput() {
    return this._cloudProvider;
  }

  // cluster_cidr - computed: false, optional: true, required: false
  private _clusterCidr?: string; 
  public get clusterCidr() {
    return this.getStringAttribute('cluster_cidr');
  }
  public set clusterCidr(value: string) {
    this._clusterCidr = value;
  }
  public resetClusterCidr() {
    this._clusterCidr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterCidrInput() {
    return this._clusterCidr;
  }

  // cluster_name - computed: false, optional: true, required: false
  private _clusterName?: string; 
  public get clusterName() {
    return this.getStringAttribute('cluster_name');
  }
  public set clusterName(value: string) {
    this._clusterName = value;
  }
  public resetClusterName() {
    this._clusterName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterNameInput() {
    return this._clusterName;
  }

  // concurrent_deployment_syncs - computed: false, optional: true, required: false
  private _concurrentDeploymentSyncs?: number; 
  public get concurrentDeploymentSyncs() {
    return this.getNumberAttribute('concurrent_deployment_syncs');
  }
  public set concurrentDeploymentSyncs(value: number) {
    this._concurrentDeploymentSyncs = value;
  }
  public resetConcurrentDeploymentSyncs() {
    this._concurrentDeploymentSyncs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrentDeploymentSyncsInput() {
    return this._concurrentDeploymentSyncs;
  }

  // concurrent_endpoint_syncs - computed: false, optional: true, required: false
  private _concurrentEndpointSyncs?: number; 
  public get concurrentEndpointSyncs() {
    return this.getNumberAttribute('concurrent_endpoint_syncs');
  }
  public set concurrentEndpointSyncs(value: number) {
    this._concurrentEndpointSyncs = value;
  }
  public resetConcurrentEndpointSyncs() {
    this._concurrentEndpointSyncs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrentEndpointSyncsInput() {
    return this._concurrentEndpointSyncs;
  }

  // concurrent_namespace_syncs - computed: false, optional: true, required: false
  private _concurrentNamespaceSyncs?: number; 
  public get concurrentNamespaceSyncs() {
    return this.getNumberAttribute('concurrent_namespace_syncs');
  }
  public set concurrentNamespaceSyncs(value: number) {
    this._concurrentNamespaceSyncs = value;
  }
  public resetConcurrentNamespaceSyncs() {
    this._concurrentNamespaceSyncs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrentNamespaceSyncsInput() {
    return this._concurrentNamespaceSyncs;
  }

  // concurrent_rc_syncs - computed: false, optional: true, required: false
  private _concurrentRcSyncs?: number; 
  public get concurrentRcSyncs() {
    return this.getNumberAttribute('concurrent_rc_syncs');
  }
  public set concurrentRcSyncs(value: number) {
    this._concurrentRcSyncs = value;
  }
  public resetConcurrentRcSyncs() {
    this._concurrentRcSyncs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrentRcSyncsInput() {
    return this._concurrentRcSyncs;
  }

  // concurrent_replicaset_syncs - computed: false, optional: true, required: false
  private _concurrentReplicasetSyncs?: number; 
  public get concurrentReplicasetSyncs() {
    return this.getNumberAttribute('concurrent_replicaset_syncs');
  }
  public set concurrentReplicasetSyncs(value: number) {
    this._concurrentReplicasetSyncs = value;
  }
  public resetConcurrentReplicasetSyncs() {
    this._concurrentReplicasetSyncs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrentReplicasetSyncsInput() {
    return this._concurrentReplicasetSyncs;
  }

  // concurrent_resource_quota_syncs - computed: false, optional: true, required: false
  private _concurrentResourceQuotaSyncs?: number; 
  public get concurrentResourceQuotaSyncs() {
    return this.getNumberAttribute('concurrent_resource_quota_syncs');
  }
  public set concurrentResourceQuotaSyncs(value: number) {
    this._concurrentResourceQuotaSyncs = value;
  }
  public resetConcurrentResourceQuotaSyncs() {
    this._concurrentResourceQuotaSyncs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrentResourceQuotaSyncsInput() {
    return this._concurrentResourceQuotaSyncs;
  }

  // concurrent_service_syncs - computed: false, optional: true, required: false
  private _concurrentServiceSyncs?: number; 
  public get concurrentServiceSyncs() {
    return this.getNumberAttribute('concurrent_service_syncs');
  }
  public set concurrentServiceSyncs(value: number) {
    this._concurrentServiceSyncs = value;
  }
  public resetConcurrentServiceSyncs() {
    this._concurrentServiceSyncs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrentServiceSyncsInput() {
    return this._concurrentServiceSyncs;
  }

  // concurrent_serviceaccount_token_syncs - computed: false, optional: true, required: false
  private _concurrentServiceaccountTokenSyncs?: number; 
  public get concurrentServiceaccountTokenSyncs() {
    return this.getNumberAttribute('concurrent_serviceaccount_token_syncs');
  }
  public set concurrentServiceaccountTokenSyncs(value: number) {
    this._concurrentServiceaccountTokenSyncs = value;
  }
  public resetConcurrentServiceaccountTokenSyncs() {
    this._concurrentServiceaccountTokenSyncs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrentServiceaccountTokenSyncsInput() {
    return this._concurrentServiceaccountTokenSyncs;
  }

  // configure_cloud_routes - computed: false, optional: true, required: false
  private _configureCloudRoutes?: boolean | cdktf.IResolvable; 
  public get configureCloudRoutes() {
    return this.getBooleanAttribute('configure_cloud_routes');
  }
  public set configureCloudRoutes(value: boolean | cdktf.IResolvable) {
    this._configureCloudRoutes = value;
  }
  public resetConfigureCloudRoutes() {
    this._configureCloudRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configureCloudRoutesInput() {
    return this._configureCloudRoutes;
  }

  // controllers - computed: false, optional: true, required: false
  private _controllers?: string[]; 
  public get controllers() {
    return this.getListAttribute('controllers');
  }
  public set controllers(value: string[]) {
    this._controllers = value;
  }
  public resetControllers() {
    this._controllers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get controllersInput() {
    return this._controllers;
  }

  // disable_attach_detach_reconcile_sync - computed: false, optional: true, required: false
  private _disableAttachDetachReconcileSync?: boolean | cdktf.IResolvable; 
  public get disableAttachDetachReconcileSync() {
    return this.getBooleanAttribute('disable_attach_detach_reconcile_sync');
  }
  public set disableAttachDetachReconcileSync(value: boolean | cdktf.IResolvable) {
    this._disableAttachDetachReconcileSync = value;
  }
  public resetDisableAttachDetachReconcileSync() {
    this._disableAttachDetachReconcileSync = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableAttachDetachReconcileSyncInput() {
    return this._disableAttachDetachReconcileSync;
  }

  // enable_leader_migration - computed: false, optional: true, required: false
  private _enableLeaderMigration?: boolean | cdktf.IResolvable; 
  public get enableLeaderMigration() {
    return this.getBooleanAttribute('enable_leader_migration');
  }
  public set enableLeaderMigration(value: boolean | cdktf.IResolvable) {
    this._enableLeaderMigration = value;
  }
  public resetEnableLeaderMigration() {
    this._enableLeaderMigration = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableLeaderMigrationInput() {
    return this._enableLeaderMigration;
  }

  // enable_profiling - computed: false, optional: true, required: false
  private _enableProfiling?: boolean | cdktf.IResolvable; 
  public get enableProfiling() {
    return this.getBooleanAttribute('enable_profiling');
  }
  public set enableProfiling(value: boolean | cdktf.IResolvable) {
    this._enableProfiling = value;
  }
  public resetEnableProfiling() {
    this._enableProfiling = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableProfilingInput() {
    return this._enableProfiling;
  }

  // experimental_cluster_signing_duration - computed: false, optional: true, required: false
  private _experimentalClusterSigningDuration?: string; 
  public get experimentalClusterSigningDuration() {
    return this.getStringAttribute('experimental_cluster_signing_duration');
  }
  public set experimentalClusterSigningDuration(value: string) {
    this._experimentalClusterSigningDuration = value;
  }
  public resetExperimentalClusterSigningDuration() {
    this._experimentalClusterSigningDuration = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get experimentalClusterSigningDurationInput() {
    return this._experimentalClusterSigningDuration;
  }

  // external_cloud_volume_plugin - computed: false, optional: true, required: false
  private _externalCloudVolumePlugin?: string; 
  public get externalCloudVolumePlugin() {
    return this.getStringAttribute('external_cloud_volume_plugin');
  }
  public set externalCloudVolumePlugin(value: string) {
    this._externalCloudVolumePlugin = value;
  }
  public resetExternalCloudVolumePlugin() {
    this._externalCloudVolumePlugin = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get externalCloudVolumePluginInput() {
    return this._externalCloudVolumePlugin;
  }

  // feature_gates - computed: false, optional: true, required: false
  private _featureGates?: { [key: string]: string }; 
  public get featureGates() {
    return this.getStringMapAttribute('feature_gates');
  }
  public set featureGates(value: { [key: string]: string }) {
    this._featureGates = value;
  }
  public resetFeatureGates() {
    this._featureGates = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get featureGatesInput() {
    return this._featureGates;
  }

  // horizontal_pod_autoscaler_cpu_initialization_period - computed: false, optional: true, required: false
  private _horizontalPodAutoscalerCpuInitializationPeriod?: string; 
  public get horizontalPodAutoscalerCpuInitializationPeriod() {
    return this.getStringAttribute('horizontal_pod_autoscaler_cpu_initialization_period');
  }
  public set horizontalPodAutoscalerCpuInitializationPeriod(value: string) {
    this._horizontalPodAutoscalerCpuInitializationPeriod = value;
  }
  public resetHorizontalPodAutoscalerCpuInitializationPeriod() {
    this._horizontalPodAutoscalerCpuInitializationPeriod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get horizontalPodAutoscalerCpuInitializationPeriodInput() {
    return this._horizontalPodAutoscalerCpuInitializationPeriod;
  }

  // horizontal_pod_autoscaler_downscale_delay - computed: false, optional: true, required: false
  private _horizontalPodAutoscalerDownscaleDelay?: string; 
  public get horizontalPodAutoscalerDownscaleDelay() {
    return this.getStringAttribute('horizontal_pod_autoscaler_downscale_delay');
  }
  public set horizontalPodAutoscalerDownscaleDelay(value: string) {
    this._horizontalPodAutoscalerDownscaleDelay = value;
  }
  public resetHorizontalPodAutoscalerDownscaleDelay() {
    this._horizontalPodAutoscalerDownscaleDelay = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get horizontalPodAutoscalerDownscaleDelayInput() {
    return this._horizontalPodAutoscalerDownscaleDelay;
  }

  // horizontal_pod_autoscaler_downscale_stabilization - computed: false, optional: true, required: false
  private _horizontalPodAutoscalerDownscaleStabilization?: string; 
  public get horizontalPodAutoscalerDownscaleStabilization() {
    return this.getStringAttribute('horizontal_pod_autoscaler_downscale_stabilization');
  }
  public set horizontalPodAutoscalerDownscaleStabilization(value: string) {
    this._horizontalPodAutoscalerDownscaleStabilization = value;
  }
  public resetHorizontalPodAutoscalerDownscaleStabilization() {
    this._horizontalPodAutoscalerDownscaleStabilization = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get horizontalPodAutoscalerDownscaleStabilizationInput() {
    return this._horizontalPodAutoscalerDownscaleStabilization;
  }

  // horizontal_pod_autoscaler_initial_readiness_delay - computed: false, optional: true, required: false
  private _horizontalPodAutoscalerInitialReadinessDelay?: string; 
  public get horizontalPodAutoscalerInitialReadinessDelay() {
    return this.getStringAttribute('horizontal_pod_autoscaler_initial_readiness_delay');
  }
  public set horizontalPodAutoscalerInitialReadinessDelay(value: string) {
    this._horizontalPodAutoscalerInitialReadinessDelay = value;
  }
  public resetHorizontalPodAutoscalerInitialReadinessDelay() {
    this._horizontalPodAutoscalerInitialReadinessDelay = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get horizontalPodAutoscalerInitialReadinessDelayInput() {
    return this._horizontalPodAutoscalerInitialReadinessDelay;
  }

  // horizontal_pod_autoscaler_sync_period - computed: false, optional: true, required: false
  private _horizontalPodAutoscalerSyncPeriod?: string; 
  public get horizontalPodAutoscalerSyncPeriod() {
    return this.getStringAttribute('horizontal_pod_autoscaler_sync_period');
  }
  public set horizontalPodAutoscalerSyncPeriod(value: string) {
    this._horizontalPodAutoscalerSyncPeriod = value;
  }
  public resetHorizontalPodAutoscalerSyncPeriod() {
    this._horizontalPodAutoscalerSyncPeriod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get horizontalPodAutoscalerSyncPeriodInput() {
    return this._horizontalPodAutoscalerSyncPeriod;
  }

  // horizontal_pod_autoscaler_tolerance - computed: false, optional: true, required: false
  private _horizontalPodAutoscalerTolerance?: string; 
  public get horizontalPodAutoscalerTolerance() {
    return this.getStringAttribute('horizontal_pod_autoscaler_tolerance');
  }
  public set horizontalPodAutoscalerTolerance(value: string) {
    this._horizontalPodAutoscalerTolerance = value;
  }
  public resetHorizontalPodAutoscalerTolerance() {
    this._horizontalPodAutoscalerTolerance = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get horizontalPodAutoscalerToleranceInput() {
    return this._horizontalPodAutoscalerTolerance;
  }

  // horizontal_pod_autoscaler_upscale_delay - computed: false, optional: true, required: false
  private _horizontalPodAutoscalerUpscaleDelay?: string; 
  public get horizontalPodAutoscalerUpscaleDelay() {
    return this.getStringAttribute('horizontal_pod_autoscaler_upscale_delay');
  }
  public set horizontalPodAutoscalerUpscaleDelay(value: string) {
    this._horizontalPodAutoscalerUpscaleDelay = value;
  }
  public resetHorizontalPodAutoscalerUpscaleDelay() {
    this._horizontalPodAutoscalerUpscaleDelay = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get horizontalPodAutoscalerUpscaleDelayInput() {
    return this._horizontalPodAutoscalerUpscaleDelay;
  }

  // horizontal_pod_autoscaler_use_rest_clients - computed: false, optional: true, required: false
  private _horizontalPodAutoscalerUseRestClients?: boolean | cdktf.IResolvable; 
  public get horizontalPodAutoscalerUseRestClients() {
    return this.getBooleanAttribute('horizontal_pod_autoscaler_use_rest_clients');
  }
  public set horizontalPodAutoscalerUseRestClients(value: boolean | cdktf.IResolvable) {
    this._horizontalPodAutoscalerUseRestClients = value;
  }
  public resetHorizontalPodAutoscalerUseRestClients() {
    this._horizontalPodAutoscalerUseRestClients = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get horizontalPodAutoscalerUseRestClientsInput() {
    return this._horizontalPodAutoscalerUseRestClients;
  }

  // image - computed: false, optional: true, required: false
  private _image?: string; 
  public get image() {
    return this.getStringAttribute('image');
  }
  public set image(value: string) {
    this._image = value;
  }
  public resetImage() {
    this._image = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageInput() {
    return this._image;
  }

  // kube_api_burst - computed: false, optional: true, required: false
  private _kubeApiBurst?: number; 
  public get kubeApiBurst() {
    return this.getNumberAttribute('kube_api_burst');
  }
  public set kubeApiBurst(value: number) {
    this._kubeApiBurst = value;
  }
  public resetKubeApiBurst() {
    this._kubeApiBurst = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeApiBurstInput() {
    return this._kubeApiBurst;
  }

  // kube_api_qps - computed: false, optional: true, required: false
  private _kubeApiQps?: string; 
  public get kubeApiQps() {
    return this.getStringAttribute('kube_api_qps');
  }
  public set kubeApiQps(value: string) {
    this._kubeApiQps = value;
  }
  public resetKubeApiQps() {
    this._kubeApiQps = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeApiQpsInput() {
    return this._kubeApiQps;
  }

  // log_format - computed: false, optional: true, required: false
  private _logFormat?: string; 
  public get logFormat() {
    return this.getStringAttribute('log_format');
  }
  public set logFormat(value: string) {
    this._logFormat = value;
  }
  public resetLogFormat() {
    this._logFormat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logFormatInput() {
    return this._logFormat;
  }

  // log_level - computed: false, optional: true, required: false
  private _logLevel?: number; 
  public get logLevel() {
    return this.getNumberAttribute('log_level');
  }
  public set logLevel(value: number) {
    this._logLevel = value;
  }
  public resetLogLevel() {
    this._logLevel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logLevelInput() {
    return this._logLevel;
  }

  // master - computed: false, optional: true, required: false
  private _master?: string; 
  public get master() {
    return this.getStringAttribute('master');
  }
  public set master(value: string) {
    this._master = value;
  }
  public resetMaster() {
    this._master = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get masterInput() {
    return this._master;
  }

  // min_resync_period - computed: false, optional: true, required: false
  private _minResyncPeriod?: string; 
  public get minResyncPeriod() {
    return this.getStringAttribute('min_resync_period');
  }
  public set minResyncPeriod(value: string) {
    this._minResyncPeriod = value;
  }
  public resetMinResyncPeriod() {
    this._minResyncPeriod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minResyncPeriodInput() {
    return this._minResyncPeriod;
  }

  // node_cidr_mask_size - computed: false, optional: true, required: false
  private _nodeCidrMaskSize?: number; 
  public get nodeCidrMaskSize() {
    return this.getNumberAttribute('node_cidr_mask_size');
  }
  public set nodeCidrMaskSize(value: number) {
    this._nodeCidrMaskSize = value;
  }
  public resetNodeCidrMaskSize() {
    this._nodeCidrMaskSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeCidrMaskSizeInput() {
    return this._nodeCidrMaskSize;
  }

  // node_monitor_grace_period - computed: false, optional: true, required: false
  private _nodeMonitorGracePeriod?: string; 
  public get nodeMonitorGracePeriod() {
    return this.getStringAttribute('node_monitor_grace_period');
  }
  public set nodeMonitorGracePeriod(value: string) {
    this._nodeMonitorGracePeriod = value;
  }
  public resetNodeMonitorGracePeriod() {
    this._nodeMonitorGracePeriod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeMonitorGracePeriodInput() {
    return this._nodeMonitorGracePeriod;
  }

  // node_monitor_period - computed: false, optional: true, required: false
  private _nodeMonitorPeriod?: string; 
  public get nodeMonitorPeriod() {
    return this.getStringAttribute('node_monitor_period');
  }
  public set nodeMonitorPeriod(value: string) {
    this._nodeMonitorPeriod = value;
  }
  public resetNodeMonitorPeriod() {
    this._nodeMonitorPeriod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeMonitorPeriodInput() {
    return this._nodeMonitorPeriod;
  }

  // pod_eviction_timeout - computed: false, optional: true, required: false
  private _podEvictionTimeout?: string; 
  public get podEvictionTimeout() {
    return this.getStringAttribute('pod_eviction_timeout');
  }
  public set podEvictionTimeout(value: string) {
    this._podEvictionTimeout = value;
  }
  public resetPodEvictionTimeout() {
    this._podEvictionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podEvictionTimeoutInput() {
    return this._podEvictionTimeout;
  }

  // root_ca_file - computed: false, optional: true, required: false
  private _rootCaFile?: string; 
  public get rootCaFile() {
    return this.getStringAttribute('root_ca_file');
  }
  public set rootCaFile(value: string) {
    this._rootCaFile = value;
  }
  public resetRootCaFile() {
    this._rootCaFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rootCaFileInput() {
    return this._rootCaFile;
  }

  // service_account_private_key_file - computed: false, optional: true, required: false
  private _serviceAccountPrivateKeyFile?: string; 
  public get serviceAccountPrivateKeyFile() {
    return this.getStringAttribute('service_account_private_key_file');
  }
  public set serviceAccountPrivateKeyFile(value: string) {
    this._serviceAccountPrivateKeyFile = value;
  }
  public resetServiceAccountPrivateKeyFile() {
    this._serviceAccountPrivateKeyFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountPrivateKeyFileInput() {
    return this._serviceAccountPrivateKeyFile;
  }

  // terminated_pod_gc_threshold - computed: false, optional: true, required: false
  private _terminatedPodGcThreshold?: number; 
  public get terminatedPodGcThreshold() {
    return this.getNumberAttribute('terminated_pod_gc_threshold');
  }
  public set terminatedPodGcThreshold(value: number) {
    this._terminatedPodGcThreshold = value;
  }
  public resetTerminatedPodGcThreshold() {
    this._terminatedPodGcThreshold = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get terminatedPodGcThresholdInput() {
    return this._terminatedPodGcThreshold;
  }

  // tls_cert_file - computed: false, optional: true, required: false
  private _tlsCertFile?: string; 
  public get tlsCertFile() {
    return this.getStringAttribute('tls_cert_file');
  }
  public set tlsCertFile(value: string) {
    this._tlsCertFile = value;
  }
  public resetTlsCertFile() {
    this._tlsCertFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsCertFileInput() {
    return this._tlsCertFile;
  }

  // tls_cipher_suites - computed: false, optional: true, required: false
  private _tlsCipherSuites?: string[]; 
  public get tlsCipherSuites() {
    return this.getListAttribute('tls_cipher_suites');
  }
  public set tlsCipherSuites(value: string[]) {
    this._tlsCipherSuites = value;
  }
  public resetTlsCipherSuites() {
    this._tlsCipherSuites = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsCipherSuitesInput() {
    return this._tlsCipherSuites;
  }

  // tls_min_version - computed: false, optional: true, required: false
  private _tlsMinVersion?: string; 
  public get tlsMinVersion() {
    return this.getStringAttribute('tls_min_version');
  }
  public set tlsMinVersion(value: string) {
    this._tlsMinVersion = value;
  }
  public resetTlsMinVersion() {
    this._tlsMinVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsMinVersionInput() {
    return this._tlsMinVersion;
  }

  // tls_private_key_file - computed: false, optional: true, required: false
  private _tlsPrivateKeyFile?: string; 
  public get tlsPrivateKeyFile() {
    return this.getStringAttribute('tls_private_key_file');
  }
  public set tlsPrivateKeyFile(value: string) {
    this._tlsPrivateKeyFile = value;
  }
  public resetTlsPrivateKeyFile() {
    this._tlsPrivateKeyFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsPrivateKeyFileInput() {
    return this._tlsPrivateKeyFile;
  }

  // use_service_account_credentials - computed: false, optional: true, required: false
  private _useServiceAccountCredentials?: boolean | cdktf.IResolvable; 
  public get useServiceAccountCredentials() {
    return this.getBooleanAttribute('use_service_account_credentials');
  }
  public set useServiceAccountCredentials(value: boolean | cdktf.IResolvable) {
    this._useServiceAccountCredentials = value;
  }
  public resetUseServiceAccountCredentials() {
    this._useServiceAccountCredentials = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useServiceAccountCredentialsInput() {
    return this._useServiceAccountCredentials;
  }

  // leader_election - computed: false, optional: true, required: false
  private _leaderElection = new ClusterKubeControllerManagerLeaderElectionOutputReference(this, "leader_election");
  public get leaderElection() {
    return this._leaderElection;
  }
  public putLeaderElection(value: ClusterKubeControllerManagerLeaderElection) {
    this._leaderElection.internalValue = value;
  }
  public resetLeaderElection() {
    this._leaderElection.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get leaderElectionInput() {
    return this._leaderElection.internalValue;
  }
}
export interface ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#key Cluster#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#operator Cluster#operator}
  */
  readonly operator?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#values Cluster#values}
  */
  readonly values?: string[];
}

export function clusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsToTerraform(struct?: ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function clusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsToHclTerraform(struct?: ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutputReference {
    return new ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#key Cluster#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#operator Cluster#operator}
  */
  readonly operator?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#values Cluster#values}
  */
  readonly values?: string[];
}

export function clusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsToTerraform(struct?: ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function clusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsToHclTerraform(struct?: ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsList extends cdktf.ComplexList {
  public internalValue? : ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutputReference {
    return new ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
  * match_expressions block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#match_expressions Cluster#match_expressions}
  */
  readonly matchExpressions?: ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[] | cdktf.IResolvable;
  /**
  * match_fields block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#match_fields Cluster#match_fields}
  */
  readonly matchFields?: ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[] | cdktf.IResolvable;
}

export function clusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceToTerraform(struct?: ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutputReference | ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(clusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsToTerraform, true)(struct!.matchExpressions),
    match_fields: cdktf.listMapper(clusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsToTerraform, true)(struct!.matchFields),
  }
}


export function clusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceToHclTerraform(struct?: ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutputReference | ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(clusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsToHclTerraform, true)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsList",
    },
    match_fields: {
      value: cdktf.listMapperHcl(clusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsToHclTerraform, true)(struct!.matchFields),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchFields?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchFields = this._matchFields?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._matchExpressions.internalValue = undefined;
      this._matchFields.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchFields.internalValue = value.matchFields;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_fields - computed: false, optional: true, required: false
  private _matchFields = new ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsList(this, "match_fields", false);
  public get matchFields() {
    return this._matchFields;
  }
  public putMatchFields(value: ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[] | cdktf.IResolvable) {
    this._matchFields.internalValue = value;
  }
  public resetMatchFields() {
    this._matchFields.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchFieldsInput() {
    return this._matchFields.internalValue;
  }
}
export interface ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#weight Cluster#weight}
  */
  readonly weight?: number;
  /**
  * preference block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#preference Cluster#preference}
  */
  readonly preference?: ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
}

export function clusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionToTerraform(struct?: ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    weight: cdktf.numberToTerraform(struct!.weight),
    preference: clusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceToTerraform(struct!.preference),
  }
}


export function clusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionToHclTerraform(struct?: ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    weight: {
      value: cdktf.numberToHclTerraform(struct!.weight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    preference: {
      value: clusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceToHclTerraform(struct!.preference),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._weight !== undefined) {
      hasAnyValues = true;
      internalValueResult.weight = this._weight;
    }
    if (this._preference?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.preference = this._preference?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._weight = undefined;
      this._preference.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._weight = value.weight;
      this._preference.internalValue = value.preference;
    }
  }

  // weight - computed: false, optional: true, required: false
  private _weight?: number; 
  public get weight() {
    return this.getNumberAttribute('weight');
  }
  public set weight(value: number) {
    this._weight = value;
  }
  public resetWeight() {
    this._weight = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get weightInput() {
    return this._weight;
  }

  // preference - computed: false, optional: true, required: false
  private _preference = new ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutputReference(this, "preference");
  public get preference() {
    return this._preference;
  }
  public putPreference(value: ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference) {
    this._preference.internalValue = value;
  }
  public resetPreference() {
    this._preference.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preferenceInput() {
    return this._preference.internalValue;
  }
}

export class ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionList extends cdktf.ComplexList {
  public internalValue? : ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference {
    return new ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#key Cluster#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#operator Cluster#operator}
  */
  readonly operator?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#values Cluster#values}
  */
  readonly values?: string[];
}

export function clusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsToTerraform(struct?: ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function clusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsToHclTerraform(struct?: ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutputReference {
    return new ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#key Cluster#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#operator Cluster#operator}
  */
  readonly operator?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#values Cluster#values}
  */
  readonly values?: string[];
}

export function clusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsToTerraform(struct?: ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function clusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsToHclTerraform(struct?: ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsList extends cdktf.ComplexList {
  public internalValue? : ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutputReference {
    return new ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
  * match_expressions block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#match_expressions Cluster#match_expressions}
  */
  readonly matchExpressions?: ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[] | cdktf.IResolvable;
  /**
  * match_fields block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#match_fields Cluster#match_fields}
  */
  readonly matchFields?: ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[] | cdktf.IResolvable;
}

export function clusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsToTerraform(struct?: ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(clusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsToTerraform, true)(struct!.matchExpressions),
    match_fields: cdktf.listMapper(clusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsToTerraform, true)(struct!.matchFields),
  }
}


export function clusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsToHclTerraform(struct?: ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(clusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsToHclTerraform, true)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsList",
    },
    match_fields: {
      value: cdktf.listMapperHcl(clusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsToHclTerraform, true)(struct!.matchFields),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchFields?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchFields = this._matchFields?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchFields.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchFields.internalValue = value.matchFields;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_fields - computed: false, optional: true, required: false
  private _matchFields = new ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsList(this, "match_fields", false);
  public get matchFields() {
    return this._matchFields;
  }
  public putMatchFields(value: ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[] | cdktf.IResolvable) {
    this._matchFields.internalValue = value;
  }
  public resetMatchFields() {
    this._matchFields.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchFieldsInput() {
    return this._matchFields.internalValue;
  }
}

export class ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsList extends cdktf.ComplexList {
  public internalValue? : ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutputReference {
    return new ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
  * node_selector_terms block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#node_selector_terms Cluster#node_selector_terms}
  */
  readonly nodeSelectorTerms?: ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[] | cdktf.IResolvable;
}

export function clusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionToTerraform(struct?: ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference | ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    node_selector_terms: cdktf.listMapper(clusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsToTerraform, true)(struct!.nodeSelectorTerms),
  }
}


export function clusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionToHclTerraform(struct?: ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference | ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    node_selector_terms: {
      value: cdktf.listMapperHcl(clusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsToHclTerraform, true)(struct!.nodeSelectorTerms),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._nodeSelectorTerms?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeSelectorTerms = this._nodeSelectorTerms?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._nodeSelectorTerms.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._nodeSelectorTerms.internalValue = value.nodeSelectorTerms;
    }
  }

  // node_selector_terms - computed: false, optional: true, required: false
  private _nodeSelectorTerms = new ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsList(this, "node_selector_terms", false);
  public get nodeSelectorTerms() {
    return this._nodeSelectorTerms;
  }
  public putNodeSelectorTerms(value: ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[] | cdktf.IResolvable) {
    this._nodeSelectorTerms.internalValue = value;
  }
  public resetNodeSelectorTerms() {
    this._nodeSelectorTerms.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeSelectorTermsInput() {
    return this._nodeSelectorTerms.internalValue;
  }
}
export interface ClusterKubeDnsAffinityNodeAffinity {
  /**
  * preferred_during_scheduling_ignored_during_execution block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#preferred_during_scheduling_ignored_during_execution Cluster#preferred_during_scheduling_ignored_during_execution}
  */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable;
  /**
  * required_during_scheduling_ignored_during_execution block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#required_during_scheduling_ignored_during_execution Cluster#required_during_scheduling_ignored_during_execution}
  */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export function clusterKubeDnsAffinityNodeAffinityToTerraform(struct?: ClusterKubeDnsAffinityNodeAffinityOutputReference | ClusterKubeDnsAffinityNodeAffinity): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    preferred_during_scheduling_ignored_during_execution: cdktf.listMapper(clusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionToTerraform, true)(struct!.preferredDuringSchedulingIgnoredDuringExecution),
    required_during_scheduling_ignored_during_execution: clusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionToTerraform(struct!.requiredDuringSchedulingIgnoredDuringExecution),
  }
}


export function clusterKubeDnsAffinityNodeAffinityToHclTerraform(struct?: ClusterKubeDnsAffinityNodeAffinityOutputReference | ClusterKubeDnsAffinityNodeAffinity): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    preferred_during_scheduling_ignored_during_execution: {
      value: cdktf.listMapperHcl(clusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionToHclTerraform, true)(struct!.preferredDuringSchedulingIgnoredDuringExecution),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionList",
    },
    required_during_scheduling_ignored_during_execution: {
      value: clusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionToHclTerraform(struct!.requiredDuringSchedulingIgnoredDuringExecution),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterKubeDnsAffinityNodeAffinityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterKubeDnsAffinityNodeAffinity | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._preferredDuringSchedulingIgnoredDuringExecution?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.preferredDuringSchedulingIgnoredDuringExecution = this._preferredDuringSchedulingIgnoredDuringExecution?.internalValue;
    }
    if (this._requiredDuringSchedulingIgnoredDuringExecution?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.requiredDuringSchedulingIgnoredDuringExecution = this._requiredDuringSchedulingIgnoredDuringExecution?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterKubeDnsAffinityNodeAffinity | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
      this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = value.preferredDuringSchedulingIgnoredDuringExecution;
      this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = value.requiredDuringSchedulingIgnoredDuringExecution;
    }
  }

  // preferred_during_scheduling_ignored_during_execution - computed: false, optional: true, required: false
  private _preferredDuringSchedulingIgnoredDuringExecution = new ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionList(this, "preferred_during_scheduling_ignored_during_execution", false);
  public get preferredDuringSchedulingIgnoredDuringExecution() {
    return this._preferredDuringSchedulingIgnoredDuringExecution;
  }
  public putPreferredDuringSchedulingIgnoredDuringExecution(value: ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable) {
    this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = value;
  }
  public resetPreferredDuringSchedulingIgnoredDuringExecution() {
    this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preferredDuringSchedulingIgnoredDuringExecutionInput() {
    return this._preferredDuringSchedulingIgnoredDuringExecution.internalValue;
  }

  // required_during_scheduling_ignored_during_execution - computed: false, optional: true, required: false
  private _requiredDuringSchedulingIgnoredDuringExecution = new ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference(this, "required_during_scheduling_ignored_during_execution");
  public get requiredDuringSchedulingIgnoredDuringExecution() {
    return this._requiredDuringSchedulingIgnoredDuringExecution;
  }
  public putRequiredDuringSchedulingIgnoredDuringExecution(value: ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution) {
    this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = value;
  }
  public resetRequiredDuringSchedulingIgnoredDuringExecution() {
    this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requiredDuringSchedulingIgnoredDuringExecutionInput() {
    return this._requiredDuringSchedulingIgnoredDuringExecution.internalValue;
  }
}
export interface ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#key Cluster#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#operator Cluster#operator}
  */
  readonly operator?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#values Cluster#values}
  */
  readonly values?: string[];
}

export function clusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToTerraform(struct?: ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function clusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToHclTerraform(struct?: ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference {
    return new ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#match_labels Cluster#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
  /**
  * match_expressions block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#match_expressions Cluster#match_expressions}
  */
  readonly matchExpressions?: ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[] | cdktf.IResolvable;
}

export function clusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToTerraform(struct?: ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputReference | ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
    match_expressions: cdktf.listMapper(clusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToTerraform, true)(struct!.matchExpressions),
  }
}


export function clusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToHclTerraform(struct?: ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputReference | ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    match_expressions: {
      value: cdktf.listMapperHcl(clusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToHclTerraform, true)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._matchLabels = undefined;
      this._matchExpressions.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._matchLabels = value.matchLabels;
      this._matchExpressions.internalValue = value.matchExpressions;
    }
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }
}
export interface ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#key Cluster#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#operator Cluster#operator}
  */
  readonly operator?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#values Cluster#values}
  */
  readonly values?: string[];
}

export function clusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToTerraform(struct?: ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function clusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToHclTerraform(struct?: ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputReference {
    return new ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#match_labels Cluster#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
  /**
  * match_expressions block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#match_expressions Cluster#match_expressions}
  */
  readonly matchExpressions?: ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[] | cdktf.IResolvable;
}

export function clusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToTerraform(struct?: ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputReference | ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
    match_expressions: cdktf.listMapper(clusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToTerraform, true)(struct!.matchExpressions),
  }
}


export function clusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToHclTerraform(struct?: ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputReference | ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    match_expressions: {
      value: cdktf.listMapperHcl(clusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToHclTerraform, true)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._matchLabels = undefined;
      this._matchExpressions.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._matchLabels = value.matchLabels;
      this._matchExpressions.internalValue = value.matchExpressions;
    }
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }
}
export interface ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#namespaces Cluster#namespaces}
  */
  readonly namespaces?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#topology_key Cluster#topology_key}
  */
  readonly topologyKey?: string;
  /**
  * label_selector block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#label_selector Cluster#label_selector}
  */
  readonly labelSelector?: ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
  /**
  * namespace_selector block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#namespace_selector Cluster#namespace_selector}
  */
  readonly namespaceSelector?: ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
}

export function clusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToTerraform(struct?: ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputReference | ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    namespaces: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.namespaces),
    topology_key: cdktf.stringToTerraform(struct!.topologyKey),
    label_selector: clusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToTerraform(struct!.labelSelector),
    namespace_selector: clusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToTerraform(struct!.namespaceSelector),
  }
}


export function clusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToHclTerraform(struct?: ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputReference | ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    namespaces: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.namespaces),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    topology_key: {
      value: cdktf.stringToHclTerraform(struct!.topologyKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_selector: {
      value: clusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToHclTerraform(struct!.labelSelector),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorList",
    },
    namespace_selector: {
      value: clusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToHclTerraform(struct!.namespaceSelector),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._namespaces !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaces = this._namespaces;
    }
    if (this._topologyKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.topologyKey = this._topologyKey;
    }
    if (this._labelSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSelector = this._labelSelector?.internalValue;
    }
    if (this._namespaceSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaceSelector = this._namespaceSelector?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._namespaces = undefined;
      this._topologyKey = undefined;
      this._labelSelector.internalValue = undefined;
      this._namespaceSelector.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._namespaces = value.namespaces;
      this._topologyKey = value.topologyKey;
      this._labelSelector.internalValue = value.labelSelector;
      this._namespaceSelector.internalValue = value.namespaceSelector;
    }
  }

  // namespaces - computed: false, optional: true, required: false
  private _namespaces?: string[]; 
  public get namespaces() {
    return this.getListAttribute('namespaces');
  }
  public set namespaces(value: string[]) {
    this._namespaces = value;
  }
  public resetNamespaces() {
    this._namespaces = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespacesInput() {
    return this._namespaces;
  }

  // topology_key - computed: false, optional: true, required: false
  private _topologyKey?: string; 
  public get topologyKey() {
    return this.getStringAttribute('topology_key');
  }
  public set topologyKey(value: string) {
    this._topologyKey = value;
  }
  public resetTopologyKey() {
    this._topologyKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get topologyKeyInput() {
    return this._topologyKey;
  }

  // label_selector - computed: false, optional: true, required: false
  private _labelSelector = new ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputReference(this, "label_selector");
  public get labelSelector() {
    return this._labelSelector;
  }
  public putLabelSelector(value: ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) {
    this._labelSelector.internalValue = value;
  }
  public resetLabelSelector() {
    this._labelSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSelectorInput() {
    return this._labelSelector.internalValue;
  }

  // namespace_selector - computed: false, optional: true, required: false
  private _namespaceSelector = new ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputReference(this, "namespace_selector");
  public get namespaceSelector() {
    return this._namespaceSelector;
  }
  public putNamespaceSelector(value: ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) {
    this._namespaceSelector.internalValue = value;
  }
  public resetNamespaceSelector() {
    this._namespaceSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceSelectorInput() {
    return this._namespaceSelector.internalValue;
  }
}
export interface ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#weight Cluster#weight}
  */
  readonly weight?: number;
  /**
  * pod_affinity_term block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#pod_affinity_term Cluster#pod_affinity_term}
  */
  readonly podAffinityTerm?: ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
}

export function clusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionToTerraform(struct?: ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    weight: cdktf.numberToTerraform(struct!.weight),
    pod_affinity_term: clusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToTerraform(struct!.podAffinityTerm),
  }
}


export function clusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionToHclTerraform(struct?: ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    weight: {
      value: cdktf.numberToHclTerraform(struct!.weight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pod_affinity_term: {
      value: clusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToHclTerraform(struct!.podAffinityTerm),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._weight !== undefined) {
      hasAnyValues = true;
      internalValueResult.weight = this._weight;
    }
    if (this._podAffinityTerm?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.podAffinityTerm = this._podAffinityTerm?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._weight = undefined;
      this._podAffinityTerm.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._weight = value.weight;
      this._podAffinityTerm.internalValue = value.podAffinityTerm;
    }
  }

  // weight - computed: false, optional: true, required: false
  private _weight?: number; 
  public get weight() {
    return this.getNumberAttribute('weight');
  }
  public set weight(value: number) {
    this._weight = value;
  }
  public resetWeight() {
    this._weight = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get weightInput() {
    return this._weight;
  }

  // pod_affinity_term - computed: false, optional: true, required: false
  private _podAffinityTerm = new ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputReference(this, "pod_affinity_term");
  public get podAffinityTerm() {
    return this._podAffinityTerm;
  }
  public putPodAffinityTerm(value: ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) {
    this._podAffinityTerm.internalValue = value;
  }
  public resetPodAffinityTerm() {
    this._podAffinityTerm.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podAffinityTermInput() {
    return this._podAffinityTerm.internalValue;
  }
}

export class ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionList extends cdktf.ComplexList {
  public internalValue? : ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference {
    return new ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#key Cluster#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#operator Cluster#operator}
  */
  readonly operator?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#values Cluster#values}
  */
  readonly values?: string[];
}

export function clusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToTerraform(struct?: ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function clusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToHclTerraform(struct?: ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference {
    return new ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#match_labels Cluster#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
  /**
  * match_expressions block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#match_expressions Cluster#match_expressions}
  */
  readonly matchExpressions?: ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[] | cdktf.IResolvable;
}

export function clusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToTerraform(struct?: ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputReference | ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
    match_expressions: cdktf.listMapper(clusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToTerraform, true)(struct!.matchExpressions),
  }
}


export function clusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToHclTerraform(struct?: ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputReference | ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    match_expressions: {
      value: cdktf.listMapperHcl(clusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToHclTerraform, true)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._matchLabels = undefined;
      this._matchExpressions.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._matchLabels = value.matchLabels;
      this._matchExpressions.internalValue = value.matchExpressions;
    }
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }
}
export interface ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#key Cluster#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#operator Cluster#operator}
  */
  readonly operator?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#values Cluster#values}
  */
  readonly values?: string[];
}

export function clusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToTerraform(struct?: ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function clusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToHclTerraform(struct?: ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputReference {
    return new ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#match_labels Cluster#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
  /**
  * match_expressions block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#match_expressions Cluster#match_expressions}
  */
  readonly matchExpressions?: ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[] | cdktf.IResolvable;
}

export function clusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToTerraform(struct?: ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputReference | ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
    match_expressions: cdktf.listMapper(clusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToTerraform, true)(struct!.matchExpressions),
  }
}


export function clusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToHclTerraform(struct?: ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputReference | ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    match_expressions: {
      value: cdktf.listMapperHcl(clusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToHclTerraform, true)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._matchLabels = undefined;
      this._matchExpressions.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._matchLabels = value.matchLabels;
      this._matchExpressions.internalValue = value.matchExpressions;
    }
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }
}
export interface ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#namespaces Cluster#namespaces}
  */
  readonly namespaces?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#topology_key Cluster#topology_key}
  */
  readonly topologyKey?: string;
  /**
  * label_selector block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#label_selector Cluster#label_selector}
  */
  readonly labelSelector?: ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
  /**
  * namespace_selector block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#namespace_selector Cluster#namespace_selector}
  */
  readonly namespaceSelector?: ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
}

export function clusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionToTerraform(struct?: ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    namespaces: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.namespaces),
    topology_key: cdktf.stringToTerraform(struct!.topologyKey),
    label_selector: clusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToTerraform(struct!.labelSelector),
    namespace_selector: clusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToTerraform(struct!.namespaceSelector),
  }
}


export function clusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionToHclTerraform(struct?: ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    namespaces: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.namespaces),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    topology_key: {
      value: cdktf.stringToHclTerraform(struct!.topologyKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_selector: {
      value: clusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToHclTerraform(struct!.labelSelector),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorList",
    },
    namespace_selector: {
      value: clusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToHclTerraform(struct!.namespaceSelector),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._namespaces !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaces = this._namespaces;
    }
    if (this._topologyKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.topologyKey = this._topologyKey;
    }
    if (this._labelSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSelector = this._labelSelector?.internalValue;
    }
    if (this._namespaceSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaceSelector = this._namespaceSelector?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._namespaces = undefined;
      this._topologyKey = undefined;
      this._labelSelector.internalValue = undefined;
      this._namespaceSelector.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._namespaces = value.namespaces;
      this._topologyKey = value.topologyKey;
      this._labelSelector.internalValue = value.labelSelector;
      this._namespaceSelector.internalValue = value.namespaceSelector;
    }
  }

  // namespaces - computed: false, optional: true, required: false
  private _namespaces?: string[]; 
  public get namespaces() {
    return this.getListAttribute('namespaces');
  }
  public set namespaces(value: string[]) {
    this._namespaces = value;
  }
  public resetNamespaces() {
    this._namespaces = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespacesInput() {
    return this._namespaces;
  }

  // topology_key - computed: false, optional: true, required: false
  private _topologyKey?: string; 
  public get topologyKey() {
    return this.getStringAttribute('topology_key');
  }
  public set topologyKey(value: string) {
    this._topologyKey = value;
  }
  public resetTopologyKey() {
    this._topologyKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get topologyKeyInput() {
    return this._topologyKey;
  }

  // label_selector - computed: false, optional: true, required: false
  private _labelSelector = new ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputReference(this, "label_selector");
  public get labelSelector() {
    return this._labelSelector;
  }
  public putLabelSelector(value: ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) {
    this._labelSelector.internalValue = value;
  }
  public resetLabelSelector() {
    this._labelSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSelectorInput() {
    return this._labelSelector.internalValue;
  }

  // namespace_selector - computed: false, optional: true, required: false
  private _namespaceSelector = new ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputReference(this, "namespace_selector");
  public get namespaceSelector() {
    return this._namespaceSelector;
  }
  public putNamespaceSelector(value: ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) {
    this._namespaceSelector.internalValue = value;
  }
  public resetNamespaceSelector() {
    this._namespaceSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceSelectorInput() {
    return this._namespaceSelector.internalValue;
  }
}

export class ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionList extends cdktf.ComplexList {
  public internalValue? : ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference {
    return new ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterKubeDnsAffinityPodAffinity {
  /**
  * preferred_during_scheduling_ignored_during_execution block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#preferred_during_scheduling_ignored_during_execution Cluster#preferred_during_scheduling_ignored_during_execution}
  */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable;
  /**
  * required_during_scheduling_ignored_during_execution block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#required_during_scheduling_ignored_during_execution Cluster#required_during_scheduling_ignored_during_execution}
  */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable;
}

export function clusterKubeDnsAffinityPodAffinityToTerraform(struct?: ClusterKubeDnsAffinityPodAffinityOutputReference | ClusterKubeDnsAffinityPodAffinity): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    preferred_during_scheduling_ignored_during_execution: cdktf.listMapper(clusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionToTerraform, true)(struct!.preferredDuringSchedulingIgnoredDuringExecution),
    required_during_scheduling_ignored_during_execution: cdktf.listMapper(clusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionToTerraform, true)(struct!.requiredDuringSchedulingIgnoredDuringExecution),
  }
}


export function clusterKubeDnsAffinityPodAffinityToHclTerraform(struct?: ClusterKubeDnsAffinityPodAffinityOutputReference | ClusterKubeDnsAffinityPodAffinity): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    preferred_during_scheduling_ignored_during_execution: {
      value: cdktf.listMapperHcl(clusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionToHclTerraform, true)(struct!.preferredDuringSchedulingIgnoredDuringExecution),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionList",
    },
    required_during_scheduling_ignored_during_execution: {
      value: cdktf.listMapperHcl(clusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionToHclTerraform, true)(struct!.requiredDuringSchedulingIgnoredDuringExecution),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterKubeDnsAffinityPodAffinityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterKubeDnsAffinityPodAffinity | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._preferredDuringSchedulingIgnoredDuringExecution?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.preferredDuringSchedulingIgnoredDuringExecution = this._preferredDuringSchedulingIgnoredDuringExecution?.internalValue;
    }
    if (this._requiredDuringSchedulingIgnoredDuringExecution?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.requiredDuringSchedulingIgnoredDuringExecution = this._requiredDuringSchedulingIgnoredDuringExecution?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterKubeDnsAffinityPodAffinity | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
      this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = value.preferredDuringSchedulingIgnoredDuringExecution;
      this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = value.requiredDuringSchedulingIgnoredDuringExecution;
    }
  }

  // preferred_during_scheduling_ignored_during_execution - computed: false, optional: true, required: false
  private _preferredDuringSchedulingIgnoredDuringExecution = new ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionList(this, "preferred_during_scheduling_ignored_during_execution", false);
  public get preferredDuringSchedulingIgnoredDuringExecution() {
    return this._preferredDuringSchedulingIgnoredDuringExecution;
  }
  public putPreferredDuringSchedulingIgnoredDuringExecution(value: ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable) {
    this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = value;
  }
  public resetPreferredDuringSchedulingIgnoredDuringExecution() {
    this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preferredDuringSchedulingIgnoredDuringExecutionInput() {
    return this._preferredDuringSchedulingIgnoredDuringExecution.internalValue;
  }

  // required_during_scheduling_ignored_during_execution - computed: false, optional: true, required: false
  private _requiredDuringSchedulingIgnoredDuringExecution = new ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionList(this, "required_during_scheduling_ignored_during_execution", false);
  public get requiredDuringSchedulingIgnoredDuringExecution() {
    return this._requiredDuringSchedulingIgnoredDuringExecution;
  }
  public putRequiredDuringSchedulingIgnoredDuringExecution(value: ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable) {
    this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = value;
  }
  public resetRequiredDuringSchedulingIgnoredDuringExecution() {
    this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requiredDuringSchedulingIgnoredDuringExecutionInput() {
    return this._requiredDuringSchedulingIgnoredDuringExecution.internalValue;
  }
}
export interface ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#key Cluster#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#operator Cluster#operator}
  */
  readonly operator?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#values Cluster#values}
  */
  readonly values?: string[];
}

export function clusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToTerraform(struct?: ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function clusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToHclTerraform(struct?: ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference {
    return new ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#match_labels Cluster#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
  /**
  * match_expressions block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#match_expressions Cluster#match_expressions}
  */
  readonly matchExpressions?: ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[] | cdktf.IResolvable;
}

export function clusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToTerraform(struct?: ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputReference | ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
    match_expressions: cdktf.listMapper(clusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToTerraform, true)(struct!.matchExpressions),
  }
}


export function clusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToHclTerraform(struct?: ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputReference | ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    match_expressions: {
      value: cdktf.listMapperHcl(clusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToHclTerraform, true)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._matchLabels = undefined;
      this._matchExpressions.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._matchLabels = value.matchLabels;
      this._matchExpressions.internalValue = value.matchExpressions;
    }
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }
}
export interface ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#key Cluster#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#operator Cluster#operator}
  */
  readonly operator?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#values Cluster#values}
  */
  readonly values?: string[];
}

export function clusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToTerraform(struct?: ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function clusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToHclTerraform(struct?: ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputReference {
    return new ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#match_labels Cluster#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
  /**
  * match_expressions block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#match_expressions Cluster#match_expressions}
  */
  readonly matchExpressions?: ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[] | cdktf.IResolvable;
}

export function clusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToTerraform(struct?: ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputReference | ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
    match_expressions: cdktf.listMapper(clusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToTerraform, true)(struct!.matchExpressions),
  }
}


export function clusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToHclTerraform(struct?: ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputReference | ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    match_expressions: {
      value: cdktf.listMapperHcl(clusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToHclTerraform, true)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._matchLabels = undefined;
      this._matchExpressions.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._matchLabels = value.matchLabels;
      this._matchExpressions.internalValue = value.matchExpressions;
    }
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }
}
export interface ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#namespaces Cluster#namespaces}
  */
  readonly namespaces?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#topology_key Cluster#topology_key}
  */
  readonly topologyKey?: string;
  /**
  * label_selector block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#label_selector Cluster#label_selector}
  */
  readonly labelSelector?: ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
  /**
  * namespace_selector block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#namespace_selector Cluster#namespace_selector}
  */
  readonly namespaceSelector?: ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
}

export function clusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToTerraform(struct?: ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputReference | ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    namespaces: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.namespaces),
    topology_key: cdktf.stringToTerraform(struct!.topologyKey),
    label_selector: clusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToTerraform(struct!.labelSelector),
    namespace_selector: clusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToTerraform(struct!.namespaceSelector),
  }
}


export function clusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToHclTerraform(struct?: ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputReference | ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    namespaces: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.namespaces),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    topology_key: {
      value: cdktf.stringToHclTerraform(struct!.topologyKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_selector: {
      value: clusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToHclTerraform(struct!.labelSelector),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorList",
    },
    namespace_selector: {
      value: clusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToHclTerraform(struct!.namespaceSelector),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._namespaces !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaces = this._namespaces;
    }
    if (this._topologyKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.topologyKey = this._topologyKey;
    }
    if (this._labelSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSelector = this._labelSelector?.internalValue;
    }
    if (this._namespaceSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaceSelector = this._namespaceSelector?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._namespaces = undefined;
      this._topologyKey = undefined;
      this._labelSelector.internalValue = undefined;
      this._namespaceSelector.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._namespaces = value.namespaces;
      this._topologyKey = value.topologyKey;
      this._labelSelector.internalValue = value.labelSelector;
      this._namespaceSelector.internalValue = value.namespaceSelector;
    }
  }

  // namespaces - computed: false, optional: true, required: false
  private _namespaces?: string[]; 
  public get namespaces() {
    return this.getListAttribute('namespaces');
  }
  public set namespaces(value: string[]) {
    this._namespaces = value;
  }
  public resetNamespaces() {
    this._namespaces = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespacesInput() {
    return this._namespaces;
  }

  // topology_key - computed: false, optional: true, required: false
  private _topologyKey?: string; 
  public get topologyKey() {
    return this.getStringAttribute('topology_key');
  }
  public set topologyKey(value: string) {
    this._topologyKey = value;
  }
  public resetTopologyKey() {
    this._topologyKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get topologyKeyInput() {
    return this._topologyKey;
  }

  // label_selector - computed: false, optional: true, required: false
  private _labelSelector = new ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputReference(this, "label_selector");
  public get labelSelector() {
    return this._labelSelector;
  }
  public putLabelSelector(value: ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) {
    this._labelSelector.internalValue = value;
  }
  public resetLabelSelector() {
    this._labelSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSelectorInput() {
    return this._labelSelector.internalValue;
  }

  // namespace_selector - computed: false, optional: true, required: false
  private _namespaceSelector = new ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputReference(this, "namespace_selector");
  public get namespaceSelector() {
    return this._namespaceSelector;
  }
  public putNamespaceSelector(value: ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) {
    this._namespaceSelector.internalValue = value;
  }
  public resetNamespaceSelector() {
    this._namespaceSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceSelectorInput() {
    return this._namespaceSelector.internalValue;
  }
}
export interface ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#weight Cluster#weight}
  */
  readonly weight?: number;
  /**
  * pod_affinity_term block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#pod_affinity_term Cluster#pod_affinity_term}
  */
  readonly podAffinityTerm?: ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
}

export function clusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionToTerraform(struct?: ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    weight: cdktf.numberToTerraform(struct!.weight),
    pod_affinity_term: clusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToTerraform(struct!.podAffinityTerm),
  }
}


export function clusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionToHclTerraform(struct?: ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    weight: {
      value: cdktf.numberToHclTerraform(struct!.weight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pod_affinity_term: {
      value: clusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToHclTerraform(struct!.podAffinityTerm),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._weight !== undefined) {
      hasAnyValues = true;
      internalValueResult.weight = this._weight;
    }
    if (this._podAffinityTerm?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.podAffinityTerm = this._podAffinityTerm?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._weight = undefined;
      this._podAffinityTerm.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._weight = value.weight;
      this._podAffinityTerm.internalValue = value.podAffinityTerm;
    }
  }

  // weight - computed: false, optional: true, required: false
  private _weight?: number; 
  public get weight() {
    return this.getNumberAttribute('weight');
  }
  public set weight(value: number) {
    this._weight = value;
  }
  public resetWeight() {
    this._weight = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get weightInput() {
    return this._weight;
  }

  // pod_affinity_term - computed: false, optional: true, required: false
  private _podAffinityTerm = new ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputReference(this, "pod_affinity_term");
  public get podAffinityTerm() {
    return this._podAffinityTerm;
  }
  public putPodAffinityTerm(value: ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) {
    this._podAffinityTerm.internalValue = value;
  }
  public resetPodAffinityTerm() {
    this._podAffinityTerm.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podAffinityTermInput() {
    return this._podAffinityTerm.internalValue;
  }
}

export class ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionList extends cdktf.ComplexList {
  public internalValue? : ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference {
    return new ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#key Cluster#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#operator Cluster#operator}
  */
  readonly operator?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#values Cluster#values}
  */
  readonly values?: string[];
}

export function clusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToTerraform(struct?: ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function clusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToHclTerraform(struct?: ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference {
    return new ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#match_labels Cluster#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
  /**
  * match_expressions block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#match_expressions Cluster#match_expressions}
  */
  readonly matchExpressions?: ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[] | cdktf.IResolvable;
}

export function clusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToTerraform(struct?: ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputReference | ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
    match_expressions: cdktf.listMapper(clusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToTerraform, true)(struct!.matchExpressions),
  }
}


export function clusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToHclTerraform(struct?: ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputReference | ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    match_expressions: {
      value: cdktf.listMapperHcl(clusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToHclTerraform, true)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._matchLabels = undefined;
      this._matchExpressions.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._matchLabels = value.matchLabels;
      this._matchExpressions.internalValue = value.matchExpressions;
    }
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }
}
export interface ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#key Cluster#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#operator Cluster#operator}
  */
  readonly operator?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#values Cluster#values}
  */
  readonly values?: string[];
}

export function clusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToTerraform(struct?: ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function clusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToHclTerraform(struct?: ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputReference {
    return new ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#match_labels Cluster#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
  /**
  * match_expressions block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#match_expressions Cluster#match_expressions}
  */
  readonly matchExpressions?: ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[] | cdktf.IResolvable;
}

export function clusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToTerraform(struct?: ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputReference | ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
    match_expressions: cdktf.listMapper(clusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToTerraform, true)(struct!.matchExpressions),
  }
}


export function clusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToHclTerraform(struct?: ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputReference | ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    match_expressions: {
      value: cdktf.listMapperHcl(clusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToHclTerraform, true)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._matchLabels = undefined;
      this._matchExpressions.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._matchLabels = value.matchLabels;
      this._matchExpressions.internalValue = value.matchExpressions;
    }
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }
}
export interface ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#namespaces Cluster#namespaces}
  */
  readonly namespaces?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#topology_key Cluster#topology_key}
  */
  readonly topologyKey?: string;
  /**
  * label_selector block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#label_selector Cluster#label_selector}
  */
  readonly labelSelector?: ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
  /**
  * namespace_selector block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#namespace_selector Cluster#namespace_selector}
  */
  readonly namespaceSelector?: ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
}

export function clusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionToTerraform(struct?: ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    namespaces: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.namespaces),
    topology_key: cdktf.stringToTerraform(struct!.topologyKey),
    label_selector: clusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToTerraform(struct!.labelSelector),
    namespace_selector: clusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToTerraform(struct!.namespaceSelector),
  }
}


export function clusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionToHclTerraform(struct?: ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    namespaces: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.namespaces),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    topology_key: {
      value: cdktf.stringToHclTerraform(struct!.topologyKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_selector: {
      value: clusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToHclTerraform(struct!.labelSelector),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorList",
    },
    namespace_selector: {
      value: clusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToHclTerraform(struct!.namespaceSelector),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._namespaces !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaces = this._namespaces;
    }
    if (this._topologyKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.topologyKey = this._topologyKey;
    }
    if (this._labelSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSelector = this._labelSelector?.internalValue;
    }
    if (this._namespaceSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaceSelector = this._namespaceSelector?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._namespaces = undefined;
      this._topologyKey = undefined;
      this._labelSelector.internalValue = undefined;
      this._namespaceSelector.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._namespaces = value.namespaces;
      this._topologyKey = value.topologyKey;
      this._labelSelector.internalValue = value.labelSelector;
      this._namespaceSelector.internalValue = value.namespaceSelector;
    }
  }

  // namespaces - computed: false, optional: true, required: false
  private _namespaces?: string[]; 
  public get namespaces() {
    return this.getListAttribute('namespaces');
  }
  public set namespaces(value: string[]) {
    this._namespaces = value;
  }
  public resetNamespaces() {
    this._namespaces = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespacesInput() {
    return this._namespaces;
  }

  // topology_key - computed: false, optional: true, required: false
  private _topologyKey?: string; 
  public get topologyKey() {
    return this.getStringAttribute('topology_key');
  }
  public set topologyKey(value: string) {
    this._topologyKey = value;
  }
  public resetTopologyKey() {
    this._topologyKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get topologyKeyInput() {
    return this._topologyKey;
  }

  // label_selector - computed: false, optional: true, required: false
  private _labelSelector = new ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputReference(this, "label_selector");
  public get labelSelector() {
    return this._labelSelector;
  }
  public putLabelSelector(value: ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) {
    this._labelSelector.internalValue = value;
  }
  public resetLabelSelector() {
    this._labelSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSelectorInput() {
    return this._labelSelector.internalValue;
  }

  // namespace_selector - computed: false, optional: true, required: false
  private _namespaceSelector = new ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputReference(this, "namespace_selector");
  public get namespaceSelector() {
    return this._namespaceSelector;
  }
  public putNamespaceSelector(value: ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) {
    this._namespaceSelector.internalValue = value;
  }
  public resetNamespaceSelector() {
    this._namespaceSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceSelectorInput() {
    return this._namespaceSelector.internalValue;
  }
}

export class ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionList extends cdktf.ComplexList {
  public internalValue? : ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference {
    return new ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterKubeDnsAffinityPodAntiAffinity {
  /**
  * preferred_during_scheduling_ignored_during_execution block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#preferred_during_scheduling_ignored_during_execution Cluster#preferred_during_scheduling_ignored_during_execution}
  */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable;
  /**
  * required_during_scheduling_ignored_during_execution block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#required_during_scheduling_ignored_during_execution Cluster#required_during_scheduling_ignored_during_execution}
  */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable;
}

export function clusterKubeDnsAffinityPodAntiAffinityToTerraform(struct?: ClusterKubeDnsAffinityPodAntiAffinityOutputReference | ClusterKubeDnsAffinityPodAntiAffinity): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    preferred_during_scheduling_ignored_during_execution: cdktf.listMapper(clusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionToTerraform, true)(struct!.preferredDuringSchedulingIgnoredDuringExecution),
    required_during_scheduling_ignored_during_execution: cdktf.listMapper(clusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionToTerraform, true)(struct!.requiredDuringSchedulingIgnoredDuringExecution),
  }
}


export function clusterKubeDnsAffinityPodAntiAffinityToHclTerraform(struct?: ClusterKubeDnsAffinityPodAntiAffinityOutputReference | ClusterKubeDnsAffinityPodAntiAffinity): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    preferred_during_scheduling_ignored_during_execution: {
      value: cdktf.listMapperHcl(clusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionToHclTerraform, true)(struct!.preferredDuringSchedulingIgnoredDuringExecution),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionList",
    },
    required_during_scheduling_ignored_during_execution: {
      value: cdktf.listMapperHcl(clusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionToHclTerraform, true)(struct!.requiredDuringSchedulingIgnoredDuringExecution),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterKubeDnsAffinityPodAntiAffinityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterKubeDnsAffinityPodAntiAffinity | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._preferredDuringSchedulingIgnoredDuringExecution?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.preferredDuringSchedulingIgnoredDuringExecution = this._preferredDuringSchedulingIgnoredDuringExecution?.internalValue;
    }
    if (this._requiredDuringSchedulingIgnoredDuringExecution?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.requiredDuringSchedulingIgnoredDuringExecution = this._requiredDuringSchedulingIgnoredDuringExecution?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterKubeDnsAffinityPodAntiAffinity | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
      this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = value.preferredDuringSchedulingIgnoredDuringExecution;
      this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = value.requiredDuringSchedulingIgnoredDuringExecution;
    }
  }

  // preferred_during_scheduling_ignored_during_execution - computed: false, optional: true, required: false
  private _preferredDuringSchedulingIgnoredDuringExecution = new ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionList(this, "preferred_during_scheduling_ignored_during_execution", false);
  public get preferredDuringSchedulingIgnoredDuringExecution() {
    return this._preferredDuringSchedulingIgnoredDuringExecution;
  }
  public putPreferredDuringSchedulingIgnoredDuringExecution(value: ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable) {
    this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = value;
  }
  public resetPreferredDuringSchedulingIgnoredDuringExecution() {
    this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preferredDuringSchedulingIgnoredDuringExecutionInput() {
    return this._preferredDuringSchedulingIgnoredDuringExecution.internalValue;
  }

  // required_during_scheduling_ignored_during_execution - computed: false, optional: true, required: false
  private _requiredDuringSchedulingIgnoredDuringExecution = new ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionList(this, "required_during_scheduling_ignored_during_execution", false);
  public get requiredDuringSchedulingIgnoredDuringExecution() {
    return this._requiredDuringSchedulingIgnoredDuringExecution;
  }
  public putRequiredDuringSchedulingIgnoredDuringExecution(value: ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable) {
    this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = value;
  }
  public resetRequiredDuringSchedulingIgnoredDuringExecution() {
    this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requiredDuringSchedulingIgnoredDuringExecutionInput() {
    return this._requiredDuringSchedulingIgnoredDuringExecution.internalValue;
  }
}
export interface ClusterKubeDnsAffinity {
  /**
  * node_affinity block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#node_affinity Cluster#node_affinity}
  */
  readonly nodeAffinity?: ClusterKubeDnsAffinityNodeAffinity;
  /**
  * pod_affinity block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#pod_affinity Cluster#pod_affinity}
  */
  readonly podAffinity?: ClusterKubeDnsAffinityPodAffinity;
  /**
  * pod_anti_affinity block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#pod_anti_affinity Cluster#pod_anti_affinity}
  */
  readonly podAntiAffinity?: ClusterKubeDnsAffinityPodAntiAffinity;
}

export function clusterKubeDnsAffinityToTerraform(struct?: ClusterKubeDnsAffinityOutputReference | ClusterKubeDnsAffinity): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    node_affinity: clusterKubeDnsAffinityNodeAffinityToTerraform(struct!.nodeAffinity),
    pod_affinity: clusterKubeDnsAffinityPodAffinityToTerraform(struct!.podAffinity),
    pod_anti_affinity: clusterKubeDnsAffinityPodAntiAffinityToTerraform(struct!.podAntiAffinity),
  }
}


export function clusterKubeDnsAffinityToHclTerraform(struct?: ClusterKubeDnsAffinityOutputReference | ClusterKubeDnsAffinity): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    node_affinity: {
      value: clusterKubeDnsAffinityNodeAffinityToHclTerraform(struct!.nodeAffinity),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterKubeDnsAffinityNodeAffinityList",
    },
    pod_affinity: {
      value: clusterKubeDnsAffinityPodAffinityToHclTerraform(struct!.podAffinity),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterKubeDnsAffinityPodAffinityList",
    },
    pod_anti_affinity: {
      value: clusterKubeDnsAffinityPodAntiAffinityToHclTerraform(struct!.podAntiAffinity),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterKubeDnsAffinityPodAntiAffinityList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterKubeDnsAffinityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterKubeDnsAffinity | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._nodeAffinity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeAffinity = this._nodeAffinity?.internalValue;
    }
    if (this._podAffinity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.podAffinity = this._podAffinity?.internalValue;
    }
    if (this._podAntiAffinity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.podAntiAffinity = this._podAntiAffinity?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterKubeDnsAffinity | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._nodeAffinity.internalValue = undefined;
      this._podAffinity.internalValue = undefined;
      this._podAntiAffinity.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._nodeAffinity.internalValue = value.nodeAffinity;
      this._podAffinity.internalValue = value.podAffinity;
      this._podAntiAffinity.internalValue = value.podAntiAffinity;
    }
  }

  // node_affinity - computed: false, optional: true, required: false
  private _nodeAffinity = new ClusterKubeDnsAffinityNodeAffinityOutputReference(this, "node_affinity");
  public get nodeAffinity() {
    return this._nodeAffinity;
  }
  public putNodeAffinity(value: ClusterKubeDnsAffinityNodeAffinity) {
    this._nodeAffinity.internalValue = value;
  }
  public resetNodeAffinity() {
    this._nodeAffinity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeAffinityInput() {
    return this._nodeAffinity.internalValue;
  }

  // pod_affinity - computed: false, optional: true, required: false
  private _podAffinity = new ClusterKubeDnsAffinityPodAffinityOutputReference(this, "pod_affinity");
  public get podAffinity() {
    return this._podAffinity;
  }
  public putPodAffinity(value: ClusterKubeDnsAffinityPodAffinity) {
    this._podAffinity.internalValue = value;
  }
  public resetPodAffinity() {
    this._podAffinity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podAffinityInput() {
    return this._podAffinity.internalValue;
  }

  // pod_anti_affinity - computed: false, optional: true, required: false
  private _podAntiAffinity = new ClusterKubeDnsAffinityPodAntiAffinityOutputReference(this, "pod_anti_affinity");
  public get podAntiAffinity() {
    return this._podAntiAffinity;
  }
  public putPodAntiAffinity(value: ClusterKubeDnsAffinityPodAntiAffinity) {
    this._podAntiAffinity.internalValue = value;
  }
  public resetPodAntiAffinity() {
    this._podAntiAffinity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podAntiAffinityInput() {
    return this._podAntiAffinity.internalValue;
  }
}
export interface ClusterKubeDnsNodeLocalDns {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#cpu_request Cluster#cpu_request}
  */
  readonly cpuRequest?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#enabled Cluster#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#forward_to_kube_dns Cluster#forward_to_kube_dns}
  */
  readonly forwardToKubeDns?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#image Cluster#image}
  */
  readonly image?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#local_ip Cluster#local_ip}
  */
  readonly localIp?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#memory_request Cluster#memory_request}
  */
  readonly memoryRequest?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#pod_annotations Cluster#pod_annotations}
  */
  readonly podAnnotations?: { [key: string]: string };
}

export function clusterKubeDnsNodeLocalDnsToTerraform(struct?: ClusterKubeDnsNodeLocalDnsOutputReference | ClusterKubeDnsNodeLocalDns): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cpu_request: cdktf.stringToTerraform(struct!.cpuRequest),
    enabled: cdktf.booleanToTerraform(struct!.enabled),
    forward_to_kube_dns: cdktf.booleanToTerraform(struct!.forwardToKubeDns),
    image: cdktf.stringToTerraform(struct!.image),
    local_ip: cdktf.stringToTerraform(struct!.localIp),
    memory_request: cdktf.stringToTerraform(struct!.memoryRequest),
    pod_annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.podAnnotations),
  }
}


export function clusterKubeDnsNodeLocalDnsToHclTerraform(struct?: ClusterKubeDnsNodeLocalDnsOutputReference | ClusterKubeDnsNodeLocalDns): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cpu_request: {
      value: cdktf.stringToHclTerraform(struct!.cpuRequest),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    forward_to_kube_dns: {
      value: cdktf.booleanToHclTerraform(struct!.forwardToKubeDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    image: {
      value: cdktf.stringToHclTerraform(struct!.image),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    local_ip: {
      value: cdktf.stringToHclTerraform(struct!.localIp),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    memory_request: {
      value: cdktf.stringToHclTerraform(struct!.memoryRequest),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pod_annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.podAnnotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterKubeDnsNodeLocalDnsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterKubeDnsNodeLocalDns | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cpuRequest !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpuRequest = this._cpuRequest;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._forwardToKubeDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.forwardToKubeDns = this._forwardToKubeDns;
    }
    if (this._image !== undefined) {
      hasAnyValues = true;
      internalValueResult.image = this._image;
    }
    if (this._localIp !== undefined) {
      hasAnyValues = true;
      internalValueResult.localIp = this._localIp;
    }
    if (this._memoryRequest !== undefined) {
      hasAnyValues = true;
      internalValueResult.memoryRequest = this._memoryRequest;
    }
    if (this._podAnnotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.podAnnotations = this._podAnnotations;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterKubeDnsNodeLocalDns | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._cpuRequest = undefined;
      this._enabled = undefined;
      this._forwardToKubeDns = undefined;
      this._image = undefined;
      this._localIp = undefined;
      this._memoryRequest = undefined;
      this._podAnnotations = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._cpuRequest = value.cpuRequest;
      this._enabled = value.enabled;
      this._forwardToKubeDns = value.forwardToKubeDns;
      this._image = value.image;
      this._localIp = value.localIp;
      this._memoryRequest = value.memoryRequest;
      this._podAnnotations = value.podAnnotations;
    }
  }

  // cpu_request - computed: false, optional: true, required: false
  private _cpuRequest?: string; 
  public get cpuRequest() {
    return this.getStringAttribute('cpu_request');
  }
  public set cpuRequest(value: string) {
    this._cpuRequest = value;
  }
  public resetCpuRequest() {
    this._cpuRequest = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuRequestInput() {
    return this._cpuRequest;
  }

  // enabled - computed: false, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // forward_to_kube_dns - computed: false, optional: true, required: false
  private _forwardToKubeDns?: boolean | cdktf.IResolvable; 
  public get forwardToKubeDns() {
    return this.getBooleanAttribute('forward_to_kube_dns');
  }
  public set forwardToKubeDns(value: boolean | cdktf.IResolvable) {
    this._forwardToKubeDns = value;
  }
  public resetForwardToKubeDns() {
    this._forwardToKubeDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get forwardToKubeDnsInput() {
    return this._forwardToKubeDns;
  }

  // image - computed: false, optional: true, required: false
  private _image?: string; 
  public get image() {
    return this.getStringAttribute('image');
  }
  public set image(value: string) {
    this._image = value;
  }
  public resetImage() {
    this._image = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageInput() {
    return this._image;
  }

  // local_ip - computed: false, optional: true, required: false
  private _localIp?: string; 
  public get localIp() {
    return this.getStringAttribute('local_ip');
  }
  public set localIp(value: string) {
    this._localIp = value;
  }
  public resetLocalIp() {
    this._localIp = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localIpInput() {
    return this._localIp;
  }

  // memory_request - computed: false, optional: true, required: false
  private _memoryRequest?: string; 
  public get memoryRequest() {
    return this.getStringAttribute('memory_request');
  }
  public set memoryRequest(value: string) {
    this._memoryRequest = value;
  }
  public resetMemoryRequest() {
    this._memoryRequest = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryRequestInput() {
    return this._memoryRequest;
  }

  // pod_annotations - computed: false, optional: true, required: false
  private _podAnnotations?: { [key: string]: string }; 
  public get podAnnotations() {
    return this.getStringMapAttribute('pod_annotations');
  }
  public set podAnnotations(value: { [key: string]: string }) {
    this._podAnnotations = value;
  }
  public resetPodAnnotations() {
    this._podAnnotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podAnnotationsInput() {
    return this._podAnnotations;
  }
}
export interface ClusterKubeDnsStubDomains {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#key Cluster#key}
  */
  readonly key: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#value Cluster#value}
  */
  readonly value: string[];
}

export function clusterKubeDnsStubDomainsToTerraform(struct?: ClusterKubeDnsStubDomains | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.value),
  }
}


export function clusterKubeDnsStubDomainsToHclTerraform(struct?: ClusterKubeDnsStubDomains | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.value),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterKubeDnsStubDomainsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterKubeDnsStubDomains | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterKubeDnsStubDomains | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value = value.value;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string[]; 
  public get value() {
    return this.getListAttribute('value');
  }
  public set value(value: string[]) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class ClusterKubeDnsStubDomainsList extends cdktf.ComplexList {
  public internalValue? : ClusterKubeDnsStubDomains[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterKubeDnsStubDomainsOutputReference {
    return new ClusterKubeDnsStubDomainsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterKubeDnsTolerations {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#effect Cluster#effect}
  */
  readonly effect?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#key Cluster#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#operator Cluster#operator}
  */
  readonly operator?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#toleration_seconds Cluster#toleration_seconds}
  */
  readonly tolerationSeconds?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#value Cluster#value}
  */
  readonly value?: string;
}

export function clusterKubeDnsTolerationsToTerraform(struct?: ClusterKubeDnsTolerations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    effect: cdktf.stringToTerraform(struct!.effect),
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    toleration_seconds: cdktf.numberToTerraform(struct!.tolerationSeconds),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function clusterKubeDnsTolerationsToHclTerraform(struct?: ClusterKubeDnsTolerations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    effect: {
      value: cdktf.stringToHclTerraform(struct!.effect),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    toleration_seconds: {
      value: cdktf.numberToHclTerraform(struct!.tolerationSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterKubeDnsTolerationsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterKubeDnsTolerations | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._effect !== undefined) {
      hasAnyValues = true;
      internalValueResult.effect = this._effect;
    }
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._tolerationSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.tolerationSeconds = this._tolerationSeconds;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterKubeDnsTolerations | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._effect = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._tolerationSeconds = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._effect = value.effect;
      this._key = value.key;
      this._operator = value.operator;
      this._tolerationSeconds = value.tolerationSeconds;
      this._value = value.value;
    }
  }

  // effect - computed: false, optional: true, required: false
  private _effect?: string; 
  public get effect() {
    return this.getStringAttribute('effect');
  }
  public set effect(value: string) {
    this._effect = value;
  }
  public resetEffect() {
    this._effect = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get effectInput() {
    return this._effect;
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // toleration_seconds - computed: false, optional: true, required: false
  private _tolerationSeconds?: number; 
  public get tolerationSeconds() {
    return this.getNumberAttribute('toleration_seconds');
  }
  public set tolerationSeconds(value: number) {
    this._tolerationSeconds = value;
  }
  public resetTolerationSeconds() {
    this._tolerationSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tolerationSecondsInput() {
    return this._tolerationSeconds;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class ClusterKubeDnsTolerationsList extends cdktf.ComplexList {
  public internalValue? : ClusterKubeDnsTolerations[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterKubeDnsTolerationsOutputReference {
    return new ClusterKubeDnsTolerationsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterKubeDns {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#cache_max_concurrent Cluster#cache_max_concurrent}
  */
  readonly cacheMaxConcurrent?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#cache_max_size Cluster#cache_max_size}
  */
  readonly cacheMaxSize?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#core_dns_image Cluster#core_dns_image}
  */
  readonly coreDnsImage?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#cpa_image Cluster#cpa_image}
  */
  readonly cpaImage?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#cpu_request Cluster#cpu_request}
  */
  readonly cpuRequest?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#domain Cluster#domain}
  */
  readonly domain?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#external_core_file Cluster#external_core_file}
  */
  readonly externalCoreFile?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#memory_limit Cluster#memory_limit}
  */
  readonly memoryLimit?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#memory_request Cluster#memory_request}
  */
  readonly memoryRequest?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#provider Cluster#provider}
  */
  readonly provider?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#server_ip Cluster#server_ip}
  */
  readonly serverIp?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#upstream_nameservers Cluster#upstream_nameservers}
  */
  readonly upstreamNameservers?: string[];
  /**
  * affinity block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#affinity Cluster#affinity}
  */
  readonly affinity?: ClusterKubeDnsAffinity;
  /**
  * node_local_dns block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#node_local_dns Cluster#node_local_dns}
  */
  readonly nodeLocalDns?: ClusterKubeDnsNodeLocalDns;
  /**
  * stub_domains block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#stub_domains Cluster#stub_domains}
  */
  readonly stubDomains?: ClusterKubeDnsStubDomains[] | cdktf.IResolvable;
  /**
  * tolerations block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#tolerations Cluster#tolerations}
  */
  readonly tolerations?: ClusterKubeDnsTolerations[] | cdktf.IResolvable;
}

export function clusterKubeDnsToTerraform(struct?: ClusterKubeDnsOutputReference | ClusterKubeDns): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cache_max_concurrent: cdktf.numberToTerraform(struct!.cacheMaxConcurrent),
    cache_max_size: cdktf.numberToTerraform(struct!.cacheMaxSize),
    core_dns_image: cdktf.stringToTerraform(struct!.coreDnsImage),
    cpa_image: cdktf.stringToTerraform(struct!.cpaImage),
    cpu_request: cdktf.stringToTerraform(struct!.cpuRequest),
    domain: cdktf.stringToTerraform(struct!.domain),
    external_core_file: cdktf.stringToTerraform(struct!.externalCoreFile),
    memory_limit: cdktf.stringToTerraform(struct!.memoryLimit),
    memory_request: cdktf.stringToTerraform(struct!.memoryRequest),
    provider: cdktf.stringToTerraform(struct!.provider),
    server_ip: cdktf.stringToTerraform(struct!.serverIp),
    upstream_nameservers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.upstreamNameservers),
    affinity: clusterKubeDnsAffinityToTerraform(struct!.affinity),
    node_local_dns: clusterKubeDnsNodeLocalDnsToTerraform(struct!.nodeLocalDns),
    stub_domains: cdktf.listMapper(clusterKubeDnsStubDomainsToTerraform, true)(struct!.stubDomains),
    tolerations: cdktf.listMapper(clusterKubeDnsTolerationsToTerraform, true)(struct!.tolerations),
  }
}


export function clusterKubeDnsToHclTerraform(struct?: ClusterKubeDnsOutputReference | ClusterKubeDns): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cache_max_concurrent: {
      value: cdktf.numberToHclTerraform(struct!.cacheMaxConcurrent),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    cache_max_size: {
      value: cdktf.numberToHclTerraform(struct!.cacheMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    core_dns_image: {
      value: cdktf.stringToHclTerraform(struct!.coreDnsImage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cpa_image: {
      value: cdktf.stringToHclTerraform(struct!.cpaImage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cpu_request: {
      value: cdktf.stringToHclTerraform(struct!.cpuRequest),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    domain: {
      value: cdktf.stringToHclTerraform(struct!.domain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    external_core_file: {
      value: cdktf.stringToHclTerraform(struct!.externalCoreFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    memory_limit: {
      value: cdktf.stringToHclTerraform(struct!.memoryLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    memory_request: {
      value: cdktf.stringToHclTerraform(struct!.memoryRequest),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    provider: {
      value: cdktf.stringToHclTerraform(struct!.provider),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server_ip: {
      value: cdktf.stringToHclTerraform(struct!.serverIp),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    upstream_nameservers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.upstreamNameservers),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    affinity: {
      value: clusterKubeDnsAffinityToHclTerraform(struct!.affinity),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterKubeDnsAffinityList",
    },
    node_local_dns: {
      value: clusterKubeDnsNodeLocalDnsToHclTerraform(struct!.nodeLocalDns),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterKubeDnsNodeLocalDnsList",
    },
    stub_domains: {
      value: cdktf.listMapperHcl(clusterKubeDnsStubDomainsToHclTerraform, true)(struct!.stubDomains),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterKubeDnsStubDomainsList",
    },
    tolerations: {
      value: cdktf.listMapperHcl(clusterKubeDnsTolerationsToHclTerraform, true)(struct!.tolerations),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterKubeDnsTolerationsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterKubeDnsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterKubeDns | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cacheMaxConcurrent !== undefined) {
      hasAnyValues = true;
      internalValueResult.cacheMaxConcurrent = this._cacheMaxConcurrent;
    }
    if (this._cacheMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.cacheMaxSize = this._cacheMaxSize;
    }
    if (this._coreDnsImage !== undefined) {
      hasAnyValues = true;
      internalValueResult.coreDnsImage = this._coreDnsImage;
    }
    if (this._cpaImage !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpaImage = this._cpaImage;
    }
    if (this._cpuRequest !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpuRequest = this._cpuRequest;
    }
    if (this._domain !== undefined) {
      hasAnyValues = true;
      internalValueResult.domain = this._domain;
    }
    if (this._externalCoreFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.externalCoreFile = this._externalCoreFile;
    }
    if (this._memoryLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.memoryLimit = this._memoryLimit;
    }
    if (this._memoryRequest !== undefined) {
      hasAnyValues = true;
      internalValueResult.memoryRequest = this._memoryRequest;
    }
    if (this._provider !== undefined) {
      hasAnyValues = true;
      internalValueResult.provider = this._provider;
    }
    if (this._serverIp !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverIp = this._serverIp;
    }
    if (this._upstreamNameservers !== undefined) {
      hasAnyValues = true;
      internalValueResult.upstreamNameservers = this._upstreamNameservers;
    }
    if (this._affinity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.affinity = this._affinity?.internalValue;
    }
    if (this._nodeLocalDns?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeLocalDns = this._nodeLocalDns?.internalValue;
    }
    if (this._stubDomains?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.stubDomains = this._stubDomains?.internalValue;
    }
    if (this._tolerations?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tolerations = this._tolerations?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterKubeDns | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._cacheMaxConcurrent = undefined;
      this._cacheMaxSize = undefined;
      this._coreDnsImage = undefined;
      this._cpaImage = undefined;
      this._cpuRequest = undefined;
      this._domain = undefined;
      this._externalCoreFile = undefined;
      this._memoryLimit = undefined;
      this._memoryRequest = undefined;
      this._provider = undefined;
      this._serverIp = undefined;
      this._upstreamNameservers = undefined;
      this._affinity.internalValue = undefined;
      this._nodeLocalDns.internalValue = undefined;
      this._stubDomains.internalValue = undefined;
      this._tolerations.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._cacheMaxConcurrent = value.cacheMaxConcurrent;
      this._cacheMaxSize = value.cacheMaxSize;
      this._coreDnsImage = value.coreDnsImage;
      this._cpaImage = value.cpaImage;
      this._cpuRequest = value.cpuRequest;
      this._domain = value.domain;
      this._externalCoreFile = value.externalCoreFile;
      this._memoryLimit = value.memoryLimit;
      this._memoryRequest = value.memoryRequest;
      this._provider = value.provider;
      this._serverIp = value.serverIp;
      this._upstreamNameservers = value.upstreamNameservers;
      this._affinity.internalValue = value.affinity;
      this._nodeLocalDns.internalValue = value.nodeLocalDns;
      this._stubDomains.internalValue = value.stubDomains;
      this._tolerations.internalValue = value.tolerations;
    }
  }

  // cache_max_concurrent - computed: false, optional: true, required: false
  private _cacheMaxConcurrent?: number; 
  public get cacheMaxConcurrent() {
    return this.getNumberAttribute('cache_max_concurrent');
  }
  public set cacheMaxConcurrent(value: number) {
    this._cacheMaxConcurrent = value;
  }
  public resetCacheMaxConcurrent() {
    this._cacheMaxConcurrent = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cacheMaxConcurrentInput() {
    return this._cacheMaxConcurrent;
  }

  // cache_max_size - computed: false, optional: true, required: false
  private _cacheMaxSize?: number; 
  public get cacheMaxSize() {
    return this.getNumberAttribute('cache_max_size');
  }
  public set cacheMaxSize(value: number) {
    this._cacheMaxSize = value;
  }
  public resetCacheMaxSize() {
    this._cacheMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cacheMaxSizeInput() {
    return this._cacheMaxSize;
  }

  // core_dns_image - computed: false, optional: true, required: false
  private _coreDnsImage?: string; 
  public get coreDnsImage() {
    return this.getStringAttribute('core_dns_image');
  }
  public set coreDnsImage(value: string) {
    this._coreDnsImage = value;
  }
  public resetCoreDnsImage() {
    this._coreDnsImage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get coreDnsImageInput() {
    return this._coreDnsImage;
  }

  // cpa_image - computed: false, optional: true, required: false
  private _cpaImage?: string; 
  public get cpaImage() {
    return this.getStringAttribute('cpa_image');
  }
  public set cpaImage(value: string) {
    this._cpaImage = value;
  }
  public resetCpaImage() {
    this._cpaImage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpaImageInput() {
    return this._cpaImage;
  }

  // cpu_request - computed: false, optional: true, required: false
  private _cpuRequest?: string; 
  public get cpuRequest() {
    return this.getStringAttribute('cpu_request');
  }
  public set cpuRequest(value: string) {
    this._cpuRequest = value;
  }
  public resetCpuRequest() {
    this._cpuRequest = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuRequestInput() {
    return this._cpuRequest;
  }

  // domain - computed: false, optional: true, required: false
  private _domain?: string; 
  public get domain() {
    return this.getStringAttribute('domain');
  }
  public set domain(value: string) {
    this._domain = value;
  }
  public resetDomain() {
    this._domain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get domainInput() {
    return this._domain;
  }

  // external_core_file - computed: false, optional: true, required: false
  private _externalCoreFile?: string; 
  public get externalCoreFile() {
    return this.getStringAttribute('external_core_file');
  }
  public set externalCoreFile(value: string) {
    this._externalCoreFile = value;
  }
  public resetExternalCoreFile() {
    this._externalCoreFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get externalCoreFileInput() {
    return this._externalCoreFile;
  }

  // memory_limit - computed: false, optional: true, required: false
  private _memoryLimit?: string; 
  public get memoryLimit() {
    return this.getStringAttribute('memory_limit');
  }
  public set memoryLimit(value: string) {
    this._memoryLimit = value;
  }
  public resetMemoryLimit() {
    this._memoryLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryLimitInput() {
    return this._memoryLimit;
  }

  // memory_request - computed: false, optional: true, required: false
  private _memoryRequest?: string; 
  public get memoryRequest() {
    return this.getStringAttribute('memory_request');
  }
  public set memoryRequest(value: string) {
    this._memoryRequest = value;
  }
  public resetMemoryRequest() {
    this._memoryRequest = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryRequestInput() {
    return this._memoryRequest;
  }

  // provider - computed: false, optional: true, required: false
  private _provider?: string; 
  public get provider() {
    return this.getStringAttribute('provider');
  }
  public set provider(value: string) {
    this._provider = value;
  }
  public resetProvider() {
    this._provider = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get providerInput() {
    return this._provider;
  }

  // server_ip - computed: false, optional: true, required: false
  private _serverIp?: string; 
  public get serverIp() {
    return this.getStringAttribute('server_ip');
  }
  public set serverIp(value: string) {
    this._serverIp = value;
  }
  public resetServerIp() {
    this._serverIp = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverIpInput() {
    return this._serverIp;
  }

  // upstream_nameservers - computed: false, optional: true, required: false
  private _upstreamNameservers?: string[]; 
  public get upstreamNameservers() {
    return this.getListAttribute('upstream_nameservers');
  }
  public set upstreamNameservers(value: string[]) {
    this._upstreamNameservers = value;
  }
  public resetUpstreamNameservers() {
    this._upstreamNameservers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get upstreamNameserversInput() {
    return this._upstreamNameservers;
  }

  // affinity - computed: false, optional: true, required: false
  private _affinity = new ClusterKubeDnsAffinityOutputReference(this, "affinity");
  public get affinity() {
    return this._affinity;
  }
  public putAffinity(value: ClusterKubeDnsAffinity) {
    this._affinity.internalValue = value;
  }
  public resetAffinity() {
    this._affinity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get affinityInput() {
    return this._affinity.internalValue;
  }

  // node_local_dns - computed: false, optional: true, required: false
  private _nodeLocalDns = new ClusterKubeDnsNodeLocalDnsOutputReference(this, "node_local_dns");
  public get nodeLocalDns() {
    return this._nodeLocalDns;
  }
  public putNodeLocalDns(value: ClusterKubeDnsNodeLocalDns) {
    this._nodeLocalDns.internalValue = value;
  }
  public resetNodeLocalDns() {
    this._nodeLocalDns.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeLocalDnsInput() {
    return this._nodeLocalDns.internalValue;
  }

  // stub_domains - computed: false, optional: true, required: false
  private _stubDomains = new ClusterKubeDnsStubDomainsList(this, "stub_domains", false);
  public get stubDomains() {
    return this._stubDomains;
  }
  public putStubDomains(value: ClusterKubeDnsStubDomains[] | cdktf.IResolvable) {
    this._stubDomains.internalValue = value;
  }
  public resetStubDomains() {
    this._stubDomains.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stubDomainsInput() {
    return this._stubDomains.internalValue;
  }

  // tolerations - computed: false, optional: true, required: false
  private _tolerations = new ClusterKubeDnsTolerationsList(this, "tolerations", false);
  public get tolerations() {
    return this._tolerations;
  }
  public putTolerations(value: ClusterKubeDnsTolerations[] | cdktf.IResolvable) {
    this._tolerations.internalValue = value;
  }
  public resetTolerations() {
    this._tolerations.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tolerationsInput() {
    return this._tolerations.internalValue;
  }
}
export interface ClusterKubeProxy {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#bind_address Cluster#bind_address}
  */
  readonly bindAddress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#cluster_cidr Cluster#cluster_cidr}
  */
  readonly clusterCidr?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#conntrack_max_per_core Cluster#conntrack_max_per_core}
  */
  readonly conntrackMaxPerCore?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#conntrack_min Cluster#conntrack_min}
  */
  readonly conntrackMin?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#cpu_limit Cluster#cpu_limit}
  */
  readonly cpuLimit?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#cpu_request Cluster#cpu_request}
  */
  readonly cpuRequest?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#enabled Cluster#enabled}
  */
  readonly enabled: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#feature_gates Cluster#feature_gates}
  */
  readonly featureGates?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#hostname_override Cluster#hostname_override}
  */
  readonly hostnameOverride?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#image Cluster#image}
  */
  readonly image?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#ip_vs_exclude_cidrs Cluster#ip_vs_exclude_cidrs}
  */
  readonly ipVsExcludeCidrs?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#ip_vs_min_sync_period Cluster#ip_vs_min_sync_period}
  */
  readonly ipVsMinSyncPeriod?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#ip_vs_scheduler Cluster#ip_vs_scheduler}
  */
  readonly ipVsScheduler?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#ip_vs_sync_period Cluster#ip_vs_sync_period}
  */
  readonly ipVsSyncPeriod?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#log_level Cluster#log_level}
  */
  readonly logLevel?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#master Cluster#master}
  */
  readonly master?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#memory_limit Cluster#memory_limit}
  */
  readonly memoryLimit?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#memory_request Cluster#memory_request}
  */
  readonly memoryRequest?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#metrics_bind_address Cluster#metrics_bind_address}
  */
  readonly metricsBindAddress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#proxy_mode Cluster#proxy_mode}
  */
  readonly proxyMode?: string;
}

export function clusterKubeProxyToTerraform(struct?: ClusterKubeProxyOutputReference | ClusterKubeProxy): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_address: cdktf.stringToTerraform(struct!.bindAddress),
    cluster_cidr: cdktf.stringToTerraform(struct!.clusterCidr),
    conntrack_max_per_core: cdktf.numberToTerraform(struct!.conntrackMaxPerCore),
    conntrack_min: cdktf.numberToTerraform(struct!.conntrackMin),
    cpu_limit: cdktf.stringToTerraform(struct!.cpuLimit),
    cpu_request: cdktf.stringToTerraform(struct!.cpuRequest),
    enabled: cdktf.booleanToTerraform(struct!.enabled),
    feature_gates: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.featureGates),
    hostname_override: cdktf.stringToTerraform(struct!.hostnameOverride),
    image: cdktf.stringToTerraform(struct!.image),
    ip_vs_exclude_cidrs: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.ipVsExcludeCidrs),
    ip_vs_min_sync_period: cdktf.stringToTerraform(struct!.ipVsMinSyncPeriod),
    ip_vs_scheduler: cdktf.stringToTerraform(struct!.ipVsScheduler),
    ip_vs_sync_period: cdktf.stringToTerraform(struct!.ipVsSyncPeriod),
    log_level: cdktf.numberToTerraform(struct!.logLevel),
    master: cdktf.stringToTerraform(struct!.master),
    memory_limit: cdktf.stringToTerraform(struct!.memoryLimit),
    memory_request: cdktf.stringToTerraform(struct!.memoryRequest),
    metrics_bind_address: cdktf.stringToTerraform(struct!.metricsBindAddress),
    proxy_mode: cdktf.stringToTerraform(struct!.proxyMode),
  }
}


export function clusterKubeProxyToHclTerraform(struct?: ClusterKubeProxyOutputReference | ClusterKubeProxy): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_address: {
      value: cdktf.stringToHclTerraform(struct!.bindAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cluster_cidr: {
      value: cdktf.stringToHclTerraform(struct!.clusterCidr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    conntrack_max_per_core: {
      value: cdktf.numberToHclTerraform(struct!.conntrackMaxPerCore),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    conntrack_min: {
      value: cdktf.numberToHclTerraform(struct!.conntrackMin),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    cpu_limit: {
      value: cdktf.stringToHclTerraform(struct!.cpuLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cpu_request: {
      value: cdktf.stringToHclTerraform(struct!.cpuRequest),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    feature_gates: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.featureGates),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    hostname_override: {
      value: cdktf.stringToHclTerraform(struct!.hostnameOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    image: {
      value: cdktf.stringToHclTerraform(struct!.image),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_vs_exclude_cidrs: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.ipVsExcludeCidrs),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    ip_vs_min_sync_period: {
      value: cdktf.stringToHclTerraform(struct!.ipVsMinSyncPeriod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_vs_scheduler: {
      value: cdktf.stringToHclTerraform(struct!.ipVsScheduler),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_vs_sync_period: {
      value: cdktf.stringToHclTerraform(struct!.ipVsSyncPeriod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_level: {
      value: cdktf.numberToHclTerraform(struct!.logLevel),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    master: {
      value: cdktf.stringToHclTerraform(struct!.master),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    memory_limit: {
      value: cdktf.stringToHclTerraform(struct!.memoryLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    memory_request: {
      value: cdktf.stringToHclTerraform(struct!.memoryRequest),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metrics_bind_address: {
      value: cdktf.stringToHclTerraform(struct!.metricsBindAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    proxy_mode: {
      value: cdktf.stringToHclTerraform(struct!.proxyMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterKubeProxyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterKubeProxy | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindAddress = this._bindAddress;
    }
    if (this._clusterCidr !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterCidr = this._clusterCidr;
    }
    if (this._conntrackMaxPerCore !== undefined) {
      hasAnyValues = true;
      internalValueResult.conntrackMaxPerCore = this._conntrackMaxPerCore;
    }
    if (this._conntrackMin !== undefined) {
      hasAnyValues = true;
      internalValueResult.conntrackMin = this._conntrackMin;
    }
    if (this._cpuLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpuLimit = this._cpuLimit;
    }
    if (this._cpuRequest !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpuRequest = this._cpuRequest;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._featureGates !== undefined) {
      hasAnyValues = true;
      internalValueResult.featureGates = this._featureGates;
    }
    if (this._hostnameOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostnameOverride = this._hostnameOverride;
    }
    if (this._image !== undefined) {
      hasAnyValues = true;
      internalValueResult.image = this._image;
    }
    if (this._ipVsExcludeCidrs !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipVsExcludeCidrs = this._ipVsExcludeCidrs;
    }
    if (this._ipVsMinSyncPeriod !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipVsMinSyncPeriod = this._ipVsMinSyncPeriod;
    }
    if (this._ipVsScheduler !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipVsScheduler = this._ipVsScheduler;
    }
    if (this._ipVsSyncPeriod !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipVsSyncPeriod = this._ipVsSyncPeriod;
    }
    if (this._logLevel !== undefined) {
      hasAnyValues = true;
      internalValueResult.logLevel = this._logLevel;
    }
    if (this._master !== undefined) {
      hasAnyValues = true;
      internalValueResult.master = this._master;
    }
    if (this._memoryLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.memoryLimit = this._memoryLimit;
    }
    if (this._memoryRequest !== undefined) {
      hasAnyValues = true;
      internalValueResult.memoryRequest = this._memoryRequest;
    }
    if (this._metricsBindAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.metricsBindAddress = this._metricsBindAddress;
    }
    if (this._proxyMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyMode = this._proxyMode;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterKubeProxy | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindAddress = undefined;
      this._clusterCidr = undefined;
      this._conntrackMaxPerCore = undefined;
      this._conntrackMin = undefined;
      this._cpuLimit = undefined;
      this._cpuRequest = undefined;
      this._enabled = undefined;
      this._featureGates = undefined;
      this._hostnameOverride = undefined;
      this._image = undefined;
      this._ipVsExcludeCidrs = undefined;
      this._ipVsMinSyncPeriod = undefined;
      this._ipVsScheduler = undefined;
      this._ipVsSyncPeriod = undefined;
      this._logLevel = undefined;
      this._master = undefined;
      this._memoryLimit = undefined;
      this._memoryRequest = undefined;
      this._metricsBindAddress = undefined;
      this._proxyMode = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindAddress = value.bindAddress;
      this._clusterCidr = value.clusterCidr;
      this._conntrackMaxPerCore = value.conntrackMaxPerCore;
      this._conntrackMin = value.conntrackMin;
      this._cpuLimit = value.cpuLimit;
      this._cpuRequest = value.cpuRequest;
      this._enabled = value.enabled;
      this._featureGates = value.featureGates;
      this._hostnameOverride = value.hostnameOverride;
      this._image = value.image;
      this._ipVsExcludeCidrs = value.ipVsExcludeCidrs;
      this._ipVsMinSyncPeriod = value.ipVsMinSyncPeriod;
      this._ipVsScheduler = value.ipVsScheduler;
      this._ipVsSyncPeriod = value.ipVsSyncPeriod;
      this._logLevel = value.logLevel;
      this._master = value.master;
      this._memoryLimit = value.memoryLimit;
      this._memoryRequest = value.memoryRequest;
      this._metricsBindAddress = value.metricsBindAddress;
      this._proxyMode = value.proxyMode;
    }
  }

  // bind_address - computed: false, optional: true, required: false
  private _bindAddress?: string; 
  public get bindAddress() {
    return this.getStringAttribute('bind_address');
  }
  public set bindAddress(value: string) {
    this._bindAddress = value;
  }
  public resetBindAddress() {
    this._bindAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindAddressInput() {
    return this._bindAddress;
  }

  // cluster_cidr - computed: false, optional: true, required: false
  private _clusterCidr?: string; 
  public get clusterCidr() {
    return this.getStringAttribute('cluster_cidr');
  }
  public set clusterCidr(value: string) {
    this._clusterCidr = value;
  }
  public resetClusterCidr() {
    this._clusterCidr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterCidrInput() {
    return this._clusterCidr;
  }

  // conntrack_max_per_core - computed: false, optional: true, required: false
  private _conntrackMaxPerCore?: number; 
  public get conntrackMaxPerCore() {
    return this.getNumberAttribute('conntrack_max_per_core');
  }
  public set conntrackMaxPerCore(value: number) {
    this._conntrackMaxPerCore = value;
  }
  public resetConntrackMaxPerCore() {
    this._conntrackMaxPerCore = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get conntrackMaxPerCoreInput() {
    return this._conntrackMaxPerCore;
  }

  // conntrack_min - computed: false, optional: true, required: false
  private _conntrackMin?: number; 
  public get conntrackMin() {
    return this.getNumberAttribute('conntrack_min');
  }
  public set conntrackMin(value: number) {
    this._conntrackMin = value;
  }
  public resetConntrackMin() {
    this._conntrackMin = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get conntrackMinInput() {
    return this._conntrackMin;
  }

  // cpu_limit - computed: false, optional: true, required: false
  private _cpuLimit?: string; 
  public get cpuLimit() {
    return this.getStringAttribute('cpu_limit');
  }
  public set cpuLimit(value: string) {
    this._cpuLimit = value;
  }
  public resetCpuLimit() {
    this._cpuLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuLimitInput() {
    return this._cpuLimit;
  }

  // cpu_request - computed: false, optional: true, required: false
  private _cpuRequest?: string; 
  public get cpuRequest() {
    return this.getStringAttribute('cpu_request');
  }
  public set cpuRequest(value: string) {
    this._cpuRequest = value;
  }
  public resetCpuRequest() {
    this._cpuRequest = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuRequestInput() {
    return this._cpuRequest;
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // feature_gates - computed: false, optional: true, required: false
  private _featureGates?: { [key: string]: string }; 
  public get featureGates() {
    return this.getStringMapAttribute('feature_gates');
  }
  public set featureGates(value: { [key: string]: string }) {
    this._featureGates = value;
  }
  public resetFeatureGates() {
    this._featureGates = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get featureGatesInput() {
    return this._featureGates;
  }

  // hostname_override - computed: false, optional: true, required: false
  private _hostnameOverride?: string; 
  public get hostnameOverride() {
    return this.getStringAttribute('hostname_override');
  }
  public set hostnameOverride(value: string) {
    this._hostnameOverride = value;
  }
  public resetHostnameOverride() {
    this._hostnameOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameOverrideInput() {
    return this._hostnameOverride;
  }

  // image - computed: false, optional: true, required: false
  private _image?: string; 
  public get image() {
    return this.getStringAttribute('image');
  }
  public set image(value: string) {
    this._image = value;
  }
  public resetImage() {
    this._image = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageInput() {
    return this._image;
  }

  // ip_vs_exclude_cidrs - computed: false, optional: true, required: false
  private _ipVsExcludeCidrs?: string[]; 
  public get ipVsExcludeCidrs() {
    return this.getListAttribute('ip_vs_exclude_cidrs');
  }
  public set ipVsExcludeCidrs(value: string[]) {
    this._ipVsExcludeCidrs = value;
  }
  public resetIpVsExcludeCidrs() {
    this._ipVsExcludeCidrs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipVsExcludeCidrsInput() {
    return this._ipVsExcludeCidrs;
  }

  // ip_vs_min_sync_period - computed: false, optional: true, required: false
  private _ipVsMinSyncPeriod?: string; 
  public get ipVsMinSyncPeriod() {
    return this.getStringAttribute('ip_vs_min_sync_period');
  }
  public set ipVsMinSyncPeriod(value: string) {
    this._ipVsMinSyncPeriod = value;
  }
  public resetIpVsMinSyncPeriod() {
    this._ipVsMinSyncPeriod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipVsMinSyncPeriodInput() {
    return this._ipVsMinSyncPeriod;
  }

  // ip_vs_scheduler - computed: false, optional: true, required: false
  private _ipVsScheduler?: string; 
  public get ipVsScheduler() {
    return this.getStringAttribute('ip_vs_scheduler');
  }
  public set ipVsScheduler(value: string) {
    this._ipVsScheduler = value;
  }
  public resetIpVsScheduler() {
    this._ipVsScheduler = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipVsSchedulerInput() {
    return this._ipVsScheduler;
  }

  // ip_vs_sync_period - computed: false, optional: true, required: false
  private _ipVsSyncPeriod?: string; 
  public get ipVsSyncPeriod() {
    return this.getStringAttribute('ip_vs_sync_period');
  }
  public set ipVsSyncPeriod(value: string) {
    this._ipVsSyncPeriod = value;
  }
  public resetIpVsSyncPeriod() {
    this._ipVsSyncPeriod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipVsSyncPeriodInput() {
    return this._ipVsSyncPeriod;
  }

  // log_level - computed: false, optional: true, required: false
  private _logLevel?: number; 
  public get logLevel() {
    return this.getNumberAttribute('log_level');
  }
  public set logLevel(value: number) {
    this._logLevel = value;
  }
  public resetLogLevel() {
    this._logLevel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logLevelInput() {
    return this._logLevel;
  }

  // master - computed: false, optional: true, required: false
  private _master?: string; 
  public get master() {
    return this.getStringAttribute('master');
  }
  public set master(value: string) {
    this._master = value;
  }
  public resetMaster() {
    this._master = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get masterInput() {
    return this._master;
  }

  // memory_limit - computed: false, optional: true, required: false
  private _memoryLimit?: string; 
  public get memoryLimit() {
    return this.getStringAttribute('memory_limit');
  }
  public set memoryLimit(value: string) {
    this._memoryLimit = value;
  }
  public resetMemoryLimit() {
    this._memoryLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryLimitInput() {
    return this._memoryLimit;
  }

  // memory_request - computed: false, optional: true, required: false
  private _memoryRequest?: string; 
  public get memoryRequest() {
    return this.getStringAttribute('memory_request');
  }
  public set memoryRequest(value: string) {
    this._memoryRequest = value;
  }
  public resetMemoryRequest() {
    this._memoryRequest = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryRequestInput() {
    return this._memoryRequest;
  }

  // metrics_bind_address - computed: false, optional: true, required: false
  private _metricsBindAddress?: string; 
  public get metricsBindAddress() {
    return this.getStringAttribute('metrics_bind_address');
  }
  public set metricsBindAddress(value: string) {
    this._metricsBindAddress = value;
  }
  public resetMetricsBindAddress() {
    this._metricsBindAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricsBindAddressInput() {
    return this._metricsBindAddress;
  }

  // proxy_mode - computed: false, optional: true, required: false
  private _proxyMode?: string; 
  public get proxyMode() {
    return this.getStringAttribute('proxy_mode');
  }
  public set proxyMode(value: string) {
    this._proxyMode = value;
  }
  public resetProxyMode() {
    this._proxyMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyModeInput() {
    return this._proxyMode;
  }
}
export interface ClusterKubeSchedulerLeaderElection {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#leader_elect Cluster#leader_elect}
  */
  readonly leaderElect?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#leader_elect_lease_duration Cluster#leader_elect_lease_duration}
  */
  readonly leaderElectLeaseDuration?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#leader_elect_renew_deadline_duration Cluster#leader_elect_renew_deadline_duration}
  */
  readonly leaderElectRenewDeadlineDuration?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#leader_elect_resource_lock Cluster#leader_elect_resource_lock}
  */
  readonly leaderElectResourceLock?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#leader_elect_resource_name Cluster#leader_elect_resource_name}
  */
  readonly leaderElectResourceName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#leader_elect_resource_namespace Cluster#leader_elect_resource_namespace}
  */
  readonly leaderElectResourceNamespace?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#leader_elect_retry_period Cluster#leader_elect_retry_period}
  */
  readonly leaderElectRetryPeriod?: string;
}

export function clusterKubeSchedulerLeaderElectionToTerraform(struct?: ClusterKubeSchedulerLeaderElectionOutputReference | ClusterKubeSchedulerLeaderElection): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    leader_elect: cdktf.booleanToTerraform(struct!.leaderElect),
    leader_elect_lease_duration: cdktf.stringToTerraform(struct!.leaderElectLeaseDuration),
    leader_elect_renew_deadline_duration: cdktf.stringToTerraform(struct!.leaderElectRenewDeadlineDuration),
    leader_elect_resource_lock: cdktf.stringToTerraform(struct!.leaderElectResourceLock),
    leader_elect_resource_name: cdktf.stringToTerraform(struct!.leaderElectResourceName),
    leader_elect_resource_namespace: cdktf.stringToTerraform(struct!.leaderElectResourceNamespace),
    leader_elect_retry_period: cdktf.stringToTerraform(struct!.leaderElectRetryPeriod),
  }
}


export function clusterKubeSchedulerLeaderElectionToHclTerraform(struct?: ClusterKubeSchedulerLeaderElectionOutputReference | ClusterKubeSchedulerLeaderElection): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    leader_elect: {
      value: cdktf.booleanToHclTerraform(struct!.leaderElect),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    leader_elect_lease_duration: {
      value: cdktf.stringToHclTerraform(struct!.leaderElectLeaseDuration),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    leader_elect_renew_deadline_duration: {
      value: cdktf.stringToHclTerraform(struct!.leaderElectRenewDeadlineDuration),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    leader_elect_resource_lock: {
      value: cdktf.stringToHclTerraform(struct!.leaderElectResourceLock),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    leader_elect_resource_name: {
      value: cdktf.stringToHclTerraform(struct!.leaderElectResourceName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    leader_elect_resource_namespace: {
      value: cdktf.stringToHclTerraform(struct!.leaderElectResourceNamespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    leader_elect_retry_period: {
      value: cdktf.stringToHclTerraform(struct!.leaderElectRetryPeriod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterKubeSchedulerLeaderElectionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterKubeSchedulerLeaderElection | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._leaderElect !== undefined) {
      hasAnyValues = true;
      internalValueResult.leaderElect = this._leaderElect;
    }
    if (this._leaderElectLeaseDuration !== undefined) {
      hasAnyValues = true;
      internalValueResult.leaderElectLeaseDuration = this._leaderElectLeaseDuration;
    }
    if (this._leaderElectRenewDeadlineDuration !== undefined) {
      hasAnyValues = true;
      internalValueResult.leaderElectRenewDeadlineDuration = this._leaderElectRenewDeadlineDuration;
    }
    if (this._leaderElectResourceLock !== undefined) {
      hasAnyValues = true;
      internalValueResult.leaderElectResourceLock = this._leaderElectResourceLock;
    }
    if (this._leaderElectResourceName !== undefined) {
      hasAnyValues = true;
      internalValueResult.leaderElectResourceName = this._leaderElectResourceName;
    }
    if (this._leaderElectResourceNamespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.leaderElectResourceNamespace = this._leaderElectResourceNamespace;
    }
    if (this._leaderElectRetryPeriod !== undefined) {
      hasAnyValues = true;
      internalValueResult.leaderElectRetryPeriod = this._leaderElectRetryPeriod;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterKubeSchedulerLeaderElection | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._leaderElect = undefined;
      this._leaderElectLeaseDuration = undefined;
      this._leaderElectRenewDeadlineDuration = undefined;
      this._leaderElectResourceLock = undefined;
      this._leaderElectResourceName = undefined;
      this._leaderElectResourceNamespace = undefined;
      this._leaderElectRetryPeriod = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._leaderElect = value.leaderElect;
      this._leaderElectLeaseDuration = value.leaderElectLeaseDuration;
      this._leaderElectRenewDeadlineDuration = value.leaderElectRenewDeadlineDuration;
      this._leaderElectResourceLock = value.leaderElectResourceLock;
      this._leaderElectResourceName = value.leaderElectResourceName;
      this._leaderElectResourceNamespace = value.leaderElectResourceNamespace;
      this._leaderElectRetryPeriod = value.leaderElectRetryPeriod;
    }
  }

  // leader_elect - computed: false, optional: true, required: false
  private _leaderElect?: boolean | cdktf.IResolvable; 
  public get leaderElect() {
    return this.getBooleanAttribute('leader_elect');
  }
  public set leaderElect(value: boolean | cdktf.IResolvable) {
    this._leaderElect = value;
  }
  public resetLeaderElect() {
    this._leaderElect = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get leaderElectInput() {
    return this._leaderElect;
  }

  // leader_elect_lease_duration - computed: false, optional: true, required: false
  private _leaderElectLeaseDuration?: string; 
  public get leaderElectLeaseDuration() {
    return this.getStringAttribute('leader_elect_lease_duration');
  }
  public set leaderElectLeaseDuration(value: string) {
    this._leaderElectLeaseDuration = value;
  }
  public resetLeaderElectLeaseDuration() {
    this._leaderElectLeaseDuration = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get leaderElectLeaseDurationInput() {
    return this._leaderElectLeaseDuration;
  }

  // leader_elect_renew_deadline_duration - computed: false, optional: true, required: false
  private _leaderElectRenewDeadlineDuration?: string; 
  public get leaderElectRenewDeadlineDuration() {
    return this.getStringAttribute('leader_elect_renew_deadline_duration');
  }
  public set leaderElectRenewDeadlineDuration(value: string) {
    this._leaderElectRenewDeadlineDuration = value;
  }
  public resetLeaderElectRenewDeadlineDuration() {
    this._leaderElectRenewDeadlineDuration = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get leaderElectRenewDeadlineDurationInput() {
    return this._leaderElectRenewDeadlineDuration;
  }

  // leader_elect_resource_lock - computed: false, optional: true, required: false
  private _leaderElectResourceLock?: string; 
  public get leaderElectResourceLock() {
    return this.getStringAttribute('leader_elect_resource_lock');
  }
  public set leaderElectResourceLock(value: string) {
    this._leaderElectResourceLock = value;
  }
  public resetLeaderElectResourceLock() {
    this._leaderElectResourceLock = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get leaderElectResourceLockInput() {
    return this._leaderElectResourceLock;
  }

  // leader_elect_resource_name - computed: false, optional: true, required: false
  private _leaderElectResourceName?: string; 
  public get leaderElectResourceName() {
    return this.getStringAttribute('leader_elect_resource_name');
  }
  public set leaderElectResourceName(value: string) {
    this._leaderElectResourceName = value;
  }
  public resetLeaderElectResourceName() {
    this._leaderElectResourceName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get leaderElectResourceNameInput() {
    return this._leaderElectResourceName;
  }

  // leader_elect_resource_namespace - computed: false, optional: true, required: false
  private _leaderElectResourceNamespace?: string; 
  public get leaderElectResourceNamespace() {
    return this.getStringAttribute('leader_elect_resource_namespace');
  }
  public set leaderElectResourceNamespace(value: string) {
    this._leaderElectResourceNamespace = value;
  }
  public resetLeaderElectResourceNamespace() {
    this._leaderElectResourceNamespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get leaderElectResourceNamespaceInput() {
    return this._leaderElectResourceNamespace;
  }

  // leader_elect_retry_period - computed: false, optional: true, required: false
  private _leaderElectRetryPeriod?: string; 
  public get leaderElectRetryPeriod() {
    return this.getStringAttribute('leader_elect_retry_period');
  }
  public set leaderElectRetryPeriod(value: string) {
    this._leaderElectRetryPeriod = value;
  }
  public resetLeaderElectRetryPeriod() {
    this._leaderElectRetryPeriod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get leaderElectRetryPeriodInput() {
    return this._leaderElectRetryPeriod;
  }
}
export interface ClusterKubeScheduler {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#authentication_kubeconfig Cluster#authentication_kubeconfig}
  */
  readonly authenticationKubeconfig?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#authorization_always_allow_paths Cluster#authorization_always_allow_paths}
  */
  readonly authorizationAlwaysAllowPaths?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#authorization_kubeconfig Cluster#authorization_kubeconfig}
  */
  readonly authorizationKubeconfig?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#burst Cluster#burst}
  */
  readonly burst?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#enable_profiling Cluster#enable_profiling}
  */
  readonly enableProfiling?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#feature_gates Cluster#feature_gates}
  */
  readonly featureGates?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#image Cluster#image}
  */
  readonly image?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#log_format Cluster#log_format}
  */
  readonly logFormat?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#log_level Cluster#log_level}
  */
  readonly logLevel?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#master Cluster#master}
  */
  readonly master?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#max_persistent_volumes Cluster#max_persistent_volumes}
  */
  readonly maxPersistentVolumes?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#qps Cluster#qps}
  */
  readonly qps?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#tls_cert_file Cluster#tls_cert_file}
  */
  readonly tlsCertFile?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#tls_private_key_file Cluster#tls_private_key_file}
  */
  readonly tlsPrivateKeyFile?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#use_policy_config_map Cluster#use_policy_config_map}
  */
  readonly usePolicyConfigMap?: boolean | cdktf.IResolvable;
  /**
  * leader_election block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#leader_election Cluster#leader_election}
  */
  readonly leaderElection?: ClusterKubeSchedulerLeaderElection;
}

export function clusterKubeSchedulerToTerraform(struct?: ClusterKubeSchedulerOutputReference | ClusterKubeScheduler): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    authentication_kubeconfig: cdktf.stringToTerraform(struct!.authenticationKubeconfig),
    authorization_always_allow_paths: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.authorizationAlwaysAllowPaths),
    authorization_kubeconfig: cdktf.stringToTerraform(struct!.authorizationKubeconfig),
    burst: cdktf.numberToTerraform(struct!.burst),
    enable_profiling: cdktf.booleanToTerraform(struct!.enableProfiling),
    feature_gates: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.featureGates),
    image: cdktf.stringToTerraform(struct!.image),
    log_format: cdktf.stringToTerraform(struct!.logFormat),
    log_level: cdktf.numberToTerraform(struct!.logLevel),
    master: cdktf.stringToTerraform(struct!.master),
    max_persistent_volumes: cdktf.numberToTerraform(struct!.maxPersistentVolumes),
    qps: cdktf.stringToTerraform(struct!.qps),
    tls_cert_file: cdktf.stringToTerraform(struct!.tlsCertFile),
    tls_private_key_file: cdktf.stringToTerraform(struct!.tlsPrivateKeyFile),
    use_policy_config_map: cdktf.booleanToTerraform(struct!.usePolicyConfigMap),
    leader_election: clusterKubeSchedulerLeaderElectionToTerraform(struct!.leaderElection),
  }
}


export function clusterKubeSchedulerToHclTerraform(struct?: ClusterKubeSchedulerOutputReference | ClusterKubeScheduler): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    authentication_kubeconfig: {
      value: cdktf.stringToHclTerraform(struct!.authenticationKubeconfig),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    authorization_always_allow_paths: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.authorizationAlwaysAllowPaths),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    authorization_kubeconfig: {
      value: cdktf.stringToHclTerraform(struct!.authorizationKubeconfig),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    burst: {
      value: cdktf.numberToHclTerraform(struct!.burst),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    enable_profiling: {
      value: cdktf.booleanToHclTerraform(struct!.enableProfiling),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    feature_gates: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.featureGates),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    image: {
      value: cdktf.stringToHclTerraform(struct!.image),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_format: {
      value: cdktf.stringToHclTerraform(struct!.logFormat),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_level: {
      value: cdktf.numberToHclTerraform(struct!.logLevel),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    master: {
      value: cdktf.stringToHclTerraform(struct!.master),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_persistent_volumes: {
      value: cdktf.numberToHclTerraform(struct!.maxPersistentVolumes),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    qps: {
      value: cdktf.stringToHclTerraform(struct!.qps),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls_cert_file: {
      value: cdktf.stringToHclTerraform(struct!.tlsCertFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls_private_key_file: {
      value: cdktf.stringToHclTerraform(struct!.tlsPrivateKeyFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_policy_config_map: {
      value: cdktf.booleanToHclTerraform(struct!.usePolicyConfigMap),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    leader_election: {
      value: clusterKubeSchedulerLeaderElectionToHclTerraform(struct!.leaderElection),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterKubeSchedulerLeaderElectionList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterKubeSchedulerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterKubeScheduler | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authenticationKubeconfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.authenticationKubeconfig = this._authenticationKubeconfig;
    }
    if (this._authorizationAlwaysAllowPaths !== undefined) {
      hasAnyValues = true;
      internalValueResult.authorizationAlwaysAllowPaths = this._authorizationAlwaysAllowPaths;
    }
    if (this._authorizationKubeconfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.authorizationKubeconfig = this._authorizationKubeconfig;
    }
    if (this._burst !== undefined) {
      hasAnyValues = true;
      internalValueResult.burst = this._burst;
    }
    if (this._enableProfiling !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableProfiling = this._enableProfiling;
    }
    if (this._featureGates !== undefined) {
      hasAnyValues = true;
      internalValueResult.featureGates = this._featureGates;
    }
    if (this._image !== undefined) {
      hasAnyValues = true;
      internalValueResult.image = this._image;
    }
    if (this._logFormat !== undefined) {
      hasAnyValues = true;
      internalValueResult.logFormat = this._logFormat;
    }
    if (this._logLevel !== undefined) {
      hasAnyValues = true;
      internalValueResult.logLevel = this._logLevel;
    }
    if (this._master !== undefined) {
      hasAnyValues = true;
      internalValueResult.master = this._master;
    }
    if (this._maxPersistentVolumes !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPersistentVolumes = this._maxPersistentVolumes;
    }
    if (this._qps !== undefined) {
      hasAnyValues = true;
      internalValueResult.qps = this._qps;
    }
    if (this._tlsCertFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsCertFile = this._tlsCertFile;
    }
    if (this._tlsPrivateKeyFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsPrivateKeyFile = this._tlsPrivateKeyFile;
    }
    if (this._usePolicyConfigMap !== undefined) {
      hasAnyValues = true;
      internalValueResult.usePolicyConfigMap = this._usePolicyConfigMap;
    }
    if (this._leaderElection?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.leaderElection = this._leaderElection?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterKubeScheduler | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._authenticationKubeconfig = undefined;
      this._authorizationAlwaysAllowPaths = undefined;
      this._authorizationKubeconfig = undefined;
      this._burst = undefined;
      this._enableProfiling = undefined;
      this._featureGates = undefined;
      this._image = undefined;
      this._logFormat = undefined;
      this._logLevel = undefined;
      this._master = undefined;
      this._maxPersistentVolumes = undefined;
      this._qps = undefined;
      this._tlsCertFile = undefined;
      this._tlsPrivateKeyFile = undefined;
      this._usePolicyConfigMap = undefined;
      this._leaderElection.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._authenticationKubeconfig = value.authenticationKubeconfig;
      this._authorizationAlwaysAllowPaths = value.authorizationAlwaysAllowPaths;
      this._authorizationKubeconfig = value.authorizationKubeconfig;
      this._burst = value.burst;
      this._enableProfiling = value.enableProfiling;
      this._featureGates = value.featureGates;
      this._image = value.image;
      this._logFormat = value.logFormat;
      this._logLevel = value.logLevel;
      this._master = value.master;
      this._maxPersistentVolumes = value.maxPersistentVolumes;
      this._qps = value.qps;
      this._tlsCertFile = value.tlsCertFile;
      this._tlsPrivateKeyFile = value.tlsPrivateKeyFile;
      this._usePolicyConfigMap = value.usePolicyConfigMap;
      this._leaderElection.internalValue = value.leaderElection;
    }
  }

  // authentication_kubeconfig - computed: false, optional: true, required: false
  private _authenticationKubeconfig?: string; 
  public get authenticationKubeconfig() {
    return this.getStringAttribute('authentication_kubeconfig');
  }
  public set authenticationKubeconfig(value: string) {
    this._authenticationKubeconfig = value;
  }
  public resetAuthenticationKubeconfig() {
    this._authenticationKubeconfig = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authenticationKubeconfigInput() {
    return this._authenticationKubeconfig;
  }

  // authorization_always_allow_paths - computed: false, optional: true, required: false
  private _authorizationAlwaysAllowPaths?: string[]; 
  public get authorizationAlwaysAllowPaths() {
    return this.getListAttribute('authorization_always_allow_paths');
  }
  public set authorizationAlwaysAllowPaths(value: string[]) {
    this._authorizationAlwaysAllowPaths = value;
  }
  public resetAuthorizationAlwaysAllowPaths() {
    this._authorizationAlwaysAllowPaths = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authorizationAlwaysAllowPathsInput() {
    return this._authorizationAlwaysAllowPaths;
  }

  // authorization_kubeconfig - computed: false, optional: true, required: false
  private _authorizationKubeconfig?: string; 
  public get authorizationKubeconfig() {
    return this.getStringAttribute('authorization_kubeconfig');
  }
  public set authorizationKubeconfig(value: string) {
    this._authorizationKubeconfig = value;
  }
  public resetAuthorizationKubeconfig() {
    this._authorizationKubeconfig = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authorizationKubeconfigInput() {
    return this._authorizationKubeconfig;
  }

  // burst - computed: false, optional: true, required: false
  private _burst?: number; 
  public get burst() {
    return this.getNumberAttribute('burst');
  }
  public set burst(value: number) {
    this._burst = value;
  }
  public resetBurst() {
    this._burst = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get burstInput() {
    return this._burst;
  }

  // enable_profiling - computed: false, optional: true, required: false
  private _enableProfiling?: boolean | cdktf.IResolvable; 
  public get enableProfiling() {
    return this.getBooleanAttribute('enable_profiling');
  }
  public set enableProfiling(value: boolean | cdktf.IResolvable) {
    this._enableProfiling = value;
  }
  public resetEnableProfiling() {
    this._enableProfiling = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableProfilingInput() {
    return this._enableProfiling;
  }

  // feature_gates - computed: false, optional: true, required: false
  private _featureGates?: { [key: string]: string }; 
  public get featureGates() {
    return this.getStringMapAttribute('feature_gates');
  }
  public set featureGates(value: { [key: string]: string }) {
    this._featureGates = value;
  }
  public resetFeatureGates() {
    this._featureGates = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get featureGatesInput() {
    return this._featureGates;
  }

  // image - computed: false, optional: true, required: false
  private _image?: string; 
  public get image() {
    return this.getStringAttribute('image');
  }
  public set image(value: string) {
    this._image = value;
  }
  public resetImage() {
    this._image = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageInput() {
    return this._image;
  }

  // log_format - computed: false, optional: true, required: false
  private _logFormat?: string; 
  public get logFormat() {
    return this.getStringAttribute('log_format');
  }
  public set logFormat(value: string) {
    this._logFormat = value;
  }
  public resetLogFormat() {
    this._logFormat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logFormatInput() {
    return this._logFormat;
  }

  // log_level - computed: false, optional: true, required: false
  private _logLevel?: number; 
  public get logLevel() {
    return this.getNumberAttribute('log_level');
  }
  public set logLevel(value: number) {
    this._logLevel = value;
  }
  public resetLogLevel() {
    this._logLevel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logLevelInput() {
    return this._logLevel;
  }

  // master - computed: false, optional: true, required: false
  private _master?: string; 
  public get master() {
    return this.getStringAttribute('master');
  }
  public set master(value: string) {
    this._master = value;
  }
  public resetMaster() {
    this._master = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get masterInput() {
    return this._master;
  }

  // max_persistent_volumes - computed: false, optional: true, required: false
  private _maxPersistentVolumes?: number; 
  public get maxPersistentVolumes() {
    return this.getNumberAttribute('max_persistent_volumes');
  }
  public set maxPersistentVolumes(value: number) {
    this._maxPersistentVolumes = value;
  }
  public resetMaxPersistentVolumes() {
    this._maxPersistentVolumes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPersistentVolumesInput() {
    return this._maxPersistentVolumes;
  }

  // qps - computed: false, optional: true, required: false
  private _qps?: string; 
  public get qps() {
    return this.getStringAttribute('qps');
  }
  public set qps(value: string) {
    this._qps = value;
  }
  public resetQps() {
    this._qps = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get qpsInput() {
    return this._qps;
  }

  // tls_cert_file - computed: false, optional: true, required: false
  private _tlsCertFile?: string; 
  public get tlsCertFile() {
    return this.getStringAttribute('tls_cert_file');
  }
  public set tlsCertFile(value: string) {
    this._tlsCertFile = value;
  }
  public resetTlsCertFile() {
    this._tlsCertFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsCertFileInput() {
    return this._tlsCertFile;
  }

  // tls_private_key_file - computed: false, optional: true, required: false
  private _tlsPrivateKeyFile?: string; 
  public get tlsPrivateKeyFile() {
    return this.getStringAttribute('tls_private_key_file');
  }
  public set tlsPrivateKeyFile(value: string) {
    this._tlsPrivateKeyFile = value;
  }
  public resetTlsPrivateKeyFile() {
    this._tlsPrivateKeyFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsPrivateKeyFileInput() {
    return this._tlsPrivateKeyFile;
  }

  // use_policy_config_map - computed: false, optional: true, required: false
  private _usePolicyConfigMap?: boolean | cdktf.IResolvable; 
  public get usePolicyConfigMap() {
    return this.getBooleanAttribute('use_policy_config_map');
  }
  public set usePolicyConfigMap(value: boolean | cdktf.IResolvable) {
    this._usePolicyConfigMap = value;
  }
  public resetUsePolicyConfigMap() {
    this._usePolicyConfigMap = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usePolicyConfigMapInput() {
    return this._usePolicyConfigMap;
  }

  // leader_election - computed: false, optional: true, required: false
  private _leaderElection = new ClusterKubeSchedulerLeaderElectionOutputReference(this, "leader_election");
  public get leaderElection() {
    return this._leaderElection;
  }
  public putLeaderElection(value: ClusterKubeSchedulerLeaderElection) {
    this._leaderElection.internalValue = value;
  }
  public resetLeaderElection() {
    this._leaderElection.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get leaderElectionInput() {
    return this._leaderElection.internalValue;
  }
}
export interface ClusterKubeletAnonymousAuth {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#value Cluster#value}
  */
  readonly value?: boolean | cdktf.IResolvable;
}

export function clusterKubeletAnonymousAuthToTerraform(struct?: ClusterKubeletAnonymousAuthOutputReference | ClusterKubeletAnonymousAuth): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value: cdktf.booleanToTerraform(struct!.value),
  }
}


export function clusterKubeletAnonymousAuthToHclTerraform(struct?: ClusterKubeletAnonymousAuthOutputReference | ClusterKubeletAnonymousAuth): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value: {
      value: cdktf.booleanToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterKubeletAnonymousAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterKubeletAnonymousAuth | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterKubeletAnonymousAuth | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._value = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._value = value.value;
    }
  }

  // value - computed: false, optional: true, required: false
  private _value?: boolean | cdktf.IResolvable; 
  public get value() {
    return this.getBooleanAttribute('value');
  }
  public set value(value: boolean | cdktf.IResolvable) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface ClusterKubeletCpuCfsQuota {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#value Cluster#value}
  */
  readonly value?: boolean | cdktf.IResolvable;
}

export function clusterKubeletCpuCfsQuotaToTerraform(struct?: ClusterKubeletCpuCfsQuotaOutputReference | ClusterKubeletCpuCfsQuota): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value: cdktf.booleanToTerraform(struct!.value),
  }
}


export function clusterKubeletCpuCfsQuotaToHclTerraform(struct?: ClusterKubeletCpuCfsQuotaOutputReference | ClusterKubeletCpuCfsQuota): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value: {
      value: cdktf.booleanToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterKubeletCpuCfsQuotaOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterKubeletCpuCfsQuota | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterKubeletCpuCfsQuota | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._value = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._value = value.value;
    }
  }

  // value - computed: false, optional: true, required: false
  private _value?: boolean | cdktf.IResolvable; 
  public get value() {
    return this.getBooleanAttribute('value');
  }
  public set value(value: boolean | cdktf.IResolvable) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface ClusterKubelet {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#allow_privileged Cluster#allow_privileged}
  */
  readonly allowPrivileged?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#allowed_unsafe_sysctls Cluster#allowed_unsafe_sysctls}
  */
  readonly allowedUnsafeSysctls?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#api_servers Cluster#api_servers}
  */
  readonly apiServers?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#authentication_token_webhook Cluster#authentication_token_webhook}
  */
  readonly authenticationTokenWebhook?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#authentication_token_webhook_cache_ttl Cluster#authentication_token_webhook_cache_ttl}
  */
  readonly authenticationTokenWebhookCacheTtl?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#authorization_mode Cluster#authorization_mode}
  */
  readonly authorizationMode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#babysit_daemons Cluster#babysit_daemons}
  */
  readonly babysitDaemons?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#bootstrap_kubeconfig Cluster#bootstrap_kubeconfig}
  */
  readonly bootstrapKubeconfig?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#cgroup_driver Cluster#cgroup_driver}
  */
  readonly cgroupDriver?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#cgroup_root Cluster#cgroup_root}
  */
  readonly cgroupRoot?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#client_ca_file Cluster#client_ca_file}
  */
  readonly clientCaFile?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#cloud_provider Cluster#cloud_provider}
  */
  readonly cloudProvider?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#cluster_dns Cluster#cluster_dns}
  */
  readonly clusterDns?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#cluster_domain Cluster#cluster_domain}
  */
  readonly clusterDomain?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#configure_cbr0 Cluster#configure_cbr0}
  */
  readonly configureCbr0?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#container_log_max_files Cluster#container_log_max_files}
  */
  readonly containerLogMaxFiles?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#container_log_max_size Cluster#container_log_max_size}
  */
  readonly containerLogMaxSize?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#cpu_cfs_quota_period Cluster#cpu_cfs_quota_period}
  */
  readonly cpuCfsQuotaPeriod?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#cpu_manager_policy Cluster#cpu_manager_policy}
  */
  readonly cpuManagerPolicy?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#docker_disable_shared_pid Cluster#docker_disable_shared_pid}
  */
  readonly dockerDisableSharedPid?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#enable_cadvisor_json_endpoints Cluster#enable_cadvisor_json_endpoints}
  */
  readonly enableCadvisorJsonEndpoints?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#enable_custom_metrics Cluster#enable_custom_metrics}
  */
  readonly enableCustomMetrics?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#enable_debugging_handlers Cluster#enable_debugging_handlers}
  */
  readonly enableDebuggingHandlers?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#enforce_node_allocatable Cluster#enforce_node_allocatable}
  */
  readonly enforceNodeAllocatable?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#event_burst Cluster#event_burst}
  */
  readonly eventBurst?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#event_qps Cluster#event_qps}
  */
  readonly eventQps?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#eviction_hard Cluster#eviction_hard}
  */
  readonly evictionHard?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#eviction_max_pod_grace_period Cluster#eviction_max_pod_grace_period}
  */
  readonly evictionMaxPodGracePeriod?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#eviction_minimum_reclaim Cluster#eviction_minimum_reclaim}
  */
  readonly evictionMinimumReclaim?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#eviction_pressure_transition_period Cluster#eviction_pressure_transition_period}
  */
  readonly evictionPressureTransitionPeriod?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#eviction_soft Cluster#eviction_soft}
  */
  readonly evictionSoft?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#eviction_soft_grace_period Cluster#eviction_soft_grace_period}
  */
  readonly evictionSoftGracePeriod?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#experimental_allowed_unsafe_sysctls Cluster#experimental_allowed_unsafe_sysctls}
  */
  readonly experimentalAllowedUnsafeSysctls?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#fail_swap_on Cluster#fail_swap_on}
  */
  readonly failSwapOn?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#feature_gates Cluster#feature_gates}
  */
  readonly featureGates?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#hairpin_mode Cluster#hairpin_mode}
  */
  readonly hairpinMode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#hostname_override Cluster#hostname_override}
  */
  readonly hostnameOverride?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#housekeeping_interval Cluster#housekeeping_interval}
  */
  readonly housekeepingInterval?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#image_gc_high_threshold_percent Cluster#image_gc_high_threshold_percent}
  */
  readonly imageGcHighThresholdPercent?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#image_gc_low_threshold_percent Cluster#image_gc_low_threshold_percent}
  */
  readonly imageGcLowThresholdPercent?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#image_pull_progress_deadline Cluster#image_pull_progress_deadline}
  */
  readonly imagePullProgressDeadline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#kernel_memcg_notification Cluster#kernel_memcg_notification}
  */
  readonly kernelMemcgNotification?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#kube_reserved Cluster#kube_reserved}
  */
  readonly kubeReserved?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#kube_reserved_cgroup Cluster#kube_reserved_cgroup}
  */
  readonly kubeReservedCgroup?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#kubeconfig_path Cluster#kubeconfig_path}
  */
  readonly kubeconfigPath?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#kubelet_cgroups Cluster#kubelet_cgroups}
  */
  readonly kubeletCgroups?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#log_format Cluster#log_format}
  */
  readonly logFormat?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#log_level Cluster#log_level}
  */
  readonly logLevel?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#max_pods Cluster#max_pods}
  */
  readonly maxPods?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#network_plugin_mtu Cluster#network_plugin_mtu}
  */
  readonly networkPluginMtu?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#network_plugin_name Cluster#network_plugin_name}
  */
  readonly networkPluginName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#node_labels Cluster#node_labels}
  */
  readonly nodeLabels?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#node_status_update_frequency Cluster#node_status_update_frequency}
  */
  readonly nodeStatusUpdateFrequency?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#non_masquerade_cidr Cluster#non_masquerade_cidr}
  */
  readonly nonMasqueradeCidr?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#nvidia_gp_us Cluster#nvidia_gp_us}
  */
  readonly nvidiaGpUs?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#pod_cidr Cluster#pod_cidr}
  */
  readonly podCidr?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#pod_infra_container_image Cluster#pod_infra_container_image}
  */
  readonly podInfraContainerImage?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#pod_manifest_path Cluster#pod_manifest_path}
  */
  readonly podManifestPath?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#pod_pids_limit Cluster#pod_pids_limit}
  */
  readonly podPidsLimit?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#protect_kernel_defaults Cluster#protect_kernel_defaults}
  */
  readonly protectKernelDefaults?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#read_only_port Cluster#read_only_port}
  */
  readonly readOnlyPort?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#reconcile_cidr Cluster#reconcile_cidr}
  */
  readonly reconcileCidr?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#register_node Cluster#register_node}
  */
  readonly registerNode?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#register_schedulable Cluster#register_schedulable}
  */
  readonly registerSchedulable?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#registry_burst Cluster#registry_burst}
  */
  readonly registryBurst?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#registry_pull_qps Cluster#registry_pull_qps}
  */
  readonly registryPullQps?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#require_kubeconfig Cluster#require_kubeconfig}
  */
  readonly requireKubeconfig?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#resolver_config Cluster#resolver_config}
  */
  readonly resolverConfig?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#root_dir Cluster#root_dir}
  */
  readonly rootDir?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#rotate_certificates Cluster#rotate_certificates}
  */
  readonly rotateCertificates?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#runtime_cgroups Cluster#runtime_cgroups}
  */
  readonly runtimeCgroups?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#runtime_request_timeout Cluster#runtime_request_timeout}
  */
  readonly runtimeRequestTimeout?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#seccomp_profile_root Cluster#seccomp_profile_root}
  */
  readonly seccompProfileRoot?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#serialize_image_pulls Cluster#serialize_image_pulls}
  */
  readonly serializeImagePulls?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#shutdown_grace_period Cluster#shutdown_grace_period}
  */
  readonly shutdownGracePeriod?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#shutdown_grace_period_critical_pods Cluster#shutdown_grace_period_critical_pods}
  */
  readonly shutdownGracePeriodCriticalPods?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#streaming_connection_idle_timeout Cluster#streaming_connection_idle_timeout}
  */
  readonly streamingConnectionIdleTimeout?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#system_cgroups Cluster#system_cgroups}
  */
  readonly systemCgroups?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#system_reserved Cluster#system_reserved}
  */
  readonly systemReserved?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#system_reserved_cgroup Cluster#system_reserved_cgroup}
  */
  readonly systemReservedCgroup?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#taints Cluster#taints}
  */
  readonly taints?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#tls_cert_file Cluster#tls_cert_file}
  */
  readonly tlsCertFile?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#tls_cipher_suites Cluster#tls_cipher_suites}
  */
  readonly tlsCipherSuites?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#tls_min_version Cluster#tls_min_version}
  */
  readonly tlsMinVersion?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#tls_private_key_file Cluster#tls_private_key_file}
  */
  readonly tlsPrivateKeyFile?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#topology_manager_policy Cluster#topology_manager_policy}
  */
  readonly topologyManagerPolicy?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#volume_plugin_directory Cluster#volume_plugin_directory}
  */
  readonly volumePluginDirectory?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#volume_stats_agg_period Cluster#volume_stats_agg_period}
  */
  readonly volumeStatsAggPeriod?: string;
  /**
  * anonymous_auth block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#anonymous_auth Cluster#anonymous_auth}
  */
  readonly anonymousAuth?: ClusterKubeletAnonymousAuth;
  /**
  * cpu_cfs_quota block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#cpu_cfs_quota Cluster#cpu_cfs_quota}
  */
  readonly cpuCfsQuota?: ClusterKubeletCpuCfsQuota;
}

export function clusterKubeletToTerraform(struct?: ClusterKubeletOutputReference | ClusterKubelet): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_privileged: cdktf.booleanToTerraform(struct!.allowPrivileged),
    allowed_unsafe_sysctls: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.allowedUnsafeSysctls),
    api_servers: cdktf.stringToTerraform(struct!.apiServers),
    authentication_token_webhook: cdktf.booleanToTerraform(struct!.authenticationTokenWebhook),
    authentication_token_webhook_cache_ttl: cdktf.stringToTerraform(struct!.authenticationTokenWebhookCacheTtl),
    authorization_mode: cdktf.stringToTerraform(struct!.authorizationMode),
    babysit_daemons: cdktf.booleanToTerraform(struct!.babysitDaemons),
    bootstrap_kubeconfig: cdktf.stringToTerraform(struct!.bootstrapKubeconfig),
    cgroup_driver: cdktf.stringToTerraform(struct!.cgroupDriver),
    cgroup_root: cdktf.stringToTerraform(struct!.cgroupRoot),
    client_ca_file: cdktf.stringToTerraform(struct!.clientCaFile),
    cloud_provider: cdktf.stringToTerraform(struct!.cloudProvider),
    cluster_dns: cdktf.stringToTerraform(struct!.clusterDns),
    cluster_domain: cdktf.stringToTerraform(struct!.clusterDomain),
    configure_cbr0: cdktf.booleanToTerraform(struct!.configureCbr0),
    container_log_max_files: cdktf.numberToTerraform(struct!.containerLogMaxFiles),
    container_log_max_size: cdktf.stringToTerraform(struct!.containerLogMaxSize),
    cpu_cfs_quota_period: cdktf.stringToTerraform(struct!.cpuCfsQuotaPeriod),
    cpu_manager_policy: cdktf.stringToTerraform(struct!.cpuManagerPolicy),
    docker_disable_shared_pid: cdktf.booleanToTerraform(struct!.dockerDisableSharedPid),
    enable_cadvisor_json_endpoints: cdktf.booleanToTerraform(struct!.enableCadvisorJsonEndpoints),
    enable_custom_metrics: cdktf.booleanToTerraform(struct!.enableCustomMetrics),
    enable_debugging_handlers: cdktf.booleanToTerraform(struct!.enableDebuggingHandlers),
    enforce_node_allocatable: cdktf.stringToTerraform(struct!.enforceNodeAllocatable),
    event_burst: cdktf.numberToTerraform(struct!.eventBurst),
    event_qps: cdktf.numberToTerraform(struct!.eventQps),
    eviction_hard: cdktf.stringToTerraform(struct!.evictionHard),
    eviction_max_pod_grace_period: cdktf.numberToTerraform(struct!.evictionMaxPodGracePeriod),
    eviction_minimum_reclaim: cdktf.stringToTerraform(struct!.evictionMinimumReclaim),
    eviction_pressure_transition_period: cdktf.stringToTerraform(struct!.evictionPressureTransitionPeriod),
    eviction_soft: cdktf.stringToTerraform(struct!.evictionSoft),
    eviction_soft_grace_period: cdktf.stringToTerraform(struct!.evictionSoftGracePeriod),
    experimental_allowed_unsafe_sysctls: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.experimentalAllowedUnsafeSysctls),
    fail_swap_on: cdktf.booleanToTerraform(struct!.failSwapOn),
    feature_gates: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.featureGates),
    hairpin_mode: cdktf.stringToTerraform(struct!.hairpinMode),
    hostname_override: cdktf.stringToTerraform(struct!.hostnameOverride),
    housekeeping_interval: cdktf.stringToTerraform(struct!.housekeepingInterval),
    image_gc_high_threshold_percent: cdktf.numberToTerraform(struct!.imageGcHighThresholdPercent),
    image_gc_low_threshold_percent: cdktf.numberToTerraform(struct!.imageGcLowThresholdPercent),
    image_pull_progress_deadline: cdktf.stringToTerraform(struct!.imagePullProgressDeadline),
    kernel_memcg_notification: cdktf.booleanToTerraform(struct!.kernelMemcgNotification),
    kube_reserved: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.kubeReserved),
    kube_reserved_cgroup: cdktf.stringToTerraform(struct!.kubeReservedCgroup),
    kubeconfig_path: cdktf.stringToTerraform(struct!.kubeconfigPath),
    kubelet_cgroups: cdktf.stringToTerraform(struct!.kubeletCgroups),
    log_format: cdktf.stringToTerraform(struct!.logFormat),
    log_level: cdktf.numberToTerraform(struct!.logLevel),
    max_pods: cdktf.numberToTerraform(struct!.maxPods),
    network_plugin_mtu: cdktf.numberToTerraform(struct!.networkPluginMtu),
    network_plugin_name: cdktf.stringToTerraform(struct!.networkPluginName),
    node_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.nodeLabels),
    node_status_update_frequency: cdktf.stringToTerraform(struct!.nodeStatusUpdateFrequency),
    non_masquerade_cidr: cdktf.stringToTerraform(struct!.nonMasqueradeCidr),
    nvidia_gp_us: cdktf.numberToTerraform(struct!.nvidiaGpUs),
    pod_cidr: cdktf.stringToTerraform(struct!.podCidr),
    pod_infra_container_image: cdktf.stringToTerraform(struct!.podInfraContainerImage),
    pod_manifest_path: cdktf.stringToTerraform(struct!.podManifestPath),
    pod_pids_limit: cdktf.numberToTerraform(struct!.podPidsLimit),
    protect_kernel_defaults: cdktf.booleanToTerraform(struct!.protectKernelDefaults),
    read_only_port: cdktf.numberToTerraform(struct!.readOnlyPort),
    reconcile_cidr: cdktf.booleanToTerraform(struct!.reconcileCidr),
    register_node: cdktf.booleanToTerraform(struct!.registerNode),
    register_schedulable: cdktf.booleanToTerraform(struct!.registerSchedulable),
    registry_burst: cdktf.numberToTerraform(struct!.registryBurst),
    registry_pull_qps: cdktf.numberToTerraform(struct!.registryPullQps),
    require_kubeconfig: cdktf.booleanToTerraform(struct!.requireKubeconfig),
    resolver_config: cdktf.stringToTerraform(struct!.resolverConfig),
    root_dir: cdktf.stringToTerraform(struct!.rootDir),
    rotate_certificates: cdktf.booleanToTerraform(struct!.rotateCertificates),
    runtime_cgroups: cdktf.stringToTerraform(struct!.runtimeCgroups),
    runtime_request_timeout: cdktf.stringToTerraform(struct!.runtimeRequestTimeout),
    seccomp_profile_root: cdktf.stringToTerraform(struct!.seccompProfileRoot),
    serialize_image_pulls: cdktf.booleanToTerraform(struct!.serializeImagePulls),
    shutdown_grace_period: cdktf.stringToTerraform(struct!.shutdownGracePeriod),
    shutdown_grace_period_critical_pods: cdktf.stringToTerraform(struct!.shutdownGracePeriodCriticalPods),
    streaming_connection_idle_timeout: cdktf.stringToTerraform(struct!.streamingConnectionIdleTimeout),
    system_cgroups: cdktf.stringToTerraform(struct!.systemCgroups),
    system_reserved: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.systemReserved),
    system_reserved_cgroup: cdktf.stringToTerraform(struct!.systemReservedCgroup),
    taints: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.taints),
    tls_cert_file: cdktf.stringToTerraform(struct!.tlsCertFile),
    tls_cipher_suites: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.tlsCipherSuites),
    tls_min_version: cdktf.stringToTerraform(struct!.tlsMinVersion),
    tls_private_key_file: cdktf.stringToTerraform(struct!.tlsPrivateKeyFile),
    topology_manager_policy: cdktf.stringToTerraform(struct!.topologyManagerPolicy),
    volume_plugin_directory: cdktf.stringToTerraform(struct!.volumePluginDirectory),
    volume_stats_agg_period: cdktf.stringToTerraform(struct!.volumeStatsAggPeriod),
    anonymous_auth: clusterKubeletAnonymousAuthToTerraform(struct!.anonymousAuth),
    cpu_cfs_quota: clusterKubeletCpuCfsQuotaToTerraform(struct!.cpuCfsQuota),
  }
}


export function clusterKubeletToHclTerraform(struct?: ClusterKubeletOutputReference | ClusterKubelet): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_privileged: {
      value: cdktf.booleanToHclTerraform(struct!.allowPrivileged),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    allowed_unsafe_sysctls: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.allowedUnsafeSysctls),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    api_servers: {
      value: cdktf.stringToHclTerraform(struct!.apiServers),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    authentication_token_webhook: {
      value: cdktf.booleanToHclTerraform(struct!.authenticationTokenWebhook),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    authentication_token_webhook_cache_ttl: {
      value: cdktf.stringToHclTerraform(struct!.authenticationTokenWebhookCacheTtl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    authorization_mode: {
      value: cdktf.stringToHclTerraform(struct!.authorizationMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    babysit_daemons: {
      value: cdktf.booleanToHclTerraform(struct!.babysitDaemons),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    bootstrap_kubeconfig: {
      value: cdktf.stringToHclTerraform(struct!.bootstrapKubeconfig),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cgroup_driver: {
      value: cdktf.stringToHclTerraform(struct!.cgroupDriver),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cgroup_root: {
      value: cdktf.stringToHclTerraform(struct!.cgroupRoot),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_ca_file: {
      value: cdktf.stringToHclTerraform(struct!.clientCaFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cloud_provider: {
      value: cdktf.stringToHclTerraform(struct!.cloudProvider),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cluster_dns: {
      value: cdktf.stringToHclTerraform(struct!.clusterDns),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cluster_domain: {
      value: cdktf.stringToHclTerraform(struct!.clusterDomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    configure_cbr0: {
      value: cdktf.booleanToHclTerraform(struct!.configureCbr0),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    container_log_max_files: {
      value: cdktf.numberToHclTerraform(struct!.containerLogMaxFiles),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    container_log_max_size: {
      value: cdktf.stringToHclTerraform(struct!.containerLogMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cpu_cfs_quota_period: {
      value: cdktf.stringToHclTerraform(struct!.cpuCfsQuotaPeriod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cpu_manager_policy: {
      value: cdktf.stringToHclTerraform(struct!.cpuManagerPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    docker_disable_shared_pid: {
      value: cdktf.booleanToHclTerraform(struct!.dockerDisableSharedPid),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_cadvisor_json_endpoints: {
      value: cdktf.booleanToHclTerraform(struct!.enableCadvisorJsonEndpoints),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_custom_metrics: {
      value: cdktf.booleanToHclTerraform(struct!.enableCustomMetrics),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_debugging_handlers: {
      value: cdktf.booleanToHclTerraform(struct!.enableDebuggingHandlers),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enforce_node_allocatable: {
      value: cdktf.stringToHclTerraform(struct!.enforceNodeAllocatable),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    event_burst: {
      value: cdktf.numberToHclTerraform(struct!.eventBurst),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    event_qps: {
      value: cdktf.numberToHclTerraform(struct!.eventQps),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    eviction_hard: {
      value: cdktf.stringToHclTerraform(struct!.evictionHard),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    eviction_max_pod_grace_period: {
      value: cdktf.numberToHclTerraform(struct!.evictionMaxPodGracePeriod),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    eviction_minimum_reclaim: {
      value: cdktf.stringToHclTerraform(struct!.evictionMinimumReclaim),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    eviction_pressure_transition_period: {
      value: cdktf.stringToHclTerraform(struct!.evictionPressureTransitionPeriod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    eviction_soft: {
      value: cdktf.stringToHclTerraform(struct!.evictionSoft),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    eviction_soft_grace_period: {
      value: cdktf.stringToHclTerraform(struct!.evictionSoftGracePeriod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    experimental_allowed_unsafe_sysctls: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.experimentalAllowedUnsafeSysctls),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    fail_swap_on: {
      value: cdktf.booleanToHclTerraform(struct!.failSwapOn),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    feature_gates: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.featureGates),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    hairpin_mode: {
      value: cdktf.stringToHclTerraform(struct!.hairpinMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname_override: {
      value: cdktf.stringToHclTerraform(struct!.hostnameOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    housekeeping_interval: {
      value: cdktf.stringToHclTerraform(struct!.housekeepingInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    image_gc_high_threshold_percent: {
      value: cdktf.numberToHclTerraform(struct!.imageGcHighThresholdPercent),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    image_gc_low_threshold_percent: {
      value: cdktf.numberToHclTerraform(struct!.imageGcLowThresholdPercent),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    image_pull_progress_deadline: {
      value: cdktf.stringToHclTerraform(struct!.imagePullProgressDeadline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kernel_memcg_notification: {
      value: cdktf.booleanToHclTerraform(struct!.kernelMemcgNotification),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    kube_reserved: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.kubeReserved),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    kube_reserved_cgroup: {
      value: cdktf.stringToHclTerraform(struct!.kubeReservedCgroup),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kubeconfig_path: {
      value: cdktf.stringToHclTerraform(struct!.kubeconfigPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kubelet_cgroups: {
      value: cdktf.stringToHclTerraform(struct!.kubeletCgroups),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_format: {
      value: cdktf.stringToHclTerraform(struct!.logFormat),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_level: {
      value: cdktf.numberToHclTerraform(struct!.logLevel),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_pods: {
      value: cdktf.numberToHclTerraform(struct!.maxPods),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    network_plugin_mtu: {
      value: cdktf.numberToHclTerraform(struct!.networkPluginMtu),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    network_plugin_name: {
      value: cdktf.stringToHclTerraform(struct!.networkPluginName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    node_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.nodeLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    node_status_update_frequency: {
      value: cdktf.stringToHclTerraform(struct!.nodeStatusUpdateFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    non_masquerade_cidr: {
      value: cdktf.stringToHclTerraform(struct!.nonMasqueradeCidr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    nvidia_gp_us: {
      value: cdktf.numberToHclTerraform(struct!.nvidiaGpUs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pod_cidr: {
      value: cdktf.stringToHclTerraform(struct!.podCidr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pod_infra_container_image: {
      value: cdktf.stringToHclTerraform(struct!.podInfraContainerImage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pod_manifest_path: {
      value: cdktf.stringToHclTerraform(struct!.podManifestPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pod_pids_limit: {
      value: cdktf.numberToHclTerraform(struct!.podPidsLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    protect_kernel_defaults: {
      value: cdktf.booleanToHclTerraform(struct!.protectKernelDefaults),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    read_only_port: {
      value: cdktf.numberToHclTerraform(struct!.readOnlyPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    reconcile_cidr: {
      value: cdktf.booleanToHclTerraform(struct!.reconcileCidr),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    register_node: {
      value: cdktf.booleanToHclTerraform(struct!.registerNode),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    register_schedulable: {
      value: cdktf.booleanToHclTerraform(struct!.registerSchedulable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    registry_burst: {
      value: cdktf.numberToHclTerraform(struct!.registryBurst),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    registry_pull_qps: {
      value: cdktf.numberToHclTerraform(struct!.registryPullQps),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    require_kubeconfig: {
      value: cdktf.booleanToHclTerraform(struct!.requireKubeconfig),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    resolver_config: {
      value: cdktf.stringToHclTerraform(struct!.resolverConfig),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    root_dir: {
      value: cdktf.stringToHclTerraform(struct!.rootDir),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    rotate_certificates: {
      value: cdktf.booleanToHclTerraform(struct!.rotateCertificates),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    runtime_cgroups: {
      value: cdktf.stringToHclTerraform(struct!.runtimeCgroups),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    runtime_request_timeout: {
      value: cdktf.stringToHclTerraform(struct!.runtimeRequestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    seccomp_profile_root: {
      value: cdktf.stringToHclTerraform(struct!.seccompProfileRoot),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    serialize_image_pulls: {
      value: cdktf.booleanToHclTerraform(struct!.serializeImagePulls),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    shutdown_grace_period: {
      value: cdktf.stringToHclTerraform(struct!.shutdownGracePeriod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    shutdown_grace_period_critical_pods: {
      value: cdktf.stringToHclTerraform(struct!.shutdownGracePeriodCriticalPods),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streaming_connection_idle_timeout: {
      value: cdktf.stringToHclTerraform(struct!.streamingConnectionIdleTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    system_cgroups: {
      value: cdktf.stringToHclTerraform(struct!.systemCgroups),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    system_reserved: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.systemReserved),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    system_reserved_cgroup: {
      value: cdktf.stringToHclTerraform(struct!.systemReservedCgroup),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    taints: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.taints),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tls_cert_file: {
      value: cdktf.stringToHclTerraform(struct!.tlsCertFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls_cipher_suites: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.tlsCipherSuites),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tls_min_version: {
      value: cdktf.stringToHclTerraform(struct!.tlsMinVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls_private_key_file: {
      value: cdktf.stringToHclTerraform(struct!.tlsPrivateKeyFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    topology_manager_policy: {
      value: cdktf.stringToHclTerraform(struct!.topologyManagerPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    volume_plugin_directory: {
      value: cdktf.stringToHclTerraform(struct!.volumePluginDirectory),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    volume_stats_agg_period: {
      value: cdktf.stringToHclTerraform(struct!.volumeStatsAggPeriod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    anonymous_auth: {
      value: clusterKubeletAnonymousAuthToHclTerraform(struct!.anonymousAuth),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterKubeletAnonymousAuthList",
    },
    cpu_cfs_quota: {
      value: clusterKubeletCpuCfsQuotaToHclTerraform(struct!.cpuCfsQuota),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterKubeletCpuCfsQuotaList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterKubeletOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterKubelet | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowPrivileged !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowPrivileged = this._allowPrivileged;
    }
    if (this._allowedUnsafeSysctls !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowedUnsafeSysctls = this._allowedUnsafeSysctls;
    }
    if (this._apiServers !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiServers = this._apiServers;
    }
    if (this._authenticationTokenWebhook !== undefined) {
      hasAnyValues = true;
      internalValueResult.authenticationTokenWebhook = this._authenticationTokenWebhook;
    }
    if (this._authenticationTokenWebhookCacheTtl !== undefined) {
      hasAnyValues = true;
      internalValueResult.authenticationTokenWebhookCacheTtl = this._authenticationTokenWebhookCacheTtl;
    }
    if (this._authorizationMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.authorizationMode = this._authorizationMode;
    }
    if (this._babysitDaemons !== undefined) {
      hasAnyValues = true;
      internalValueResult.babysitDaemons = this._babysitDaemons;
    }
    if (this._bootstrapKubeconfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.bootstrapKubeconfig = this._bootstrapKubeconfig;
    }
    if (this._cgroupDriver !== undefined) {
      hasAnyValues = true;
      internalValueResult.cgroupDriver = this._cgroupDriver;
    }
    if (this._cgroupRoot !== undefined) {
      hasAnyValues = true;
      internalValueResult.cgroupRoot = this._cgroupRoot;
    }
    if (this._clientCaFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientCaFile = this._clientCaFile;
    }
    if (this._cloudProvider !== undefined) {
      hasAnyValues = true;
      internalValueResult.cloudProvider = this._cloudProvider;
    }
    if (this._clusterDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterDns = this._clusterDns;
    }
    if (this._clusterDomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterDomain = this._clusterDomain;
    }
    if (this._configureCbr0 !== undefined) {
      hasAnyValues = true;
      internalValueResult.configureCbr0 = this._configureCbr0;
    }
    if (this._containerLogMaxFiles !== undefined) {
      hasAnyValues = true;
      internalValueResult.containerLogMaxFiles = this._containerLogMaxFiles;
    }
    if (this._containerLogMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.containerLogMaxSize = this._containerLogMaxSize;
    }
    if (this._cpuCfsQuotaPeriod !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpuCfsQuotaPeriod = this._cpuCfsQuotaPeriod;
    }
    if (this._cpuManagerPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpuManagerPolicy = this._cpuManagerPolicy;
    }
    if (this._dockerDisableSharedPid !== undefined) {
      hasAnyValues = true;
      internalValueResult.dockerDisableSharedPid = this._dockerDisableSharedPid;
    }
    if (this._enableCadvisorJsonEndpoints !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableCadvisorJsonEndpoints = this._enableCadvisorJsonEndpoints;
    }
    if (this._enableCustomMetrics !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableCustomMetrics = this._enableCustomMetrics;
    }
    if (this._enableDebuggingHandlers !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableDebuggingHandlers = this._enableDebuggingHandlers;
    }
    if (this._enforceNodeAllocatable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enforceNodeAllocatable = this._enforceNodeAllocatable;
    }
    if (this._eventBurst !== undefined) {
      hasAnyValues = true;
      internalValueResult.eventBurst = this._eventBurst;
    }
    if (this._eventQps !== undefined) {
      hasAnyValues = true;
      internalValueResult.eventQps = this._eventQps;
    }
    if (this._evictionHard !== undefined) {
      hasAnyValues = true;
      internalValueResult.evictionHard = this._evictionHard;
    }
    if (this._evictionMaxPodGracePeriod !== undefined) {
      hasAnyValues = true;
      internalValueResult.evictionMaxPodGracePeriod = this._evictionMaxPodGracePeriod;
    }
    if (this._evictionMinimumReclaim !== undefined) {
      hasAnyValues = true;
      internalValueResult.evictionMinimumReclaim = this._evictionMinimumReclaim;
    }
    if (this._evictionPressureTransitionPeriod !== undefined) {
      hasAnyValues = true;
      internalValueResult.evictionPressureTransitionPeriod = this._evictionPressureTransitionPeriod;
    }
    if (this._evictionSoft !== undefined) {
      hasAnyValues = true;
      internalValueResult.evictionSoft = this._evictionSoft;
    }
    if (this._evictionSoftGracePeriod !== undefined) {
      hasAnyValues = true;
      internalValueResult.evictionSoftGracePeriod = this._evictionSoftGracePeriod;
    }
    if (this._experimentalAllowedUnsafeSysctls !== undefined) {
      hasAnyValues = true;
      internalValueResult.experimentalAllowedUnsafeSysctls = this._experimentalAllowedUnsafeSysctls;
    }
    if (this._failSwapOn !== undefined) {
      hasAnyValues = true;
      internalValueResult.failSwapOn = this._failSwapOn;
    }
    if (this._featureGates !== undefined) {
      hasAnyValues = true;
      internalValueResult.featureGates = this._featureGates;
    }
    if (this._hairpinMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.hairpinMode = this._hairpinMode;
    }
    if (this._hostnameOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostnameOverride = this._hostnameOverride;
    }
    if (this._housekeepingInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.housekeepingInterval = this._housekeepingInterval;
    }
    if (this._imageGcHighThresholdPercent !== undefined) {
      hasAnyValues = true;
      internalValueResult.imageGcHighThresholdPercent = this._imageGcHighThresholdPercent;
    }
    if (this._imageGcLowThresholdPercent !== undefined) {
      hasAnyValues = true;
      internalValueResult.imageGcLowThresholdPercent = this._imageGcLowThresholdPercent;
    }
    if (this._imagePullProgressDeadline !== undefined) {
      hasAnyValues = true;
      internalValueResult.imagePullProgressDeadline = this._imagePullProgressDeadline;
    }
    if (this._kernelMemcgNotification !== undefined) {
      hasAnyValues = true;
      internalValueResult.kernelMemcgNotification = this._kernelMemcgNotification;
    }
    if (this._kubeReserved !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubeReserved = this._kubeReserved;
    }
    if (this._kubeReservedCgroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubeReservedCgroup = this._kubeReservedCgroup;
    }
    if (this._kubeconfigPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubeconfigPath = this._kubeconfigPath;
    }
    if (this._kubeletCgroups !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubeletCgroups = this._kubeletCgroups;
    }
    if (this._logFormat !== undefined) {
      hasAnyValues = true;
      internalValueResult.logFormat = this._logFormat;
    }
    if (this._logLevel !== undefined) {
      hasAnyValues = true;
      internalValueResult.logLevel = this._logLevel;
    }
    if (this._maxPods !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPods = this._maxPods;
    }
    if (this._networkPluginMtu !== undefined) {
      hasAnyValues = true;
      internalValueResult.networkPluginMtu = this._networkPluginMtu;
    }
    if (this._networkPluginName !== undefined) {
      hasAnyValues = true;
      internalValueResult.networkPluginName = this._networkPluginName;
    }
    if (this._nodeLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeLabels = this._nodeLabels;
    }
    if (this._nodeStatusUpdateFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeStatusUpdateFrequency = this._nodeStatusUpdateFrequency;
    }
    if (this._nonMasqueradeCidr !== undefined) {
      hasAnyValues = true;
      internalValueResult.nonMasqueradeCidr = this._nonMasqueradeCidr;
    }
    if (this._nvidiaGpUs !== undefined) {
      hasAnyValues = true;
      internalValueResult.nvidiaGpUs = this._nvidiaGpUs;
    }
    if (this._podCidr !== undefined) {
      hasAnyValues = true;
      internalValueResult.podCidr = this._podCidr;
    }
    if (this._podInfraContainerImage !== undefined) {
      hasAnyValues = true;
      internalValueResult.podInfraContainerImage = this._podInfraContainerImage;
    }
    if (this._podManifestPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.podManifestPath = this._podManifestPath;
    }
    if (this._podPidsLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.podPidsLimit = this._podPidsLimit;
    }
    if (this._protectKernelDefaults !== undefined) {
      hasAnyValues = true;
      internalValueResult.protectKernelDefaults = this._protectKernelDefaults;
    }
    if (this._readOnlyPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.readOnlyPort = this._readOnlyPort;
    }
    if (this._reconcileCidr !== undefined) {
      hasAnyValues = true;
      internalValueResult.reconcileCidr = this._reconcileCidr;
    }
    if (this._registerNode !== undefined) {
      hasAnyValues = true;
      internalValueResult.registerNode = this._registerNode;
    }
    if (this._registerSchedulable !== undefined) {
      hasAnyValues = true;
      internalValueResult.registerSchedulable = this._registerSchedulable;
    }
    if (this._registryBurst !== undefined) {
      hasAnyValues = true;
      internalValueResult.registryBurst = this._registryBurst;
    }
    if (this._registryPullQps !== undefined) {
      hasAnyValues = true;
      internalValueResult.registryPullQps = this._registryPullQps;
    }
    if (this._requireKubeconfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.requireKubeconfig = this._requireKubeconfig;
    }
    if (this._resolverConfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.resolverConfig = this._resolverConfig;
    }
    if (this._rootDir !== undefined) {
      hasAnyValues = true;
      internalValueResult.rootDir = this._rootDir;
    }
    if (this._rotateCertificates !== undefined) {
      hasAnyValues = true;
      internalValueResult.rotateCertificates = this._rotateCertificates;
    }
    if (this._runtimeCgroups !== undefined) {
      hasAnyValues = true;
      internalValueResult.runtimeCgroups = this._runtimeCgroups;
    }
    if (this._runtimeRequestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.runtimeRequestTimeout = this._runtimeRequestTimeout;
    }
    if (this._seccompProfileRoot !== undefined) {
      hasAnyValues = true;
      internalValueResult.seccompProfileRoot = this._seccompProfileRoot;
    }
    if (this._serializeImagePulls !== undefined) {
      hasAnyValues = true;
      internalValueResult.serializeImagePulls = this._serializeImagePulls;
    }
    if (this._shutdownGracePeriod !== undefined) {
      hasAnyValues = true;
      internalValueResult.shutdownGracePeriod = this._shutdownGracePeriod;
    }
    if (this._shutdownGracePeriodCriticalPods !== undefined) {
      hasAnyValues = true;
      internalValueResult.shutdownGracePeriodCriticalPods = this._shutdownGracePeriodCriticalPods;
    }
    if (this._streamingConnectionIdleTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamingConnectionIdleTimeout = this._streamingConnectionIdleTimeout;
    }
    if (this._systemCgroups !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemCgroups = this._systemCgroups;
    }
    if (this._systemReserved !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemReserved = this._systemReserved;
    }
    if (this._systemReservedCgroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemReservedCgroup = this._systemReservedCgroup;
    }
    if (this._taints !== undefined) {
      hasAnyValues = true;
      internalValueResult.taints = this._taints;
    }
    if (this._tlsCertFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsCertFile = this._tlsCertFile;
    }
    if (this._tlsCipherSuites !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsCipherSuites = this._tlsCipherSuites;
    }
    if (this._tlsMinVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsMinVersion = this._tlsMinVersion;
    }
    if (this._tlsPrivateKeyFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsPrivateKeyFile = this._tlsPrivateKeyFile;
    }
    if (this._topologyManagerPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.topologyManagerPolicy = this._topologyManagerPolicy;
    }
    if (this._volumePluginDirectory !== undefined) {
      hasAnyValues = true;
      internalValueResult.volumePluginDirectory = this._volumePluginDirectory;
    }
    if (this._volumeStatsAggPeriod !== undefined) {
      hasAnyValues = true;
      internalValueResult.volumeStatsAggPeriod = this._volumeStatsAggPeriod;
    }
    if (this._anonymousAuth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.anonymousAuth = this._anonymousAuth?.internalValue;
    }
    if (this._cpuCfsQuota?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpuCfsQuota = this._cpuCfsQuota?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterKubelet | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._allowPrivileged = undefined;
      this._allowedUnsafeSysctls = undefined;
      this._apiServers = undefined;
      this._authenticationTokenWebhook = undefined;
      this._authenticationTokenWebhookCacheTtl = undefined;
      this._authorizationMode = undefined;
      this._babysitDaemons = undefined;
      this._bootstrapKubeconfig = undefined;
      this._cgroupDriver = undefined;
      this._cgroupRoot = undefined;
      this._clientCaFile = undefined;
      this._cloudProvider = undefined;
      this._clusterDns = undefined;
      this._clusterDomain = undefined;
      this._configureCbr0 = undefined;
      this._containerLogMaxFiles = undefined;
      this._containerLogMaxSize = undefined;
      this._cpuCfsQuotaPeriod = undefined;
      this._cpuManagerPolicy = undefined;
      this._dockerDisableSharedPid = undefined;
      this._enableCadvisorJsonEndpoints = undefined;
      this._enableCustomMetrics = undefined;
      this._enableDebuggingHandlers = undefined;
      this._enforceNodeAllocatable = undefined;
      this._eventBurst = undefined;
      this._eventQps = undefined;
      this._evictionHard = undefined;
      this._evictionMaxPodGracePeriod = undefined;
      this._evictionMinimumReclaim = undefined;
      this._evictionPressureTransitionPeriod = undefined;
      this._evictionSoft = undefined;
      this._evictionSoftGracePeriod = undefined;
      this._experimentalAllowedUnsafeSysctls = undefined;
      this._failSwapOn = undefined;
      this._featureGates = undefined;
      this._hairpinMode = undefined;
      this._hostnameOverride = undefined;
      this._housekeepingInterval = undefined;
      this._imageGcHighThresholdPercent = undefined;
      this._imageGcLowThresholdPercent = undefined;
      this._imagePullProgressDeadline = undefined;
      this._kernelMemcgNotification = undefined;
      this._kubeReserved = undefined;
      this._kubeReservedCgroup = undefined;
      this._kubeconfigPath = undefined;
      this._kubeletCgroups = undefined;
      this._logFormat = undefined;
      this._logLevel = undefined;
      this._maxPods = undefined;
      this._networkPluginMtu = undefined;
      this._networkPluginName = undefined;
      this._nodeLabels = undefined;
      this._nodeStatusUpdateFrequency = undefined;
      this._nonMasqueradeCidr = undefined;
      this._nvidiaGpUs = undefined;
      this._podCidr = undefined;
      this._podInfraContainerImage = undefined;
      this._podManifestPath = undefined;
      this._podPidsLimit = undefined;
      this._protectKernelDefaults = undefined;
      this._readOnlyPort = undefined;
      this._reconcileCidr = undefined;
      this._registerNode = undefined;
      this._registerSchedulable = undefined;
      this._registryBurst = undefined;
      this._registryPullQps = undefined;
      this._requireKubeconfig = undefined;
      this._resolverConfig = undefined;
      this._rootDir = undefined;
      this._rotateCertificates = undefined;
      this._runtimeCgroups = undefined;
      this._runtimeRequestTimeout = undefined;
      this._seccompProfileRoot = undefined;
      this._serializeImagePulls = undefined;
      this._shutdownGracePeriod = undefined;
      this._shutdownGracePeriodCriticalPods = undefined;
      this._streamingConnectionIdleTimeout = undefined;
      this._systemCgroups = undefined;
      this._systemReserved = undefined;
      this._systemReservedCgroup = undefined;
      this._taints = undefined;
      this._tlsCertFile = undefined;
      this._tlsCipherSuites = undefined;
      this._tlsMinVersion = undefined;
      this._tlsPrivateKeyFile = undefined;
      this._topologyManagerPolicy = undefined;
      this._volumePluginDirectory = undefined;
      this._volumeStatsAggPeriod = undefined;
      this._anonymousAuth.internalValue = undefined;
      this._cpuCfsQuota.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._allowPrivileged = value.allowPrivileged;
      this._allowedUnsafeSysctls = value.allowedUnsafeSysctls;
      this._apiServers = value.apiServers;
      this._authenticationTokenWebhook = value.authenticationTokenWebhook;
      this._authenticationTokenWebhookCacheTtl = value.authenticationTokenWebhookCacheTtl;
      this._authorizationMode = value.authorizationMode;
      this._babysitDaemons = value.babysitDaemons;
      this._bootstrapKubeconfig = value.bootstrapKubeconfig;
      this._cgroupDriver = value.cgroupDriver;
      this._cgroupRoot = value.cgroupRoot;
      this._clientCaFile = value.clientCaFile;
      this._cloudProvider = value.cloudProvider;
      this._clusterDns = value.clusterDns;
      this._clusterDomain = value.clusterDomain;
      this._configureCbr0 = value.configureCbr0;
      this._containerLogMaxFiles = value.containerLogMaxFiles;
      this._containerLogMaxSize = value.containerLogMaxSize;
      this._cpuCfsQuotaPeriod = value.cpuCfsQuotaPeriod;
      this._cpuManagerPolicy = value.cpuManagerPolicy;
      this._dockerDisableSharedPid = value.dockerDisableSharedPid;
      this._enableCadvisorJsonEndpoints = value.enableCadvisorJsonEndpoints;
      this._enableCustomMetrics = value.enableCustomMetrics;
      this._enableDebuggingHandlers = value.enableDebuggingHandlers;
      this._enforceNodeAllocatable = value.enforceNodeAllocatable;
      this._eventBurst = value.eventBurst;
      this._eventQps = value.eventQps;
      this._evictionHard = value.evictionHard;
      this._evictionMaxPodGracePeriod = value.evictionMaxPodGracePeriod;
      this._evictionMinimumReclaim = value.evictionMinimumReclaim;
      this._evictionPressureTransitionPeriod = value.evictionPressureTransitionPeriod;
      this._evictionSoft = value.evictionSoft;
      this._evictionSoftGracePeriod = value.evictionSoftGracePeriod;
      this._experimentalAllowedUnsafeSysctls = value.experimentalAllowedUnsafeSysctls;
      this._failSwapOn = value.failSwapOn;
      this._featureGates = value.featureGates;
      this._hairpinMode = value.hairpinMode;
      this._hostnameOverride = value.hostnameOverride;
      this._housekeepingInterval = value.housekeepingInterval;
      this._imageGcHighThresholdPercent = value.imageGcHighThresholdPercent;
      this._imageGcLowThresholdPercent = value.imageGcLowThresholdPercent;
      this._imagePullProgressDeadline = value.imagePullProgressDeadline;
      this._kernelMemcgNotification = value.kernelMemcgNotification;
      this._kubeReserved = value.kubeReserved;
      this._kubeReservedCgroup = value.kubeReservedCgroup;
      this._kubeconfigPath = value.kubeconfigPath;
      this._kubeletCgroups = value.kubeletCgroups;
      this._logFormat = value.logFormat;
      this._logLevel = value.logLevel;
      this._maxPods = value.maxPods;
      this._networkPluginMtu = value.networkPluginMtu;
      this._networkPluginName = value.networkPluginName;
      this._nodeLabels = value.nodeLabels;
      this._nodeStatusUpdateFrequency = value.nodeStatusUpdateFrequency;
      this._nonMasqueradeCidr = value.nonMasqueradeCidr;
      this._nvidiaGpUs = value.nvidiaGpUs;
      this._podCidr = value.podCidr;
      this._podInfraContainerImage = value.podInfraContainerImage;
      this._podManifestPath = value.podManifestPath;
      this._podPidsLimit = value.podPidsLimit;
      this._protectKernelDefaults = value.protectKernelDefaults;
      this._readOnlyPort = value.readOnlyPort;
      this._reconcileCidr = value.reconcileCidr;
      this._registerNode = value.registerNode;
      this._registerSchedulable = value.registerSchedulable;
      this._registryBurst = value.registryBurst;
      this._registryPullQps = value.registryPullQps;
      this._requireKubeconfig = value.requireKubeconfig;
      this._resolverConfig = value.resolverConfig;
      this._rootDir = value.rootDir;
      this._rotateCertificates = value.rotateCertificates;
      this._runtimeCgroups = value.runtimeCgroups;
      this._runtimeRequestTimeout = value.runtimeRequestTimeout;
      this._seccompProfileRoot = value.seccompProfileRoot;
      this._serializeImagePulls = value.serializeImagePulls;
      this._shutdownGracePeriod = value.shutdownGracePeriod;
      this._shutdownGracePeriodCriticalPods = value.shutdownGracePeriodCriticalPods;
      this._streamingConnectionIdleTimeout = value.streamingConnectionIdleTimeout;
      this._systemCgroups = value.systemCgroups;
      this._systemReserved = value.systemReserved;
      this._systemReservedCgroup = value.systemReservedCgroup;
      this._taints = value.taints;
      this._tlsCertFile = value.tlsCertFile;
      this._tlsCipherSuites = value.tlsCipherSuites;
      this._tlsMinVersion = value.tlsMinVersion;
      this._tlsPrivateKeyFile = value.tlsPrivateKeyFile;
      this._topologyManagerPolicy = value.topologyManagerPolicy;
      this._volumePluginDirectory = value.volumePluginDirectory;
      this._volumeStatsAggPeriod = value.volumeStatsAggPeriod;
      this._anonymousAuth.internalValue = value.anonymousAuth;
      this._cpuCfsQuota.internalValue = value.cpuCfsQuota;
    }
  }

  // allow_privileged - computed: false, optional: true, required: false
  private _allowPrivileged?: boolean | cdktf.IResolvable; 
  public get allowPrivileged() {
    return this.getBooleanAttribute('allow_privileged');
  }
  public set allowPrivileged(value: boolean | cdktf.IResolvable) {
    this._allowPrivileged = value;
  }
  public resetAllowPrivileged() {
    this._allowPrivileged = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowPrivilegedInput() {
    return this._allowPrivileged;
  }

  // allowed_unsafe_sysctls - computed: false, optional: true, required: false
  private _allowedUnsafeSysctls?: string[]; 
  public get allowedUnsafeSysctls() {
    return this.getListAttribute('allowed_unsafe_sysctls');
  }
  public set allowedUnsafeSysctls(value: string[]) {
    this._allowedUnsafeSysctls = value;
  }
  public resetAllowedUnsafeSysctls() {
    this._allowedUnsafeSysctls = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowedUnsafeSysctlsInput() {
    return this._allowedUnsafeSysctls;
  }

  // api_servers - computed: false, optional: true, required: false
  private _apiServers?: string; 
  public get apiServers() {
    return this.getStringAttribute('api_servers');
  }
  public set apiServers(value: string) {
    this._apiServers = value;
  }
  public resetApiServers() {
    this._apiServers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiServersInput() {
    return this._apiServers;
  }

  // authentication_token_webhook - computed: false, optional: true, required: false
  private _authenticationTokenWebhook?: boolean | cdktf.IResolvable; 
  public get authenticationTokenWebhook() {
    return this.getBooleanAttribute('authentication_token_webhook');
  }
  public set authenticationTokenWebhook(value: boolean | cdktf.IResolvable) {
    this._authenticationTokenWebhook = value;
  }
  public resetAuthenticationTokenWebhook() {
    this._authenticationTokenWebhook = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authenticationTokenWebhookInput() {
    return this._authenticationTokenWebhook;
  }

  // authentication_token_webhook_cache_ttl - computed: false, optional: true, required: false
  private _authenticationTokenWebhookCacheTtl?: string; 
  public get authenticationTokenWebhookCacheTtl() {
    return this.getStringAttribute('authentication_token_webhook_cache_ttl');
  }
  public set authenticationTokenWebhookCacheTtl(value: string) {
    this._authenticationTokenWebhookCacheTtl = value;
  }
  public resetAuthenticationTokenWebhookCacheTtl() {
    this._authenticationTokenWebhookCacheTtl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authenticationTokenWebhookCacheTtlInput() {
    return this._authenticationTokenWebhookCacheTtl;
  }

  // authorization_mode - computed: false, optional: true, required: false
  private _authorizationMode?: string; 
  public get authorizationMode() {
    return this.getStringAttribute('authorization_mode');
  }
  public set authorizationMode(value: string) {
    this._authorizationMode = value;
  }
  public resetAuthorizationMode() {
    this._authorizationMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authorizationModeInput() {
    return this._authorizationMode;
  }

  // babysit_daemons - computed: false, optional: true, required: false
  private _babysitDaemons?: boolean | cdktf.IResolvable; 
  public get babysitDaemons() {
    return this.getBooleanAttribute('babysit_daemons');
  }
  public set babysitDaemons(value: boolean | cdktf.IResolvable) {
    this._babysitDaemons = value;
  }
  public resetBabysitDaemons() {
    this._babysitDaemons = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get babysitDaemonsInput() {
    return this._babysitDaemons;
  }

  // bootstrap_kubeconfig - computed: false, optional: true, required: false
  private _bootstrapKubeconfig?: string; 
  public get bootstrapKubeconfig() {
    return this.getStringAttribute('bootstrap_kubeconfig');
  }
  public set bootstrapKubeconfig(value: string) {
    this._bootstrapKubeconfig = value;
  }
  public resetBootstrapKubeconfig() {
    this._bootstrapKubeconfig = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bootstrapKubeconfigInput() {
    return this._bootstrapKubeconfig;
  }

  // cgroup_driver - computed: false, optional: true, required: false
  private _cgroupDriver?: string; 
  public get cgroupDriver() {
    return this.getStringAttribute('cgroup_driver');
  }
  public set cgroupDriver(value: string) {
    this._cgroupDriver = value;
  }
  public resetCgroupDriver() {
    this._cgroupDriver = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cgroupDriverInput() {
    return this._cgroupDriver;
  }

  // cgroup_root - computed: false, optional: true, required: false
  private _cgroupRoot?: string; 
  public get cgroupRoot() {
    return this.getStringAttribute('cgroup_root');
  }
  public set cgroupRoot(value: string) {
    this._cgroupRoot = value;
  }
  public resetCgroupRoot() {
    this._cgroupRoot = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cgroupRootInput() {
    return this._cgroupRoot;
  }

  // client_ca_file - computed: false, optional: true, required: false
  private _clientCaFile?: string; 
  public get clientCaFile() {
    return this.getStringAttribute('client_ca_file');
  }
  public set clientCaFile(value: string) {
    this._clientCaFile = value;
  }
  public resetClientCaFile() {
    this._clientCaFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientCaFileInput() {
    return this._clientCaFile;
  }

  // cloud_provider - computed: false, optional: true, required: false
  private _cloudProvider?: string; 
  public get cloudProvider() {
    return this.getStringAttribute('cloud_provider');
  }
  public set cloudProvider(value: string) {
    this._cloudProvider = value;
  }
  public resetCloudProvider() {
    this._cloudProvider = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cloudProviderInput() {
    return this._cloudProvider;
  }

  // cluster_dns - computed: false, optional: true, required: false
  private _clusterDns?: string; 
  public get clusterDns() {
    return this.getStringAttribute('cluster_dns');
  }
  public set clusterDns(value: string) {
    this._clusterDns = value;
  }
  public resetClusterDns() {
    this._clusterDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterDnsInput() {
    return this._clusterDns;
  }

  // cluster_domain - computed: false, optional: true, required: false
  private _clusterDomain?: string; 
  public get clusterDomain() {
    return this.getStringAttribute('cluster_domain');
  }
  public set clusterDomain(value: string) {
    this._clusterDomain = value;
  }
  public resetClusterDomain() {
    this._clusterDomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterDomainInput() {
    return this._clusterDomain;
  }

  // configure_cbr0 - computed: false, optional: true, required: false
  private _configureCbr0?: boolean | cdktf.IResolvable; 
  public get configureCbr0() {
    return this.getBooleanAttribute('configure_cbr0');
  }
  public set configureCbr0(value: boolean | cdktf.IResolvable) {
    this._configureCbr0 = value;
  }
  public resetConfigureCbr0() {
    this._configureCbr0 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configureCbr0Input() {
    return this._configureCbr0;
  }

  // container_log_max_files - computed: false, optional: true, required: false
  private _containerLogMaxFiles?: number; 
  public get containerLogMaxFiles() {
    return this.getNumberAttribute('container_log_max_files');
  }
  public set containerLogMaxFiles(value: number) {
    this._containerLogMaxFiles = value;
  }
  public resetContainerLogMaxFiles() {
    this._containerLogMaxFiles = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get containerLogMaxFilesInput() {
    return this._containerLogMaxFiles;
  }

  // container_log_max_size - computed: false, optional: true, required: false
  private _containerLogMaxSize?: string; 
  public get containerLogMaxSize() {
    return this.getStringAttribute('container_log_max_size');
  }
  public set containerLogMaxSize(value: string) {
    this._containerLogMaxSize = value;
  }
  public resetContainerLogMaxSize() {
    this._containerLogMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get containerLogMaxSizeInput() {
    return this._containerLogMaxSize;
  }

  // cpu_cfs_quota_period - computed: false, optional: true, required: false
  private _cpuCfsQuotaPeriod?: string; 
  public get cpuCfsQuotaPeriod() {
    return this.getStringAttribute('cpu_cfs_quota_period');
  }
  public set cpuCfsQuotaPeriod(value: string) {
    this._cpuCfsQuotaPeriod = value;
  }
  public resetCpuCfsQuotaPeriod() {
    this._cpuCfsQuotaPeriod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuCfsQuotaPeriodInput() {
    return this._cpuCfsQuotaPeriod;
  }

  // cpu_manager_policy - computed: false, optional: true, required: false
  private _cpuManagerPolicy?: string; 
  public get cpuManagerPolicy() {
    return this.getStringAttribute('cpu_manager_policy');
  }
  public set cpuManagerPolicy(value: string) {
    this._cpuManagerPolicy = value;
  }
  public resetCpuManagerPolicy() {
    this._cpuManagerPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuManagerPolicyInput() {
    return this._cpuManagerPolicy;
  }

  // docker_disable_shared_pid - computed: false, optional: true, required: false
  private _dockerDisableSharedPid?: boolean | cdktf.IResolvable; 
  public get dockerDisableSharedPid() {
    return this.getBooleanAttribute('docker_disable_shared_pid');
  }
  public set dockerDisableSharedPid(value: boolean | cdktf.IResolvable) {
    this._dockerDisableSharedPid = value;
  }
  public resetDockerDisableSharedPid() {
    this._dockerDisableSharedPid = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dockerDisableSharedPidInput() {
    return this._dockerDisableSharedPid;
  }

  // enable_cadvisor_json_endpoints - computed: false, optional: true, required: false
  private _enableCadvisorJsonEndpoints?: boolean | cdktf.IResolvable; 
  public get enableCadvisorJsonEndpoints() {
    return this.getBooleanAttribute('enable_cadvisor_json_endpoints');
  }
  public set enableCadvisorJsonEndpoints(value: boolean | cdktf.IResolvable) {
    this._enableCadvisorJsonEndpoints = value;
  }
  public resetEnableCadvisorJsonEndpoints() {
    this._enableCadvisorJsonEndpoints = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableCadvisorJsonEndpointsInput() {
    return this._enableCadvisorJsonEndpoints;
  }

  // enable_custom_metrics - computed: false, optional: true, required: false
  private _enableCustomMetrics?: boolean | cdktf.IResolvable; 
  public get enableCustomMetrics() {
    return this.getBooleanAttribute('enable_custom_metrics');
  }
  public set enableCustomMetrics(value: boolean | cdktf.IResolvable) {
    this._enableCustomMetrics = value;
  }
  public resetEnableCustomMetrics() {
    this._enableCustomMetrics = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableCustomMetricsInput() {
    return this._enableCustomMetrics;
  }

  // enable_debugging_handlers - computed: false, optional: true, required: false
  private _enableDebuggingHandlers?: boolean | cdktf.IResolvable; 
  public get enableDebuggingHandlers() {
    return this.getBooleanAttribute('enable_debugging_handlers');
  }
  public set enableDebuggingHandlers(value: boolean | cdktf.IResolvable) {
    this._enableDebuggingHandlers = value;
  }
  public resetEnableDebuggingHandlers() {
    this._enableDebuggingHandlers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableDebuggingHandlersInput() {
    return this._enableDebuggingHandlers;
  }

  // enforce_node_allocatable - computed: false, optional: true, required: false
  private _enforceNodeAllocatable?: string; 
  public get enforceNodeAllocatable() {
    return this.getStringAttribute('enforce_node_allocatable');
  }
  public set enforceNodeAllocatable(value: string) {
    this._enforceNodeAllocatable = value;
  }
  public resetEnforceNodeAllocatable() {
    this._enforceNodeAllocatable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enforceNodeAllocatableInput() {
    return this._enforceNodeAllocatable;
  }

  // event_burst - computed: false, optional: true, required: false
  private _eventBurst?: number; 
  public get eventBurst() {
    return this.getNumberAttribute('event_burst');
  }
  public set eventBurst(value: number) {
    this._eventBurst = value;
  }
  public resetEventBurst() {
    this._eventBurst = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get eventBurstInput() {
    return this._eventBurst;
  }

  // event_qps - computed: false, optional: true, required: false
  private _eventQps?: number; 
  public get eventQps() {
    return this.getNumberAttribute('event_qps');
  }
  public set eventQps(value: number) {
    this._eventQps = value;
  }
  public resetEventQps() {
    this._eventQps = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get eventQpsInput() {
    return this._eventQps;
  }

  // eviction_hard - computed: false, optional: true, required: false
  private _evictionHard?: string; 
  public get evictionHard() {
    return this.getStringAttribute('eviction_hard');
  }
  public set evictionHard(value: string) {
    this._evictionHard = value;
  }
  public resetEvictionHard() {
    this._evictionHard = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get evictionHardInput() {
    return this._evictionHard;
  }

  // eviction_max_pod_grace_period - computed: false, optional: true, required: false
  private _evictionMaxPodGracePeriod?: number; 
  public get evictionMaxPodGracePeriod() {
    return this.getNumberAttribute('eviction_max_pod_grace_period');
  }
  public set evictionMaxPodGracePeriod(value: number) {
    this._evictionMaxPodGracePeriod = value;
  }
  public resetEvictionMaxPodGracePeriod() {
    this._evictionMaxPodGracePeriod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get evictionMaxPodGracePeriodInput() {
    return this._evictionMaxPodGracePeriod;
  }

  // eviction_minimum_reclaim - computed: false, optional: true, required: false
  private _evictionMinimumReclaim?: string; 
  public get evictionMinimumReclaim() {
    return this.getStringAttribute('eviction_minimum_reclaim');
  }
  public set evictionMinimumReclaim(value: string) {
    this._evictionMinimumReclaim = value;
  }
  public resetEvictionMinimumReclaim() {
    this._evictionMinimumReclaim = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get evictionMinimumReclaimInput() {
    return this._evictionMinimumReclaim;
  }

  // eviction_pressure_transition_period - computed: false, optional: true, required: false
  private _evictionPressureTransitionPeriod?: string; 
  public get evictionPressureTransitionPeriod() {
    return this.getStringAttribute('eviction_pressure_transition_period');
  }
  public set evictionPressureTransitionPeriod(value: string) {
    this._evictionPressureTransitionPeriod = value;
  }
  public resetEvictionPressureTransitionPeriod() {
    this._evictionPressureTransitionPeriod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get evictionPressureTransitionPeriodInput() {
    return this._evictionPressureTransitionPeriod;
  }

  // eviction_soft - computed: false, optional: true, required: false
  private _evictionSoft?: string; 
  public get evictionSoft() {
    return this.getStringAttribute('eviction_soft');
  }
  public set evictionSoft(value: string) {
    this._evictionSoft = value;
  }
  public resetEvictionSoft() {
    this._evictionSoft = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get evictionSoftInput() {
    return this._evictionSoft;
  }

  // eviction_soft_grace_period - computed: false, optional: true, required: false
  private _evictionSoftGracePeriod?: string; 
  public get evictionSoftGracePeriod() {
    return this.getStringAttribute('eviction_soft_grace_period');
  }
  public set evictionSoftGracePeriod(value: string) {
    this._evictionSoftGracePeriod = value;
  }
  public resetEvictionSoftGracePeriod() {
    this._evictionSoftGracePeriod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get evictionSoftGracePeriodInput() {
    return this._evictionSoftGracePeriod;
  }

  // experimental_allowed_unsafe_sysctls - computed: false, optional: true, required: false
  private _experimentalAllowedUnsafeSysctls?: string[]; 
  public get experimentalAllowedUnsafeSysctls() {
    return this.getListAttribute('experimental_allowed_unsafe_sysctls');
  }
  public set experimentalAllowedUnsafeSysctls(value: string[]) {
    this._experimentalAllowedUnsafeSysctls = value;
  }
  public resetExperimentalAllowedUnsafeSysctls() {
    this._experimentalAllowedUnsafeSysctls = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get experimentalAllowedUnsafeSysctlsInput() {
    return this._experimentalAllowedUnsafeSysctls;
  }

  // fail_swap_on - computed: false, optional: true, required: false
  private _failSwapOn?: boolean | cdktf.IResolvable; 
  public get failSwapOn() {
    return this.getBooleanAttribute('fail_swap_on');
  }
  public set failSwapOn(value: boolean | cdktf.IResolvable) {
    this._failSwapOn = value;
  }
  public resetFailSwapOn() {
    this._failSwapOn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failSwapOnInput() {
    return this._failSwapOn;
  }

  // feature_gates - computed: false, optional: true, required: false
  private _featureGates?: { [key: string]: string }; 
  public get featureGates() {
    return this.getStringMapAttribute('feature_gates');
  }
  public set featureGates(value: { [key: string]: string }) {
    this._featureGates = value;
  }
  public resetFeatureGates() {
    this._featureGates = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get featureGatesInput() {
    return this._featureGates;
  }

  // hairpin_mode - computed: false, optional: true, required: false
  private _hairpinMode?: string; 
  public get hairpinMode() {
    return this.getStringAttribute('hairpin_mode');
  }
  public set hairpinMode(value: string) {
    this._hairpinMode = value;
  }
  public resetHairpinMode() {
    this._hairpinMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hairpinModeInput() {
    return this._hairpinMode;
  }

  // hostname_override - computed: false, optional: true, required: false
  private _hostnameOverride?: string; 
  public get hostnameOverride() {
    return this.getStringAttribute('hostname_override');
  }
  public set hostnameOverride(value: string) {
    this._hostnameOverride = value;
  }
  public resetHostnameOverride() {
    this._hostnameOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameOverrideInput() {
    return this._hostnameOverride;
  }

  // housekeeping_interval - computed: false, optional: true, required: false
  private _housekeepingInterval?: string; 
  public get housekeepingInterval() {
    return this.getStringAttribute('housekeeping_interval');
  }
  public set housekeepingInterval(value: string) {
    this._housekeepingInterval = value;
  }
  public resetHousekeepingInterval() {
    this._housekeepingInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get housekeepingIntervalInput() {
    return this._housekeepingInterval;
  }

  // image_gc_high_threshold_percent - computed: false, optional: true, required: false
  private _imageGcHighThresholdPercent?: number; 
  public get imageGcHighThresholdPercent() {
    return this.getNumberAttribute('image_gc_high_threshold_percent');
  }
  public set imageGcHighThresholdPercent(value: number) {
    this._imageGcHighThresholdPercent = value;
  }
  public resetImageGcHighThresholdPercent() {
    this._imageGcHighThresholdPercent = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageGcHighThresholdPercentInput() {
    return this._imageGcHighThresholdPercent;
  }

  // image_gc_low_threshold_percent - computed: false, optional: true, required: false
  private _imageGcLowThresholdPercent?: number; 
  public get imageGcLowThresholdPercent() {
    return this.getNumberAttribute('image_gc_low_threshold_percent');
  }
  public set imageGcLowThresholdPercent(value: number) {
    this._imageGcLowThresholdPercent = value;
  }
  public resetImageGcLowThresholdPercent() {
    this._imageGcLowThresholdPercent = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageGcLowThresholdPercentInput() {
    return this._imageGcLowThresholdPercent;
  }

  // image_pull_progress_deadline - computed: false, optional: true, required: false
  private _imagePullProgressDeadline?: string; 
  public get imagePullProgressDeadline() {
    return this.getStringAttribute('image_pull_progress_deadline');
  }
  public set imagePullProgressDeadline(value: string) {
    this._imagePullProgressDeadline = value;
  }
  public resetImagePullProgressDeadline() {
    this._imagePullProgressDeadline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imagePullProgressDeadlineInput() {
    return this._imagePullProgressDeadline;
  }

  // kernel_memcg_notification - computed: false, optional: true, required: false
  private _kernelMemcgNotification?: boolean | cdktf.IResolvable; 
  public get kernelMemcgNotification() {
    return this.getBooleanAttribute('kernel_memcg_notification');
  }
  public set kernelMemcgNotification(value: boolean | cdktf.IResolvable) {
    this._kernelMemcgNotification = value;
  }
  public resetKernelMemcgNotification() {
    this._kernelMemcgNotification = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kernelMemcgNotificationInput() {
    return this._kernelMemcgNotification;
  }

  // kube_reserved - computed: false, optional: true, required: false
  private _kubeReserved?: { [key: string]: string }; 
  public get kubeReserved() {
    return this.getStringMapAttribute('kube_reserved');
  }
  public set kubeReserved(value: { [key: string]: string }) {
    this._kubeReserved = value;
  }
  public resetKubeReserved() {
    this._kubeReserved = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeReservedInput() {
    return this._kubeReserved;
  }

  // kube_reserved_cgroup - computed: false, optional: true, required: false
  private _kubeReservedCgroup?: string; 
  public get kubeReservedCgroup() {
    return this.getStringAttribute('kube_reserved_cgroup');
  }
  public set kubeReservedCgroup(value: string) {
    this._kubeReservedCgroup = value;
  }
  public resetKubeReservedCgroup() {
    this._kubeReservedCgroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeReservedCgroupInput() {
    return this._kubeReservedCgroup;
  }

  // kubeconfig_path - computed: false, optional: true, required: false
  private _kubeconfigPath?: string; 
  public get kubeconfigPath() {
    return this.getStringAttribute('kubeconfig_path');
  }
  public set kubeconfigPath(value: string) {
    this._kubeconfigPath = value;
  }
  public resetKubeconfigPath() {
    this._kubeconfigPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeconfigPathInput() {
    return this._kubeconfigPath;
  }

  // kubelet_cgroups - computed: false, optional: true, required: false
  private _kubeletCgroups?: string; 
  public get kubeletCgroups() {
    return this.getStringAttribute('kubelet_cgroups');
  }
  public set kubeletCgroups(value: string) {
    this._kubeletCgroups = value;
  }
  public resetKubeletCgroups() {
    this._kubeletCgroups = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeletCgroupsInput() {
    return this._kubeletCgroups;
  }

  // log_format - computed: false, optional: true, required: false
  private _logFormat?: string; 
  public get logFormat() {
    return this.getStringAttribute('log_format');
  }
  public set logFormat(value: string) {
    this._logFormat = value;
  }
  public resetLogFormat() {
    this._logFormat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logFormatInput() {
    return this._logFormat;
  }

  // log_level - computed: false, optional: true, required: false
  private _logLevel?: number; 
  public get logLevel() {
    return this.getNumberAttribute('log_level');
  }
  public set logLevel(value: number) {
    this._logLevel = value;
  }
  public resetLogLevel() {
    this._logLevel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logLevelInput() {
    return this._logLevel;
  }

  // max_pods - computed: false, optional: true, required: false
  private _maxPods?: number; 
  public get maxPods() {
    return this.getNumberAttribute('max_pods');
  }
  public set maxPods(value: number) {
    this._maxPods = value;
  }
  public resetMaxPods() {
    this._maxPods = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPodsInput() {
    return this._maxPods;
  }

  // network_plugin_mtu - computed: false, optional: true, required: false
  private _networkPluginMtu?: number; 
  public get networkPluginMtu() {
    return this.getNumberAttribute('network_plugin_mtu');
  }
  public set networkPluginMtu(value: number) {
    this._networkPluginMtu = value;
  }
  public resetNetworkPluginMtu() {
    this._networkPluginMtu = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get networkPluginMtuInput() {
    return this._networkPluginMtu;
  }

  // network_plugin_name - computed: false, optional: true, required: false
  private _networkPluginName?: string; 
  public get networkPluginName() {
    return this.getStringAttribute('network_plugin_name');
  }
  public set networkPluginName(value: string) {
    this._networkPluginName = value;
  }
  public resetNetworkPluginName() {
    this._networkPluginName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get networkPluginNameInput() {
    return this._networkPluginName;
  }

  // node_labels - computed: false, optional: true, required: false
  private _nodeLabels?: { [key: string]: string }; 
  public get nodeLabels() {
    return this.getStringMapAttribute('node_labels');
  }
  public set nodeLabels(value: { [key: string]: string }) {
    this._nodeLabels = value;
  }
  public resetNodeLabels() {
    this._nodeLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeLabelsInput() {
    return this._nodeLabels;
  }

  // node_status_update_frequency - computed: false, optional: true, required: false
  private _nodeStatusUpdateFrequency?: string; 
  public get nodeStatusUpdateFrequency() {
    return this.getStringAttribute('node_status_update_frequency');
  }
  public set nodeStatusUpdateFrequency(value: string) {
    this._nodeStatusUpdateFrequency = value;
  }
  public resetNodeStatusUpdateFrequency() {
    this._nodeStatusUpdateFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeStatusUpdateFrequencyInput() {
    return this._nodeStatusUpdateFrequency;
  }

  // non_masquerade_cidr - computed: false, optional: true, required: false
  private _nonMasqueradeCidr?: string; 
  public get nonMasqueradeCidr() {
    return this.getStringAttribute('non_masquerade_cidr');
  }
  public set nonMasqueradeCidr(value: string) {
    this._nonMasqueradeCidr = value;
  }
  public resetNonMasqueradeCidr() {
    this._nonMasqueradeCidr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nonMasqueradeCidrInput() {
    return this._nonMasqueradeCidr;
  }

  // nvidia_gp_us - computed: false, optional: true, required: false
  private _nvidiaGpUs?: number; 
  public get nvidiaGpUs() {
    return this.getNumberAttribute('nvidia_gp_us');
  }
  public set nvidiaGpUs(value: number) {
    this._nvidiaGpUs = value;
  }
  public resetNvidiaGpUs() {
    this._nvidiaGpUs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nvidiaGpUsInput() {
    return this._nvidiaGpUs;
  }

  // pod_cidr - computed: false, optional: true, required: false
  private _podCidr?: string; 
  public get podCidr() {
    return this.getStringAttribute('pod_cidr');
  }
  public set podCidr(value: string) {
    this._podCidr = value;
  }
  public resetPodCidr() {
    this._podCidr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podCidrInput() {
    return this._podCidr;
  }

  // pod_infra_container_image - computed: false, optional: true, required: false
  private _podInfraContainerImage?: string; 
  public get podInfraContainerImage() {
    return this.getStringAttribute('pod_infra_container_image');
  }
  public set podInfraContainerImage(value: string) {
    this._podInfraContainerImage = value;
  }
  public resetPodInfraContainerImage() {
    this._podInfraContainerImage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podInfraContainerImageInput() {
    return this._podInfraContainerImage;
  }

  // pod_manifest_path - computed: false, optional: true, required: false
  private _podManifestPath?: string; 
  public get podManifestPath() {
    return this.getStringAttribute('pod_manifest_path');
  }
  public set podManifestPath(value: string) {
    this._podManifestPath = value;
  }
  public resetPodManifestPath() {
    this._podManifestPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podManifestPathInput() {
    return this._podManifestPath;
  }

  // pod_pids_limit - computed: false, optional: true, required: false
  private _podPidsLimit?: number; 
  public get podPidsLimit() {
    return this.getNumberAttribute('pod_pids_limit');
  }
  public set podPidsLimit(value: number) {
    this._podPidsLimit = value;
  }
  public resetPodPidsLimit() {
    this._podPidsLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podPidsLimitInput() {
    return this._podPidsLimit;
  }

  // protect_kernel_defaults - computed: false, optional: true, required: false
  private _protectKernelDefaults?: boolean | cdktf.IResolvable; 
  public get protectKernelDefaults() {
    return this.getBooleanAttribute('protect_kernel_defaults');
  }
  public set protectKernelDefaults(value: boolean | cdktf.IResolvable) {
    this._protectKernelDefaults = value;
  }
  public resetProtectKernelDefaults() {
    this._protectKernelDefaults = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protectKernelDefaultsInput() {
    return this._protectKernelDefaults;
  }

  // read_only_port - computed: false, optional: true, required: false
  private _readOnlyPort?: number; 
  public get readOnlyPort() {
    return this.getNumberAttribute('read_only_port');
  }
  public set readOnlyPort(value: number) {
    this._readOnlyPort = value;
  }
  public resetReadOnlyPort() {
    this._readOnlyPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get readOnlyPortInput() {
    return this._readOnlyPort;
  }

  // reconcile_cidr - computed: false, optional: true, required: false
  private _reconcileCidr?: boolean | cdktf.IResolvable; 
  public get reconcileCidr() {
    return this.getBooleanAttribute('reconcile_cidr');
  }
  public set reconcileCidr(value: boolean | cdktf.IResolvable) {
    this._reconcileCidr = value;
  }
  public resetReconcileCidr() {
    this._reconcileCidr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reconcileCidrInput() {
    return this._reconcileCidr;
  }

  // register_node - computed: false, optional: true, required: false
  private _registerNode?: boolean | cdktf.IResolvable; 
  public get registerNode() {
    return this.getBooleanAttribute('register_node');
  }
  public set registerNode(value: boolean | cdktf.IResolvable) {
    this._registerNode = value;
  }
  public resetRegisterNode() {
    this._registerNode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get registerNodeInput() {
    return this._registerNode;
  }

  // register_schedulable - computed: false, optional: true, required: false
  private _registerSchedulable?: boolean | cdktf.IResolvable; 
  public get registerSchedulable() {
    return this.getBooleanAttribute('register_schedulable');
  }
  public set registerSchedulable(value: boolean | cdktf.IResolvable) {
    this._registerSchedulable = value;
  }
  public resetRegisterSchedulable() {
    this._registerSchedulable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get registerSchedulableInput() {
    return this._registerSchedulable;
  }

  // registry_burst - computed: false, optional: true, required: false
  private _registryBurst?: number; 
  public get registryBurst() {
    return this.getNumberAttribute('registry_burst');
  }
  public set registryBurst(value: number) {
    this._registryBurst = value;
  }
  public resetRegistryBurst() {
    this._registryBurst = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get registryBurstInput() {
    return this._registryBurst;
  }

  // registry_pull_qps - computed: false, optional: true, required: false
  private _registryPullQps?: number; 
  public get registryPullQps() {
    return this.getNumberAttribute('registry_pull_qps');
  }
  public set registryPullQps(value: number) {
    this._registryPullQps = value;
  }
  public resetRegistryPullQps() {
    this._registryPullQps = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get registryPullQpsInput() {
    return this._registryPullQps;
  }

  // require_kubeconfig - computed: false, optional: true, required: false
  private _requireKubeconfig?: boolean | cdktf.IResolvable; 
  public get requireKubeconfig() {
    return this.getBooleanAttribute('require_kubeconfig');
  }
  public set requireKubeconfig(value: boolean | cdktf.IResolvable) {
    this._requireKubeconfig = value;
  }
  public resetRequireKubeconfig() {
    this._requireKubeconfig = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requireKubeconfigInput() {
    return this._requireKubeconfig;
  }

  // resolver_config - computed: false, optional: true, required: false
  private _resolverConfig?: string; 
  public get resolverConfig() {
    return this.getStringAttribute('resolver_config');
  }
  public set resolverConfig(value: string) {
    this._resolverConfig = value;
  }
  public resetResolverConfig() {
    this._resolverConfig = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resolverConfigInput() {
    return this._resolverConfig;
  }

  // root_dir - computed: false, optional: true, required: false
  private _rootDir?: string; 
  public get rootDir() {
    return this.getStringAttribute('root_dir');
  }
  public set rootDir(value: string) {
    this._rootDir = value;
  }
  public resetRootDir() {
    this._rootDir = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rootDirInput() {
    return this._rootDir;
  }

  // rotate_certificates - computed: false, optional: true, required: false
  private _rotateCertificates?: boolean | cdktf.IResolvable; 
  public get rotateCertificates() {
    return this.getBooleanAttribute('rotate_certificates');
  }
  public set rotateCertificates(value: boolean | cdktf.IResolvable) {
    this._rotateCertificates = value;
  }
  public resetRotateCertificates() {
    this._rotateCertificates = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rotateCertificatesInput() {
    return this._rotateCertificates;
  }

  // runtime_cgroups - computed: false, optional: true, required: false
  private _runtimeCgroups?: string; 
  public get runtimeCgroups() {
    return this.getStringAttribute('runtime_cgroups');
  }
  public set runtimeCgroups(value: string) {
    this._runtimeCgroups = value;
  }
  public resetRuntimeCgroups() {
    this._runtimeCgroups = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get runtimeCgroupsInput() {
    return this._runtimeCgroups;
  }

  // runtime_request_timeout - computed: false, optional: true, required: false
  private _runtimeRequestTimeout?: string; 
  public get runtimeRequestTimeout() {
    return this.getStringAttribute('runtime_request_timeout');
  }
  public set runtimeRequestTimeout(value: string) {
    this._runtimeRequestTimeout = value;
  }
  public resetRuntimeRequestTimeout() {
    this._runtimeRequestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get runtimeRequestTimeoutInput() {
    return this._runtimeRequestTimeout;
  }

  // seccomp_profile_root - computed: false, optional: true, required: false
  private _seccompProfileRoot?: string; 
  public get seccompProfileRoot() {
    return this.getStringAttribute('seccomp_profile_root');
  }
  public set seccompProfileRoot(value: string) {
    this._seccompProfileRoot = value;
  }
  public resetSeccompProfileRoot() {
    this._seccompProfileRoot = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get seccompProfileRootInput() {
    return this._seccompProfileRoot;
  }

  // serialize_image_pulls - computed: false, optional: true, required: false
  private _serializeImagePulls?: boolean | cdktf.IResolvable; 
  public get serializeImagePulls() {
    return this.getBooleanAttribute('serialize_image_pulls');
  }
  public set serializeImagePulls(value: boolean | cdktf.IResolvable) {
    this._serializeImagePulls = value;
  }
  public resetSerializeImagePulls() {
    this._serializeImagePulls = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serializeImagePullsInput() {
    return this._serializeImagePulls;
  }

  // shutdown_grace_period - computed: false, optional: true, required: false
  private _shutdownGracePeriod?: string; 
  public get shutdownGracePeriod() {
    return this.getStringAttribute('shutdown_grace_period');
  }
  public set shutdownGracePeriod(value: string) {
    this._shutdownGracePeriod = value;
  }
  public resetShutdownGracePeriod() {
    this._shutdownGracePeriod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get shutdownGracePeriodInput() {
    return this._shutdownGracePeriod;
  }

  // shutdown_grace_period_critical_pods - computed: false, optional: true, required: false
  private _shutdownGracePeriodCriticalPods?: string; 
  public get shutdownGracePeriodCriticalPods() {
    return this.getStringAttribute('shutdown_grace_period_critical_pods');
  }
  public set shutdownGracePeriodCriticalPods(value: string) {
    this._shutdownGracePeriodCriticalPods = value;
  }
  public resetShutdownGracePeriodCriticalPods() {
    this._shutdownGracePeriodCriticalPods = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get shutdownGracePeriodCriticalPodsInput() {
    return this._shutdownGracePeriodCriticalPods;
  }

  // streaming_connection_idle_timeout - computed: false, optional: true, required: false
  private _streamingConnectionIdleTimeout?: string; 
  public get streamingConnectionIdleTimeout() {
    return this.getStringAttribute('streaming_connection_idle_timeout');
  }
  public set streamingConnectionIdleTimeout(value: string) {
    this._streamingConnectionIdleTimeout = value;
  }
  public resetStreamingConnectionIdleTimeout() {
    this._streamingConnectionIdleTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamingConnectionIdleTimeoutInput() {
    return this._streamingConnectionIdleTimeout;
  }

  // system_cgroups - computed: false, optional: true, required: false
  private _systemCgroups?: string; 
  public get systemCgroups() {
    return this.getStringAttribute('system_cgroups');
  }
  public set systemCgroups(value: string) {
    this._systemCgroups = value;
  }
  public resetSystemCgroups() {
    this._systemCgroups = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemCgroupsInput() {
    return this._systemCgroups;
  }

  // system_reserved - computed: false, optional: true, required: false
  private _systemReserved?: { [key: string]: string }; 
  public get systemReserved() {
    return this.getStringMapAttribute('system_reserved');
  }
  public set systemReserved(value: { [key: string]: string }) {
    this._systemReserved = value;
  }
  public resetSystemReserved() {
    this._systemReserved = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemReservedInput() {
    return this._systemReserved;
  }

  // system_reserved_cgroup - computed: false, optional: true, required: false
  private _systemReservedCgroup?: string; 
  public get systemReservedCgroup() {
    return this.getStringAttribute('system_reserved_cgroup');
  }
  public set systemReservedCgroup(value: string) {
    this._systemReservedCgroup = value;
  }
  public resetSystemReservedCgroup() {
    this._systemReservedCgroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemReservedCgroupInput() {
    return this._systemReservedCgroup;
  }

  // taints - computed: false, optional: true, required: false
  private _taints?: string[]; 
  public get taints() {
    return this.getListAttribute('taints');
  }
  public set taints(value: string[]) {
    this._taints = value;
  }
  public resetTaints() {
    this._taints = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get taintsInput() {
    return this._taints;
  }

  // tls_cert_file - computed: false, optional: true, required: false
  private _tlsCertFile?: string; 
  public get tlsCertFile() {
    return this.getStringAttribute('tls_cert_file');
  }
  public set tlsCertFile(value: string) {
    this._tlsCertFile = value;
  }
  public resetTlsCertFile() {
    this._tlsCertFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsCertFileInput() {
    return this._tlsCertFile;
  }

  // tls_cipher_suites - computed: false, optional: true, required: false
  private _tlsCipherSuites?: string[]; 
  public get tlsCipherSuites() {
    return this.getListAttribute('tls_cipher_suites');
  }
  public set tlsCipherSuites(value: string[]) {
    this._tlsCipherSuites = value;
  }
  public resetTlsCipherSuites() {
    this._tlsCipherSuites = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsCipherSuitesInput() {
    return this._tlsCipherSuites;
  }

  // tls_min_version - computed: false, optional: true, required: false
  private _tlsMinVersion?: string; 
  public get tlsMinVersion() {
    return this.getStringAttribute('tls_min_version');
  }
  public set tlsMinVersion(value: string) {
    this._tlsMinVersion = value;
  }
  public resetTlsMinVersion() {
    this._tlsMinVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsMinVersionInput() {
    return this._tlsMinVersion;
  }

  // tls_private_key_file - computed: false, optional: true, required: false
  private _tlsPrivateKeyFile?: string; 
  public get tlsPrivateKeyFile() {
    return this.getStringAttribute('tls_private_key_file');
  }
  public set tlsPrivateKeyFile(value: string) {
    this._tlsPrivateKeyFile = value;
  }
  public resetTlsPrivateKeyFile() {
    this._tlsPrivateKeyFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsPrivateKeyFileInput() {
    return this._tlsPrivateKeyFile;
  }

  // topology_manager_policy - computed: false, optional: true, required: false
  private _topologyManagerPolicy?: string; 
  public get topologyManagerPolicy() {
    return this.getStringAttribute('topology_manager_policy');
  }
  public set topologyManagerPolicy(value: string) {
    this._topologyManagerPolicy = value;
  }
  public resetTopologyManagerPolicy() {
    this._topologyManagerPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get topologyManagerPolicyInput() {
    return this._topologyManagerPolicy;
  }

  // volume_plugin_directory - computed: false, optional: true, required: false
  private _volumePluginDirectory?: string; 
  public get volumePluginDirectory() {
    return this.getStringAttribute('volume_plugin_directory');
  }
  public set volumePluginDirectory(value: string) {
    this._volumePluginDirectory = value;
  }
  public resetVolumePluginDirectory() {
    this._volumePluginDirectory = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get volumePluginDirectoryInput() {
    return this._volumePluginDirectory;
  }

  // volume_stats_agg_period - computed: false, optional: true, required: false
  private _volumeStatsAggPeriod?: string; 
  public get volumeStatsAggPeriod() {
    return this.getStringAttribute('volume_stats_agg_period');
  }
  public set volumeStatsAggPeriod(value: string) {
    this._volumeStatsAggPeriod = value;
  }
  public resetVolumeStatsAggPeriod() {
    this._volumeStatsAggPeriod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get volumeStatsAggPeriodInput() {
    return this._volumeStatsAggPeriod;
  }

  // anonymous_auth - computed: false, optional: true, required: false
  private _anonymousAuth = new ClusterKubeletAnonymousAuthOutputReference(this, "anonymous_auth");
  public get anonymousAuth() {
    return this._anonymousAuth;
  }
  public putAnonymousAuth(value: ClusterKubeletAnonymousAuth) {
    this._anonymousAuth.internalValue = value;
  }
  public resetAnonymousAuth() {
    this._anonymousAuth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get anonymousAuthInput() {
    return this._anonymousAuth.internalValue;
  }

  // cpu_cfs_quota - computed: false, optional: true, required: false
  private _cpuCfsQuota = new ClusterKubeletCpuCfsQuotaOutputReference(this, "cpu_cfs_quota");
  public get cpuCfsQuota() {
    return this._cpuCfsQuota;
  }
  public putCpuCfsQuota(value: ClusterKubeletCpuCfsQuota) {
    this._cpuCfsQuota.internalValue = value;
  }
  public resetCpuCfsQuota() {
    this._cpuCfsQuota.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuCfsQuotaInput() {
    return this._cpuCfsQuota.internalValue;
  }
}
export interface ClusterMasterKubeletAnonymousAuth {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#value Cluster#value}
  */
  readonly value?: boolean | cdktf.IResolvable;
}

export function clusterMasterKubeletAnonymousAuthToTerraform(struct?: ClusterMasterKubeletAnonymousAuthOutputReference | ClusterMasterKubeletAnonymousAuth): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value: cdktf.booleanToTerraform(struct!.value),
  }
}


export function clusterMasterKubeletAnonymousAuthToHclTerraform(struct?: ClusterMasterKubeletAnonymousAuthOutputReference | ClusterMasterKubeletAnonymousAuth): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value: {
      value: cdktf.booleanToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterMasterKubeletAnonymousAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterMasterKubeletAnonymousAuth | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterMasterKubeletAnonymousAuth | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._value = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._value = value.value;
    }
  }

  // value - computed: false, optional: true, required: false
  private _value?: boolean | cdktf.IResolvable; 
  public get value() {
    return this.getBooleanAttribute('value');
  }
  public set value(value: boolean | cdktf.IResolvable) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface ClusterMasterKubeletCpuCfsQuota {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#value Cluster#value}
  */
  readonly value?: boolean | cdktf.IResolvable;
}

export function clusterMasterKubeletCpuCfsQuotaToTerraform(struct?: ClusterMasterKubeletCpuCfsQuotaOutputReference | ClusterMasterKubeletCpuCfsQuota): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value: cdktf.booleanToTerraform(struct!.value),
  }
}


export function clusterMasterKubeletCpuCfsQuotaToHclTerraform(struct?: ClusterMasterKubeletCpuCfsQuotaOutputReference | ClusterMasterKubeletCpuCfsQuota): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value: {
      value: cdktf.booleanToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterMasterKubeletCpuCfsQuotaOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterMasterKubeletCpuCfsQuota | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterMasterKubeletCpuCfsQuota | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._value = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._value = value.value;
    }
  }

  // value - computed: false, optional: true, required: false
  private _value?: boolean | cdktf.IResolvable; 
  public get value() {
    return this.getBooleanAttribute('value');
  }
  public set value(value: boolean | cdktf.IResolvable) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface ClusterMasterKubelet {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#allow_privileged Cluster#allow_privileged}
  */
  readonly allowPrivileged?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#allowed_unsafe_sysctls Cluster#allowed_unsafe_sysctls}
  */
  readonly allowedUnsafeSysctls?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#api_servers Cluster#api_servers}
  */
  readonly apiServers?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#authentication_token_webhook Cluster#authentication_token_webhook}
  */
  readonly authenticationTokenWebhook?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#authentication_token_webhook_cache_ttl Cluster#authentication_token_webhook_cache_ttl}
  */
  readonly authenticationTokenWebhookCacheTtl?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#authorization_mode Cluster#authorization_mode}
  */
  readonly authorizationMode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#babysit_daemons Cluster#babysit_daemons}
  */
  readonly babysitDaemons?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#bootstrap_kubeconfig Cluster#bootstrap_kubeconfig}
  */
  readonly bootstrapKubeconfig?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#cgroup_driver Cluster#cgroup_driver}
  */
  readonly cgroupDriver?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#cgroup_root Cluster#cgroup_root}
  */
  readonly cgroupRoot?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#client_ca_file Cluster#client_ca_file}
  */
  readonly clientCaFile?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#cloud_provider Cluster#cloud_provider}
  */
  readonly cloudProvider?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#cluster_dns Cluster#cluster_dns}
  */
  readonly clusterDns?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#cluster_domain Cluster#cluster_domain}
  */
  readonly clusterDomain?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#configure_cbr0 Cluster#configure_cbr0}
  */
  readonly configureCbr0?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#container_log_max_files Cluster#container_log_max_files}
  */
  readonly containerLogMaxFiles?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#container_log_max_size Cluster#container_log_max_size}
  */
  readonly containerLogMaxSize?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#cpu_cfs_quota_period Cluster#cpu_cfs_quota_period}
  */
  readonly cpuCfsQuotaPeriod?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#cpu_manager_policy Cluster#cpu_manager_policy}
  */
  readonly cpuManagerPolicy?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#docker_disable_shared_pid Cluster#docker_disable_shared_pid}
  */
  readonly dockerDisableSharedPid?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#enable_cadvisor_json_endpoints Cluster#enable_cadvisor_json_endpoints}
  */
  readonly enableCadvisorJsonEndpoints?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#enable_custom_metrics Cluster#enable_custom_metrics}
  */
  readonly enableCustomMetrics?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#enable_debugging_handlers Cluster#enable_debugging_handlers}
  */
  readonly enableDebuggingHandlers?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#enforce_node_allocatable Cluster#enforce_node_allocatable}
  */
  readonly enforceNodeAllocatable?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#event_burst Cluster#event_burst}
  */
  readonly eventBurst?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#event_qps Cluster#event_qps}
  */
  readonly eventQps?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#eviction_hard Cluster#eviction_hard}
  */
  readonly evictionHard?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#eviction_max_pod_grace_period Cluster#eviction_max_pod_grace_period}
  */
  readonly evictionMaxPodGracePeriod?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#eviction_minimum_reclaim Cluster#eviction_minimum_reclaim}
  */
  readonly evictionMinimumReclaim?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#eviction_pressure_transition_period Cluster#eviction_pressure_transition_period}
  */
  readonly evictionPressureTransitionPeriod?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#eviction_soft Cluster#eviction_soft}
  */
  readonly evictionSoft?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#eviction_soft_grace_period Cluster#eviction_soft_grace_period}
  */
  readonly evictionSoftGracePeriod?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#experimental_allowed_unsafe_sysctls Cluster#experimental_allowed_unsafe_sysctls}
  */
  readonly experimentalAllowedUnsafeSysctls?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#fail_swap_on Cluster#fail_swap_on}
  */
  readonly failSwapOn?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#feature_gates Cluster#feature_gates}
  */
  readonly featureGates?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#hairpin_mode Cluster#hairpin_mode}
  */
  readonly hairpinMode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#hostname_override Cluster#hostname_override}
  */
  readonly hostnameOverride?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#housekeeping_interval Cluster#housekeeping_interval}
  */
  readonly housekeepingInterval?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#image_gc_high_threshold_percent Cluster#image_gc_high_threshold_percent}
  */
  readonly imageGcHighThresholdPercent?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#image_gc_low_threshold_percent Cluster#image_gc_low_threshold_percent}
  */
  readonly imageGcLowThresholdPercent?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#image_pull_progress_deadline Cluster#image_pull_progress_deadline}
  */
  readonly imagePullProgressDeadline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#kernel_memcg_notification Cluster#kernel_memcg_notification}
  */
  readonly kernelMemcgNotification?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#kube_reserved Cluster#kube_reserved}
  */
  readonly kubeReserved?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#kube_reserved_cgroup Cluster#kube_reserved_cgroup}
  */
  readonly kubeReservedCgroup?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#kubeconfig_path Cluster#kubeconfig_path}
  */
  readonly kubeconfigPath?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#kubelet_cgroups Cluster#kubelet_cgroups}
  */
  readonly kubeletCgroups?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#log_format Cluster#log_format}
  */
  readonly logFormat?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#log_level Cluster#log_level}
  */
  readonly logLevel?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#max_pods Cluster#max_pods}
  */
  readonly maxPods?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#network_plugin_mtu Cluster#network_plugin_mtu}
  */
  readonly networkPluginMtu?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#network_plugin_name Cluster#network_plugin_name}
  */
  readonly networkPluginName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#node_labels Cluster#node_labels}
  */
  readonly nodeLabels?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#node_status_update_frequency Cluster#node_status_update_frequency}
  */
  readonly nodeStatusUpdateFrequency?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#non_masquerade_cidr Cluster#non_masquerade_cidr}
  */
  readonly nonMasqueradeCidr?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#nvidia_gp_us Cluster#nvidia_gp_us}
  */
  readonly nvidiaGpUs?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#pod_cidr Cluster#pod_cidr}
  */
  readonly podCidr?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#pod_infra_container_image Cluster#pod_infra_container_image}
  */
  readonly podInfraContainerImage?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#pod_manifest_path Cluster#pod_manifest_path}
  */
  readonly podManifestPath?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#pod_pids_limit Cluster#pod_pids_limit}
  */
  readonly podPidsLimit?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#protect_kernel_defaults Cluster#protect_kernel_defaults}
  */
  readonly protectKernelDefaults?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#read_only_port Cluster#read_only_port}
  */
  readonly readOnlyPort?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#reconcile_cidr Cluster#reconcile_cidr}
  */
  readonly reconcileCidr?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#register_node Cluster#register_node}
  */
  readonly registerNode?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#register_schedulable Cluster#register_schedulable}
  */
  readonly registerSchedulable?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#registry_burst Cluster#registry_burst}
  */
  readonly registryBurst?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#registry_pull_qps Cluster#registry_pull_qps}
  */
  readonly registryPullQps?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#require_kubeconfig Cluster#require_kubeconfig}
  */
  readonly requireKubeconfig?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#resolver_config Cluster#resolver_config}
  */
  readonly resolverConfig?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#root_dir Cluster#root_dir}
  */
  readonly rootDir?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#rotate_certificates Cluster#rotate_certificates}
  */
  readonly rotateCertificates?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#runtime_cgroups Cluster#runtime_cgroups}
  */
  readonly runtimeCgroups?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#runtime_request_timeout Cluster#runtime_request_timeout}
  */
  readonly runtimeRequestTimeout?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#seccomp_profile_root Cluster#seccomp_profile_root}
  */
  readonly seccompProfileRoot?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#serialize_image_pulls Cluster#serialize_image_pulls}
  */
  readonly serializeImagePulls?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#shutdown_grace_period Cluster#shutdown_grace_period}
  */
  readonly shutdownGracePeriod?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#shutdown_grace_period_critical_pods Cluster#shutdown_grace_period_critical_pods}
  */
  readonly shutdownGracePeriodCriticalPods?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#streaming_connection_idle_timeout Cluster#streaming_connection_idle_timeout}
  */
  readonly streamingConnectionIdleTimeout?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#system_cgroups Cluster#system_cgroups}
  */
  readonly systemCgroups?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#system_reserved Cluster#system_reserved}
  */
  readonly systemReserved?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#system_reserved_cgroup Cluster#system_reserved_cgroup}
  */
  readonly systemReservedCgroup?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#taints Cluster#taints}
  */
  readonly taints?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#tls_cert_file Cluster#tls_cert_file}
  */
  readonly tlsCertFile?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#tls_cipher_suites Cluster#tls_cipher_suites}
  */
  readonly tlsCipherSuites?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#tls_min_version Cluster#tls_min_version}
  */
  readonly tlsMinVersion?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#tls_private_key_file Cluster#tls_private_key_file}
  */
  readonly tlsPrivateKeyFile?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#topology_manager_policy Cluster#topology_manager_policy}
  */
  readonly topologyManagerPolicy?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#volume_plugin_directory Cluster#volume_plugin_directory}
  */
  readonly volumePluginDirectory?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#volume_stats_agg_period Cluster#volume_stats_agg_period}
  */
  readonly volumeStatsAggPeriod?: string;
  /**
  * anonymous_auth block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#anonymous_auth Cluster#anonymous_auth}
  */
  readonly anonymousAuth?: ClusterMasterKubeletAnonymousAuth;
  /**
  * cpu_cfs_quota block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#cpu_cfs_quota Cluster#cpu_cfs_quota}
  */
  readonly cpuCfsQuota?: ClusterMasterKubeletCpuCfsQuota;
}

export function clusterMasterKubeletToTerraform(struct?: ClusterMasterKubeletOutputReference | ClusterMasterKubelet): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_privileged: cdktf.booleanToTerraform(struct!.allowPrivileged),
    allowed_unsafe_sysctls: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.allowedUnsafeSysctls),
    api_servers: cdktf.stringToTerraform(struct!.apiServers),
    authentication_token_webhook: cdktf.booleanToTerraform(struct!.authenticationTokenWebhook),
    authentication_token_webhook_cache_ttl: cdktf.stringToTerraform(struct!.authenticationTokenWebhookCacheTtl),
    authorization_mode: cdktf.stringToTerraform(struct!.authorizationMode),
    babysit_daemons: cdktf.booleanToTerraform(struct!.babysitDaemons),
    bootstrap_kubeconfig: cdktf.stringToTerraform(struct!.bootstrapKubeconfig),
    cgroup_driver: cdktf.stringToTerraform(struct!.cgroupDriver),
    cgroup_root: cdktf.stringToTerraform(struct!.cgroupRoot),
    client_ca_file: cdktf.stringToTerraform(struct!.clientCaFile),
    cloud_provider: cdktf.stringToTerraform(struct!.cloudProvider),
    cluster_dns: cdktf.stringToTerraform(struct!.clusterDns),
    cluster_domain: cdktf.stringToTerraform(struct!.clusterDomain),
    configure_cbr0: cdktf.booleanToTerraform(struct!.configureCbr0),
    container_log_max_files: cdktf.numberToTerraform(struct!.containerLogMaxFiles),
    container_log_max_size: cdktf.stringToTerraform(struct!.containerLogMaxSize),
    cpu_cfs_quota_period: cdktf.stringToTerraform(struct!.cpuCfsQuotaPeriod),
    cpu_manager_policy: cdktf.stringToTerraform(struct!.cpuManagerPolicy),
    docker_disable_shared_pid: cdktf.booleanToTerraform(struct!.dockerDisableSharedPid),
    enable_cadvisor_json_endpoints: cdktf.booleanToTerraform(struct!.enableCadvisorJsonEndpoints),
    enable_custom_metrics: cdktf.booleanToTerraform(struct!.enableCustomMetrics),
    enable_debugging_handlers: cdktf.booleanToTerraform(struct!.enableDebuggingHandlers),
    enforce_node_allocatable: cdktf.stringToTerraform(struct!.enforceNodeAllocatable),
    event_burst: cdktf.numberToTerraform(struct!.eventBurst),
    event_qps: cdktf.numberToTerraform(struct!.eventQps),
    eviction_hard: cdktf.stringToTerraform(struct!.evictionHard),
    eviction_max_pod_grace_period: cdktf.numberToTerraform(struct!.evictionMaxPodGracePeriod),
    eviction_minimum_reclaim: cdktf.stringToTerraform(struct!.evictionMinimumReclaim),
    eviction_pressure_transition_period: cdktf.stringToTerraform(struct!.evictionPressureTransitionPeriod),
    eviction_soft: cdktf.stringToTerraform(struct!.evictionSoft),
    eviction_soft_grace_period: cdktf.stringToTerraform(struct!.evictionSoftGracePeriod),
    experimental_allowed_unsafe_sysctls: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.experimentalAllowedUnsafeSysctls),
    fail_swap_on: cdktf.booleanToTerraform(struct!.failSwapOn),
    feature_gates: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.featureGates),
    hairpin_mode: cdktf.stringToTerraform(struct!.hairpinMode),
    hostname_override: cdktf.stringToTerraform(struct!.hostnameOverride),
    housekeeping_interval: cdktf.stringToTerraform(struct!.housekeepingInterval),
    image_gc_high_threshold_percent: cdktf.numberToTerraform(struct!.imageGcHighThresholdPercent),
    image_gc_low_threshold_percent: cdktf.numberToTerraform(struct!.imageGcLowThresholdPercent),
    image_pull_progress_deadline: cdktf.stringToTerraform(struct!.imagePullProgressDeadline),
    kernel_memcg_notification: cdktf.booleanToTerraform(struct!.kernelMemcgNotification),
    kube_reserved: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.kubeReserved),
    kube_reserved_cgroup: cdktf.stringToTerraform(struct!.kubeReservedCgroup),
    kubeconfig_path: cdktf.stringToTerraform(struct!.kubeconfigPath),
    kubelet_cgroups: cdktf.stringToTerraform(struct!.kubeletCgroups),
    log_format: cdktf.stringToTerraform(struct!.logFormat),
    log_level: cdktf.numberToTerraform(struct!.logLevel),
    max_pods: cdktf.numberToTerraform(struct!.maxPods),
    network_plugin_mtu: cdktf.numberToTerraform(struct!.networkPluginMtu),
    network_plugin_name: cdktf.stringToTerraform(struct!.networkPluginName),
    node_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.nodeLabels),
    node_status_update_frequency: cdktf.stringToTerraform(struct!.nodeStatusUpdateFrequency),
    non_masquerade_cidr: cdktf.stringToTerraform(struct!.nonMasqueradeCidr),
    nvidia_gp_us: cdktf.numberToTerraform(struct!.nvidiaGpUs),
    pod_cidr: cdktf.stringToTerraform(struct!.podCidr),
    pod_infra_container_image: cdktf.stringToTerraform(struct!.podInfraContainerImage),
    pod_manifest_path: cdktf.stringToTerraform(struct!.podManifestPath),
    pod_pids_limit: cdktf.numberToTerraform(struct!.podPidsLimit),
    protect_kernel_defaults: cdktf.booleanToTerraform(struct!.protectKernelDefaults),
    read_only_port: cdktf.numberToTerraform(struct!.readOnlyPort),
    reconcile_cidr: cdktf.booleanToTerraform(struct!.reconcileCidr),
    register_node: cdktf.booleanToTerraform(struct!.registerNode),
    register_schedulable: cdktf.booleanToTerraform(struct!.registerSchedulable),
    registry_burst: cdktf.numberToTerraform(struct!.registryBurst),
    registry_pull_qps: cdktf.numberToTerraform(struct!.registryPullQps),
    require_kubeconfig: cdktf.booleanToTerraform(struct!.requireKubeconfig),
    resolver_config: cdktf.stringToTerraform(struct!.resolverConfig),
    root_dir: cdktf.stringToTerraform(struct!.rootDir),
    rotate_certificates: cdktf.booleanToTerraform(struct!.rotateCertificates),
    runtime_cgroups: cdktf.stringToTerraform(struct!.runtimeCgroups),
    runtime_request_timeout: cdktf.stringToTerraform(struct!.runtimeRequestTimeout),
    seccomp_profile_root: cdktf.stringToTerraform(struct!.seccompProfileRoot),
    serialize_image_pulls: cdktf.booleanToTerraform(struct!.serializeImagePulls),
    shutdown_grace_period: cdktf.stringToTerraform(struct!.shutdownGracePeriod),
    shutdown_grace_period_critical_pods: cdktf.stringToTerraform(struct!.shutdownGracePeriodCriticalPods),
    streaming_connection_idle_timeout: cdktf.stringToTerraform(struct!.streamingConnectionIdleTimeout),
    system_cgroups: cdktf.stringToTerraform(struct!.systemCgroups),
    system_reserved: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.systemReserved),
    system_reserved_cgroup: cdktf.stringToTerraform(struct!.systemReservedCgroup),
    taints: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.taints),
    tls_cert_file: cdktf.stringToTerraform(struct!.tlsCertFile),
    tls_cipher_suites: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.tlsCipherSuites),
    tls_min_version: cdktf.stringToTerraform(struct!.tlsMinVersion),
    tls_private_key_file: cdktf.stringToTerraform(struct!.tlsPrivateKeyFile),
    topology_manager_policy: cdktf.stringToTerraform(struct!.topologyManagerPolicy),
    volume_plugin_directory: cdktf.stringToTerraform(struct!.volumePluginDirectory),
    volume_stats_agg_period: cdktf.stringToTerraform(struct!.volumeStatsAggPeriod),
    anonymous_auth: clusterMasterKubeletAnonymousAuthToTerraform(struct!.anonymousAuth),
    cpu_cfs_quota: clusterMasterKubeletCpuCfsQuotaToTerraform(struct!.cpuCfsQuota),
  }
}


export function clusterMasterKubeletToHclTerraform(struct?: ClusterMasterKubeletOutputReference | ClusterMasterKubelet): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_privileged: {
      value: cdktf.booleanToHclTerraform(struct!.allowPrivileged),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    allowed_unsafe_sysctls: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.allowedUnsafeSysctls),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    api_servers: {
      value: cdktf.stringToHclTerraform(struct!.apiServers),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    authentication_token_webhook: {
      value: cdktf.booleanToHclTerraform(struct!.authenticationTokenWebhook),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    authentication_token_webhook_cache_ttl: {
      value: cdktf.stringToHclTerraform(struct!.authenticationTokenWebhookCacheTtl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    authorization_mode: {
      value: cdktf.stringToHclTerraform(struct!.authorizationMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    babysit_daemons: {
      value: cdktf.booleanToHclTerraform(struct!.babysitDaemons),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    bootstrap_kubeconfig: {
      value: cdktf.stringToHclTerraform(struct!.bootstrapKubeconfig),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cgroup_driver: {
      value: cdktf.stringToHclTerraform(struct!.cgroupDriver),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cgroup_root: {
      value: cdktf.stringToHclTerraform(struct!.cgroupRoot),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_ca_file: {
      value: cdktf.stringToHclTerraform(struct!.clientCaFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cloud_provider: {
      value: cdktf.stringToHclTerraform(struct!.cloudProvider),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cluster_dns: {
      value: cdktf.stringToHclTerraform(struct!.clusterDns),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cluster_domain: {
      value: cdktf.stringToHclTerraform(struct!.clusterDomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    configure_cbr0: {
      value: cdktf.booleanToHclTerraform(struct!.configureCbr0),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    container_log_max_files: {
      value: cdktf.numberToHclTerraform(struct!.containerLogMaxFiles),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    container_log_max_size: {
      value: cdktf.stringToHclTerraform(struct!.containerLogMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cpu_cfs_quota_period: {
      value: cdktf.stringToHclTerraform(struct!.cpuCfsQuotaPeriod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cpu_manager_policy: {
      value: cdktf.stringToHclTerraform(struct!.cpuManagerPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    docker_disable_shared_pid: {
      value: cdktf.booleanToHclTerraform(struct!.dockerDisableSharedPid),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_cadvisor_json_endpoints: {
      value: cdktf.booleanToHclTerraform(struct!.enableCadvisorJsonEndpoints),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_custom_metrics: {
      value: cdktf.booleanToHclTerraform(struct!.enableCustomMetrics),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_debugging_handlers: {
      value: cdktf.booleanToHclTerraform(struct!.enableDebuggingHandlers),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enforce_node_allocatable: {
      value: cdktf.stringToHclTerraform(struct!.enforceNodeAllocatable),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    event_burst: {
      value: cdktf.numberToHclTerraform(struct!.eventBurst),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    event_qps: {
      value: cdktf.numberToHclTerraform(struct!.eventQps),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    eviction_hard: {
      value: cdktf.stringToHclTerraform(struct!.evictionHard),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    eviction_max_pod_grace_period: {
      value: cdktf.numberToHclTerraform(struct!.evictionMaxPodGracePeriod),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    eviction_minimum_reclaim: {
      value: cdktf.stringToHclTerraform(struct!.evictionMinimumReclaim),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    eviction_pressure_transition_period: {
      value: cdktf.stringToHclTerraform(struct!.evictionPressureTransitionPeriod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    eviction_soft: {
      value: cdktf.stringToHclTerraform(struct!.evictionSoft),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    eviction_soft_grace_period: {
      value: cdktf.stringToHclTerraform(struct!.evictionSoftGracePeriod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    experimental_allowed_unsafe_sysctls: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.experimentalAllowedUnsafeSysctls),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    fail_swap_on: {
      value: cdktf.booleanToHclTerraform(struct!.failSwapOn),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    feature_gates: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.featureGates),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    hairpin_mode: {
      value: cdktf.stringToHclTerraform(struct!.hairpinMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname_override: {
      value: cdktf.stringToHclTerraform(struct!.hostnameOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    housekeeping_interval: {
      value: cdktf.stringToHclTerraform(struct!.housekeepingInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    image_gc_high_threshold_percent: {
      value: cdktf.numberToHclTerraform(struct!.imageGcHighThresholdPercent),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    image_gc_low_threshold_percent: {
      value: cdktf.numberToHclTerraform(struct!.imageGcLowThresholdPercent),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    image_pull_progress_deadline: {
      value: cdktf.stringToHclTerraform(struct!.imagePullProgressDeadline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kernel_memcg_notification: {
      value: cdktf.booleanToHclTerraform(struct!.kernelMemcgNotification),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    kube_reserved: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.kubeReserved),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    kube_reserved_cgroup: {
      value: cdktf.stringToHclTerraform(struct!.kubeReservedCgroup),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kubeconfig_path: {
      value: cdktf.stringToHclTerraform(struct!.kubeconfigPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kubelet_cgroups: {
      value: cdktf.stringToHclTerraform(struct!.kubeletCgroups),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_format: {
      value: cdktf.stringToHclTerraform(struct!.logFormat),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_level: {
      value: cdktf.numberToHclTerraform(struct!.logLevel),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_pods: {
      value: cdktf.numberToHclTerraform(struct!.maxPods),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    network_plugin_mtu: {
      value: cdktf.numberToHclTerraform(struct!.networkPluginMtu),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    network_plugin_name: {
      value: cdktf.stringToHclTerraform(struct!.networkPluginName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    node_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.nodeLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    node_status_update_frequency: {
      value: cdktf.stringToHclTerraform(struct!.nodeStatusUpdateFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    non_masquerade_cidr: {
      value: cdktf.stringToHclTerraform(struct!.nonMasqueradeCidr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    nvidia_gp_us: {
      value: cdktf.numberToHclTerraform(struct!.nvidiaGpUs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pod_cidr: {
      value: cdktf.stringToHclTerraform(struct!.podCidr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pod_infra_container_image: {
      value: cdktf.stringToHclTerraform(struct!.podInfraContainerImage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pod_manifest_path: {
      value: cdktf.stringToHclTerraform(struct!.podManifestPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pod_pids_limit: {
      value: cdktf.numberToHclTerraform(struct!.podPidsLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    protect_kernel_defaults: {
      value: cdktf.booleanToHclTerraform(struct!.protectKernelDefaults),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    read_only_port: {
      value: cdktf.numberToHclTerraform(struct!.readOnlyPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    reconcile_cidr: {
      value: cdktf.booleanToHclTerraform(struct!.reconcileCidr),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    register_node: {
      value: cdktf.booleanToHclTerraform(struct!.registerNode),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    register_schedulable: {
      value: cdktf.booleanToHclTerraform(struct!.registerSchedulable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    registry_burst: {
      value: cdktf.numberToHclTerraform(struct!.registryBurst),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    registry_pull_qps: {
      value: cdktf.numberToHclTerraform(struct!.registryPullQps),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    require_kubeconfig: {
      value: cdktf.booleanToHclTerraform(struct!.requireKubeconfig),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    resolver_config: {
      value: cdktf.stringToHclTerraform(struct!.resolverConfig),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    root_dir: {
      value: cdktf.stringToHclTerraform(struct!.rootDir),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    rotate_certificates: {
      value: cdktf.booleanToHclTerraform(struct!.rotateCertificates),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    runtime_cgroups: {
      value: cdktf.stringToHclTerraform(struct!.runtimeCgroups),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    runtime_request_timeout: {
      value: cdktf.stringToHclTerraform(struct!.runtimeRequestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    seccomp_profile_root: {
      value: cdktf.stringToHclTerraform(struct!.seccompProfileRoot),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    serialize_image_pulls: {
      value: cdktf.booleanToHclTerraform(struct!.serializeImagePulls),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    shutdown_grace_period: {
      value: cdktf.stringToHclTerraform(struct!.shutdownGracePeriod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    shutdown_grace_period_critical_pods: {
      value: cdktf.stringToHclTerraform(struct!.shutdownGracePeriodCriticalPods),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streaming_connection_idle_timeout: {
      value: cdktf.stringToHclTerraform(struct!.streamingConnectionIdleTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    system_cgroups: {
      value: cdktf.stringToHclTerraform(struct!.systemCgroups),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    system_reserved: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.systemReserved),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    system_reserved_cgroup: {
      value: cdktf.stringToHclTerraform(struct!.systemReservedCgroup),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    taints: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.taints),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tls_cert_file: {
      value: cdktf.stringToHclTerraform(struct!.tlsCertFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls_cipher_suites: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.tlsCipherSuites),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tls_min_version: {
      value: cdktf.stringToHclTerraform(struct!.tlsMinVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls_private_key_file: {
      value: cdktf.stringToHclTerraform(struct!.tlsPrivateKeyFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    topology_manager_policy: {
      value: cdktf.stringToHclTerraform(struct!.topologyManagerPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    volume_plugin_directory: {
      value: cdktf.stringToHclTerraform(struct!.volumePluginDirectory),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    volume_stats_agg_period: {
      value: cdktf.stringToHclTerraform(struct!.volumeStatsAggPeriod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    anonymous_auth: {
      value: clusterMasterKubeletAnonymousAuthToHclTerraform(struct!.anonymousAuth),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterMasterKubeletAnonymousAuthList",
    },
    cpu_cfs_quota: {
      value: clusterMasterKubeletCpuCfsQuotaToHclTerraform(struct!.cpuCfsQuota),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterMasterKubeletCpuCfsQuotaList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterMasterKubeletOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterMasterKubelet | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowPrivileged !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowPrivileged = this._allowPrivileged;
    }
    if (this._allowedUnsafeSysctls !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowedUnsafeSysctls = this._allowedUnsafeSysctls;
    }
    if (this._apiServers !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiServers = this._apiServers;
    }
    if (this._authenticationTokenWebhook !== undefined) {
      hasAnyValues = true;
      internalValueResult.authenticationTokenWebhook = this._authenticationTokenWebhook;
    }
    if (this._authenticationTokenWebhookCacheTtl !== undefined) {
      hasAnyValues = true;
      internalValueResult.authenticationTokenWebhookCacheTtl = this._authenticationTokenWebhookCacheTtl;
    }
    if (this._authorizationMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.authorizationMode = this._authorizationMode;
    }
    if (this._babysitDaemons !== undefined) {
      hasAnyValues = true;
      internalValueResult.babysitDaemons = this._babysitDaemons;
    }
    if (this._bootstrapKubeconfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.bootstrapKubeconfig = this._bootstrapKubeconfig;
    }
    if (this._cgroupDriver !== undefined) {
      hasAnyValues = true;
      internalValueResult.cgroupDriver = this._cgroupDriver;
    }
    if (this._cgroupRoot !== undefined) {
      hasAnyValues = true;
      internalValueResult.cgroupRoot = this._cgroupRoot;
    }
    if (this._clientCaFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientCaFile = this._clientCaFile;
    }
    if (this._cloudProvider !== undefined) {
      hasAnyValues = true;
      internalValueResult.cloudProvider = this._cloudProvider;
    }
    if (this._clusterDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterDns = this._clusterDns;
    }
    if (this._clusterDomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterDomain = this._clusterDomain;
    }
    if (this._configureCbr0 !== undefined) {
      hasAnyValues = true;
      internalValueResult.configureCbr0 = this._configureCbr0;
    }
    if (this._containerLogMaxFiles !== undefined) {
      hasAnyValues = true;
      internalValueResult.containerLogMaxFiles = this._containerLogMaxFiles;
    }
    if (this._containerLogMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.containerLogMaxSize = this._containerLogMaxSize;
    }
    if (this._cpuCfsQuotaPeriod !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpuCfsQuotaPeriod = this._cpuCfsQuotaPeriod;
    }
    if (this._cpuManagerPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpuManagerPolicy = this._cpuManagerPolicy;
    }
    if (this._dockerDisableSharedPid !== undefined) {
      hasAnyValues = true;
      internalValueResult.dockerDisableSharedPid = this._dockerDisableSharedPid;
    }
    if (this._enableCadvisorJsonEndpoints !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableCadvisorJsonEndpoints = this._enableCadvisorJsonEndpoints;
    }
    if (this._enableCustomMetrics !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableCustomMetrics = this._enableCustomMetrics;
    }
    if (this._enableDebuggingHandlers !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableDebuggingHandlers = this._enableDebuggingHandlers;
    }
    if (this._enforceNodeAllocatable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enforceNodeAllocatable = this._enforceNodeAllocatable;
    }
    if (this._eventBurst !== undefined) {
      hasAnyValues = true;
      internalValueResult.eventBurst = this._eventBurst;
    }
    if (this._eventQps !== undefined) {
      hasAnyValues = true;
      internalValueResult.eventQps = this._eventQps;
    }
    if (this._evictionHard !== undefined) {
      hasAnyValues = true;
      internalValueResult.evictionHard = this._evictionHard;
    }
    if (this._evictionMaxPodGracePeriod !== undefined) {
      hasAnyValues = true;
      internalValueResult.evictionMaxPodGracePeriod = this._evictionMaxPodGracePeriod;
    }
    if (this._evictionMinimumReclaim !== undefined) {
      hasAnyValues = true;
      internalValueResult.evictionMinimumReclaim = this._evictionMinimumReclaim;
    }
    if (this._evictionPressureTransitionPeriod !== undefined) {
      hasAnyValues = true;
      internalValueResult.evictionPressureTransitionPeriod = this._evictionPressureTransitionPeriod;
    }
    if (this._evictionSoft !== undefined) {
      hasAnyValues = true;
      internalValueResult.evictionSoft = this._evictionSoft;
    }
    if (this._evictionSoftGracePeriod !== undefined) {
      hasAnyValues = true;
      internalValueResult.evictionSoftGracePeriod = this._evictionSoftGracePeriod;
    }
    if (this._experimentalAllowedUnsafeSysctls !== undefined) {
      hasAnyValues = true;
      internalValueResult.experimentalAllowedUnsafeSysctls = this._experimentalAllowedUnsafeSysctls;
    }
    if (this._failSwapOn !== undefined) {
      hasAnyValues = true;
      internalValueResult.failSwapOn = this._failSwapOn;
    }
    if (this._featureGates !== undefined) {
      hasAnyValues = true;
      internalValueResult.featureGates = this._featureGates;
    }
    if (this._hairpinMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.hairpinMode = this._hairpinMode;
    }
    if (this._hostnameOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostnameOverride = this._hostnameOverride;
    }
    if (this._housekeepingInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.housekeepingInterval = this._housekeepingInterval;
    }
    if (this._imageGcHighThresholdPercent !== undefined) {
      hasAnyValues = true;
      internalValueResult.imageGcHighThresholdPercent = this._imageGcHighThresholdPercent;
    }
    if (this._imageGcLowThresholdPercent !== undefined) {
      hasAnyValues = true;
      internalValueResult.imageGcLowThresholdPercent = this._imageGcLowThresholdPercent;
    }
    if (this._imagePullProgressDeadline !== undefined) {
      hasAnyValues = true;
      internalValueResult.imagePullProgressDeadline = this._imagePullProgressDeadline;
    }
    if (this._kernelMemcgNotification !== undefined) {
      hasAnyValues = true;
      internalValueResult.kernelMemcgNotification = this._kernelMemcgNotification;
    }
    if (this._kubeReserved !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubeReserved = this._kubeReserved;
    }
    if (this._kubeReservedCgroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubeReservedCgroup = this._kubeReservedCgroup;
    }
    if (this._kubeconfigPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubeconfigPath = this._kubeconfigPath;
    }
    if (this._kubeletCgroups !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubeletCgroups = this._kubeletCgroups;
    }
    if (this._logFormat !== undefined) {
      hasAnyValues = true;
      internalValueResult.logFormat = this._logFormat;
    }
    if (this._logLevel !== undefined) {
      hasAnyValues = true;
      internalValueResult.logLevel = this._logLevel;
    }
    if (this._maxPods !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPods = this._maxPods;
    }
    if (this._networkPluginMtu !== undefined) {
      hasAnyValues = true;
      internalValueResult.networkPluginMtu = this._networkPluginMtu;
    }
    if (this._networkPluginName !== undefined) {
      hasAnyValues = true;
      internalValueResult.networkPluginName = this._networkPluginName;
    }
    if (this._nodeLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeLabels = this._nodeLabels;
    }
    if (this._nodeStatusUpdateFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeStatusUpdateFrequency = this._nodeStatusUpdateFrequency;
    }
    if (this._nonMasqueradeCidr !== undefined) {
      hasAnyValues = true;
      internalValueResult.nonMasqueradeCidr = this._nonMasqueradeCidr;
    }
    if (this._nvidiaGpUs !== undefined) {
      hasAnyValues = true;
      internalValueResult.nvidiaGpUs = this._nvidiaGpUs;
    }
    if (this._podCidr !== undefined) {
      hasAnyValues = true;
      internalValueResult.podCidr = this._podCidr;
    }
    if (this._podInfraContainerImage !== undefined) {
      hasAnyValues = true;
      internalValueResult.podInfraContainerImage = this._podInfraContainerImage;
    }
    if (this._podManifestPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.podManifestPath = this._podManifestPath;
    }
    if (this._podPidsLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.podPidsLimit = this._podPidsLimit;
    }
    if (this._protectKernelDefaults !== undefined) {
      hasAnyValues = true;
      internalValueResult.protectKernelDefaults = this._protectKernelDefaults;
    }
    if (this._readOnlyPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.readOnlyPort = this._readOnlyPort;
    }
    if (this._reconcileCidr !== undefined) {
      hasAnyValues = true;
      internalValueResult.reconcileCidr = this._reconcileCidr;
    }
    if (this._registerNode !== undefined) {
      hasAnyValues = true;
      internalValueResult.registerNode = this._registerNode;
    }
    if (this._registerSchedulable !== undefined) {
      hasAnyValues = true;
      internalValueResult.registerSchedulable = this._registerSchedulable;
    }
    if (this._registryBurst !== undefined) {
      hasAnyValues = true;
      internalValueResult.registryBurst = this._registryBurst;
    }
    if (this._registryPullQps !== undefined) {
      hasAnyValues = true;
      internalValueResult.registryPullQps = this._registryPullQps;
    }
    if (this._requireKubeconfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.requireKubeconfig = this._requireKubeconfig;
    }
    if (this._resolverConfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.resolverConfig = this._resolverConfig;
    }
    if (this._rootDir !== undefined) {
      hasAnyValues = true;
      internalValueResult.rootDir = this._rootDir;
    }
    if (this._rotateCertificates !== undefined) {
      hasAnyValues = true;
      internalValueResult.rotateCertificates = this._rotateCertificates;
    }
    if (this._runtimeCgroups !== undefined) {
      hasAnyValues = true;
      internalValueResult.runtimeCgroups = this._runtimeCgroups;
    }
    if (this._runtimeRequestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.runtimeRequestTimeout = this._runtimeRequestTimeout;
    }
    if (this._seccompProfileRoot !== undefined) {
      hasAnyValues = true;
      internalValueResult.seccompProfileRoot = this._seccompProfileRoot;
    }
    if (this._serializeImagePulls !== undefined) {
      hasAnyValues = true;
      internalValueResult.serializeImagePulls = this._serializeImagePulls;
    }
    if (this._shutdownGracePeriod !== undefined) {
      hasAnyValues = true;
      internalValueResult.shutdownGracePeriod = this._shutdownGracePeriod;
    }
    if (this._shutdownGracePeriodCriticalPods !== undefined) {
      hasAnyValues = true;
      internalValueResult.shutdownGracePeriodCriticalPods = this._shutdownGracePeriodCriticalPods;
    }
    if (this._streamingConnectionIdleTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamingConnectionIdleTimeout = this._streamingConnectionIdleTimeout;
    }
    if (this._systemCgroups !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemCgroups = this._systemCgroups;
    }
    if (this._systemReserved !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemReserved = this._systemReserved;
    }
    if (this._systemReservedCgroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemReservedCgroup = this._systemReservedCgroup;
    }
    if (this._taints !== undefined) {
      hasAnyValues = true;
      internalValueResult.taints = this._taints;
    }
    if (this._tlsCertFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsCertFile = this._tlsCertFile;
    }
    if (this._tlsCipherSuites !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsCipherSuites = this._tlsCipherSuites;
    }
    if (this._tlsMinVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsMinVersion = this._tlsMinVersion;
    }
    if (this._tlsPrivateKeyFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsPrivateKeyFile = this._tlsPrivateKeyFile;
    }
    if (this._topologyManagerPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.topologyManagerPolicy = this._topologyManagerPolicy;
    }
    if (this._volumePluginDirectory !== undefined) {
      hasAnyValues = true;
      internalValueResult.volumePluginDirectory = this._volumePluginDirectory;
    }
    if (this._volumeStatsAggPeriod !== undefined) {
      hasAnyValues = true;
      internalValueResult.volumeStatsAggPeriod = this._volumeStatsAggPeriod;
    }
    if (this._anonymousAuth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.anonymousAuth = this._anonymousAuth?.internalValue;
    }
    if (this._cpuCfsQuota?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpuCfsQuota = this._cpuCfsQuota?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterMasterKubelet | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._allowPrivileged = undefined;
      this._allowedUnsafeSysctls = undefined;
      this._apiServers = undefined;
      this._authenticationTokenWebhook = undefined;
      this._authenticationTokenWebhookCacheTtl = undefined;
      this._authorizationMode = undefined;
      this._babysitDaemons = undefined;
      this._bootstrapKubeconfig = undefined;
      this._cgroupDriver = undefined;
      this._cgroupRoot = undefined;
      this._clientCaFile = undefined;
      this._cloudProvider = undefined;
      this._clusterDns = undefined;
      this._clusterDomain = undefined;
      this._configureCbr0 = undefined;
      this._containerLogMaxFiles = undefined;
      this._containerLogMaxSize = undefined;
      this._cpuCfsQuotaPeriod = undefined;
      this._cpuManagerPolicy = undefined;
      this._dockerDisableSharedPid = undefined;
      this._enableCadvisorJsonEndpoints = undefined;
      this._enableCustomMetrics = undefined;
      this._enableDebuggingHandlers = undefined;
      this._enforceNodeAllocatable = undefined;
      this._eventBurst = undefined;
      this._eventQps = undefined;
      this._evictionHard = undefined;
      this._evictionMaxPodGracePeriod = undefined;
      this._evictionMinimumReclaim = undefined;
      this._evictionPressureTransitionPeriod = undefined;
      this._evictionSoft = undefined;
      this._evictionSoftGracePeriod = undefined;
      this._experimentalAllowedUnsafeSysctls = undefined;
      this._failSwapOn = undefined;
      this._featureGates = undefined;
      this._hairpinMode = undefined;
      this._hostnameOverride = undefined;
      this._housekeepingInterval = undefined;
      this._imageGcHighThresholdPercent = undefined;
      this._imageGcLowThresholdPercent = undefined;
      this._imagePullProgressDeadline = undefined;
      this._kernelMemcgNotification = undefined;
      this._kubeReserved = undefined;
      this._kubeReservedCgroup = undefined;
      this._kubeconfigPath = undefined;
      this._kubeletCgroups = undefined;
      this._logFormat = undefined;
      this._logLevel = undefined;
      this._maxPods = undefined;
      this._networkPluginMtu = undefined;
      this._networkPluginName = undefined;
      this._nodeLabels = undefined;
      this._nodeStatusUpdateFrequency = undefined;
      this._nonMasqueradeCidr = undefined;
      this._nvidiaGpUs = undefined;
      this._podCidr = undefined;
      this._podInfraContainerImage = undefined;
      this._podManifestPath = undefined;
      this._podPidsLimit = undefined;
      this._protectKernelDefaults = undefined;
      this._readOnlyPort = undefined;
      this._reconcileCidr = undefined;
      this._registerNode = undefined;
      this._registerSchedulable = undefined;
      this._registryBurst = undefined;
      this._registryPullQps = undefined;
      this._requireKubeconfig = undefined;
      this._resolverConfig = undefined;
      this._rootDir = undefined;
      this._rotateCertificates = undefined;
      this._runtimeCgroups = undefined;
      this._runtimeRequestTimeout = undefined;
      this._seccompProfileRoot = undefined;
      this._serializeImagePulls = undefined;
      this._shutdownGracePeriod = undefined;
      this._shutdownGracePeriodCriticalPods = undefined;
      this._streamingConnectionIdleTimeout = undefined;
      this._systemCgroups = undefined;
      this._systemReserved = undefined;
      this._systemReservedCgroup = undefined;
      this._taints = undefined;
      this._tlsCertFile = undefined;
      this._tlsCipherSuites = undefined;
      this._tlsMinVersion = undefined;
      this._tlsPrivateKeyFile = undefined;
      this._topologyManagerPolicy = undefined;
      this._volumePluginDirectory = undefined;
      this._volumeStatsAggPeriod = undefined;
      this._anonymousAuth.internalValue = undefined;
      this._cpuCfsQuota.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._allowPrivileged = value.allowPrivileged;
      this._allowedUnsafeSysctls = value.allowedUnsafeSysctls;
      this._apiServers = value.apiServers;
      this._authenticationTokenWebhook = value.authenticationTokenWebhook;
      this._authenticationTokenWebhookCacheTtl = value.authenticationTokenWebhookCacheTtl;
      this._authorizationMode = value.authorizationMode;
      this._babysitDaemons = value.babysitDaemons;
      this._bootstrapKubeconfig = value.bootstrapKubeconfig;
      this._cgroupDriver = value.cgroupDriver;
      this._cgroupRoot = value.cgroupRoot;
      this._clientCaFile = value.clientCaFile;
      this._cloudProvider = value.cloudProvider;
      this._clusterDns = value.clusterDns;
      this._clusterDomain = value.clusterDomain;
      this._configureCbr0 = value.configureCbr0;
      this._containerLogMaxFiles = value.containerLogMaxFiles;
      this._containerLogMaxSize = value.containerLogMaxSize;
      this._cpuCfsQuotaPeriod = value.cpuCfsQuotaPeriod;
      this._cpuManagerPolicy = value.cpuManagerPolicy;
      this._dockerDisableSharedPid = value.dockerDisableSharedPid;
      this._enableCadvisorJsonEndpoints = value.enableCadvisorJsonEndpoints;
      this._enableCustomMetrics = value.enableCustomMetrics;
      this._enableDebuggingHandlers = value.enableDebuggingHandlers;
      this._enforceNodeAllocatable = value.enforceNodeAllocatable;
      this._eventBurst = value.eventBurst;
      this._eventQps = value.eventQps;
      this._evictionHard = value.evictionHard;
      this._evictionMaxPodGracePeriod = value.evictionMaxPodGracePeriod;
      this._evictionMinimumReclaim = value.evictionMinimumReclaim;
      this._evictionPressureTransitionPeriod = value.evictionPressureTransitionPeriod;
      this._evictionSoft = value.evictionSoft;
      this._evictionSoftGracePeriod = value.evictionSoftGracePeriod;
      this._experimentalAllowedUnsafeSysctls = value.experimentalAllowedUnsafeSysctls;
      this._failSwapOn = value.failSwapOn;
      this._featureGates = value.featureGates;
      this._hairpinMode = value.hairpinMode;
      this._hostnameOverride = value.hostnameOverride;
      this._housekeepingInterval = value.housekeepingInterval;
      this._imageGcHighThresholdPercent = value.imageGcHighThresholdPercent;
      this._imageGcLowThresholdPercent = value.imageGcLowThresholdPercent;
      this._imagePullProgressDeadline = value.imagePullProgressDeadline;
      this._kernelMemcgNotification = value.kernelMemcgNotification;
      this._kubeReserved = value.kubeReserved;
      this._kubeReservedCgroup = value.kubeReservedCgroup;
      this._kubeconfigPath = value.kubeconfigPath;
      this._kubeletCgroups = value.kubeletCgroups;
      this._logFormat = value.logFormat;
      this._logLevel = value.logLevel;
      this._maxPods = value.maxPods;
      this._networkPluginMtu = value.networkPluginMtu;
      this._networkPluginName = value.networkPluginName;
      this._nodeLabels = value.nodeLabels;
      this._nodeStatusUpdateFrequency = value.nodeStatusUpdateFrequency;
      this._nonMasqueradeCidr = value.nonMasqueradeCidr;
      this._nvidiaGpUs = value.nvidiaGpUs;
      this._podCidr = value.podCidr;
      this._podInfraContainerImage = value.podInfraContainerImage;
      this._podManifestPath = value.podManifestPath;
      this._podPidsLimit = value.podPidsLimit;
      this._protectKernelDefaults = value.protectKernelDefaults;
      this._readOnlyPort = value.readOnlyPort;
      this._reconcileCidr = value.reconcileCidr;
      this._registerNode = value.registerNode;
      this._registerSchedulable = value.registerSchedulable;
      this._registryBurst = value.registryBurst;
      this._registryPullQps = value.registryPullQps;
      this._requireKubeconfig = value.requireKubeconfig;
      this._resolverConfig = value.resolverConfig;
      this._rootDir = value.rootDir;
      this._rotateCertificates = value.rotateCertificates;
      this._runtimeCgroups = value.runtimeCgroups;
      this._runtimeRequestTimeout = value.runtimeRequestTimeout;
      this._seccompProfileRoot = value.seccompProfileRoot;
      this._serializeImagePulls = value.serializeImagePulls;
      this._shutdownGracePeriod = value.shutdownGracePeriod;
      this._shutdownGracePeriodCriticalPods = value.shutdownGracePeriodCriticalPods;
      this._streamingConnectionIdleTimeout = value.streamingConnectionIdleTimeout;
      this._systemCgroups = value.systemCgroups;
      this._systemReserved = value.systemReserved;
      this._systemReservedCgroup = value.systemReservedCgroup;
      this._taints = value.taints;
      this._tlsCertFile = value.tlsCertFile;
      this._tlsCipherSuites = value.tlsCipherSuites;
      this._tlsMinVersion = value.tlsMinVersion;
      this._tlsPrivateKeyFile = value.tlsPrivateKeyFile;
      this._topologyManagerPolicy = value.topologyManagerPolicy;
      this._volumePluginDirectory = value.volumePluginDirectory;
      this._volumeStatsAggPeriod = value.volumeStatsAggPeriod;
      this._anonymousAuth.internalValue = value.anonymousAuth;
      this._cpuCfsQuota.internalValue = value.cpuCfsQuota;
    }
  }

  // allow_privileged - computed: false, optional: true, required: false
  private _allowPrivileged?: boolean | cdktf.IResolvable; 
  public get allowPrivileged() {
    return this.getBooleanAttribute('allow_privileged');
  }
  public set allowPrivileged(value: boolean | cdktf.IResolvable) {
    this._allowPrivileged = value;
  }
  public resetAllowPrivileged() {
    this._allowPrivileged = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowPrivilegedInput() {
    return this._allowPrivileged;
  }

  // allowed_unsafe_sysctls - computed: false, optional: true, required: false
  private _allowedUnsafeSysctls?: string[]; 
  public get allowedUnsafeSysctls() {
    return this.getListAttribute('allowed_unsafe_sysctls');
  }
  public set allowedUnsafeSysctls(value: string[]) {
    this._allowedUnsafeSysctls = value;
  }
  public resetAllowedUnsafeSysctls() {
    this._allowedUnsafeSysctls = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowedUnsafeSysctlsInput() {
    return this._allowedUnsafeSysctls;
  }

  // api_servers - computed: false, optional: true, required: false
  private _apiServers?: string; 
  public get apiServers() {
    return this.getStringAttribute('api_servers');
  }
  public set apiServers(value: string) {
    this._apiServers = value;
  }
  public resetApiServers() {
    this._apiServers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiServersInput() {
    return this._apiServers;
  }

  // authentication_token_webhook - computed: false, optional: true, required: false
  private _authenticationTokenWebhook?: boolean | cdktf.IResolvable; 
  public get authenticationTokenWebhook() {
    return this.getBooleanAttribute('authentication_token_webhook');
  }
  public set authenticationTokenWebhook(value: boolean | cdktf.IResolvable) {
    this._authenticationTokenWebhook = value;
  }
  public resetAuthenticationTokenWebhook() {
    this._authenticationTokenWebhook = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authenticationTokenWebhookInput() {
    return this._authenticationTokenWebhook;
  }

  // authentication_token_webhook_cache_ttl - computed: false, optional: true, required: false
  private _authenticationTokenWebhookCacheTtl?: string; 
  public get authenticationTokenWebhookCacheTtl() {
    return this.getStringAttribute('authentication_token_webhook_cache_ttl');
  }
  public set authenticationTokenWebhookCacheTtl(value: string) {
    this._authenticationTokenWebhookCacheTtl = value;
  }
  public resetAuthenticationTokenWebhookCacheTtl() {
    this._authenticationTokenWebhookCacheTtl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authenticationTokenWebhookCacheTtlInput() {
    return this._authenticationTokenWebhookCacheTtl;
  }

  // authorization_mode - computed: false, optional: true, required: false
  private _authorizationMode?: string; 
  public get authorizationMode() {
    return this.getStringAttribute('authorization_mode');
  }
  public set authorizationMode(value: string) {
    this._authorizationMode = value;
  }
  public resetAuthorizationMode() {
    this._authorizationMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authorizationModeInput() {
    return this._authorizationMode;
  }

  // babysit_daemons - computed: false, optional: true, required: false
  private _babysitDaemons?: boolean | cdktf.IResolvable; 
  public get babysitDaemons() {
    return this.getBooleanAttribute('babysit_daemons');
  }
  public set babysitDaemons(value: boolean | cdktf.IResolvable) {
    this._babysitDaemons = value;
  }
  public resetBabysitDaemons() {
    this._babysitDaemons = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get babysitDaemonsInput() {
    return this._babysitDaemons;
  }

  // bootstrap_kubeconfig - computed: false, optional: true, required: false
  private _bootstrapKubeconfig?: string; 
  public get bootstrapKubeconfig() {
    return this.getStringAttribute('bootstrap_kubeconfig');
  }
  public set bootstrapKubeconfig(value: string) {
    this._bootstrapKubeconfig = value;
  }
  public resetBootstrapKubeconfig() {
    this._bootstrapKubeconfig = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bootstrapKubeconfigInput() {
    return this._bootstrapKubeconfig;
  }

  // cgroup_driver - computed: false, optional: true, required: false
  private _cgroupDriver?: string; 
  public get cgroupDriver() {
    return this.getStringAttribute('cgroup_driver');
  }
  public set cgroupDriver(value: string) {
    this._cgroupDriver = value;
  }
  public resetCgroupDriver() {
    this._cgroupDriver = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cgroupDriverInput() {
    return this._cgroupDriver;
  }

  // cgroup_root - computed: false, optional: true, required: false
  private _cgroupRoot?: string; 
  public get cgroupRoot() {
    return this.getStringAttribute('cgroup_root');
  }
  public set cgroupRoot(value: string) {
    this._cgroupRoot = value;
  }
  public resetCgroupRoot() {
    this._cgroupRoot = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cgroupRootInput() {
    return this._cgroupRoot;
  }

  // client_ca_file - computed: false, optional: true, required: false
  private _clientCaFile?: string; 
  public get clientCaFile() {
    return this.getStringAttribute('client_ca_file');
  }
  public set clientCaFile(value: string) {
    this._clientCaFile = value;
  }
  public resetClientCaFile() {
    this._clientCaFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientCaFileInput() {
    return this._clientCaFile;
  }

  // cloud_provider - computed: false, optional: true, required: false
  private _cloudProvider?: string; 
  public get cloudProvider() {
    return this.getStringAttribute('cloud_provider');
  }
  public set cloudProvider(value: string) {
    this._cloudProvider = value;
  }
  public resetCloudProvider() {
    this._cloudProvider = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cloudProviderInput() {
    return this._cloudProvider;
  }

  // cluster_dns - computed: false, optional: true, required: false
  private _clusterDns?: string; 
  public get clusterDns() {
    return this.getStringAttribute('cluster_dns');
  }
  public set clusterDns(value: string) {
    this._clusterDns = value;
  }
  public resetClusterDns() {
    this._clusterDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterDnsInput() {
    return this._clusterDns;
  }

  // cluster_domain - computed: false, optional: true, required: false
  private _clusterDomain?: string; 
  public get clusterDomain() {
    return this.getStringAttribute('cluster_domain');
  }
  public set clusterDomain(value: string) {
    this._clusterDomain = value;
  }
  public resetClusterDomain() {
    this._clusterDomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterDomainInput() {
    return this._clusterDomain;
  }

  // configure_cbr0 - computed: false, optional: true, required: false
  private _configureCbr0?: boolean | cdktf.IResolvable; 
  public get configureCbr0() {
    return this.getBooleanAttribute('configure_cbr0');
  }
  public set configureCbr0(value: boolean | cdktf.IResolvable) {
    this._configureCbr0 = value;
  }
  public resetConfigureCbr0() {
    this._configureCbr0 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configureCbr0Input() {
    return this._configureCbr0;
  }

  // container_log_max_files - computed: false, optional: true, required: false
  private _containerLogMaxFiles?: number; 
  public get containerLogMaxFiles() {
    return this.getNumberAttribute('container_log_max_files');
  }
  public set containerLogMaxFiles(value: number) {
    this._containerLogMaxFiles = value;
  }
  public resetContainerLogMaxFiles() {
    this._containerLogMaxFiles = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get containerLogMaxFilesInput() {
    return this._containerLogMaxFiles;
  }

  // container_log_max_size - computed: false, optional: true, required: false
  private _containerLogMaxSize?: string; 
  public get containerLogMaxSize() {
    return this.getStringAttribute('container_log_max_size');
  }
  public set containerLogMaxSize(value: string) {
    this._containerLogMaxSize = value;
  }
  public resetContainerLogMaxSize() {
    this._containerLogMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get containerLogMaxSizeInput() {
    return this._containerLogMaxSize;
  }

  // cpu_cfs_quota_period - computed: false, optional: true, required: false
  private _cpuCfsQuotaPeriod?: string; 
  public get cpuCfsQuotaPeriod() {
    return this.getStringAttribute('cpu_cfs_quota_period');
  }
  public set cpuCfsQuotaPeriod(value: string) {
    this._cpuCfsQuotaPeriod = value;
  }
  public resetCpuCfsQuotaPeriod() {
    this._cpuCfsQuotaPeriod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuCfsQuotaPeriodInput() {
    return this._cpuCfsQuotaPeriod;
  }

  // cpu_manager_policy - computed: false, optional: true, required: false
  private _cpuManagerPolicy?: string; 
  public get cpuManagerPolicy() {
    return this.getStringAttribute('cpu_manager_policy');
  }
  public set cpuManagerPolicy(value: string) {
    this._cpuManagerPolicy = value;
  }
  public resetCpuManagerPolicy() {
    this._cpuManagerPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuManagerPolicyInput() {
    return this._cpuManagerPolicy;
  }

  // docker_disable_shared_pid - computed: false, optional: true, required: false
  private _dockerDisableSharedPid?: boolean | cdktf.IResolvable; 
  public get dockerDisableSharedPid() {
    return this.getBooleanAttribute('docker_disable_shared_pid');
  }
  public set dockerDisableSharedPid(value: boolean | cdktf.IResolvable) {
    this._dockerDisableSharedPid = value;
  }
  public resetDockerDisableSharedPid() {
    this._dockerDisableSharedPid = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dockerDisableSharedPidInput() {
    return this._dockerDisableSharedPid;
  }

  // enable_cadvisor_json_endpoints - computed: false, optional: true, required: false
  private _enableCadvisorJsonEndpoints?: boolean | cdktf.IResolvable; 
  public get enableCadvisorJsonEndpoints() {
    return this.getBooleanAttribute('enable_cadvisor_json_endpoints');
  }
  public set enableCadvisorJsonEndpoints(value: boolean | cdktf.IResolvable) {
    this._enableCadvisorJsonEndpoints = value;
  }
  public resetEnableCadvisorJsonEndpoints() {
    this._enableCadvisorJsonEndpoints = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableCadvisorJsonEndpointsInput() {
    return this._enableCadvisorJsonEndpoints;
  }

  // enable_custom_metrics - computed: false, optional: true, required: false
  private _enableCustomMetrics?: boolean | cdktf.IResolvable; 
  public get enableCustomMetrics() {
    return this.getBooleanAttribute('enable_custom_metrics');
  }
  public set enableCustomMetrics(value: boolean | cdktf.IResolvable) {
    this._enableCustomMetrics = value;
  }
  public resetEnableCustomMetrics() {
    this._enableCustomMetrics = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableCustomMetricsInput() {
    return this._enableCustomMetrics;
  }

  // enable_debugging_handlers - computed: false, optional: true, required: false
  private _enableDebuggingHandlers?: boolean | cdktf.IResolvable; 
  public get enableDebuggingHandlers() {
    return this.getBooleanAttribute('enable_debugging_handlers');
  }
  public set enableDebuggingHandlers(value: boolean | cdktf.IResolvable) {
    this._enableDebuggingHandlers = value;
  }
  public resetEnableDebuggingHandlers() {
    this._enableDebuggingHandlers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableDebuggingHandlersInput() {
    return this._enableDebuggingHandlers;
  }

  // enforce_node_allocatable - computed: false, optional: true, required: false
  private _enforceNodeAllocatable?: string; 
  public get enforceNodeAllocatable() {
    return this.getStringAttribute('enforce_node_allocatable');
  }
  public set enforceNodeAllocatable(value: string) {
    this._enforceNodeAllocatable = value;
  }
  public resetEnforceNodeAllocatable() {
    this._enforceNodeAllocatable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enforceNodeAllocatableInput() {
    return this._enforceNodeAllocatable;
  }

  // event_burst - computed: false, optional: true, required: false
  private _eventBurst?: number; 
  public get eventBurst() {
    return this.getNumberAttribute('event_burst');
  }
  public set eventBurst(value: number) {
    this._eventBurst = value;
  }
  public resetEventBurst() {
    this._eventBurst = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get eventBurstInput() {
    return this._eventBurst;
  }

  // event_qps - computed: false, optional: true, required: false
  private _eventQps?: number; 
  public get eventQps() {
    return this.getNumberAttribute('event_qps');
  }
  public set eventQps(value: number) {
    this._eventQps = value;
  }
  public resetEventQps() {
    this._eventQps = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get eventQpsInput() {
    return this._eventQps;
  }

  // eviction_hard - computed: false, optional: true, required: false
  private _evictionHard?: string; 
  public get evictionHard() {
    return this.getStringAttribute('eviction_hard');
  }
  public set evictionHard(value: string) {
    this._evictionHard = value;
  }
  public resetEvictionHard() {
    this._evictionHard = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get evictionHardInput() {
    return this._evictionHard;
  }

  // eviction_max_pod_grace_period - computed: false, optional: true, required: false
  private _evictionMaxPodGracePeriod?: number; 
  public get evictionMaxPodGracePeriod() {
    return this.getNumberAttribute('eviction_max_pod_grace_period');
  }
  public set evictionMaxPodGracePeriod(value: number) {
    this._evictionMaxPodGracePeriod = value;
  }
  public resetEvictionMaxPodGracePeriod() {
    this._evictionMaxPodGracePeriod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get evictionMaxPodGracePeriodInput() {
    return this._evictionMaxPodGracePeriod;
  }

  // eviction_minimum_reclaim - computed: false, optional: true, required: false
  private _evictionMinimumReclaim?: string; 
  public get evictionMinimumReclaim() {
    return this.getStringAttribute('eviction_minimum_reclaim');
  }
  public set evictionMinimumReclaim(value: string) {
    this._evictionMinimumReclaim = value;
  }
  public resetEvictionMinimumReclaim() {
    this._evictionMinimumReclaim = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get evictionMinimumReclaimInput() {
    return this._evictionMinimumReclaim;
  }

  // eviction_pressure_transition_period - computed: false, optional: true, required: false
  private _evictionPressureTransitionPeriod?: string; 
  public get evictionPressureTransitionPeriod() {
    return this.getStringAttribute('eviction_pressure_transition_period');
  }
  public set evictionPressureTransitionPeriod(value: string) {
    this._evictionPressureTransitionPeriod = value;
  }
  public resetEvictionPressureTransitionPeriod() {
    this._evictionPressureTransitionPeriod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get evictionPressureTransitionPeriodInput() {
    return this._evictionPressureTransitionPeriod;
  }

  // eviction_soft - computed: false, optional: true, required: false
  private _evictionSoft?: string; 
  public get evictionSoft() {
    return this.getStringAttribute('eviction_soft');
  }
  public set evictionSoft(value: string) {
    this._evictionSoft = value;
  }
  public resetEvictionSoft() {
    this._evictionSoft = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get evictionSoftInput() {
    return this._evictionSoft;
  }

  // eviction_soft_grace_period - computed: false, optional: true, required: false
  private _evictionSoftGracePeriod?: string; 
  public get evictionSoftGracePeriod() {
    return this.getStringAttribute('eviction_soft_grace_period');
  }
  public set evictionSoftGracePeriod(value: string) {
    this._evictionSoftGracePeriod = value;
  }
  public resetEvictionSoftGracePeriod() {
    this._evictionSoftGracePeriod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get evictionSoftGracePeriodInput() {
    return this._evictionSoftGracePeriod;
  }

  // experimental_allowed_unsafe_sysctls - computed: false, optional: true, required: false
  private _experimentalAllowedUnsafeSysctls?: string[]; 
  public get experimentalAllowedUnsafeSysctls() {
    return this.getListAttribute('experimental_allowed_unsafe_sysctls');
  }
  public set experimentalAllowedUnsafeSysctls(value: string[]) {
    this._experimentalAllowedUnsafeSysctls = value;
  }
  public resetExperimentalAllowedUnsafeSysctls() {
    this._experimentalAllowedUnsafeSysctls = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get experimentalAllowedUnsafeSysctlsInput() {
    return this._experimentalAllowedUnsafeSysctls;
  }

  // fail_swap_on - computed: false, optional: true, required: false
  private _failSwapOn?: boolean | cdktf.IResolvable; 
  public get failSwapOn() {
    return this.getBooleanAttribute('fail_swap_on');
  }
  public set failSwapOn(value: boolean | cdktf.IResolvable) {
    this._failSwapOn = value;
  }
  public resetFailSwapOn() {
    this._failSwapOn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failSwapOnInput() {
    return this._failSwapOn;
  }

  // feature_gates - computed: false, optional: true, required: false
  private _featureGates?: { [key: string]: string }; 
  public get featureGates() {
    return this.getStringMapAttribute('feature_gates');
  }
  public set featureGates(value: { [key: string]: string }) {
    this._featureGates = value;
  }
  public resetFeatureGates() {
    this._featureGates = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get featureGatesInput() {
    return this._featureGates;
  }

  // hairpin_mode - computed: false, optional: true, required: false
  private _hairpinMode?: string; 
  public get hairpinMode() {
    return this.getStringAttribute('hairpin_mode');
  }
  public set hairpinMode(value: string) {
    this._hairpinMode = value;
  }
  public resetHairpinMode() {
    this._hairpinMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hairpinModeInput() {
    return this._hairpinMode;
  }

  // hostname_override - computed: false, optional: true, required: false
  private _hostnameOverride?: string; 
  public get hostnameOverride() {
    return this.getStringAttribute('hostname_override');
  }
  public set hostnameOverride(value: string) {
    this._hostnameOverride = value;
  }
  public resetHostnameOverride() {
    this._hostnameOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameOverrideInput() {
    return this._hostnameOverride;
  }

  // housekeeping_interval - computed: false, optional: true, required: false
  private _housekeepingInterval?: string; 
  public get housekeepingInterval() {
    return this.getStringAttribute('housekeeping_interval');
  }
  public set housekeepingInterval(value: string) {
    this._housekeepingInterval = value;
  }
  public resetHousekeepingInterval() {
    this._housekeepingInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get housekeepingIntervalInput() {
    return this._housekeepingInterval;
  }

  // image_gc_high_threshold_percent - computed: false, optional: true, required: false
  private _imageGcHighThresholdPercent?: number; 
  public get imageGcHighThresholdPercent() {
    return this.getNumberAttribute('image_gc_high_threshold_percent');
  }
  public set imageGcHighThresholdPercent(value: number) {
    this._imageGcHighThresholdPercent = value;
  }
  public resetImageGcHighThresholdPercent() {
    this._imageGcHighThresholdPercent = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageGcHighThresholdPercentInput() {
    return this._imageGcHighThresholdPercent;
  }

  // image_gc_low_threshold_percent - computed: false, optional: true, required: false
  private _imageGcLowThresholdPercent?: number; 
  public get imageGcLowThresholdPercent() {
    return this.getNumberAttribute('image_gc_low_threshold_percent');
  }
  public set imageGcLowThresholdPercent(value: number) {
    this._imageGcLowThresholdPercent = value;
  }
  public resetImageGcLowThresholdPercent() {
    this._imageGcLowThresholdPercent = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageGcLowThresholdPercentInput() {
    return this._imageGcLowThresholdPercent;
  }

  // image_pull_progress_deadline - computed: false, optional: true, required: false
  private _imagePullProgressDeadline?: string; 
  public get imagePullProgressDeadline() {
    return this.getStringAttribute('image_pull_progress_deadline');
  }
  public set imagePullProgressDeadline(value: string) {
    this._imagePullProgressDeadline = value;
  }
  public resetImagePullProgressDeadline() {
    this._imagePullProgressDeadline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imagePullProgressDeadlineInput() {
    return this._imagePullProgressDeadline;
  }

  // kernel_memcg_notification - computed: false, optional: true, required: false
  private _kernelMemcgNotification?: boolean | cdktf.IResolvable; 
  public get kernelMemcgNotification() {
    return this.getBooleanAttribute('kernel_memcg_notification');
  }
  public set kernelMemcgNotification(value: boolean | cdktf.IResolvable) {
    this._kernelMemcgNotification = value;
  }
  public resetKernelMemcgNotification() {
    this._kernelMemcgNotification = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kernelMemcgNotificationInput() {
    return this._kernelMemcgNotification;
  }

  // kube_reserved - computed: false, optional: true, required: false
  private _kubeReserved?: { [key: string]: string }; 
  public get kubeReserved() {
    return this.getStringMapAttribute('kube_reserved');
  }
  public set kubeReserved(value: { [key: string]: string }) {
    this._kubeReserved = value;
  }
  public resetKubeReserved() {
    this._kubeReserved = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeReservedInput() {
    return this._kubeReserved;
  }

  // kube_reserved_cgroup - computed: false, optional: true, required: false
  private _kubeReservedCgroup?: string; 
  public get kubeReservedCgroup() {
    return this.getStringAttribute('kube_reserved_cgroup');
  }
  public set kubeReservedCgroup(value: string) {
    this._kubeReservedCgroup = value;
  }
  public resetKubeReservedCgroup() {
    this._kubeReservedCgroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeReservedCgroupInput() {
    return this._kubeReservedCgroup;
  }

  // kubeconfig_path - computed: false, optional: true, required: false
  private _kubeconfigPath?: string; 
  public get kubeconfigPath() {
    return this.getStringAttribute('kubeconfig_path');
  }
  public set kubeconfigPath(value: string) {
    this._kubeconfigPath = value;
  }
  public resetKubeconfigPath() {
    this._kubeconfigPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeconfigPathInput() {
    return this._kubeconfigPath;
  }

  // kubelet_cgroups - computed: false, optional: true, required: false
  private _kubeletCgroups?: string; 
  public get kubeletCgroups() {
    return this.getStringAttribute('kubelet_cgroups');
  }
  public set kubeletCgroups(value: string) {
    this._kubeletCgroups = value;
  }
  public resetKubeletCgroups() {
    this._kubeletCgroups = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeletCgroupsInput() {
    return this._kubeletCgroups;
  }

  // log_format - computed: false, optional: true, required: false
  private _logFormat?: string; 
  public get logFormat() {
    return this.getStringAttribute('log_format');
  }
  public set logFormat(value: string) {
    this._logFormat = value;
  }
  public resetLogFormat() {
    this._logFormat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logFormatInput() {
    return this._logFormat;
  }

  // log_level - computed: false, optional: true, required: false
  private _logLevel?: number; 
  public get logLevel() {
    return this.getNumberAttribute('log_level');
  }
  public set logLevel(value: number) {
    this._logLevel = value;
  }
  public resetLogLevel() {
    this._logLevel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logLevelInput() {
    return this._logLevel;
  }

  // max_pods - computed: false, optional: true, required: false
  private _maxPods?: number; 
  public get maxPods() {
    return this.getNumberAttribute('max_pods');
  }
  public set maxPods(value: number) {
    this._maxPods = value;
  }
  public resetMaxPods() {
    this._maxPods = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPodsInput() {
    return this._maxPods;
  }

  // network_plugin_mtu - computed: false, optional: true, required: false
  private _networkPluginMtu?: number; 
  public get networkPluginMtu() {
    return this.getNumberAttribute('network_plugin_mtu');
  }
  public set networkPluginMtu(value: number) {
    this._networkPluginMtu = value;
  }
  public resetNetworkPluginMtu() {
    this._networkPluginMtu = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get networkPluginMtuInput() {
    return this._networkPluginMtu;
  }

  // network_plugin_name - computed: false, optional: true, required: false
  private _networkPluginName?: string; 
  public get networkPluginName() {
    return this.getStringAttribute('network_plugin_name');
  }
  public set networkPluginName(value: string) {
    this._networkPluginName = value;
  }
  public resetNetworkPluginName() {
    this._networkPluginName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get networkPluginNameInput() {
    return this._networkPluginName;
  }

  // node_labels - computed: false, optional: true, required: false
  private _nodeLabels?: { [key: string]: string }; 
  public get nodeLabels() {
    return this.getStringMapAttribute('node_labels');
  }
  public set nodeLabels(value: { [key: string]: string }) {
    this._nodeLabels = value;
  }
  public resetNodeLabels() {
    this._nodeLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeLabelsInput() {
    return this._nodeLabels;
  }

  // node_status_update_frequency - computed: false, optional: true, required: false
  private _nodeStatusUpdateFrequency?: string; 
  public get nodeStatusUpdateFrequency() {
    return this.getStringAttribute('node_status_update_frequency');
  }
  public set nodeStatusUpdateFrequency(value: string) {
    this._nodeStatusUpdateFrequency = value;
  }
  public resetNodeStatusUpdateFrequency() {
    this._nodeStatusUpdateFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeStatusUpdateFrequencyInput() {
    return this._nodeStatusUpdateFrequency;
  }

  // non_masquerade_cidr - computed: false, optional: true, required: false
  private _nonMasqueradeCidr?: string; 
  public get nonMasqueradeCidr() {
    return this.getStringAttribute('non_masquerade_cidr');
  }
  public set nonMasqueradeCidr(value: string) {
    this._nonMasqueradeCidr = value;
  }
  public resetNonMasqueradeCidr() {
    this._nonMasqueradeCidr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nonMasqueradeCidrInput() {
    return this._nonMasqueradeCidr;
  }

  // nvidia_gp_us - computed: false, optional: true, required: false
  private _nvidiaGpUs?: number; 
  public get nvidiaGpUs() {
    return this.getNumberAttribute('nvidia_gp_us');
  }
  public set nvidiaGpUs(value: number) {
    this._nvidiaGpUs = value;
  }
  public resetNvidiaGpUs() {
    this._nvidiaGpUs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nvidiaGpUsInput() {
    return this._nvidiaGpUs;
  }

  // pod_cidr - computed: false, optional: true, required: false
  private _podCidr?: string; 
  public get podCidr() {
    return this.getStringAttribute('pod_cidr');
  }
  public set podCidr(value: string) {
    this._podCidr = value;
  }
  public resetPodCidr() {
    this._podCidr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podCidrInput() {
    return this._podCidr;
  }

  // pod_infra_container_image - computed: false, optional: true, required: false
  private _podInfraContainerImage?: string; 
  public get podInfraContainerImage() {
    return this.getStringAttribute('pod_infra_container_image');
  }
  public set podInfraContainerImage(value: string) {
    this._podInfraContainerImage = value;
  }
  public resetPodInfraContainerImage() {
    this._podInfraContainerImage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podInfraContainerImageInput() {
    return this._podInfraContainerImage;
  }

  // pod_manifest_path - computed: false, optional: true, required: false
  private _podManifestPath?: string; 
  public get podManifestPath() {
    return this.getStringAttribute('pod_manifest_path');
  }
  public set podManifestPath(value: string) {
    this._podManifestPath = value;
  }
  public resetPodManifestPath() {
    this._podManifestPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podManifestPathInput() {
    return this._podManifestPath;
  }

  // pod_pids_limit - computed: false, optional: true, required: false
  private _podPidsLimit?: number; 
  public get podPidsLimit() {
    return this.getNumberAttribute('pod_pids_limit');
  }
  public set podPidsLimit(value: number) {
    this._podPidsLimit = value;
  }
  public resetPodPidsLimit() {
    this._podPidsLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podPidsLimitInput() {
    return this._podPidsLimit;
  }

  // protect_kernel_defaults - computed: false, optional: true, required: false
  private _protectKernelDefaults?: boolean | cdktf.IResolvable; 
  public get protectKernelDefaults() {
    return this.getBooleanAttribute('protect_kernel_defaults');
  }
  public set protectKernelDefaults(value: boolean | cdktf.IResolvable) {
    this._protectKernelDefaults = value;
  }
  public resetProtectKernelDefaults() {
    this._protectKernelDefaults = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protectKernelDefaultsInput() {
    return this._protectKernelDefaults;
  }

  // read_only_port - computed: false, optional: true, required: false
  private _readOnlyPort?: number; 
  public get readOnlyPort() {
    return this.getNumberAttribute('read_only_port');
  }
  public set readOnlyPort(value: number) {
    this._readOnlyPort = value;
  }
  public resetReadOnlyPort() {
    this._readOnlyPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get readOnlyPortInput() {
    return this._readOnlyPort;
  }

  // reconcile_cidr - computed: false, optional: true, required: false
  private _reconcileCidr?: boolean | cdktf.IResolvable; 
  public get reconcileCidr() {
    return this.getBooleanAttribute('reconcile_cidr');
  }
  public set reconcileCidr(value: boolean | cdktf.IResolvable) {
    this._reconcileCidr = value;
  }
  public resetReconcileCidr() {
    this._reconcileCidr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reconcileCidrInput() {
    return this._reconcileCidr;
  }

  // register_node - computed: false, optional: true, required: false
  private _registerNode?: boolean | cdktf.IResolvable; 
  public get registerNode() {
    return this.getBooleanAttribute('register_node');
  }
  public set registerNode(value: boolean | cdktf.IResolvable) {
    this._registerNode = value;
  }
  public resetRegisterNode() {
    this._registerNode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get registerNodeInput() {
    return this._registerNode;
  }

  // register_schedulable - computed: false, optional: true, required: false
  private _registerSchedulable?: boolean | cdktf.IResolvable; 
  public get registerSchedulable() {
    return this.getBooleanAttribute('register_schedulable');
  }
  public set registerSchedulable(value: boolean | cdktf.IResolvable) {
    this._registerSchedulable = value;
  }
  public resetRegisterSchedulable() {
    this._registerSchedulable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get registerSchedulableInput() {
    return this._registerSchedulable;
  }

  // registry_burst - computed: false, optional: true, required: false
  private _registryBurst?: number; 
  public get registryBurst() {
    return this.getNumberAttribute('registry_burst');
  }
  public set registryBurst(value: number) {
    this._registryBurst = value;
  }
  public resetRegistryBurst() {
    this._registryBurst = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get registryBurstInput() {
    return this._registryBurst;
  }

  // registry_pull_qps - computed: false, optional: true, required: false
  private _registryPullQps?: number; 
  public get registryPullQps() {
    return this.getNumberAttribute('registry_pull_qps');
  }
  public set registryPullQps(value: number) {
    this._registryPullQps = value;
  }
  public resetRegistryPullQps() {
    this._registryPullQps = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get registryPullQpsInput() {
    return this._registryPullQps;
  }

  // require_kubeconfig - computed: false, optional: true, required: false
  private _requireKubeconfig?: boolean | cdktf.IResolvable; 
  public get requireKubeconfig() {
    return this.getBooleanAttribute('require_kubeconfig');
  }
  public set requireKubeconfig(value: boolean | cdktf.IResolvable) {
    this._requireKubeconfig = value;
  }
  public resetRequireKubeconfig() {
    this._requireKubeconfig = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requireKubeconfigInput() {
    return this._requireKubeconfig;
  }

  // resolver_config - computed: false, optional: true, required: false
  private _resolverConfig?: string; 
  public get resolverConfig() {
    return this.getStringAttribute('resolver_config');
  }
  public set resolverConfig(value: string) {
    this._resolverConfig = value;
  }
  public resetResolverConfig() {
    this._resolverConfig = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resolverConfigInput() {
    return this._resolverConfig;
  }

  // root_dir - computed: false, optional: true, required: false
  private _rootDir?: string; 
  public get rootDir() {
    return this.getStringAttribute('root_dir');
  }
  public set rootDir(value: string) {
    this._rootDir = value;
  }
  public resetRootDir() {
    this._rootDir = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rootDirInput() {
    return this._rootDir;
  }

  // rotate_certificates - computed: false, optional: true, required: false
  private _rotateCertificates?: boolean | cdktf.IResolvable; 
  public get rotateCertificates() {
    return this.getBooleanAttribute('rotate_certificates');
  }
  public set rotateCertificates(value: boolean | cdktf.IResolvable) {
    this._rotateCertificates = value;
  }
  public resetRotateCertificates() {
    this._rotateCertificates = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rotateCertificatesInput() {
    return this._rotateCertificates;
  }

  // runtime_cgroups - computed: false, optional: true, required: false
  private _runtimeCgroups?: string; 
  public get runtimeCgroups() {
    return this.getStringAttribute('runtime_cgroups');
  }
  public set runtimeCgroups(value: string) {
    this._runtimeCgroups = value;
  }
  public resetRuntimeCgroups() {
    this._runtimeCgroups = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get runtimeCgroupsInput() {
    return this._runtimeCgroups;
  }

  // runtime_request_timeout - computed: false, optional: true, required: false
  private _runtimeRequestTimeout?: string; 
  public get runtimeRequestTimeout() {
    return this.getStringAttribute('runtime_request_timeout');
  }
  public set runtimeRequestTimeout(value: string) {
    this._runtimeRequestTimeout = value;
  }
  public resetRuntimeRequestTimeout() {
    this._runtimeRequestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get runtimeRequestTimeoutInput() {
    return this._runtimeRequestTimeout;
  }

  // seccomp_profile_root - computed: false, optional: true, required: false
  private _seccompProfileRoot?: string; 
  public get seccompProfileRoot() {
    return this.getStringAttribute('seccomp_profile_root');
  }
  public set seccompProfileRoot(value: string) {
    this._seccompProfileRoot = value;
  }
  public resetSeccompProfileRoot() {
    this._seccompProfileRoot = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get seccompProfileRootInput() {
    return this._seccompProfileRoot;
  }

  // serialize_image_pulls - computed: false, optional: true, required: false
  private _serializeImagePulls?: boolean | cdktf.IResolvable; 
  public get serializeImagePulls() {
    return this.getBooleanAttribute('serialize_image_pulls');
  }
  public set serializeImagePulls(value: boolean | cdktf.IResolvable) {
    this._serializeImagePulls = value;
  }
  public resetSerializeImagePulls() {
    this._serializeImagePulls = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serializeImagePullsInput() {
    return this._serializeImagePulls;
  }

  // shutdown_grace_period - computed: false, optional: true, required: false
  private _shutdownGracePeriod?: string; 
  public get shutdownGracePeriod() {
    return this.getStringAttribute('shutdown_grace_period');
  }
  public set shutdownGracePeriod(value: string) {
    this._shutdownGracePeriod = value;
  }
  public resetShutdownGracePeriod() {
    this._shutdownGracePeriod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get shutdownGracePeriodInput() {
    return this._shutdownGracePeriod;
  }

  // shutdown_grace_period_critical_pods - computed: false, optional: true, required: false
  private _shutdownGracePeriodCriticalPods?: string; 
  public get shutdownGracePeriodCriticalPods() {
    return this.getStringAttribute('shutdown_grace_period_critical_pods');
  }
  public set shutdownGracePeriodCriticalPods(value: string) {
    this._shutdownGracePeriodCriticalPods = value;
  }
  public resetShutdownGracePeriodCriticalPods() {
    this._shutdownGracePeriodCriticalPods = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get shutdownGracePeriodCriticalPodsInput() {
    return this._shutdownGracePeriodCriticalPods;
  }

  // streaming_connection_idle_timeout - computed: false, optional: true, required: false
  private _streamingConnectionIdleTimeout?: string; 
  public get streamingConnectionIdleTimeout() {
    return this.getStringAttribute('streaming_connection_idle_timeout');
  }
  public set streamingConnectionIdleTimeout(value: string) {
    this._streamingConnectionIdleTimeout = value;
  }
  public resetStreamingConnectionIdleTimeout() {
    this._streamingConnectionIdleTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamingConnectionIdleTimeoutInput() {
    return this._streamingConnectionIdleTimeout;
  }

  // system_cgroups - computed: false, optional: true, required: false
  private _systemCgroups?: string; 
  public get systemCgroups() {
    return this.getStringAttribute('system_cgroups');
  }
  public set systemCgroups(value: string) {
    this._systemCgroups = value;
  }
  public resetSystemCgroups() {
    this._systemCgroups = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemCgroupsInput() {
    return this._systemCgroups;
  }

  // system_reserved - computed: false, optional: true, required: false
  private _systemReserved?: { [key: string]: string }; 
  public get systemReserved() {
    return this.getStringMapAttribute('system_reserved');
  }
  public set systemReserved(value: { [key: string]: string }) {
    this._systemReserved = value;
  }
  public resetSystemReserved() {
    this._systemReserved = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemReservedInput() {
    return this._systemReserved;
  }

  // system_reserved_cgroup - computed: false, optional: true, required: false
  private _systemReservedCgroup?: string; 
  public get systemReservedCgroup() {
    return this.getStringAttribute('system_reserved_cgroup');
  }
  public set systemReservedCgroup(value: string) {
    this._systemReservedCgroup = value;
  }
  public resetSystemReservedCgroup() {
    this._systemReservedCgroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemReservedCgroupInput() {
    return this._systemReservedCgroup;
  }

  // taints - computed: false, optional: true, required: false
  private _taints?: string[]; 
  public get taints() {
    return this.getListAttribute('taints');
  }
  public set taints(value: string[]) {
    this._taints = value;
  }
  public resetTaints() {
    this._taints = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get taintsInput() {
    return this._taints;
  }

  // tls_cert_file - computed: false, optional: true, required: false
  private _tlsCertFile?: string; 
  public get tlsCertFile() {
    return this.getStringAttribute('tls_cert_file');
  }
  public set tlsCertFile(value: string) {
    this._tlsCertFile = value;
  }
  public resetTlsCertFile() {
    this._tlsCertFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsCertFileInput() {
    return this._tlsCertFile;
  }

  // tls_cipher_suites - computed: false, optional: true, required: false
  private _tlsCipherSuites?: string[]; 
  public get tlsCipherSuites() {
    return this.getListAttribute('tls_cipher_suites');
  }
  public set tlsCipherSuites(value: string[]) {
    this._tlsCipherSuites = value;
  }
  public resetTlsCipherSuites() {
    this._tlsCipherSuites = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsCipherSuitesInput() {
    return this._tlsCipherSuites;
  }

  // tls_min_version - computed: false, optional: true, required: false
  private _tlsMinVersion?: string; 
  public get tlsMinVersion() {
    return this.getStringAttribute('tls_min_version');
  }
  public set tlsMinVersion(value: string) {
    this._tlsMinVersion = value;
  }
  public resetTlsMinVersion() {
    this._tlsMinVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsMinVersionInput() {
    return this._tlsMinVersion;
  }

  // tls_private_key_file - computed: false, optional: true, required: false
  private _tlsPrivateKeyFile?: string; 
  public get tlsPrivateKeyFile() {
    return this.getStringAttribute('tls_private_key_file');
  }
  public set tlsPrivateKeyFile(value: string) {
    this._tlsPrivateKeyFile = value;
  }
  public resetTlsPrivateKeyFile() {
    this._tlsPrivateKeyFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsPrivateKeyFileInput() {
    return this._tlsPrivateKeyFile;
  }

  // topology_manager_policy - computed: false, optional: true, required: false
  private _topologyManagerPolicy?: string; 
  public get topologyManagerPolicy() {
    return this.getStringAttribute('topology_manager_policy');
  }
  public set topologyManagerPolicy(value: string) {
    this._topologyManagerPolicy = value;
  }
  public resetTopologyManagerPolicy() {
    this._topologyManagerPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get topologyManagerPolicyInput() {
    return this._topologyManagerPolicy;
  }

  // volume_plugin_directory - computed: false, optional: true, required: false
  private _volumePluginDirectory?: string; 
  public get volumePluginDirectory() {
    return this.getStringAttribute('volume_plugin_directory');
  }
  public set volumePluginDirectory(value: string) {
    this._volumePluginDirectory = value;
  }
  public resetVolumePluginDirectory() {
    this._volumePluginDirectory = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get volumePluginDirectoryInput() {
    return this._volumePluginDirectory;
  }

  // volume_stats_agg_period - computed: false, optional: true, required: false
  private _volumeStatsAggPeriod?: string; 
  public get volumeStatsAggPeriod() {
    return this.getStringAttribute('volume_stats_agg_period');
  }
  public set volumeStatsAggPeriod(value: string) {
    this._volumeStatsAggPeriod = value;
  }
  public resetVolumeStatsAggPeriod() {
    this._volumeStatsAggPeriod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get volumeStatsAggPeriodInput() {
    return this._volumeStatsAggPeriod;
  }

  // anonymous_auth - computed: false, optional: true, required: false
  private _anonymousAuth = new ClusterMasterKubeletAnonymousAuthOutputReference(this, "anonymous_auth");
  public get anonymousAuth() {
    return this._anonymousAuth;
  }
  public putAnonymousAuth(value: ClusterMasterKubeletAnonymousAuth) {
    this._anonymousAuth.internalValue = value;
  }
  public resetAnonymousAuth() {
    this._anonymousAuth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get anonymousAuthInput() {
    return this._anonymousAuth.internalValue;
  }

  // cpu_cfs_quota - computed: false, optional: true, required: false
  private _cpuCfsQuota = new ClusterMasterKubeletCpuCfsQuotaOutputReference(this, "cpu_cfs_quota");
  public get cpuCfsQuota() {
    return this._cpuCfsQuota;
  }
  public putCpuCfsQuota(value: ClusterMasterKubeletCpuCfsQuota) {
    this._cpuCfsQuota.internalValue = value;
  }
  public resetCpuCfsQuota() {
    this._cpuCfsQuota.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuCfsQuotaInput() {
    return this._cpuCfsQuota.internalValue;
  }
}
export interface ClusterMetricsServer {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#enabled Cluster#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#image Cluster#image}
  */
  readonly image?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#insecure Cluster#insecure}
  */
  readonly insecure: boolean | cdktf.IResolvable;
}

export function clusterMetricsServerToTerraform(struct?: ClusterMetricsServerOutputReference | ClusterMetricsServer): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.booleanToTerraform(struct!.enabled),
    image: cdktf.stringToTerraform(struct!.image),
    insecure: cdktf.booleanToTerraform(struct!.insecure),
  }
}


export function clusterMetricsServerToHclTerraform(struct?: ClusterMetricsServerOutputReference | ClusterMetricsServer): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    image: {
      value: cdktf.stringToHclTerraform(struct!.image),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    insecure: {
      value: cdktf.booleanToHclTerraform(struct!.insecure),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterMetricsServerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterMetricsServer | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._image !== undefined) {
      hasAnyValues = true;
      internalValueResult.image = this._image;
    }
    if (this._insecure !== undefined) {
      hasAnyValues = true;
      internalValueResult.insecure = this._insecure;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterMetricsServer | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._enabled = undefined;
      this._image = undefined;
      this._insecure = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._enabled = value.enabled;
      this._image = value.image;
      this._insecure = value.insecure;
    }
  }

  // enabled - computed: false, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // image - computed: false, optional: true, required: false
  private _image?: string; 
  public get image() {
    return this.getStringAttribute('image');
  }
  public set image(value: string) {
    this._image = value;
  }
  public resetImage() {
    this._image = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageInput() {
    return this._image;
  }

  // insecure - computed: false, optional: false, required: true
  private _insecure?: boolean | cdktf.IResolvable; 
  public get insecure() {
    return this.getBooleanAttribute('insecure');
  }
  public set insecure(value: boolean | cdktf.IResolvable) {
    this._insecure = value;
  }
  // Temporarily expose input value. Use with caution.
  public get insecureInput() {
    return this._insecure;
  }
}
export interface ClusterNetworkingAmazonVpcEnv {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#name Cluster#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#value Cluster#value}
  */
  readonly value?: string;
}

export function clusterNetworkingAmazonVpcEnvToTerraform(struct?: ClusterNetworkingAmazonVpcEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function clusterNetworkingAmazonVpcEnvToHclTerraform(struct?: ClusterNetworkingAmazonVpcEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterNetworkingAmazonVpcEnvOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): ClusterNetworkingAmazonVpcEnv | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterNetworkingAmazonVpcEnv | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class ClusterNetworkingAmazonVpcEnvList extends cdktf.ComplexList {
  public internalValue? : ClusterNetworkingAmazonVpcEnv[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): ClusterNetworkingAmazonVpcEnvOutputReference {
    return new ClusterNetworkingAmazonVpcEnvOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface ClusterNetworkingAmazonVpc {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#image Cluster#image}
  */
  readonly image?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#init_image Cluster#init_image}
  */
  readonly initImage?: string;
  /**
  * env block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#env Cluster#env}
  */
  readonly env?: ClusterNetworkingAmazonVpcEnv[] | cdktf.IResolvable;
}

export function clusterNetworkingAmazonVpcToTerraform(struct?: ClusterNetworkingAmazonVpcOutputReference | ClusterNetworkingAmazonVpc): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    image: cdktf.stringToTerraform(struct!.image),
    init_image: cdktf.stringToTerraform(struct!.initImage),
    env: cdktf.listMapper(clusterNetworkingAmazonVpcEnvToTerraform, true)(struct!.env),
  }
}


export function clusterNetworkingAmazonVpcToHclTerraform(struct?: ClusterNetworkingAmazonVpcOutputReference | ClusterNetworkingAmazonVpc): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    image: {
      value: cdktf.stringToHclTerraform(struct!.image),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    init_image: {
      value: cdktf.stringToHclTerraform(struct!.initImage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    env: {
      value: cdktf.listMapperHcl(clusterNetworkingAmazonVpcEnvToHclTerraform, true)(struct!.env),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterNetworkingAmazonVpcEnvList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterNetworkingAmazonVpcOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterNetworkingAmazonVpc | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._image !== undefined) {
      hasAnyValues = true;
      internalValueResult.image = this._image;
    }
    if (this._initImage !== undefined) {
      hasAnyValues = true;
      internalValueResult.initImage = this._initImage;
    }
    if (this._env?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.env = this._env?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterNetworkingAmazonVpc | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._image = undefined;
      this._initImage = undefined;
      this._env.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._image = value.image;
      this._initImage = value.initImage;
      this._env.internalValue = value.env;
    }
  }

  // image - computed: false, optional: true, required: false
  private _image?: string; 
  public get image() {
    return this.getStringAttribute('image');
  }
  public set image(value: string) {
    this._image = value;
  }
  public resetImage() {
    this._image = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageInput() {
    return this._image;
  }

  // init_image - computed: false, optional: true, required: false
  private _initImage?: string; 
  public get initImage() {
    return this.getStringAttribute('init_image');
  }
  public set initImage(value: string) {
    this._initImage = value;
  }
  public resetInitImage() {
    this._initImage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initImageInput() {
    return this._initImage;
  }

  // env - computed: false, optional: true, required: false
  private _env = new ClusterNetworkingAmazonVpcEnvList(this, "env", false);
  public get env() {
    return this._env;
  }
  public putEnv(value: ClusterNetworkingAmazonVpcEnv[] | cdktf.IResolvable) {
    this._env.internalValue = value;
  }
  public resetEnv() {
    this._env.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get envInput() {
    return this._env.internalValue;
  }
}
export interface ClusterNetworkingCalico {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#allow_ip_forwarding Cluster#allow_ip_forwarding}
  */
  readonly allowIpForwarding?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#aws_src_dst_check Cluster#aws_src_dst_check}
  */
  readonly awsSrcDstCheck?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#bpf_enabled Cluster#bpf_enabled}
  */
  readonly bpfEnabled?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#bpf_external_service_mode Cluster#bpf_external_service_mode}
  */
  readonly bpfExternalServiceMode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#bpf_kube_proxy_iptables_cleanup_enabled Cluster#bpf_kube_proxy_iptables_cleanup_enabled}
  */
  readonly bpfKubeProxyIptablesCleanupEnabled?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#bpf_log_level Cluster#bpf_log_level}
  */
  readonly bpfLogLevel?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#chain_insert_mode Cluster#chain_insert_mode}
  */
  readonly chainInsertMode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#cpu_request Cluster#cpu_request}
  */
  readonly cpuRequest?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#cross_subnet Cluster#cross_subnet}
  */
  readonly crossSubnet?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#encapsulation_mode Cluster#encapsulation_mode}
  */
  readonly encapsulationMode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#ip_ip_mode Cluster#ip_ip_mode}
  */
  readonly ipIpMode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#iptables_backend Cluster#iptables_backend}
  */
  readonly iptablesBackend?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#ipv4_auto_detection_method Cluster#ipv4_auto_detection_method}
  */
  readonly ipv4AutoDetectionMethod?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#ipv6_auto_detection_method Cluster#ipv6_auto_detection_method}
  */
  readonly ipv6AutoDetectionMethod?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#log_severity_screen Cluster#log_severity_screen}
  */
  readonly logSeverityScreen?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#mtu Cluster#mtu}
  */
  readonly mtu?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#prometheus_go_metrics_enabled Cluster#prometheus_go_metrics_enabled}
  */
  readonly prometheusGoMetricsEnabled?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#prometheus_metrics_enabled Cluster#prometheus_metrics_enabled}
  */
  readonly prometheusMetricsEnabled?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#prometheus_metrics_port Cluster#prometheus_metrics_port}
  */
  readonly prometheusMetricsPort?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#prometheus_process_metrics_enabled Cluster#prometheus_process_metrics_enabled}
  */
  readonly prometheusProcessMetricsEnabled?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#registry Cluster#registry}
  */
  readonly registry?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#typha_prometheus_metrics_enabled Cluster#typha_prometheus_metrics_enabled}
  */
  readonly typhaPrometheusMetricsEnabled?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#typha_prometheus_metrics_port Cluster#typha_prometheus_metrics_port}
  */
  readonly typhaPrometheusMetricsPort?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#typha_replicas Cluster#typha_replicas}
  */
  readonly typhaReplicas?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#version Cluster#version}
  */
  readonly version?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#vxlan_mode Cluster#vxlan_mode}
  */
  readonly vxlanMode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#wireguard_enabled Cluster#wireguard_enabled}
  */
  readonly wireguardEnabled?: boolean | cdktf.IResolvable;
}

export function clusterNetworkingCalicoToTerraform(struct?: ClusterNetworkingCalicoOutputReference | ClusterNetworkingCalico): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_ip_forwarding: cdktf.booleanToTerraform(struct!.allowIpForwarding),
    aws_src_dst_check: cdktf.stringToTerraform(struct!.awsSrcDstCheck),
    bpf_enabled: cdktf.booleanToTerraform(struct!.bpfEnabled),
    bpf_external_service_mode: cdktf.stringToTerraform(struct!.bpfExternalServiceMode),
    bpf_kube_proxy_iptables_cleanup_enabled: cdktf.booleanToTerraform(struct!.bpfKubeProxyIptablesCleanupEnabled),
    bpf_log_level: cdktf.stringToTerraform(struct!.bpfLogLevel),
    chain_insert_mode: cdktf.stringToTerraform(struct!.chainInsertMode),
    cpu_request: cdktf.stringToTerraform(struct!.cpuRequest),
    cross_subnet: cdktf.booleanToTerraform(struct!.crossSubnet),
    encapsulation_mode: cdktf.stringToTerraform(struct!.encapsulationMode),
    ip_ip_mode: cdktf.stringToTerraform(struct!.ipIpMode),
    iptables_backend: cdktf.stringToTerraform(struct!.iptablesBackend),
    ipv4_auto_detection_method: cdktf.stringToTerraform(struct!.ipv4AutoDetectionMethod),
    ipv6_auto_detection_method: cdktf.stringToTerraform(struct!.ipv6AutoDetectionMethod),
    log_severity_screen: cdktf.stringToTerraform(struct!.logSeverityScreen),
    mtu: cdktf.numberToTerraform(struct!.mtu),
    prometheus_go_metrics_enabled: cdktf.booleanToTerraform(struct!.prometheusGoMetricsEnabled),
    prometheus_metrics_enabled: cdktf.booleanToTerraform(struct!.prometheusMetricsEnabled),
    prometheus_metrics_port: cdktf.numberToTerraform(struct!.prometheusMetricsPort),
    prometheus_process_metrics_enabled: cdktf.booleanToTerraform(struct!.prometheusProcessMetricsEnabled),
    registry: cdktf.stringToTerraform(struct!.registry),
    typha_prometheus_metrics_enabled: cdktf.booleanToTerraform(struct!.typhaPrometheusMetricsEnabled),
    typha_prometheus_metrics_port: cdktf.numberToTerraform(struct!.typhaPrometheusMetricsPort),
    typha_replicas: cdktf.numberToTerraform(struct!.typhaReplicas),
    version: cdktf.stringToTerraform(struct!.version),
    vxlan_mode: cdktf.stringToTerraform(struct!.vxlanMode),
    wireguard_enabled: cdktf.booleanToTerraform(struct!.wireguardEnabled),
  }
}


export function clusterNetworkingCalicoToHclTerraform(struct?: ClusterNetworkingCalicoOutputReference | ClusterNetworkingCalico): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_ip_forwarding: {
      value: cdktf.booleanToHclTerraform(struct!.allowIpForwarding),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    aws_src_dst_check: {
      value: cdktf.stringToHclTerraform(struct!.awsSrcDstCheck),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bpf_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.bpfEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    bpf_external_service_mode: {
      value: cdktf.stringToHclTerraform(struct!.bpfExternalServiceMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bpf_kube_proxy_iptables_cleanup_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.bpfKubeProxyIptablesCleanupEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    bpf_log_level: {
      value: cdktf.stringToHclTerraform(struct!.bpfLogLevel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    chain_insert_mode: {
      value: cdktf.stringToHclTerraform(struct!.chainInsertMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cpu_request: {
      value: cdktf.stringToHclTerraform(struct!.cpuRequest),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cross_subnet: {
      value: cdktf.booleanToHclTerraform(struct!.crossSubnet),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    encapsulation_mode: {
      value: cdktf.stringToHclTerraform(struct!.encapsulationMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_ip_mode: {
      value: cdktf.stringToHclTerraform(struct!.ipIpMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    iptables_backend: {
      value: cdktf.stringToHclTerraform(struct!.iptablesBackend),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ipv4_auto_detection_method: {
      value: cdktf.stringToHclTerraform(struct!.ipv4AutoDetectionMethod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ipv6_auto_detection_method: {
      value: cdktf.stringToHclTerraform(struct!.ipv6AutoDetectionMethod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_severity_screen: {
      value: cdktf.stringToHclTerraform(struct!.logSeverityScreen),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mtu: {
      value: cdktf.numberToHclTerraform(struct!.mtu),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    prometheus_go_metrics_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.prometheusGoMetricsEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    prometheus_metrics_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.prometheusMetricsEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    prometheus_metrics_port: {
      value: cdktf.numberToHclTerraform(struct!.prometheusMetricsPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    prometheus_process_metrics_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.prometheusProcessMetricsEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    registry: {
      value: cdktf.stringToHclTerraform(struct!.registry),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    typha_prometheus_metrics_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.typhaPrometheusMetricsEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    typha_prometheus_metrics_port: {
      value: cdktf.numberToHclTerraform(struct!.typhaPrometheusMetricsPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    typha_replicas: {
      value: cdktf.numberToHclTerraform(struct!.typhaReplicas),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    version: {
      value: cdktf.stringToHclTerraform(struct!.version),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    vxlan_mode: {
      value: cdktf.stringToHclTerraform(struct!.vxlanMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    wireguard_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.wireguardEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterNetworkingCalicoOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterNetworkingCalico | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowIpForwarding !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowIpForwarding = this._allowIpForwarding;
    }
    if (this._awsSrcDstCheck !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSrcDstCheck = this._awsSrcDstCheck;
    }
    if (this._bpfEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.bpfEnabled = this._bpfEnabled;
    }
    if (this._bpfExternalServiceMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.bpfExternalServiceMode = this._bpfExternalServiceMode;
    }
    if (this._bpfKubeProxyIptablesCleanupEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.bpfKubeProxyIptablesCleanupEnabled = this._bpfKubeProxyIptablesCleanupEnabled;
    }
    if (this._bpfLogLevel !== undefined) {
      hasAnyValues = true;
      internalValueResult.bpfLogLevel = this._bpfLogLevel;
    }
    if (this._chainInsertMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.chainInsertMode = this._chainInsertMode;
    }
    if (this._cpuRequest !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpuRequest = this._cpuRequest;
    }
    if (this._crossSubnet !== undefined) {
      hasAnyValues = true;
      internalValueResult.crossSubnet = this._crossSubnet;
    }
    if (this._encapsulationMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.encapsulationMode = this._encapsulationMode;
    }
    if (this._ipIpMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipIpMode = this._ipIpMode;
    }
    if (this._iptablesBackend !== undefined) {
      hasAnyValues = true;
      internalValueResult.iptablesBackend = this._iptablesBackend;
    }
    if (this._ipv4AutoDetectionMethod !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipv4AutoDetectionMethod = this._ipv4AutoDetectionMethod;
    }
    if (this._ipv6AutoDetectionMethod !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipv6AutoDetectionMethod = this._ipv6AutoDetectionMethod;
    }
    if (this._logSeverityScreen !== undefined) {
      hasAnyValues = true;
      internalValueResult.logSeverityScreen = this._logSeverityScreen;
    }
    if (this._mtu !== undefined) {
      hasAnyValues = true;
      internalValueResult.mtu = this._mtu;
    }
    if (this._prometheusGoMetricsEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.prometheusGoMetricsEnabled = this._prometheusGoMetricsEnabled;
    }
    if (this._prometheusMetricsEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.prometheusMetricsEnabled = this._prometheusMetricsEnabled;
    }
    if (this._prometheusMetricsPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.prometheusMetricsPort = this._prometheusMetricsPort;
    }
    if (this._prometheusProcessMetricsEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.prometheusProcessMetricsEnabled = this._prometheusProcessMetricsEnabled;
    }
    if (this._registry !== undefined) {
      hasAnyValues = true;
      internalValueResult.registry = this._registry;
    }
    if (this._typhaPrometheusMetricsEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.typhaPrometheusMetricsEnabled = this._typhaPrometheusMetricsEnabled;
    }
    if (this._typhaPrometheusMetricsPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.typhaPrometheusMetricsPort = this._typhaPrometheusMetricsPort;
    }
    if (this._typhaReplicas !== undefined) {
      hasAnyValues = true;
      internalValueResult.typhaReplicas = this._typhaReplicas;
    }
    if (this._version !== undefined) {
      hasAnyValues = true;
      internalValueResult.version = this._version;
    }
    if (this._vxlanMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.vxlanMode = this._vxlanMode;
    }
    if (this._wireguardEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.wireguardEnabled = this._wireguardEnabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterNetworkingCalico | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._allowIpForwarding = undefined;
      this._awsSrcDstCheck = undefined;
      this._bpfEnabled = undefined;
      this._bpfExternalServiceMode = undefined;
      this._bpfKubeProxyIptablesCleanupEnabled = undefined;
      this._bpfLogLevel = undefined;
      this._chainInsertMode = undefined;
      this._cpuRequest = undefined;
      this._crossSubnet = undefined;
      this._encapsulationMode = undefined;
      this._ipIpMode = undefined;
      this._iptablesBackend = undefined;
      this._ipv4AutoDetectionMethod = undefined;
      this._ipv6AutoDetectionMethod = undefined;
      this._logSeverityScreen = undefined;
      this._mtu = undefined;
      this._prometheusGoMetricsEnabled = undefined;
      this._prometheusMetricsEnabled = undefined;
      this._prometheusMetricsPort = undefined;
      this._prometheusProcessMetricsEnabled = undefined;
      this._registry = undefined;
      this._typhaPrometheusMetricsEnabled = undefined;
      this._typhaPrometheusMetricsPort = undefined;
      this._typhaReplicas = undefined;
      this._version = undefined;
      this._vxlanMode = undefined;
      this._wireguardEnabled = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._allowIpForwarding = value.allowIpForwarding;
      this._awsSrcDstCheck = value.awsSrcDstCheck;
      this._bpfEnabled = value.bpfEnabled;
      this._bpfExternalServiceMode = value.bpfExternalServiceMode;
      this._bpfKubeProxyIptablesCleanupEnabled = value.bpfKubeProxyIptablesCleanupEnabled;
      this._bpfLogLevel = value.bpfLogLevel;
      this._chainInsertMode = value.chainInsertMode;
      this._cpuRequest = value.cpuRequest;
      this._crossSubnet = value.crossSubnet;
      this._encapsulationMode = value.encapsulationMode;
      this._ipIpMode = value.ipIpMode;
      this._iptablesBackend = value.iptablesBackend;
      this._ipv4AutoDetectionMethod = value.ipv4AutoDetectionMethod;
      this._ipv6AutoDetectionMethod = value.ipv6AutoDetectionMethod;
      this._logSeverityScreen = value.logSeverityScreen;
      this._mtu = value.mtu;
      this._prometheusGoMetricsEnabled = value.prometheusGoMetricsEnabled;
      this._prometheusMetricsEnabled = value.prometheusMetricsEnabled;
      this._prometheusMetricsPort = value.prometheusMetricsPort;
      this._prometheusProcessMetricsEnabled = value.prometheusProcessMetricsEnabled;
      this._registry = value.registry;
      this._typhaPrometheusMetricsEnabled = value.typhaPrometheusMetricsEnabled;
      this._typhaPrometheusMetricsPort = value.typhaPrometheusMetricsPort;
      this._typhaReplicas = value.typhaReplicas;
      this._version = value.version;
      this._vxlanMode = value.vxlanMode;
      this._wireguardEnabled = value.wireguardEnabled;
    }
  }

  // allow_ip_forwarding - computed: false, optional: true, required: false
  private _allowIpForwarding?: boolean | cdktf.IResolvable; 
  public get allowIpForwarding() {
    return this.getBooleanAttribute('allow_ip_forwarding');
  }
  public set allowIpForwarding(value: boolean | cdktf.IResolvable) {
    this._allowIpForwarding = value;
  }
  public resetAllowIpForwarding() {
    this._allowIpForwarding = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowIpForwardingInput() {
    return this._allowIpForwarding;
  }

  // aws_src_dst_check - computed: false, optional: true, required: false
  private _awsSrcDstCheck?: string; 
  public get awsSrcDstCheck() {
    return this.getStringAttribute('aws_src_dst_check');
  }
  public set awsSrcDstCheck(value: string) {
    this._awsSrcDstCheck = value;
  }
  public resetAwsSrcDstCheck() {
    this._awsSrcDstCheck = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSrcDstCheckInput() {
    return this._awsSrcDstCheck;
  }

  // bpf_enabled - computed: false, optional: true, required: false
  private _bpfEnabled?: boolean | cdktf.IResolvable; 
  public get bpfEnabled() {
    return this.getBooleanAttribute('bpf_enabled');
  }
  public set bpfEnabled(value: boolean | cdktf.IResolvable) {
    this._bpfEnabled = value;
  }
  public resetBpfEnabled() {
    this._bpfEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bpfEnabledInput() {
    return this._bpfEnabled;
  }

  // bpf_external_service_mode - computed: false, optional: true, required: false
  private _bpfExternalServiceMode?: string; 
  public get bpfExternalServiceMode() {
    return this.getStringAttribute('bpf_external_service_mode');
  }
  public set bpfExternalServiceMode(value: string) {
    this._bpfExternalServiceMode = value;
  }
  public resetBpfExternalServiceMode() {
    this._bpfExternalServiceMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bpfExternalServiceModeInput() {
    return this._bpfExternalServiceMode;
  }

  // bpf_kube_proxy_iptables_cleanup_enabled - computed: false, optional: true, required: false
  private _bpfKubeProxyIptablesCleanupEnabled?: boolean | cdktf.IResolvable; 
  public get bpfKubeProxyIptablesCleanupEnabled() {
    return this.getBooleanAttribute('bpf_kube_proxy_iptables_cleanup_enabled');
  }
  public set bpfKubeProxyIptablesCleanupEnabled(value: boolean | cdktf.IResolvable) {
    this._bpfKubeProxyIptablesCleanupEnabled = value;
  }
  public resetBpfKubeProxyIptablesCleanupEnabled() {
    this._bpfKubeProxyIptablesCleanupEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bpfKubeProxyIptablesCleanupEnabledInput() {
    return this._bpfKubeProxyIptablesCleanupEnabled;
  }

  // bpf_log_level - computed: false, optional: true, required: false
  private _bpfLogLevel?: string; 
  public get bpfLogLevel() {
    return this.getStringAttribute('bpf_log_level');
  }
  public set bpfLogLevel(value: string) {
    this._bpfLogLevel = value;
  }
  public resetBpfLogLevel() {
    this._bpfLogLevel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bpfLogLevelInput() {
    return this._bpfLogLevel;
  }

  // chain_insert_mode - computed: false, optional: true, required: false
  private _chainInsertMode?: string; 
  public get chainInsertMode() {
    return this.getStringAttribute('chain_insert_mode');
  }
  public set chainInsertMode(value: string) {
    this._chainInsertMode = value;
  }
  public resetChainInsertMode() {
    this._chainInsertMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get chainInsertModeInput() {
    return this._chainInsertMode;
  }

  // cpu_request - computed: false, optional: true, required: false
  private _cpuRequest?: string; 
  public get cpuRequest() {
    return this.getStringAttribute('cpu_request');
  }
  public set cpuRequest(value: string) {
    this._cpuRequest = value;
  }
  public resetCpuRequest() {
    this._cpuRequest = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuRequestInput() {
    return this._cpuRequest;
  }

  // cross_subnet - computed: false, optional: true, required: false
  private _crossSubnet?: boolean | cdktf.IResolvable; 
  public get crossSubnet() {
    return this.getBooleanAttribute('cross_subnet');
  }
  public set crossSubnet(value: boolean | cdktf.IResolvable) {
    this._crossSubnet = value;
  }
  public resetCrossSubnet() {
    this._crossSubnet = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get crossSubnetInput() {
    return this._crossSubnet;
  }

  // encapsulation_mode - computed: false, optional: true, required: false
  private _encapsulationMode?: string; 
  public get encapsulationMode() {
    return this.getStringAttribute('encapsulation_mode');
  }
  public set encapsulationMode(value: string) {
    this._encapsulationMode = value;
  }
  public resetEncapsulationMode() {
    this._encapsulationMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get encapsulationModeInput() {
    return this._encapsulationMode;
  }

  // ip_ip_mode - computed: false, optional: true, required: false
  private _ipIpMode?: string; 
  public get ipIpMode() {
    return this.getStringAttribute('ip_ip_mode');
  }
  public set ipIpMode(value: string) {
    this._ipIpMode = value;
  }
  public resetIpIpMode() {
    this._ipIpMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipIpModeInput() {
    return this._ipIpMode;
  }

  // iptables_backend - computed: false, optional: true, required: false
  private _iptablesBackend?: string; 
  public get iptablesBackend() {
    return this.getStringAttribute('iptables_backend');
  }
  public set iptablesBackend(value: string) {
    this._iptablesBackend = value;
  }
  public resetIptablesBackend() {
    this._iptablesBackend = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get iptablesBackendInput() {
    return this._iptablesBackend;
  }

  // ipv4_auto_detection_method - computed: false, optional: true, required: false
  private _ipv4AutoDetectionMethod?: string; 
  public get ipv4AutoDetectionMethod() {
    return this.getStringAttribute('ipv4_auto_detection_method');
  }
  public set ipv4AutoDetectionMethod(value: string) {
    this._ipv4AutoDetectionMethod = value;
  }
  public resetIpv4AutoDetectionMethod() {
    this._ipv4AutoDetectionMethod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipv4AutoDetectionMethodInput() {
    return this._ipv4AutoDetectionMethod;
  }

  // ipv6_auto_detection_method - computed: false, optional: true, required: false
  private _ipv6AutoDetectionMethod?: string; 
  public get ipv6AutoDetectionMethod() {
    return this.getStringAttribute('ipv6_auto_detection_method');
  }
  public set ipv6AutoDetectionMethod(value: string) {
    this._ipv6AutoDetectionMethod = value;
  }
  public resetIpv6AutoDetectionMethod() {
    this._ipv6AutoDetectionMethod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipv6AutoDetectionMethodInput() {
    return this._ipv6AutoDetectionMethod;
  }

  // log_severity_screen - computed: false, optional: true, required: false
  private _logSeverityScreen?: string; 
  public get logSeverityScreen() {
    return this.getStringAttribute('log_severity_screen');
  }
  public set logSeverityScreen(value: string) {
    this._logSeverityScreen = value;
  }
  public resetLogSeverityScreen() {
    this._logSeverityScreen = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logSeverityScreenInput() {
    return this._logSeverityScreen;
  }

  // mtu - computed: false, optional: true, required: false
  private _mtu?: number; 
  public get mtu() {
    return this.getNumberAttribute('mtu');
  }
  public set mtu(value: number) {
    this._mtu = value;
  }
  public resetMtu() {
    this._mtu = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mtuInput() {
    return this._mtu;
  }

  // prometheus_go_metrics_enabled - computed: false, optional: true, required: false
  private _prometheusGoMetricsEnabled?: boolean | cdktf.IResolvable; 
  public get prometheusGoMetricsEnabled() {
    return this.getBooleanAttribute('prometheus_go_metrics_enabled');
  }
  public set prometheusGoMetricsEnabled(value: boolean | cdktf.IResolvable) {
    this._prometheusGoMetricsEnabled = value;
  }
  public resetPrometheusGoMetricsEnabled() {
    this._prometheusGoMetricsEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prometheusGoMetricsEnabledInput() {
    return this._prometheusGoMetricsEnabled;
  }

  // prometheus_metrics_enabled - computed: false, optional: true, required: false
  private _prometheusMetricsEnabled?: boolean | cdktf.IResolvable; 
  public get prometheusMetricsEnabled() {
    return this.getBooleanAttribute('prometheus_metrics_enabled');
  }
  public set prometheusMetricsEnabled(value: boolean | cdktf.IResolvable) {
    this._prometheusMetricsEnabled = value;
  }
  public resetPrometheusMetricsEnabled() {
    this._prometheusMetricsEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prometheusMetricsEnabledInput() {
    return this._prometheusMetricsEnabled;
  }

  // prometheus_metrics_port - computed: false, optional: true, required: false
  private _prometheusMetricsPort?: number; 
  public get prometheusMetricsPort() {
    return this.getNumberAttribute('prometheus_metrics_port');
  }
  public set prometheusMetricsPort(value: number) {
    this._prometheusMetricsPort = value;
  }
  public resetPrometheusMetricsPort() {
    this._prometheusMetricsPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prometheusMetricsPortInput() {
    return this._prometheusMetricsPort;
  }

  // prometheus_process_metrics_enabled - computed: false, optional: true, required: false
  private _prometheusProcessMetricsEnabled?: boolean | cdktf.IResolvable; 
  public get prometheusProcessMetricsEnabled() {
    return this.getBooleanAttribute('prometheus_process_metrics_enabled');
  }
  public set prometheusProcessMetricsEnabled(value: boolean | cdktf.IResolvable) {
    this._prometheusProcessMetricsEnabled = value;
  }
  public resetPrometheusProcessMetricsEnabled() {
    this._prometheusProcessMetricsEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prometheusProcessMetricsEnabledInput() {
    return this._prometheusProcessMetricsEnabled;
  }

  // registry - computed: false, optional: true, required: false
  private _registry?: string; 
  public get registry() {
    return this.getStringAttribute('registry');
  }
  public set registry(value: string) {
    this._registry = value;
  }
  public resetRegistry() {
    this._registry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get registryInput() {
    return this._registry;
  }

  // typha_prometheus_metrics_enabled - computed: false, optional: true, required: false
  private _typhaPrometheusMetricsEnabled?: boolean | cdktf.IResolvable; 
  public get typhaPrometheusMetricsEnabled() {
    return this.getBooleanAttribute('typha_prometheus_metrics_enabled');
  }
  public set typhaPrometheusMetricsEnabled(value: boolean | cdktf.IResolvable) {
    this._typhaPrometheusMetricsEnabled = value;
  }
  public resetTyphaPrometheusMetricsEnabled() {
    this._typhaPrometheusMetricsEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typhaPrometheusMetricsEnabledInput() {
    return this._typhaPrometheusMetricsEnabled;
  }

  // typha_prometheus_metrics_port - computed: false, optional: true, required: false
  private _typhaPrometheusMetricsPort?: number; 
  public get typhaPrometheusMetricsPort() {
    return this.getNumberAttribute('typha_prometheus_metrics_port');
  }
  public set typhaPrometheusMetricsPort(value: number) {
    this._typhaPrometheusMetricsPort = value;
  }
  public resetTyphaPrometheusMetricsPort() {
    this._typhaPrometheusMetricsPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typhaPrometheusMetricsPortInput() {
    return this._typhaPrometheusMetricsPort;
  }

  // typha_replicas - computed: false, optional: true, required: false
  private _typhaReplicas?: number; 
  public get typhaReplicas() {
    return this.getNumberAttribute('typha_replicas');
  }
  public set typhaReplicas(value: number) {
    this._typhaReplicas = value;
  }
  public resetTyphaReplicas() {
    this._typhaReplicas = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typhaReplicasInput() {
    return this._typhaReplicas;
  }

  // version - computed: false, optional: true, required: false
  private _version?: string; 
  public get version() {
    return this.getStringAttribute('version');
  }
  public set version(value: string) {
    this._version = value;
  }
  public resetVersion() {
    this._version = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get versionInput() {
    return this._version;
  }

  // vxlan_mode - computed: false, optional: true, required: false
  private _vxlanMode?: string; 
  public get vxlanMode() {
    return this.getStringAttribute('vxlan_mode');
  }
  public set vxlanMode(value: string) {
    this._vxlanMode = value;
  }
  public resetVxlanMode() {
    this._vxlanMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vxlanModeInput() {
    return this._vxlanMode;
  }

  // wireguard_enabled - computed: false, optional: true, required: false
  private _wireguardEnabled?: boolean | cdktf.IResolvable; 
  public get wireguardEnabled() {
    return this.getBooleanAttribute('wireguard_enabled');
  }
  public set wireguardEnabled(value: boolean | cdktf.IResolvable) {
    this._wireguardEnabled = value;
  }
  public resetWireguardEnabled() {
    this._wireguardEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get wireguardEnabledInput() {
    return this._wireguardEnabled;
  }
}
export interface ClusterNetworkingCanal {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#chain_insert_mode Cluster#chain_insert_mode}
  */
  readonly chainInsertMode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#cpu_request Cluster#cpu_request}
  */
  readonly cpuRequest?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#default_endpoint_to_host_action Cluster#default_endpoint_to_host_action}
  */
  readonly defaultEndpointToHostAction?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#flanneld_iptables_forward_rules Cluster#flanneld_iptables_forward_rules}
  */
  readonly flanneldIptablesForwardRules?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#iptables_backend Cluster#iptables_backend}
  */
  readonly iptablesBackend?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#log_severity_sys Cluster#log_severity_sys}
  */
  readonly logSeveritySys?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#mtu Cluster#mtu}
  */
  readonly mtu?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#prometheus_go_metrics_enabled Cluster#prometheus_go_metrics_enabled}
  */
  readonly prometheusGoMetricsEnabled?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#prometheus_metrics_enabled Cluster#prometheus_metrics_enabled}
  */
  readonly prometheusMetricsEnabled?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#prometheus_metrics_port Cluster#prometheus_metrics_port}
  */
  readonly prometheusMetricsPort?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#prometheus_process_metrics_enabled Cluster#prometheus_process_metrics_enabled}
  */
  readonly prometheusProcessMetricsEnabled?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#typha_prometheus_metrics_enabled Cluster#typha_prometheus_metrics_enabled}
  */
  readonly typhaPrometheusMetricsEnabled?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#typha_prometheus_metrics_port Cluster#typha_prometheus_metrics_port}
  */
  readonly typhaPrometheusMetricsPort?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#typha_replicas Cluster#typha_replicas}
  */
  readonly typhaReplicas?: number;
}

export function clusterNetworkingCanalToTerraform(struct?: ClusterNetworkingCanalOutputReference | ClusterNetworkingCanal): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    chain_insert_mode: cdktf.stringToTerraform(struct!.chainInsertMode),
    cpu_request: cdktf.stringToTerraform(struct!.cpuRequest),
    default_endpoint_to_host_action: cdktf.stringToTerraform(struct!.defaultEndpointToHostAction),
    flanneld_iptables_forward_rules: cdktf.booleanToTerraform(struct!.flanneldIptablesForwardRules),
    iptables_backend: cdktf.stringToTerraform(struct!.iptablesBackend),
    log_severity_sys: cdktf.stringToTerraform(struct!.logSeveritySys),
    mtu: cdktf.numberToTerraform(struct!.mtu),
    prometheus_go_metrics_enabled: cdktf.booleanToTerraform(struct!.prometheusGoMetricsEnabled),
    prometheus_metrics_enabled: cdktf.booleanToTerraform(struct!.prometheusMetricsEnabled),
    prometheus_metrics_port: cdktf.numberToTerraform(struct!.prometheusMetricsPort),
    prometheus_process_metrics_enabled: cdktf.booleanToTerraform(struct!.prometheusProcessMetricsEnabled),
    typha_prometheus_metrics_enabled: cdktf.booleanToTerraform(struct!.typhaPrometheusMetricsEnabled),
    typha_prometheus_metrics_port: cdktf.numberToTerraform(struct!.typhaPrometheusMetricsPort),
    typha_replicas: cdktf.numberToTerraform(struct!.typhaReplicas),
  }
}


export function clusterNetworkingCanalToHclTerraform(struct?: ClusterNetworkingCanalOutputReference | ClusterNetworkingCanal): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    chain_insert_mode: {
      value: cdktf.stringToHclTerraform(struct!.chainInsertMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cpu_request: {
      value: cdktf.stringToHclTerraform(struct!.cpuRequest),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    default_endpoint_to_host_action: {
      value: cdktf.stringToHclTerraform(struct!.defaultEndpointToHostAction),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flanneld_iptables_forward_rules: {
      value: cdktf.booleanToHclTerraform(struct!.flanneldIptablesForwardRules),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    iptables_backend: {
      value: cdktf.stringToHclTerraform(struct!.iptablesBackend),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_severity_sys: {
      value: cdktf.stringToHclTerraform(struct!.logSeveritySys),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mtu: {
      value: cdktf.numberToHclTerraform(struct!.mtu),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    prometheus_go_metrics_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.prometheusGoMetricsEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    prometheus_metrics_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.prometheusMetricsEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    prometheus_metrics_port: {
      value: cdktf.numberToHclTerraform(struct!.prometheusMetricsPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    prometheus_process_metrics_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.prometheusProcessMetricsEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    typha_prometheus_metrics_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.typhaPrometheusMetricsEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    typha_prometheus_metrics_port: {
      value: cdktf.numberToHclTerraform(struct!.typhaPrometheusMetricsPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    typha_replicas: {
      value: cdktf.numberToHclTerraform(struct!.typhaReplicas),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterNetworkingCanalOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterNetworkingCanal | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._chainInsertMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.chainInsertMode = this._chainInsertMode;
    }
    if (this._cpuRequest !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpuRequest = this._cpuRequest;
    }
    if (this._defaultEndpointToHostAction !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultEndpointToHostAction = this._defaultEndpointToHostAction;
    }
    if (this._flanneldIptablesForwardRules !== undefined) {
      hasAnyValues = true;
      internalValueResult.flanneldIptablesForwardRules = this._flanneldIptablesForwardRules;
    }
    if (this._iptablesBackend !== undefined) {
      hasAnyValues = true;
      internalValueResult.iptablesBackend = this._iptablesBackend;
    }
    if (this._logSeveritySys !== undefined) {
      hasAnyValues = true;
      internalValueResult.logSeveritySys = this._logSeveritySys;
    }
    if (this._mtu !== undefined) {
      hasAnyValues = true;
      internalValueResult.mtu = this._mtu;
    }
    if (this._prometheusGoMetricsEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.prometheusGoMetricsEnabled = this._prometheusGoMetricsEnabled;
    }
    if (this._prometheusMetricsEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.prometheusMetricsEnabled = this._prometheusMetricsEnabled;
    }
    if (this._prometheusMetricsPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.prometheusMetricsPort = this._prometheusMetricsPort;
    }
    if (this._prometheusProcessMetricsEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.prometheusProcessMetricsEnabled = this._prometheusProcessMetricsEnabled;
    }
    if (this._typhaPrometheusMetricsEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.typhaPrometheusMetricsEnabled = this._typhaPrometheusMetricsEnabled;
    }
    if (this._typhaPrometheusMetricsPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.typhaPrometheusMetricsPort = this._typhaPrometheusMetricsPort;
    }
    if (this._typhaReplicas !== undefined) {
      hasAnyValues = true;
      internalValueResult.typhaReplicas = this._typhaReplicas;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterNetworkingCanal | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._chainInsertMode = undefined;
      this._cpuRequest = undefined;
      this._defaultEndpointToHostAction = undefined;
      this._flanneldIptablesForwardRules = undefined;
      this._iptablesBackend = undefined;
      this._logSeveritySys = undefined;
      this._mtu = undefined;
      this._prometheusGoMetricsEnabled = undefined;
      this._prometheusMetricsEnabled = undefined;
      this._prometheusMetricsPort = undefined;
      this._prometheusProcessMetricsEnabled = undefined;
      this._typhaPrometheusMetricsEnabled = undefined;
      this._typhaPrometheusMetricsPort = undefined;
      this._typhaReplicas = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._chainInsertMode = value.chainInsertMode;
      this._cpuRequest = value.cpuRequest;
      this._defaultEndpointToHostAction = value.defaultEndpointToHostAction;
      this._flanneldIptablesForwardRules = value.flanneldIptablesForwardRules;
      this._iptablesBackend = value.iptablesBackend;
      this._logSeveritySys = value.logSeveritySys;
      this._mtu = value.mtu;
      this._prometheusGoMetricsEnabled = value.prometheusGoMetricsEnabled;
      this._prometheusMetricsEnabled = value.prometheusMetricsEnabled;
      this._prometheusMetricsPort = value.prometheusMetricsPort;
      this._prometheusProcessMetricsEnabled = value.prometheusProcessMetricsEnabled;
      this._typhaPrometheusMetricsEnabled = value.typhaPrometheusMetricsEnabled;
      this._typhaPrometheusMetricsPort = value.typhaPrometheusMetricsPort;
      this._typhaReplicas = value.typhaReplicas;
    }
  }

  // chain_insert_mode - computed: false, optional: true, required: false
  private _chainInsertMode?: string; 
  public get chainInsertMode() {
    return this.getStringAttribute('chain_insert_mode');
  }
  public set chainInsertMode(value: string) {
    this._chainInsertMode = value;
  }
  public resetChainInsertMode() {
    this._chainInsertMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get chainInsertModeInput() {
    return this._chainInsertMode;
  }

  // cpu_request - computed: false, optional: true, required: false
  private _cpuRequest?: string; 
  public get cpuRequest() {
    return this.getStringAttribute('cpu_request');
  }
  public set cpuRequest(value: string) {
    this._cpuRequest = value;
  }
  public resetCpuRequest() {
    this._cpuRequest = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuRequestInput() {
    return this._cpuRequest;
  }

  // default_endpoint_to_host_action - computed: false, optional: true, required: false
  private _defaultEndpointToHostAction?: string; 
  public get defaultEndpointToHostAction() {
    return this.getStringAttribute('default_endpoint_to_host_action');
  }
  public set defaultEndpointToHostAction(value: string) {
    this._defaultEndpointToHostAction = value;
  }
  public resetDefaultEndpointToHostAction() {
    this._defaultEndpointToHostAction = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultEndpointToHostActionInput() {
    return this._defaultEndpointToHostAction;
  }

  // flanneld_iptables_forward_rules - computed: false, optional: true, required: false
  private _flanneldIptablesForwardRules?: boolean | cdktf.IResolvable; 
  public get flanneldIptablesForwardRules() {
    return this.getBooleanAttribute('flanneld_iptables_forward_rules');
  }
  public set flanneldIptablesForwardRules(value: boolean | cdktf.IResolvable) {
    this._flanneldIptablesForwardRules = value;
  }
  public resetFlanneldIptablesForwardRules() {
    this._flanneldIptablesForwardRules = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flanneldIptablesForwardRulesInput() {
    return this._flanneldIptablesForwardRules;
  }

  // iptables_backend - computed: false, optional: true, required: false
  private _iptablesBackend?: string; 
  public get iptablesBackend() {
    return this.getStringAttribute('iptables_backend');
  }
  public set iptablesBackend(value: string) {
    this._iptablesBackend = value;
  }
  public resetIptablesBackend() {
    this._iptablesBackend = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get iptablesBackendInput() {
    return this._iptablesBackend;
  }

  // log_severity_sys - computed: false, optional: true, required: false
  private _logSeveritySys?: string; 
  public get logSeveritySys() {
    return this.getStringAttribute('log_severity_sys');
  }
  public set logSeveritySys(value: string) {
    this._logSeveritySys = value;
  }
  public resetLogSeveritySys() {
    this._logSeveritySys = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logSeveritySysInput() {
    return this._logSeveritySys;
  }

  // mtu - computed: false, optional: true, required: false
  private _mtu?: number; 
  public get mtu() {
    return this.getNumberAttribute('mtu');
  }
  public set mtu(value: number) {
    this._mtu = value;
  }
  public resetMtu() {
    this._mtu = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mtuInput() {
    return this._mtu;
  }

  // prometheus_go_metrics_enabled - computed: false, optional: true, required: false
  private _prometheusGoMetricsEnabled?: boolean | cdktf.IResolvable; 
  public get prometheusGoMetricsEnabled() {
    return this.getBooleanAttribute('prometheus_go_metrics_enabled');
  }
  public set prometheusGoMetricsEnabled(value: boolean | cdktf.IResolvable) {
    this._prometheusGoMetricsEnabled = value;
  }
  public resetPrometheusGoMetricsEnabled() {
    this._prometheusGoMetricsEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prometheusGoMetricsEnabledInput() {
    return this._prometheusGoMetricsEnabled;
  }

  // prometheus_metrics_enabled - computed: false, optional: true, required: false
  private _prometheusMetricsEnabled?: boolean | cdktf.IResolvable; 
  public get prometheusMetricsEnabled() {
    return this.getBooleanAttribute('prometheus_metrics_enabled');
  }
  public set prometheusMetricsEnabled(value: boolean | cdktf.IResolvable) {
    this._prometheusMetricsEnabled = value;
  }
  public resetPrometheusMetricsEnabled() {
    this._prometheusMetricsEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prometheusMetricsEnabledInput() {
    return this._prometheusMetricsEnabled;
  }

  // prometheus_metrics_port - computed: false, optional: true, required: false
  private _prometheusMetricsPort?: number; 
  public get prometheusMetricsPort() {
    return this.getNumberAttribute('prometheus_metrics_port');
  }
  public set prometheusMetricsPort(value: number) {
    this._prometheusMetricsPort = value;
  }
  public resetPrometheusMetricsPort() {
    this._prometheusMetricsPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prometheusMetricsPortInput() {
    return this._prometheusMetricsPort;
  }

  // prometheus_process_metrics_enabled - computed: false, optional: true, required: false
  private _prometheusProcessMetricsEnabled?: boolean | cdktf.IResolvable; 
  public get prometheusProcessMetricsEnabled() {
    return this.getBooleanAttribute('prometheus_process_metrics_enabled');
  }
  public set prometheusProcessMetricsEnabled(value: boolean | cdktf.IResolvable) {
    this._prometheusProcessMetricsEnabled = value;
  }
  public resetPrometheusProcessMetricsEnabled() {
    this._prometheusProcessMetricsEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prometheusProcessMetricsEnabledInput() {
    return this._prometheusProcessMetricsEnabled;
  }

  // typha_prometheus_metrics_enabled - computed: false, optional: true, required: false
  private _typhaPrometheusMetricsEnabled?: boolean | cdktf.IResolvable; 
  public get typhaPrometheusMetricsEnabled() {
    return this.getBooleanAttribute('typha_prometheus_metrics_enabled');
  }
  public set typhaPrometheusMetricsEnabled(value: boolean | cdktf.IResolvable) {
    this._typhaPrometheusMetricsEnabled = value;
  }
  public resetTyphaPrometheusMetricsEnabled() {
    this._typhaPrometheusMetricsEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typhaPrometheusMetricsEnabledInput() {
    return this._typhaPrometheusMetricsEnabled;
  }

  // typha_prometheus_metrics_port - computed: false, optional: true, required: false
  private _typhaPrometheusMetricsPort?: number; 
  public get typhaPrometheusMetricsPort() {
    return this.getNumberAttribute('typha_prometheus_metrics_port');
  }
  public set typhaPrometheusMetricsPort(value: number) {
    this._typhaPrometheusMetricsPort = value;
  }
  public resetTyphaPrometheusMetricsPort() {
    this._typhaPrometheusMetricsPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typhaPrometheusMetricsPortInput() {
    return this._typhaPrometheusMetricsPort;
  }

  // typha_replicas - computed: false, optional: true, required: false
  private _typhaReplicas?: number; 
  public get typhaReplicas() {
    return this.getNumberAttribute('typha_replicas');
  }
  public set typhaReplicas(value: number) {
    this._typhaReplicas = value;
  }
  public resetTyphaReplicas() {
    this._typhaReplicas = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typhaReplicasInput() {
    return this._typhaReplicas;
  }
}
export interface ClusterNetworkingCiliumHubble {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#enabled Cluster#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#metrics Cluster#metrics}
  */
  readonly metrics?: string[];
}

export function clusterNetworkingCiliumHubbleToTerraform(struct?: ClusterNetworkingCiliumHubbleOutputReference | ClusterNetworkingCiliumHubble): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.booleanToTerraform(struct!.enabled),
    metrics: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.metrics),
  }
}


export function clusterNetworkingCiliumHubbleToHclTerraform(struct?: ClusterNetworkingCiliumHubbleOutputReference | ClusterNetworkingCiliumHubble): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    metrics: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.metrics),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterNetworkingCiliumHubbleOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterNetworkingCiliumHubble | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._metrics !== undefined) {
      hasAnyValues = true;
      internalValueResult.metrics = this._metrics;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterNetworkingCiliumHubble | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._enabled = undefined;
      this._metrics = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._enabled = value.enabled;
      this._metrics = value.metrics;
    }
  }

  // enabled - computed: false, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // metrics - computed: false, optional: true, required: false
  private _metrics?: string[]; 
  public get metrics() {
    return this.getListAttribute('metrics');
  }
  public set metrics(value: string[]) {
    this._metrics = value;
  }
  public resetMetrics() {
    this._metrics = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricsInput() {
    return this._metrics;
  }
}
export interface ClusterNetworkingCilium {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#agent_pod_annotations Cluster#agent_pod_annotations}
  */
  readonly agentPodAnnotations?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#agent_prometheus_port Cluster#agent_prometheus_port}
  */
  readonly agentPrometheusPort?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#auto_direct_node_routes Cluster#auto_direct_node_routes}
  */
  readonly autoDirectNodeRoutes?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#bpf_neigh_global_max Cluster#bpf_neigh_global_max}
  */
  readonly bpfNeighGlobalMax?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#bpf_policy_map_max Cluster#bpf_policy_map_max}
  */
  readonly bpfPolicyMapMax?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#bpfct_global_any_max Cluster#bpfct_global_any_max}
  */
  readonly bpfctGlobalAnyMax?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#bpfct_global_tcp_max Cluster#bpfct_global_tcp_max}
  */
  readonly bpfctGlobalTcpMax?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#bpflb_algorithm Cluster#bpflb_algorithm}
  */
  readonly bpflbAlgorithm?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#bpflb_maglev_table_size Cluster#bpflb_maglev_table_size}
  */
  readonly bpflbMaglevTableSize?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#bpflb_map_max Cluster#bpflb_map_max}
  */
  readonly bpflbMapMax?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#bpflb_sock_host_ns_only Cluster#bpflb_sock_host_ns_only}
  */
  readonly bpflbSockHostNsOnly?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#bpfnat_global_max Cluster#bpfnat_global_max}
  */
  readonly bpfnatGlobalMax?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#chaining_mode Cluster#chaining_mode}
  */
  readonly chainingMode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#cluster_name Cluster#cluster_name}
  */
  readonly clusterName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#cpu_request Cluster#cpu_request}
  */
  readonly cpuRequest?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#debug Cluster#debug}
  */
  readonly debug?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#disable_cnp_status_updates Cluster#disable_cnp_status_updates}
  */
  readonly disableCnpStatusUpdates?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#disable_endpoint_crd Cluster#disable_endpoint_crd}
  */
  readonly disableEndpointCrd?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#enable_bpf_masquerade Cluster#enable_bpf_masquerade}
  */
  readonly enableBpfMasquerade?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#enable_encryption Cluster#enable_encryption}
  */
  readonly enableEncryption?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#enable_endpoint_health_checking Cluster#enable_endpoint_health_checking}
  */
  readonly enableEndpointHealthChecking?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#enable_host_reachable_services Cluster#enable_host_reachable_services}
  */
  readonly enableHostReachableServices?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#enable_l7_proxy Cluster#enable_l7_proxy}
  */
  readonly enableL7Proxy?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#enable_node_port Cluster#enable_node_port}
  */
  readonly enableNodePort?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#enable_policy Cluster#enable_policy}
  */
  readonly enablePolicy?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#enable_prometheus_metrics Cluster#enable_prometheus_metrics}
  */
  readonly enablePrometheusMetrics?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#enable_remote_node_identity Cluster#enable_remote_node_identity}
  */
  readonly enableRemoteNodeIdentity: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#enable_service_topology Cluster#enable_service_topology}
  */
  readonly enableServiceTopology?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#encryption_type Cluster#encryption_type}
  */
  readonly encryptionType?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#etcd_managed Cluster#etcd_managed}
  */
  readonly etcdManaged?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#identity_allocation_mode Cluster#identity_allocation_mode}
  */
  readonly identityAllocationMode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#identity_change_grace_period Cluster#identity_change_grace_period}
  */
  readonly identityChangeGracePeriod?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#install_iptables_rules Cluster#install_iptables_rules}
  */
  readonly installIptablesRules?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#ipam Cluster#ipam}
  */
  readonly ipam?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#masquerade Cluster#masquerade}
  */
  readonly masquerade?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#memory_request Cluster#memory_request}
  */
  readonly memoryRequest?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#metrics Cluster#metrics}
  */
  readonly metrics?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#monitor_aggregation Cluster#monitor_aggregation}
  */
  readonly monitorAggregation?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#preallocate_bpf_maps Cluster#preallocate_bpf_maps}
  */
  readonly preallocateBpfMaps: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#sidecar_istio_proxy_image Cluster#sidecar_istio_proxy_image}
  */
  readonly sidecarIstioProxyImage?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#to_fqdns_dns_reject_response_code Cluster#to_fqdns_dns_reject_response_code}
  */
  readonly toFqdnsDnsRejectResponseCode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#to_fqdns_enable_poller Cluster#to_fqdns_enable_poller}
  */
  readonly toFqdnsEnablePoller?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#tunnel Cluster#tunnel}
  */
  readonly tunnel?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#version Cluster#version}
  */
  readonly version?: string;
  /**
  * hubble block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#hubble Cluster#hubble}
  */
  readonly hubble?: ClusterNetworkingCiliumHubble;
}

export function clusterNetworkingCiliumToTerraform(struct?: ClusterNetworkingCiliumOutputReference | ClusterNetworkingCilium): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    agent_pod_annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.agentPodAnnotations),
    agent_prometheus_port: cdktf.numberToTerraform(struct!.agentPrometheusPort),
    auto_direct_node_routes: cdktf.booleanToTerraform(struct!.autoDirectNodeRoutes),
    bpf_neigh_global_max: cdktf.numberToTerraform(struct!.bpfNeighGlobalMax),
    bpf_policy_map_max: cdktf.numberToTerraform(struct!.bpfPolicyMapMax),
    bpfct_global_any_max: cdktf.numberToTerraform(struct!.bpfctGlobalAnyMax),
    bpfct_global_tcp_max: cdktf.numberToTerraform(struct!.bpfctGlobalTcpMax),
    bpflb_algorithm: cdktf.stringToTerraform(struct!.bpflbAlgorithm),
    bpflb_maglev_table_size: cdktf.stringToTerraform(struct!.bpflbMaglevTableSize),
    bpflb_map_max: cdktf.numberToTerraform(struct!.bpflbMapMax),
    bpflb_sock_host_ns_only: cdktf.booleanToTerraform(struct!.bpflbSockHostNsOnly),
    bpfnat_global_max: cdktf.numberToTerraform(struct!.bpfnatGlobalMax),
    chaining_mode: cdktf.stringToTerraform(struct!.chainingMode),
    cluster_name: cdktf.stringToTerraform(struct!.clusterName),
    cpu_request: cdktf.stringToTerraform(struct!.cpuRequest),
    debug: cdktf.booleanToTerraform(struct!.debug),
    disable_cnp_status_updates: cdktf.booleanToTerraform(struct!.disableCnpStatusUpdates),
    disable_endpoint_crd: cdktf.booleanToTerraform(struct!.disableEndpointCrd),
    enable_bpf_masquerade: cdktf.booleanToTerraform(struct!.enableBpfMasquerade),
    enable_encryption: cdktf.booleanToTerraform(struct!.enableEncryption),
    enable_endpoint_health_checking: cdktf.booleanToTerraform(struct!.enableEndpointHealthChecking),
    enable_host_reachable_services: cdktf.booleanToTerraform(struct!.enableHostReachableServices),
    enable_l7_proxy: cdktf.booleanToTerraform(struct!.enableL7Proxy),
    enable_node_port: cdktf.booleanToTerraform(struct!.enableNodePort),
    enable_policy: cdktf.stringToTerraform(struct!.enablePolicy),
    enable_prometheus_metrics: cdktf.booleanToTerraform(struct!.enablePrometheusMetrics),
    enable_remote_node_identity: cdktf.booleanToTerraform(struct!.enableRemoteNodeIdentity),
    enable_service_topology: cdktf.booleanToTerraform(struct!.enableServiceTopology),
    encryption_type: cdktf.stringToTerraform(struct!.encryptionType),
    etcd_managed: cdktf.booleanToTerraform(struct!.etcdManaged),
    identity_allocation_mode: cdktf.stringToTerraform(struct!.identityAllocationMode),
    identity_change_grace_period: cdktf.stringToTerraform(struct!.identityChangeGracePeriod),
    install_iptables_rules: cdktf.booleanToTerraform(struct!.installIptablesRules),
    ipam: cdktf.stringToTerraform(struct!.ipam),
    masquerade: cdktf.booleanToTerraform(struct!.masquerade),
    memory_request: cdktf.stringToTerraform(struct!.memoryRequest),
    metrics: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.metrics),
    monitor_aggregation: cdktf.stringToTerraform(struct!.monitorAggregation),
    preallocate_bpf_maps: cdktf.booleanToTerraform(struct!.preallocateBpfMaps),
    sidecar_istio_proxy_image: cdktf.stringToTerraform(struct!.sidecarIstioProxyImage),
    to_fqdns_dns_reject_response_code: cdktf.stringToTerraform(struct!.toFqdnsDnsRejectResponseCode),
    to_fqdns_enable_poller: cdktf.booleanToTerraform(struct!.toFqdnsEnablePoller),
    tunnel: cdktf.stringToTerraform(struct!.tunnel),
    version: cdktf.stringToTerraform(struct!.version),
    hubble: clusterNetworkingCiliumHubbleToTerraform(struct!.hubble),
  }
}


export function clusterNetworkingCiliumToHclTerraform(struct?: ClusterNetworkingCiliumOutputReference | ClusterNetworkingCilium): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    agent_pod_annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.agentPodAnnotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    agent_prometheus_port: {
      value: cdktf.numberToHclTerraform(struct!.agentPrometheusPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    auto_direct_node_routes: {
      value: cdktf.booleanToHclTerraform(struct!.autoDirectNodeRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    bpf_neigh_global_max: {
      value: cdktf.numberToHclTerraform(struct!.bpfNeighGlobalMax),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    bpf_policy_map_max: {
      value: cdktf.numberToHclTerraform(struct!.bpfPolicyMapMax),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    bpfct_global_any_max: {
      value: cdktf.numberToHclTerraform(struct!.bpfctGlobalAnyMax),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    bpfct_global_tcp_max: {
      value: cdktf.numberToHclTerraform(struct!.bpfctGlobalTcpMax),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    bpflb_algorithm: {
      value: cdktf.stringToHclTerraform(struct!.bpflbAlgorithm),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bpflb_maglev_table_size: {
      value: cdktf.stringToHclTerraform(struct!.bpflbMaglevTableSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bpflb_map_max: {
      value: cdktf.numberToHclTerraform(struct!.bpflbMapMax),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    bpflb_sock_host_ns_only: {
      value: cdktf.booleanToHclTerraform(struct!.bpflbSockHostNsOnly),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    bpfnat_global_max: {
      value: cdktf.numberToHclTerraform(struct!.bpfnatGlobalMax),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    chaining_mode: {
      value: cdktf.stringToHclTerraform(struct!.chainingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cluster_name: {
      value: cdktf.stringToHclTerraform(struct!.clusterName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cpu_request: {
      value: cdktf.stringToHclTerraform(struct!.cpuRequest),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    debug: {
      value: cdktf.booleanToHclTerraform(struct!.debug),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    disable_cnp_status_updates: {
      value: cdktf.booleanToHclTerraform(struct!.disableCnpStatusUpdates),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    disable_endpoint_crd: {
      value: cdktf.booleanToHclTerraform(struct!.disableEndpointCrd),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_bpf_masquerade: {
      value: cdktf.booleanToHclTerraform(struct!.enableBpfMasquerade),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_encryption: {
      value: cdktf.booleanToHclTerraform(struct!.enableEncryption),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_endpoint_health_checking: {
      value: cdktf.booleanToHclTerraform(struct!.enableEndpointHealthChecking),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_host_reachable_services: {
      value: cdktf.booleanToHclTerraform(struct!.enableHostReachableServices),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_l7_proxy: {
      value: cdktf.booleanToHclTerraform(struct!.enableL7Proxy),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_node_port: {
      value: cdktf.booleanToHclTerraform(struct!.enableNodePort),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_policy: {
      value: cdktf.stringToHclTerraform(struct!.enablePolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enable_prometheus_metrics: {
      value: cdktf.booleanToHclTerraform(struct!.enablePrometheusMetrics),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_remote_node_identity: {
      value: cdktf.booleanToHclTerraform(struct!.enableRemoteNodeIdentity),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_service_topology: {
      value: cdktf.booleanToHclTerraform(struct!.enableServiceTopology),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    encryption_type: {
      value: cdktf.stringToHclTerraform(struct!.encryptionType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    etcd_managed: {
      value: cdktf.booleanToHclTerraform(struct!.etcdManaged),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    identity_allocation_mode: {
      value: cdktf.stringToHclTerraform(struct!.identityAllocationMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    identity_change_grace_period: {
      value: cdktf.stringToHclTerraform(struct!.identityChangeGracePeriod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    install_iptables_rules: {
      value: cdktf.booleanToHclTerraform(struct!.installIptablesRules),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    ipam: {
      value: cdktf.stringToHclTerraform(struct!.ipam),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    masquerade: {
      value: cdktf.booleanToHclTerraform(struct!.masquerade),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    memory_request: {
      value: cdktf.stringToHclTerraform(struct!.memoryRequest),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metrics: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.metrics),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    monitor_aggregation: {
      value: cdktf.stringToHclTerraform(struct!.monitorAggregation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    preallocate_bpf_maps: {
      value: cdktf.booleanToHclTerraform(struct!.preallocateBpfMaps),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    sidecar_istio_proxy_image: {
      value: cdktf.stringToHclTerraform(struct!.sidecarIstioProxyImage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    to_fqdns_dns_reject_response_code: {
      value: cdktf.stringToHclTerraform(struct!.toFqdnsDnsRejectResponseCode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    to_fqdns_enable_poller: {
      value: cdktf.booleanToHclTerraform(struct!.toFqdnsEnablePoller),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tunnel: {
      value: cdktf.stringToHclTerraform(struct!.tunnel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    version: {
      value: cdktf.stringToHclTerraform(struct!.version),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hubble: {
      value: clusterNetworkingCiliumHubbleToHclTerraform(struct!.hubble),
      isBlock: true,
      type: "list",
      storageClassType: "ClusterNetworkingCiliumHubbleList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterNetworkingCiliumOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterNetworkingCilium | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._agentPodAnnotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.agentPodAnnotations = this._agentPodAnnotations;
    }
    if (this._agentPrometheusPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.agentPrometheusPort = this._agentPrometheusPort;
    }
    if (this._autoDirectNodeRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoDirectNodeRoutes = this._autoDirectNodeRoutes;
    }
    if (this._bpfNeighGlobalMax !== undefined) {
      hasAnyValues = true;
      internalValueResult.bpfNeighGlobalMax = this._bpfNeighGlobalMax;
    }
    if (this._bpfPolicyMapMax !== undefined) {
      hasAnyValues = true;
      internalValueResult.bpfPolicyMapMax = this._bpfPolicyMapMax;
    }
    if (this._bpfctGlobalAnyMax !== undefined) {
      hasAnyValues = true;
      internalValueResult.bpfctGlobalAnyMax = this._bpfctGlobalAnyMax;
    }
    if (this._bpfctGlobalTcpMax !== undefined) {
      hasAnyValues = true;
      internalValueResult.bpfctGlobalTcpMax = this._bpfctGlobalTcpMax;
    }
    if (this._bpflbAlgorithm !== undefined) {
      hasAnyValues = true;
      internalValueResult.bpflbAlgorithm = this._bpflbAlgorithm;
    }
    if (this._bpflbMaglevTableSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.bpflbMaglevTableSize = this._bpflbMaglevTableSize;
    }
    if (this._bpflbMapMax !== undefined) {
      hasAnyValues = true;
      internalValueResult.bpflbMapMax = this._bpflbMapMax;
    }
    if (this._bpflbSockHostNsOnly !== undefined) {
      hasAnyValues = true;
      internalValueResult.bpflbSockHostNsOnly = this._bpflbSockHostNsOnly;
    }
    if (this._bpfnatGlobalMax !== undefined) {
      hasAnyValues = true;
      internalValueResult.bpfnatGlobalMax = this._bpfnatGlobalMax;
    }
    if (this._chainingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.chainingMode = this._chainingMode;
    }
    if (this._clusterName !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterName = this._clusterName;
    }
    if (this._cpuRequest !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpuRequest = this._cpuRequest;
    }
    if (this._debug !== undefined) {
      hasAnyValues = true;
      internalValueResult.debug = this._debug;
    }
    if (this._disableCnpStatusUpdates !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableCnpStatusUpdates = this._disableCnpStatusUpdates;
    }
    if (this._disableEndpointCrd !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableEndpointCrd = this._disableEndpointCrd;
    }
    if (this._enableBpfMasquerade !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableBpfMasquerade = this._enableBpfMasquerade;
    }
    if (this._enableEncryption !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableEncryption = this._enableEncryption;
    }
    if (this._enableEndpointHealthChecking !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableEndpointHealthChecking = this._enableEndpointHealthChecking;
    }
    if (this._enableHostReachableServices !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHostReachableServices = this._enableHostReachableServices;
    }
    if (this._enableL7Proxy !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableL7Proxy = this._enableL7Proxy;
    }
    if (this._enableNodePort !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableNodePort = this._enableNodePort;
    }
    if (this._enablePolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.enablePolicy = this._enablePolicy;
    }
    if (this._enablePrometheusMetrics !== undefined) {
      hasAnyValues = true;
      internalValueResult.enablePrometheusMetrics = this._enablePrometheusMetrics;
    }
    if (this._enableRemoteNodeIdentity !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableRemoteNodeIdentity = this._enableRemoteNodeIdentity;
    }
    if (this._enableServiceTopology !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableServiceTopology = this._enableServiceTopology;
    }
    if (this._encryptionType !== undefined) {
      hasAnyValues = true;
      internalValueResult.encryptionType = this._encryptionType;
    }
    if (this._etcdManaged !== undefined) {
      hasAnyValues = true;
      internalValueResult.etcdManaged = this._etcdManaged;
    }
    if (this._identityAllocationMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.identityAllocationMode = this._identityAllocationMode;
    }
    if (this._identityChangeGracePeriod !== undefined) {
      hasAnyValues = true;
      internalValueResult.identityChangeGracePeriod = this._identityChangeGracePeriod;
    }
    if (this._installIptablesRules !== undefined) {
      hasAnyValues = true;
      internalValueResult.installIptablesRules = this._installIptablesRules;
    }
    if (this._ipam !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipam = this._ipam;
    }
    if (this._masquerade !== undefined) {
      hasAnyValues = true;
      internalValueResult.masquerade = this._masquerade;
    }
    if (this._memoryRequest !== undefined) {
      hasAnyValues = true;
      internalValueResult.memoryRequest = this._memoryRequest;
    }
    if (this._metrics !== undefined) {
      hasAnyValues = true;
      internalValueResult.metrics = this._metrics;
    }
    if (this._monitorAggregation !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitorAggregation = this._monitorAggregation;
    }
    if (this._preallocateBpfMaps !== undefined) {
      hasAnyValues = true;
      internalValueResult.preallocateBpfMaps = this._preallocateBpfMaps;
    }
    if (this._sidecarIstioProxyImage !== undefined) {
      hasAnyValues = true;
      internalValueResult.sidecarIstioProxyImage = this._sidecarIstioProxyImage;
    }
    if (this._toFqdnsDnsRejectResponseCode !== undefined) {
      hasAnyValues = true;
      internalValueResult.toFqdnsDnsRejectResponseCode = this._toFqdnsDnsRejectResponseCode;
    }
    if (this._toFqdnsEnablePoller !== undefined) {
      hasAnyValues = true;
      internalValueResult.toFqdnsEnablePoller = this._toFqdnsEnablePoller;
    }
    if (this._tunnel !== undefined) {
      hasAnyValues = true;
      internalValueResult.tunnel = this._tunnel;
    }
    if (this._version !== undefined) {
      hasAnyValues = true;
      internalValueResult.version = this._version;
    }
    if (this._hubble?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.hubble = this._hubble?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterNetworkingCilium | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._agentPodAnnotations = undefined;
      this._agentPrometheusPort = undefined;
      this._autoDirectNodeRoutes = undefined;
      this._bpfNeighGlobalMax = undefined;
      this._bpfPolicyMapMax = undefined;
      this._bpfctGlobalAnyMax = undefined;
      this._bpfctGlobalTcpMax = undefined;
      this._bpflbAlgorithm = undefined;
      this._bpflbMaglevTableSize = undefined;
      this._bpflbMapMax = undefined;
      this._bpflbSockHostNsOnly = undefined;
      this._bpfnatGlobalMax = undefined;
      this._chainingMode = undefined;
      this._clusterName = undefined;
      this._cpuRequest = undefined;
      this._debug = undefined;
      this._disableCnpStatusUpdates = undefined;
      this._disableEndpointCrd = undefined;
      this._enableBpfMasquerade = undefined;
      this._enableEncryption = undefined;
      this._enableEndpointHealthChecking = undefined;
      this._enableHostReachableServices = undefined;
      this._enableL7Proxy = undefined;
      this._enableNodePort = undefined;
      this._enablePolicy = undefined;
      this._enablePrometheusMetrics = undefined;
      this._enableRemoteNodeIdentity = undefined;
      this._enableServiceTopology = undefined;
      this._encryptionType = undefined;
      this._etcdManaged = undefined;
      this._identityAllocationMode = undefined;
      this._identityChangeGracePeriod = undefined;
      this._installIptablesRules = undefined;
      this._ipam = undefined;
      this._masquerade = undefined;
      this._memoryRequest = undefined;
      this._metrics = undefined;
      this._monitorAggregation = undefined;
      this._preallocateBpfMaps = undefined;
      this._sidecarIstioProxyImage = undefined;
      this._toFqdnsDnsRejectResponseCode = undefined;
      this._toFqdnsEnablePoller = undefined;
      this._tunnel = undefined;
      this._version = undefined;
      this._hubble.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._agentPodAnnotations = value.agentPodAnnotations;
      this._agentPrometheusPort = value.agentPrometheusPort;
      this._autoDirectNodeRoutes = value.autoDirectNodeRoutes;
      this._bpfNeighGlobalMax = value.bpfNeighGlobalMax;
      this._bpfPolicyMapMax = value.bpfPolicyMapMax;
      this._bpfctGlobalAnyMax = value.bpfctGlobalAnyMax;
      this._bpfctGlobalTcpMax = value.bpfctGlobalTcpMax;
      this._bpflbAlgorithm = value.bpflbAlgorithm;
      this._bpflbMaglevTableSize = value.bpflbMaglevTableSize;
      this._bpflbMapMax = value.bpflbMapMax;
      this._bpflbSockHostNsOnly = value.bpflbSockHostNsOnly;
      this._bpfnatGlobalMax = value.bpfnatGlobalMax;
      this._chainingMode = value.chainingMode;
      this._clusterName = value.clusterName;
      this._cpuRequest = value.cpuRequest;
      this._debug = value.debug;
      this._disableCnpStatusUpdates = value.disableCnpStatusUpdates;
      this._disableEndpointCrd = value.disableEndpointCrd;
      this._enableBpfMasquerade = value.enableBpfMasquerade;
      this._enableEncryption = value.enableEncryption;
      this._enableEndpointHealthChecking = value.enableEndpointHealthChecking;
      this._enableHostReachableServices = value.enableHostReachableServices;
      this._enableL7Proxy = value.enableL7Proxy;
      this._enableNodePort = value.enableNodePort;
      this._enablePolicy = value.enablePolicy;
      this._enablePrometheusMetrics = value.enablePrometheusMetrics;
      this._enableRemoteNodeIdentity = value.enableRemoteNodeIdentity;
      this._enableServiceTopology = value.enableServiceTopology;
      this._encryptionType = value.encryptionType;
      this._etcdManaged = value.etcdManaged;
      this._identityAllocationMode = value.identityAllocationMode;
      this._identityChangeGracePeriod = value.identityChangeGracePeriod;
      this._installIptablesRules = value.installIptablesRules;
      this._ipam = value.ipam;
      this._masquerade = value.masquerade;
      this._memoryRequest = value.memoryRequest;
      this._metrics = value.metrics;
      this._monitorAggregation = value.monitorAggregation;
      this._preallocateBpfMaps = value.preallocateBpfMaps;
      this._sidecarIstioProxyImage = value.sidecarIstioProxyImage;
      this._toFqdnsDnsRejectResponseCode = value.toFqdnsDnsRejectResponseCode;
      this._toFqdnsEnablePoller = value.toFqdnsEnablePoller;
      this._tunnel = value.tunnel;
      this._version = value.version;
      this._hubble.internalValue = value.hubble;
    }
  }

  // agent_pod_annotations - computed: false, optional: true, required: false
  private _agentPodAnnotations?: { [key: string]: string }; 
  public get agentPodAnnotations() {
    return this.getStringMapAttribute('agent_pod_annotations');
  }
  public set agentPodAnnotations(value: { [key: string]: string }) {
    this._agentPodAnnotations = value;
  }
  public resetAgentPodAnnotations() {
    this._agentPodAnnotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get agentPodAnnotationsInput() {
    return this._agentPodAnnotations;
  }

  // agent_prometheus_port - computed: false, optional: true, required: false
  private _agentPrometheusPort?: number; 
  public get agentPrometheusPort() {
    return this.getNumberAttribute('agent_prometheus_port');
  }
  public set agentPrometheusPort(value: number) {
    this._agentPrometheusPort = value;
  }
  public resetAgentPrometheusPort() {
    this._agentPrometheusPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get agentPrometheusPortInput() {
    return this._agentPrometheusPort;
  }

  // auto_direct_node_routes - computed: false, optional: true, required: false
  private _autoDirectNodeRoutes?: boolean | cdktf.IResolvable; 
  public get autoDirectNodeRoutes() {
    return this.getBooleanAttribute('auto_direct_node_routes');
  }
  public set autoDirectNodeRoutes(value: boolean | cdktf.IResolvable) {
    this._autoDirectNodeRoutes = value;
  }
  public resetAutoDirectNodeRoutes() {
    this._autoDirectNodeRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoDirectNodeRoutesInput() {
    return this._autoDirectNodeRoutes;
  }

  // bpf_neigh_global_max - computed: false, optional: true, required: false
  private _bpfNeighGlobalMax?: number; 
  public get bpfNeighGlobalMax() {
    return this.getNumberAttribute('bpf_neigh_global_max');
  }
  public set bpfNeighGlobalMax(value: number) {
    this._bpfNeighGlobalMax = value;
  }
  public resetBpfNeighGlobalMax() {
    this._bpfNeighGlobalMax = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bpfNeighGlobalMaxInput() {
    return this._bpfNeighGlobalMax;
  }

  // bpf_policy_map_max - computed: false, optional: true, required: false
  private _bpfPolicyMapMax?: number; 
  public get bpfPolicyMapMax() {
    return this.getNumberAttribute('bpf_policy_map_max');
  }
  public set bpfPolicyMapMax(value: number) {
    this._bpfPolicyMapMax = value;
  }
  public resetBpfPolicyMapMax() {
    this._bpfPolicyMapMax = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bpfPolicyMapMaxInput() {
    return this._bpfPolicyMapMax;
  }

  // bpfct_global_any_max - computed: false, optional: true, required: false
  private _bpfctGlobalAnyMax?: number; 
  public get bpfctGlobalAnyMax() {
    return this.getNumberAttribute('bpfct_global_any_max');
  }
  public set bpfctGlobalAnyMax(value: number) {
    this._bpfctGlobalAnyMax = value;
  }
  public resetBpfctGlobalAnyMax() {
    this._bpfctGlobalAnyMax = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bpfctGlobalAnyMaxInput() {
    return this._bpfctGlobalAnyMax;
  }

  // bpfct_global_tcp_max - computed: false, optional: true, required: false
  private _bpfctGlobalTcpMax?: number; 
  public get bpfctGlobalTcpMax() {
    return this.getNumberAttribute('bpfct_global_tcp_max');
  }
  public set bpfctGlobalTcpMax(value: number) {
    this._bpfctGlobalTcpMax = value;
  }
  public resetBpfctGlobalTcpMax() {
    this._bpfctGlobalTcpMax = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bpfctGlobalTcpMaxInput() {
    return this._bpfctGlobalTcpMax;
  }

  // bpflb_algorithm - computed: false, optional: true, required: false
  private _bpflbAlgorithm?: string; 
  public get bpflbAlgorithm() {
    return this.getStringAttribute('bpflb_algorithm');
  }
  public set bpflbAlgorithm(value: string) {
    this._bpflbAlgorithm = value;
  }
  public resetBpflbAlgorithm() {
    this._bpflbAlgorithm = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bpflbAlgorithmInput() {
    return this._bpflbAlgorithm;
  }

  // bpflb_maglev_table_size - computed: false, optional: true, required: false
  private _bpflbMaglevTableSize?: string; 
  public get bpflbMaglevTableSize() {
    return this.getStringAttribute('bpflb_maglev_table_size');
  }
  public set bpflbMaglevTableSize(value: string) {
    this._bpflbMaglevTableSize = value;
  }
  public resetBpflbMaglevTableSize() {
    this._bpflbMaglevTableSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bpflbMaglevTableSizeInput() {
    return this._bpflbMaglevTableSize;
  }

  // bpflb_map_max - computed: false, optional: true, required: false
  private _bpflbMapMax?: number; 
  public get bpflbMapMax() {
    return this.getNumberAttribute('bpflb_map_max');
  }
  public set bpflbMapMax(value: number) {
    this._bpflbMapMax = value;
  }
  public resetBpflbMapMax() {
    this._bpflbMapMax = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bpflbMapMaxInput() {
    return this._bpflbMapMax;
  }

  // bpflb_sock_host_ns_only - computed: false, optional: true, required: false
  private _bpflbSockHostNsOnly?: boolean | cdktf.IResolvable; 
  public get bpflbSockHostNsOnly() {
    return this.getBooleanAttribute('bpflb_sock_host_ns_only');
  }
  public set bpflbSockHostNsOnly(value: boolean | cdktf.IResolvable) {
    this._bpflbSockHostNsOnly = value;
  }
  public resetBpflbSockHostNsOnly() {
    this._bpflbSockHostNsOnly = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bpflbSockHostNsOnlyInput() {
    return this._bpflbSockHostNsOnly;
  }

  // bpfnat_global_max - computed: false, optional: true, required: false
  private _bpfnatGlobalMax?: number; 
  public get bpfnatGlobalMax() {
    return this.getNumberAttribute('bpfnat_global_max');
  }
  public set bpfnatGlobalMax(value: number) {
    this._bpfnatGlobalMax = value;
  }
  public resetBpfnatGlobalMax() {
    this._bpfnatGlobalMax = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bpfnatGlobalMaxInput() {
    return this._bpfnatGlobalMax;
  }

  // chaining_mode - computed: false, optional: true, required: false
  private _chainingMode?: string; 
  public get chainingMode() {
    return this.getStringAttribute('chaining_mode');
  }
  public set chainingMode(value: string) {
    this._chainingMode = value;
  }
  public resetChainingMode() {
    this._chainingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get chainingModeInput() {
    return this._chainingMode;
  }

  // cluster_name - computed: false, optional: true, required: false
  private _clusterName?: string; 
  public get clusterName() {
    return this.getStringAttribute('cluster_name');
  }
  public set clusterName(value: string) {
    this._clusterName = value;
  }
  public resetClusterName() {
    this._clusterName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterNameInput() {
    return this._clusterName;
  }

  // cpu_request - computed: false, optional: true, required: false
  private _cpuRequest?: string; 
  public get cpuRequest() {
    return this.getStringAttribute('cpu_request');
  }
  public set cpuRequest(value: string) {
    this._cpuRequest = value;
  }
  public resetCpuRequest() {
    this._cpuRequest = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuRequestInput() {
    return this._cpuRequest;
  }

  // debug - computed: false, optional: true, required: false
  private _debug?: boolean | cdktf.IResolvable; 
  public get debug() {
    return this.getBooleanAttribute('debug');
  }
  public set debug(value: boolean | cdktf.IResolvable) {
    this._debug = value;
  }
  public resetDebug() {
    this._debug = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get debugInput() {
    return this._debug;
  }

  // disable_cnp_status_updates - computed: false, optional: true, required: false
  private _disableCnpStatusUpdates?: boolean | cdktf.IResolvable; 
  public get disableCnpStatusUpdates() {
    return this.getBooleanAttribute('disable_cnp_status_updates');
  }
  public set disableCnpStatusUpdates(value: boolean | cdktf.IResolvable) {
    this._disableCnpStatusUpdates = value;
  }
  public resetDisableCnpStatusUpdates() {
    this._disableCnpStatusUpdates = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableCnpStatusUpdatesInput() {
    return this._disableCnpStatusUpdates;
  }

  // disable_endpoint_crd - computed: false, optional: true, required: false
  private _disableEndpointCrd?: boolean | cdktf.IResolvable; 
  public get disableEndpointCrd() {
    return this.getBooleanAttribute('disable_endpoint_crd');
  }
  public set disableEndpointCrd(value: boolean | cdktf.IResolvable) {
    this._disableEndpointCrd = value;
  }
  public resetDisableEndpointCrd() {
    this._disableEndpointCrd = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableEndpointCrdInput() {
    return this._disableEndpointCrd;
  }

  // enable_bpf_masquerade - computed: false, optional: true, required: false
  private _enableBpfMasquerade?: boolean | cdktf.IResolvable; 
  public get enableBpfMasquerade() {
    return this.getBooleanAttribute('enable_bpf_masquerade');
  }
  public set enableBpfMasquerade(value: boolean | cdktf.IResolvable) {
    this._enableBpfMasquerade = value;
  }
  public resetEnableBpfMasquerade() {
    this._enableBpfMasquerade = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableBpfMasqueradeInput() {
    return this._enableBpfMasquerade;
  }

  // enable_encryption - computed: false, optional: true, required: false
  private _enableEncryption?: boolean | cdktf.IResolvable; 
  public get enableEncryption() {
    return this.getBooleanAttribute('enable_encryption');
  }
  public set enableEncryption(value: boolean | cdktf.IResolvable) {
    this._enableEncryption = value;
  }
  public resetEnableEncryption() {
    this._enableEncryption = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableEncryptionInput() {
    return this._enableEncryption;
  }

  // enable_endpoint_health_checking - computed: false, optional: true, required: false
  private _enableEndpointHealthChecking?: boolean | cdktf.IResolvable; 
  public get enableEndpointHealthChecking() {
    return this.getBooleanAttribute('enable_endpoint_health_checking');
  }
  public set enableEndpointHealthChecking(value: boolean | cdktf.IResolvable) {
    this._enableEndpointHealthChecking = value;
  }
  public resetEnableEndpointHealthChecking() {
    this._enableEndpointHealthChecking = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableEndpointHealthCheckingInput() {
    return this._enableEndpointHealthChecking;
  }

  // enable_host_reachable_services - computed: false, optional: true, required: false
  private _enableHostReachableServices?: boolean | cdktf.IResolvable; 
  public get enableHostReachableServices() {
    return this.getBooleanAttribute('enable_host_reachable_services');
  }
  public set enableHostReachableServices(value: boolean | cdktf.IResolvable) {
    this._enableHostReachableServices = value;
  }
  public resetEnableHostReachableServices() {
    this._enableHostReachableServices = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHostReachableServicesInput() {
    return this._enableHostReachableServices;
  }

  // enable_l7_proxy - computed: false, optional: true, required: false
  private _enableL7Proxy?: boolean | cdktf.IResolvable; 
  public get enableL7Proxy() {
    return this.getBooleanAttribute('enable_l7_proxy');
  }
  public set enableL7Proxy(value: boolean | cdktf.IResolvable) {
    this._enableL7Proxy = value;
  }
  public resetEnableL7Proxy() {
    this._enableL7Proxy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableL7ProxyInput() {
    return this._enableL7Proxy;
  }

  // enable_node_port - computed: false, optional: true, required: false
  private _enableNodePort?: boolean | cdktf.IResolvable; 
  public get enableNodePort() {
    return this.getBooleanAttribute('enable_node_port');
  }
  public set enableNodePort(value: boolean | cdktf.IResolvable) {
    this._enableNodePort = value;
  }
  public resetEnableNodePort() {
    this._enableNodePort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableNodePortInput() {
    return this._enableNodePort;
  }

  // enable_policy - computed: false, optional: true, required: false
  private _enablePolicy?: string; 
  public get enablePolicy() {
    return this.getStringAttribute('enable_policy');
  }
  public set enablePolicy(value: string) {
    this._enablePolicy = value;
  }
  public resetEnablePolicy() {
    this._enablePolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enablePolicyInput() {
    return this._enablePolicy;
  }

  // enable_prometheus_metrics - computed: false, optional: true, required: false
  private _enablePrometheusMetrics?: boolean | cdktf.IResolvable; 
  public get enablePrometheusMetrics() {
    return this.getBooleanAttribute('enable_prometheus_metrics');
  }
  public set enablePrometheusMetrics(value: boolean | cdktf.IResolvable) {
    this._enablePrometheusMetrics = value;
  }
  public resetEnablePrometheusMetrics() {
    this._enablePrometheusMetrics = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enablePrometheusMetricsInput() {
    return this._enablePrometheusMetrics;
  }

  // enable_remote_node_identity - computed: false, optional: false, required: true
  private _enableRemoteNodeIdentity?: boolean | cdktf.IResolvable; 
  public get enableRemoteNodeIdentity() {
    return this.getBooleanAttribute('enable_remote_node_identity');
  }
  public set enableRemoteNodeIdentity(value: boolean | cdktf.IResolvable) {
    this._enableRemoteNodeIdentity = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enableRemoteNodeIdentityInput() {
    return this._enableRemoteNodeIdentity;
  }

  // enable_service_topology - computed: false, optional: true, required: false
  private _enableServiceTopology?: boolean | cdktf.IResolvable; 
  public get enableServiceTopology() {
    return this.getBooleanAttribute('enable_service_topology');
  }
  public set enableServiceTopology(value: boolean | cdktf.IResolvable) {
    this._enableServiceTopology = value;
  }
  public resetEnableServiceTopology() {
    this._enableServiceTopology = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableServiceTopologyInput() {
    return this._enableServiceTopology;
  }

  // encryption_type - computed: false, optional: true, required: false
  private _encryptionType?: string; 
  public get encryptionType() {
    return this.getStringAttribute('encryption_type');
  }
  public set encryptionType(value: string) {
    this._encryptionType = value;
  }
  public resetEncryptionType() {
    this._encryptionType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get encryptionTypeInput() {
    return this._encryptionType;
  }

  // etcd_managed - computed: false, optional: true, required: false
  private _etcdManaged?: boolean | cdktf.IResolvable; 
  public get etcdManaged() {
    return this.getBooleanAttribute('etcd_managed');
  }
  public set etcdManaged(value: boolean | cdktf.IResolvable) {
    this._etcdManaged = value;
  }
  public resetEtcdManaged() {
    this._etcdManaged = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get etcdManagedInput() {
    return this._etcdManaged;
  }

  // identity_allocation_mode - computed: false, optional: true, required: false
  private _identityAllocationMode?: string; 
  public get identityAllocationMode() {
    return this.getStringAttribute('identity_allocation_mode');
  }
  public set identityAllocationMode(value: string) {
    this._identityAllocationMode = value;
  }
  public resetIdentityAllocationMode() {
    this._identityAllocationMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get identityAllocationModeInput() {
    return this._identityAllocationMode;
  }

  // identity_change_grace_period - computed: false, optional: true, required: false
  private _identityChangeGracePeriod?: string; 
  public get identityChangeGracePeriod() {
    return this.getStringAttribute('identity_change_grace_period');
  }
  public set identityChangeGracePeriod(value: string) {
    this._identityChangeGracePeriod = value;
  }
  public resetIdentityChangeGracePeriod() {
    this._identityChangeGracePeriod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get identityChangeGracePeriodInput() {
    return this._identityChangeGracePeriod;
  }

  // install_iptables_rules - computed: false, optional: true, required: false
  private _installIptablesRules?: boolean | cdktf.IResolvable; 
  public get installIptablesRules() {
    return this.getBooleanAttribute('install_iptables_rules');
  }
  public set installIptablesRules(value: boolean | cdktf.IResolvable) {
    this._installIptablesRules = value;
  }
  public resetInstallIptablesRules() {
    this._installIptablesRules = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get installIptablesRulesInput() {
    return this._installIptablesRules;
  }

  // ipam - computed: false, optional: true, required: false
  private _ipam?: string; 
  public get ipam() {
    return this.getStringAttribute('ipam');
  }
  public set ipam(value: string) {
    this._ipam = value;
  }
  public resetIpam() {
    this._ipam = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipamInput() {
    return this._ipam;
  }

  // masquerade - computed: false, optional: true, required: false
  private _masquerade?: boolean | cdktf.IResolvable; 
  public get masquerade() {
    return this.getBooleanAttribute('masquerade');
  }
  public set masquerade(value: boolean | cdktf.IResolvable) {
    this._masquerade = value;
  }
  public resetMasquerade() {
    this._masquerade = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get masqueradeInput() {
    return this._masquerade;
  }

  // memory_request - computed: false, optional: true, required: false
  private _memoryRequest?: string; 
  public get memoryRequest() {
    return this.getStringAttribute('memory_request');
  }
  public set memoryRequest(value: string) {
    this._memoryRequest = value;
  }
  public resetMemoryRequest() {
    this._memoryRequest = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryRequestInput() {
    return this._memoryRequest;
  }

  // metrics - computed: false, optional: true, required: false
  private _metrics?: string[]; 
  public get metrics() {
    return this.getListAttribute('metrics');
  }
  public set metrics(value: string[]) {
    this._metrics = value;
  }
  public resetMetrics() {
    this._metrics = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricsInput() {
    return this._metrics;
  }

  // monitor_aggregation - computed: false, optional: true, required: false
  private _monitorAggregation?: string; 
  public get monitorAggregation() {
    return this.getStringAttribute('monitor_aggregation');
  }
  public set monitorAggregation(value: string) {
    this._monitorAggregation = value;
  }
  public resetMonitorAggregation() {
    this._monitorAggregation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitorAggregationInput() {
    return this._monitorAggregation;
  }

  // preallocate_bpf_maps - computed: false, optional: false, required: true
  private _preallocateBpfMaps?: boolean | cdktf.IResolvable; 
  public get preallocateBpfMaps() {
    return this.getBooleanAttribute('preallocate_bpf_maps');
  }
  public set preallocateBpfMaps(value: boolean | cdktf.IResolvable) {
    this._preallocateBpfMaps = value;
  }
  // Temporarily expose input value. Use with caution.
  public get preallocateBpfMapsInput() {
    return this._preallocateBpfMaps;
  }

  // sidecar_istio_proxy_image - computed: false, optional: true, required: false
  private _sidecarIstioProxyImage?: string; 
  public get sidecarIstioProxyImage() {
    return this.getStringAttribute('sidecar_istio_proxy_image');
  }
  public set sidecarIstioProxyImage(value: string) {
    this._sidecarIstioProxyImage = value;
  }
  public resetSidecarIstioProxyImage() {
    this._sidecarIstioProxyImage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sidecarIstioProxyImageInput() {
    return this._sidecarIstioProxyImage;
  }

  // to_fqdns_dns_reject_response_code - computed: false, optional: true, required: false
  private _toFqdnsDnsRejectResponseCode?: string; 
  public get toFqdnsDnsRejectResponseCode() {
    return this.getStringAttribute('to_fqdns_dns_reject_response_code');
  }
  public set toFqdnsDnsRejectResponseCode(value: string) {
    this._toFqdnsDnsRejectResponseCode = value;
  }
  public resetToFqdnsDnsRejectResponseCode() {
    this._toFqdnsDnsRejectResponseCode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get toFqdnsDnsRejectResponseCodeInput() {
    return this._toFqdnsDnsRejectResponseCode;
  }

  // to_fqdns_enable_poller - computed: false, optional: true, required: false
  private _toFqdnsEnablePoller?: boolean | cdktf.IResolvable; 
  public get toFqdnsEnablePoller() {
    return this.getBooleanAttribute('to_fqdns_enable_poller');
  }
  public set toFqdnsEnablePoller(value: boolean | cdktf.IResolvable) {
    this._toFqdnsEnablePoller = value;
  }
  public resetToFqdnsEnablePoller() {
    this._toFqdnsEnablePoller = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get toFqdnsEnablePollerInput() {
    return this._toFqdnsEnablePoller;
  }

  // tunnel - computed: false, optional: true, required: false
  private _tunnel?: string; 
  public get tunnel() {
    return this.getStringAttribute('tunnel');
  }
  public set tunnel(value: string) {
    this._tunnel = value;
  }
  public resetTunnel() {
    this._tunnel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tunnelInput() {
    return this._tunnel;
  }

  // version - computed: false, optional: true, required: false
  private _version?: string; 
  public get version() {
    return this.getStringAttribute('version');
  }
  public set version(value: string) {
    this._version = value;
  }
  public resetVersion() {
    this._version = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get versionInput() {
    return this._version;
  }

  // hubble - computed: false, optional: true, required: false
  private _hubble = new ClusterNetworkingCiliumHubbleOutputReference(this, "hubble");
  public get hubble() {
    return this._hubble;
  }
  public putHubble(value: ClusterNetworkingCiliumHubble) {
    this._hubble.internalValue = value;
  }
  public resetHubble() {
    this._hubble.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hubbleInput() {
    return this._hubble.internalValue;
  }
}
export interface ClusterNetworkingClassic {
}

export function clusterNetworkingClassicToTerraform(struct?: ClusterNetworkingClassicOutputReference | ClusterNetworkingClassic): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function clusterNetworkingClassicToHclTerraform(struct?: ClusterNetworkingClassicOutputReference | ClusterNetworkingClassic): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class ClusterNetworkingClassicOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterNetworkingClassic | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterNetworkingClassic | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }
}
export interface ClusterNetworkingCni {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#uses_secondary_ip Cluster#uses_secondary_ip}
  */
  readonly usesSecondaryIp?: boolean | cdktf.IResolvable;
}

export function clusterNetworkingCniToTerraform(struct?: ClusterNetworkingCniOutputReference | ClusterNetworkingCni): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    uses_secondary_ip: cdktf.booleanToTerraform(struct!.usesSecondaryIp),
  }
}


export function clusterNetworkingCniToHclTerraform(struct?: ClusterNetworkingCniOutputReference | ClusterNetworkingCni): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    uses_secondary_ip: {
      value: cdktf.booleanToHclTerraform(struct!.usesSecondaryIp),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterNetworkingCniOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterNetworkingCni | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._usesSecondaryIp !== undefined) {
      hasAnyValues = true;
      internalValueResult.usesSecondaryIp = this._usesSecondaryIp;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterNetworkingCni | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._usesSecondaryIp = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._usesSecondaryIp = value.usesSecondaryIp;
    }
  }

  // uses_secondary_ip - computed: false, optional: true, required: false
  private _usesSecondaryIp?: boolean | cdktf.IResolvable; 
  public get usesSecondaryIp() {
    return this.getBooleanAttribute('uses_secondary_ip');
  }
  public set usesSecondaryIp(value: boolean | cdktf.IResolvable) {
    this._usesSecondaryIp = value;
  }
  public resetUsesSecondaryIp() {
    this._usesSecondaryIp = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usesSecondaryIpInput() {
    return this._usesSecondaryIp;
  }
}
export interface ClusterNetworkingExternal {
}

export function clusterNetworkingExternalToTerraform(struct?: ClusterNetworkingExternalOutputReference | ClusterNetworkingExternal): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function clusterNetworkingExternalToHclTerraform(struct?: ClusterNetworkingExternalOutputReference | ClusterNetworkingExternal): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class ClusterNetworkingExternalOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterNetworkingExternal | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterNetworkingExternal | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }
}
export interface ClusterNetworkingFlannel {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#backend Cluster#backend}
  */
  readonly backend?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/eddycharly/kops/1.25.4/docs/resources/cluster#iptables_resync_seconds Cluster#iptables_resync_seconds}
  */
  readonly iptablesResyncSeconds?: number;
}

export function clusterNetworkingFlannelToTerraform(struct?: ClusterNetworkingFlannelOutputReference | ClusterNetworkingFlannel): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backend: cdktf.stringToTerraform(struct!.backend),
    iptables_resync_seconds: cdktf.numberToTerraform(struct!.iptablesResyncSeconds),
  }
}


export function clusterNetworkingFlannelToHclTerraform(struct?: ClusterNetworkingFlannelOutputReference | ClusterNetworkingFlannel): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backend: {
      value: cdktf.stringToHclTerraform(struct!.backend),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    iptables_resync_seconds: {
      value: cdktf.numberToHclTerraform(struct!.iptablesResyncSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ClusterNetworkingFlannelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ClusterNetworkingFlannel | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backend !== undefined) {
      hasAnyValues = true;
      internalValueResult.backend = this._backend;
    }
    if (this._iptablesResyncSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.iptablesResyncSeconds = this._iptablesResyncSeconds;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ClusterNetworkingFlannel | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._backend = undefined;
      this._iptablesResyncSeconds = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._backend = value.backend;
      this._iptablesResyncSeconds = value.iptablesResyncSeconds;
    }
  }

  // backend - computed: false, optional: true, required: false
  private _backend?: string; 
  public get backend() {
    return this.getStringAttribute('backend');
  }
  public set backend(value: string) {
    this._backend = value;
  }
  public resetBackend() {
    this._backend = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backendInput() {
    return this._backend;
  }

  // iptables_resync_seconds - computed: false, optional: true, required: false
  private _iptablesResyncSeconds?: number; 
  public get iptablesResyncSeconds() {
    return this.getNumberAttribute('iptables_resync_seconds');
  }
  public set iptablesResyncSeconds(value: number) {
    this._iptablesResyncSeconds = value;
  }
  public resetIptablesResyncSeconds() {
    this._iptablesResyncSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get iptablesResyncSecondsInput() {
    return this._iptablesResyncSeconds;
  }
}
