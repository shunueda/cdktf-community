// https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestConfig extends cdktf.TerraformMetaArguments {
  /**
  * Data that helps uniquely identify this object. See https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#metadata DataK8STemporalIoTemporalClusterV1Beta1Manifest#metadata}
  */
  readonly metadata: DataK8STemporalIoTemporalClusterV1Beta1ManifestMetadata;
  /**
  * Specification of the desired behavior of the Temporal cluster.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#spec DataK8STemporalIoTemporalClusterV1Beta1Manifest#spec}
  */
  readonly spec?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpec;
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestMetadata {
  /**
  * Keys and values that can be used by external tooling to store and retrieve arbitrary metadata about this object. See https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/ for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#annotations DataK8STemporalIoTemporalClusterV1Beta1Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Keys and values that can be used to organize and categorize objects. See https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/ for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#labels DataK8STemporalIoTemporalClusterV1Beta1Manifest#labels}
  */
  readonly labels?: { [key: string]: string };
  /**
  * Unique identifier for this object. See https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#name DataK8STemporalIoTemporalClusterV1Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * Namespaces provides a mechanism for isolating groups of resources within a single cluster. See https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/ for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#namespace DataK8STemporalIoTemporalClusterV1Beta1Manifest#namespace}
  */
  readonly namespace: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestMetadataToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestMetadataToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotations = undefined;
      this._labels = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotations = value.annotations;
      this._labels = value.labels;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: false, required: true
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentMetadata {
  /**
  * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#annotations DataK8STemporalIoTemporalClusterV1Beta1Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Map of string keys and values that can be used to organize and categorize (scope and select) objects.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#labels DataK8STemporalIoTemporalClusterV1Beta1Manifest#labels}
  */
  readonly labels?: { [key: string]: string };
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentMetadataToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentMetadataToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotations = undefined;
      this._labels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotations = value.annotations;
      this._labels = value.labels;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentSpecTemplateMetadata {
  /**
  * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#annotations DataK8STemporalIoTemporalClusterV1Beta1Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Map of string keys and values that can be used to organize and categorize (scope and select) objects.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#labels DataK8STemporalIoTemporalClusterV1Beta1Manifest#labels}
  */
  readonly labels?: { [key: string]: string };
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentSpecTemplateMetadataToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentSpecTemplateMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentSpecTemplateMetadataToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentSpecTemplateMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentSpecTemplateMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentSpecTemplateMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentSpecTemplateMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotations = undefined;
      this._labels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotations = value.annotations;
      this._labels = value.labels;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentSpecTemplate {
  /**
  * ObjectMetaOverride provides the ability to override an object metadata. It's a subset of the fields included in k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#metadata DataK8STemporalIoTemporalClusterV1Beta1Manifest#metadata}
  */
  readonly metadata?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentSpecTemplateMetadata;
  /**
  * Specification of the desired behavior of the pod.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#spec DataK8STemporalIoTemporalClusterV1Beta1Manifest#spec}
  */
  readonly spec?: { [key: string]: string };
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentSpecTemplateToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentSpecTemplate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    metadata: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentSpecTemplateMetadataToTerraform(struct!.metadata),
    spec: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.spec),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentSpecTemplateToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentSpecTemplate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    metadata: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentSpecTemplateMetadataToHclTerraform(struct!.metadata),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentSpecTemplateMetadata",
    },
    spec: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.spec),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentSpecTemplateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentSpecTemplate | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._spec !== undefined) {
      hasAnyValues = true;
      internalValueResult.spec = this._spec;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentSpecTemplate | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._metadata.internalValue = undefined;
      this._spec = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._metadata.internalValue = value.metadata;
      this._spec = value.spec;
    }
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentSpecTemplateMetadataOutputReference(this, "metadata");
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentSpecTemplateMetadata) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // spec - computed: false, optional: true, required: false
  private _spec?: { [key: string]: string }; 
  public get spec() {
    return this.getStringMapAttribute('spec');
  }
  public set spec(value: { [key: string]: string }) {
    this._spec = value;
  }
  public resetSpec() {
    this._spec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get specInput() {
    return this._spec;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentSpec {
  /**
  * Template describes the pods that will be created.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#template DataK8STemporalIoTemporalClusterV1Beta1Manifest#template}
  */
  readonly template?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentSpecTemplate;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentSpecToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    template: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentSpecTemplateToTerraform(struct!.template),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentSpecToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    template: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentSpecTemplateToHclTerraform(struct!.template),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentSpecTemplate",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentSpecOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentSpec | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._template?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.template = this._template?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentSpec | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._template.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._template.internalValue = value.template;
    }
  }

  // template - computed: false, optional: true, required: false
  private _template = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentSpecTemplateOutputReference(this, "template");
  public get template() {
    return this._template;
  }
  public putTemplate(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentSpecTemplate) {
    this._template.internalValue = value;
  }
  public resetTemplate() {
    this._template.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get templateInput() {
    return this._template.internalValue;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeployment {
  /**
  * ObjectMetaOverride provides the ability to override an object metadata. It's a subset of the fields included in k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#metadata DataK8STemporalIoTemporalClusterV1Beta1Manifest#metadata}
  */
  readonly metadata?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentMetadata;
  /**
  * Specification of the desired behavior of the Deployment.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#spec DataK8STemporalIoTemporalClusterV1Beta1Manifest#spec}
  */
  readonly spec?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentSpec;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeployment | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    metadata: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentMetadataToTerraform(struct!.metadata),
    spec: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentSpecToTerraform(struct!.spec),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeployment | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    metadata: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentMetadataToHclTerraform(struct!.metadata),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentMetadata",
    },
    spec: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentSpecToHclTerraform(struct!.spec),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentSpec",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeployment | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._spec?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.spec = this._spec?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeployment | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._metadata.internalValue = undefined;
      this._spec.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._metadata.internalValue = value.metadata;
      this._spec.internalValue = value.spec;
    }
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentMetadataOutputReference(this, "metadata");
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentMetadata) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // spec - computed: false, optional: true, required: false
  private _spec = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentSpecOutputReference(this, "spec");
  public get spec() {
    return this._spec;
  }
  public putSpec(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentSpec) {
    this._spec.internalValue = value;
  }
  public resetSpec() {
    this._spec.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get specInput() {
    return this._spec.internalValue;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverrides {
  /**
  * Override configuration for the temporal service Deployment.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#deployment DataK8STemporalIoTemporalClusterV1Beta1Manifest#deployment}
  */
  readonly deployment?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeployment;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverrides | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    deployment: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentToTerraform(struct!.deployment),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverrides | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    deployment: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentToHclTerraform(struct!.deployment),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeployment",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverrides | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._deployment?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.deployment = this._deployment?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverrides | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._deployment.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._deployment.internalValue = value.deployment;
    }
  }

  // deployment - computed: false, optional: true, required: false
  private _deployment = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeploymentOutputReference(this, "deployment");
  public get deployment() {
    return this._deployment;
  }
  public putDeployment(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesDeployment) {
    this._deployment.internalValue = value;
  }
  public resetDeployment() {
    this._deployment.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deploymentInput() {
    return this._deployment.internalValue;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsResourcesClaims {
  /**
  * Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#name DataK8STemporalIoTemporalClusterV1Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * Request is the name chosen for a request in the referenced claim. If empty, everything from the claim is made available, otherwise only the result of this request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#request DataK8STemporalIoTemporalClusterV1Beta1Manifest#request}
  */
  readonly request?: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsResourcesClaimsToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsResourcesClaims | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    request: cdktf.stringToTerraform(struct!.request),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsResourcesClaimsToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsResourcesClaims | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request: {
      value: cdktf.stringToHclTerraform(struct!.request),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsResourcesClaimsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsResourcesClaims | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._request !== undefined) {
      hasAnyValues = true;
      internalValueResult.request = this._request;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsResourcesClaims | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._request = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._request = value.request;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // request - computed: false, optional: true, required: false
  private _request?: string; 
  public get request() {
    return this.getStringAttribute('request');
  }
  public set request(value: string) {
    this._request = value;
  }
  public resetRequest() {
    this._request = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestInput() {
    return this._request;
  }
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsResourcesClaimsList extends cdktf.ComplexList {
  public internalValue? : DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsResourcesClaims[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsResourcesClaimsOutputReference {
    return new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsResourcesClaimsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsResources {
  /**
  * Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container. This is an alpha field and requires enabling the DynamicResourceAllocation feature gate. This field is immutable. It can only be set for containers.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#claims DataK8STemporalIoTemporalClusterV1Beta1Manifest#claims}
  */
  readonly claims?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsResourcesClaims[] | cdktf.IResolvable;
  /**
  * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#limits DataK8STemporalIoTemporalClusterV1Beta1Manifest#limits}
  */
  readonly limits?: { [key: string]: string };
  /**
  * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. Requests cannot exceed Limits. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#requests DataK8STemporalIoTemporalClusterV1Beta1Manifest#requests}
  */
  readonly requests?: { [key: string]: string };
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsResourcesToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsResources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    claims: cdktf.listMapper(dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsResourcesClaimsToTerraform, false)(struct!.claims),
    limits: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.limits),
    requests: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.requests),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsResourcesToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsResources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    claims: {
      value: cdktf.listMapperHcl(dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsResourcesClaimsToHclTerraform, false)(struct!.claims),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsResourcesClaimsList",
    },
    limits: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.limits),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    requests: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.requests),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsResourcesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsResources | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._claims?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.claims = this._claims?.internalValue;
    }
    if (this._limits !== undefined) {
      hasAnyValues = true;
      internalValueResult.limits = this._limits;
    }
    if (this._requests !== undefined) {
      hasAnyValues = true;
      internalValueResult.requests = this._requests;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsResources | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._claims.internalValue = undefined;
      this._limits = undefined;
      this._requests = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._claims.internalValue = value.claims;
      this._limits = value.limits;
      this._requests = value.requests;
    }
  }

  // claims - computed: false, optional: true, required: false
  private _claims = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsResourcesClaimsList(this, "claims", false);
  public get claims() {
    return this._claims;
  }
  public putClaims(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsResourcesClaims[] | cdktf.IResolvable) {
    this._claims.internalValue = value;
  }
  public resetClaims() {
    this._claims.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get claimsInput() {
    return this._claims.internalValue;
  }

  // limits - computed: false, optional: true, required: false
  private _limits?: { [key: string]: string }; 
  public get limits() {
    return this.getStringMapAttribute('limits');
  }
  public set limits(value: { [key: string]: string }) {
    this._limits = value;
  }
  public resetLimits() {
    this._limits = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get limitsInput() {
    return this._limits;
  }

  // requests - computed: false, optional: true, required: false
  private _requests?: { [key: string]: string }; 
  public get requests() {
    return this.getStringMapAttribute('requests');
  }
  public set requests(value: { [key: string]: string }) {
    this._requests = value;
  }
  public resetRequests() {
    this._requests = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestsInput() {
    return this._requests;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintools {
  /**
  * Enabled defines if the operator should deploy the admin tools alongside the cluster.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#enabled DataK8STemporalIoTemporalClusterV1Beta1Manifest#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
  /**
  * Image defines the temporal admin tools docker image the instance should run.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#image DataK8STemporalIoTemporalClusterV1Beta1Manifest#image}
  */
  readonly image?: string;
  /**
  * Overrides adds some overrides to the resources deployed for the ui.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#overrides DataK8STemporalIoTemporalClusterV1Beta1Manifest#overrides}
  */
  readonly overrides?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverrides;
  /**
  * Compute Resources required by the ui. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#resources DataK8STemporalIoTemporalClusterV1Beta1Manifest#resources}
  */
  readonly resources?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsResources;
  /**
  * Version defines the temporal admin tools version the instance should run.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#version DataK8STemporalIoTemporalClusterV1Beta1Manifest#version}
  */
  readonly version?: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintools | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.booleanToTerraform(struct!.enabled),
    image: cdktf.stringToTerraform(struct!.image),
    overrides: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesToTerraform(struct!.overrides),
    resources: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsResourcesToTerraform(struct!.resources),
    version: cdktf.stringToTerraform(struct!.version),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintools | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    image: {
      value: cdktf.stringToHclTerraform(struct!.image),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    overrides: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesToHclTerraform(struct!.overrides),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverrides",
    },
    resources: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsResourcesToHclTerraform(struct!.resources),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsResources",
    },
    version: {
      value: cdktf.stringToHclTerraform(struct!.version),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintools | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._image !== undefined) {
      hasAnyValues = true;
      internalValueResult.image = this._image;
    }
    if (this._overrides?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.overrides = this._overrides?.internalValue;
    }
    if (this._resources?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resources = this._resources?.internalValue;
    }
    if (this._version !== undefined) {
      hasAnyValues = true;
      internalValueResult.version = this._version;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintools | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._image = undefined;
      this._overrides.internalValue = undefined;
      this._resources.internalValue = undefined;
      this._version = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._image = value.image;
      this._overrides.internalValue = value.overrides;
      this._resources.internalValue = value.resources;
      this._version = value.version;
    }
  }

  // enabled - computed: false, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // image - computed: false, optional: true, required: false
  private _image?: string; 
  public get image() {
    return this.getStringAttribute('image');
  }
  public set image(value: string) {
    this._image = value;
  }
  public resetImage() {
    this._image = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageInput() {
    return this._image;
  }

  // overrides - computed: false, optional: true, required: false
  private _overrides = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverridesOutputReference(this, "overrides");
  public get overrides() {
    return this._overrides;
  }
  public putOverrides(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOverrides) {
    this._overrides.internalValue = value;
  }
  public resetOverrides() {
    this._overrides.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overridesInput() {
    return this._overrides.internalValue;
  }

  // resources - computed: false, optional: true, required: false
  private _resources = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsResourcesOutputReference(this, "resources");
  public get resources() {
    return this._resources;
  }
  public putResources(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsResources) {
    this._resources.internalValue = value;
  }
  public resetResources() {
    this._resources.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourcesInput() {
    return this._resources.internalValue;
  }

  // version - computed: false, optional: true, required: false
  private _version?: string; 
  public get version() {
    return this.getStringAttribute('version');
  }
  public set version(value: string) {
    this._version = value;
  }
  public resetVersion() {
    this._version = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get versionInput() {
    return this._version;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalHistory {
  /**
  * EnableRead allows temporal to read from the archived Event History.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#enable_read DataK8STemporalIoTemporalClusterV1Beta1Manifest#enable_read}
  */
  readonly enableRead: boolean | cdktf.IResolvable;
  /**
  * Enabled defines if the archival is enabled by default for all namespaces or for a particular namespace (depends if it's for a TemporalCluster or a TemporalNamespace).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#enabled DataK8STemporalIoTemporalClusterV1Beta1Manifest#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
  /**
  * Path is ...
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#path DataK8STemporalIoTemporalClusterV1Beta1Manifest#path}
  */
  readonly path: string;
  /**
  * Paused defines if the archival is paused.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#paused DataK8STemporalIoTemporalClusterV1Beta1Manifest#paused}
  */
  readonly paused: boolean | cdktf.IResolvable;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalHistoryToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalHistory | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enable_read: cdktf.booleanToTerraform(struct!.enableRead),
    enabled: cdktf.booleanToTerraform(struct!.enabled),
    path: cdktf.stringToTerraform(struct!.path),
    paused: cdktf.booleanToTerraform(struct!.paused),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalHistoryToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalHistory | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enable_read: {
      value: cdktf.booleanToHclTerraform(struct!.enableRead),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    paused: {
      value: cdktf.booleanToHclTerraform(struct!.paused),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalHistoryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalHistory | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enableRead !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableRead = this._enableRead;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._paused !== undefined) {
      hasAnyValues = true;
      internalValueResult.paused = this._paused;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalHistory | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enableRead = undefined;
      this._enabled = undefined;
      this._path = undefined;
      this._paused = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enableRead = value.enableRead;
      this._enabled = value.enabled;
      this._path = value.path;
      this._paused = value.paused;
    }
  }

  // enable_read - computed: false, optional: false, required: true
  private _enableRead?: boolean | cdktf.IResolvable; 
  public get enableRead() {
    return this.getBooleanAttribute('enable_read');
  }
  public set enableRead(value: boolean | cdktf.IResolvable) {
    this._enableRead = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enableReadInput() {
    return this._enableRead;
  }

  // enabled - computed: false, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // paused - computed: false, optional: false, required: true
  private _paused?: boolean | cdktf.IResolvable; 
  public get paused() {
    return this.getBooleanAttribute('paused');
  }
  public set paused(value: boolean | cdktf.IResolvable) {
    this._paused = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pausedInput() {
    return this._paused;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderFilestore {
  /**
  * DirPermissions sets the directory permissions of the archive directory. It's recommend to leave it empty and use the default value of '0766' to avoid read/write issues.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#dir_permissions DataK8STemporalIoTemporalClusterV1Beta1Manifest#dir_permissions}
  */
  readonly dirPermissions: string;
  /**
  * FilePermissions sets the file permissions of the archived files. It's recommend to leave it empty and use the default value of '0666' to avoid read/write issues.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#file_permissions DataK8STemporalIoTemporalClusterV1Beta1Manifest#file_permissions}
  */
  readonly filePermissions: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderFilestoreToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderFilestore | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dir_permissions: cdktf.stringToTerraform(struct!.dirPermissions),
    file_permissions: cdktf.stringToTerraform(struct!.filePermissions),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderFilestoreToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderFilestore | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dir_permissions: {
      value: cdktf.stringToHclTerraform(struct!.dirPermissions),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    file_permissions: {
      value: cdktf.stringToHclTerraform(struct!.filePermissions),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderFilestoreOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderFilestore | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dirPermissions !== undefined) {
      hasAnyValues = true;
      internalValueResult.dirPermissions = this._dirPermissions;
    }
    if (this._filePermissions !== undefined) {
      hasAnyValues = true;
      internalValueResult.filePermissions = this._filePermissions;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderFilestore | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dirPermissions = undefined;
      this._filePermissions = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dirPermissions = value.dirPermissions;
      this._filePermissions = value.filePermissions;
    }
  }

  // dir_permissions - computed: false, optional: false, required: true
  private _dirPermissions?: string; 
  public get dirPermissions() {
    return this.getStringAttribute('dir_permissions');
  }
  public set dirPermissions(value: string) {
    this._dirPermissions = value;
  }
  // Temporarily expose input value. Use with caution.
  public get dirPermissionsInput() {
    return this._dirPermissions;
  }

  // file_permissions - computed: false, optional: false, required: true
  private _filePermissions?: string; 
  public get filePermissions() {
    return this.getStringAttribute('file_permissions');
  }
  public set filePermissions(value: string) {
    this._filePermissions = value;
  }
  // Temporarily expose input value. Use with caution.
  public get filePermissionsInput() {
    return this._filePermissions;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderGcsCredentialsRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#key DataK8STemporalIoTemporalClusterV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#name DataK8STemporalIoTemporalClusterV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#optional DataK8STemporalIoTemporalClusterV1Beta1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderGcsCredentialsRefToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderGcsCredentialsRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderGcsCredentialsRefToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderGcsCredentialsRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderGcsCredentialsRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderGcsCredentialsRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderGcsCredentialsRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderGcs {
  /**
  * SecretAccessKeyRef is the secret key selector containing Google Cloud Storage credentials file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#credentials_ref DataK8STemporalIoTemporalClusterV1Beta1Manifest#credentials_ref}
  */
  readonly credentialsRef: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderGcsCredentialsRef;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderGcsToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderGcs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    credentials_ref: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderGcsCredentialsRefToTerraform(struct!.credentialsRef),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderGcsToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderGcs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    credentials_ref: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderGcsCredentialsRefToHclTerraform(struct!.credentialsRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderGcsCredentialsRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderGcsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderGcs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._credentialsRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialsRef = this._credentialsRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderGcs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._credentialsRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._credentialsRef.internalValue = value.credentialsRef;
    }
  }

  // credentials_ref - computed: false, optional: false, required: true
  private _credentialsRef = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderGcsCredentialsRefOutputReference(this, "credentials_ref");
  public get credentialsRef() {
    return this._credentialsRef;
  }
  public putCredentialsRef(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderGcsCredentialsRef) {
    this._credentialsRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsRefInput() {
    return this._credentialsRef.internalValue;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderS3CredentialsAccessKeyIdRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#key DataK8STemporalIoTemporalClusterV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#name DataK8STemporalIoTemporalClusterV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#optional DataK8STemporalIoTemporalClusterV1Beta1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderS3CredentialsAccessKeyIdRefToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderS3CredentialsAccessKeyIdRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderS3CredentialsAccessKeyIdRefToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderS3CredentialsAccessKeyIdRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderS3CredentialsAccessKeyIdRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderS3CredentialsAccessKeyIdRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderS3CredentialsAccessKeyIdRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderS3CredentialsSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#key DataK8STemporalIoTemporalClusterV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#name DataK8STemporalIoTemporalClusterV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#optional DataK8STemporalIoTemporalClusterV1Beta1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderS3CredentialsSecretKeyRefToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderS3CredentialsSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderS3CredentialsSecretKeyRefToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderS3CredentialsSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderS3CredentialsSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderS3CredentialsSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderS3CredentialsSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderS3Credentials {
  /**
  * AccessKeyIDRef is the secret key selector containing AWS access key ID.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#access_key_id_ref DataK8STemporalIoTemporalClusterV1Beta1Manifest#access_key_id_ref}
  */
  readonly accessKeyIdRef: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderS3CredentialsAccessKeyIdRef;
  /**
  * SecretAccessKeyRef is the secret key selector containing AWS secret access key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#secret_key_ref DataK8STemporalIoTemporalClusterV1Beta1Manifest#secret_key_ref}
  */
  readonly secretKeyRef: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderS3CredentialsSecretKeyRef;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderS3CredentialsToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderS3Credentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_key_id_ref: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderS3CredentialsAccessKeyIdRefToTerraform(struct!.accessKeyIdRef),
    secret_key_ref: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderS3CredentialsSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderS3CredentialsToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderS3Credentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_key_id_ref: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderS3CredentialsAccessKeyIdRefToHclTerraform(struct!.accessKeyIdRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderS3CredentialsAccessKeyIdRef",
    },
    secret_key_ref: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderS3CredentialsSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderS3CredentialsSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderS3CredentialsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderS3Credentials | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessKeyIdRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessKeyIdRef = this._accessKeyIdRef?.internalValue;
    }
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderS3Credentials | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessKeyIdRef.internalValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessKeyIdRef.internalValue = value.accessKeyIdRef;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // access_key_id_ref - computed: false, optional: false, required: true
  private _accessKeyIdRef = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderS3CredentialsAccessKeyIdRefOutputReference(this, "access_key_id_ref");
  public get accessKeyIdRef() {
    return this._accessKeyIdRef;
  }
  public putAccessKeyIdRef(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderS3CredentialsAccessKeyIdRef) {
    this._accessKeyIdRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get accessKeyIdRefInput() {
    return this._accessKeyIdRef.internalValue;
  }

  // secret_key_ref - computed: false, optional: false, required: true
  private _secretKeyRef = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderS3CredentialsSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderS3CredentialsSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderS3 {
  /**
  * Use credentials if you want to use aws credentials from secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#credentials DataK8STemporalIoTemporalClusterV1Beta1Manifest#credentials}
  */
  readonly credentials?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderS3Credentials;
  /**
  * Use Endpoint if you want to use s3-compatible object storage.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#endpoint DataK8STemporalIoTemporalClusterV1Beta1Manifest#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Region is the aws s3 region.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#region DataK8STemporalIoTemporalClusterV1Beta1Manifest#region}
  */
  readonly region: string;
  /**
  * Use RoleName if you want the temporal service account to assume an AWS Identity and Access Management (IAM) role.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#role_name DataK8STemporalIoTemporalClusterV1Beta1Manifest#role_name}
  */
  readonly roleName?: string;
  /**
  * Use s3ForcePathStyle if you want to use s3 path style.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#s3_force_path_style DataK8STemporalIoTemporalClusterV1Beta1Manifest#s3_force_path_style}
  */
  readonly s3ForcePathStyle?: boolean | cdktf.IResolvable;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderS3ToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderS3 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    credentials: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderS3CredentialsToTerraform(struct!.credentials),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    region: cdktf.stringToTerraform(struct!.region),
    role_name: cdktf.stringToTerraform(struct!.roleName),
    s3_force_path_style: cdktf.booleanToTerraform(struct!.s3ForcePathStyle),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderS3ToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderS3 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    credentials: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderS3CredentialsToHclTerraform(struct!.credentials),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderS3Credentials",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role_name: {
      value: cdktf.stringToHclTerraform(struct!.roleName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    s3_force_path_style: {
      value: cdktf.booleanToHclTerraform(struct!.s3ForcePathStyle),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderS3OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderS3 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._credentials?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentials = this._credentials?.internalValue;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._roleName !== undefined) {
      hasAnyValues = true;
      internalValueResult.roleName = this._roleName;
    }
    if (this._s3ForcePathStyle !== undefined) {
      hasAnyValues = true;
      internalValueResult.s3ForcePathStyle = this._s3ForcePathStyle;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderS3 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._credentials.internalValue = undefined;
      this._endpoint = undefined;
      this._region = undefined;
      this._roleName = undefined;
      this._s3ForcePathStyle = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._credentials.internalValue = value.credentials;
      this._endpoint = value.endpoint;
      this._region = value.region;
      this._roleName = value.roleName;
      this._s3ForcePathStyle = value.s3ForcePathStyle;
    }
  }

  // credentials - computed: false, optional: true, required: false
  private _credentials = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderS3CredentialsOutputReference(this, "credentials");
  public get credentials() {
    return this._credentials;
  }
  public putCredentials(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderS3Credentials) {
    this._credentials.internalValue = value;
  }
  public resetCredentials() {
    this._credentials.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsInput() {
    return this._credentials.internalValue;
  }

  // endpoint - computed: false, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // region - computed: false, optional: false, required: true
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // role_name - computed: false, optional: true, required: false
  private _roleName?: string; 
  public get roleName() {
    return this.getStringAttribute('role_name');
  }
  public set roleName(value: string) {
    this._roleName = value;
  }
  public resetRoleName() {
    this._roleName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleNameInput() {
    return this._roleName;
  }

  // s3_force_path_style - computed: false, optional: true, required: false
  private _s3ForcePathStyle?: boolean | cdktf.IResolvable; 
  public get s3ForcePathStyle() {
    return this.getBooleanAttribute('s3_force_path_style');
  }
  public set s3ForcePathStyle(value: boolean | cdktf.IResolvable) {
    this._s3ForcePathStyle = value;
  }
  public resetS3ForcePathStyle() {
    this._s3ForcePathStyle = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get s3ForcePathStyleInput() {
    return this._s3ForcePathStyle;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProvider {
  /**
  * FilestoreArchiver is the file store archival provider configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#filestore DataK8STemporalIoTemporalClusterV1Beta1Manifest#filestore}
  */
  readonly filestore?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderFilestore;
  /**
  * GCSArchiver is the GCS archival provider configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#gcs DataK8STemporalIoTemporalClusterV1Beta1Manifest#gcs}
  */
  readonly gcs?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderGcs;
  /**
  * S3Archiver is the S3 archival provider configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#s3 DataK8STemporalIoTemporalClusterV1Beta1Manifest#s3}
  */
  readonly s3?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderS3;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProvider | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    filestore: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderFilestoreToTerraform(struct!.filestore),
    gcs: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderGcsToTerraform(struct!.gcs),
    s3: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderS3ToTerraform(struct!.s3),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProvider | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    filestore: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderFilestoreToHclTerraform(struct!.filestore),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderFilestore",
    },
    gcs: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderGcsToHclTerraform(struct!.gcs),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderGcs",
    },
    s3: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderS3ToHclTerraform(struct!.s3),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderS3",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProvider | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._filestore?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.filestore = this._filestore?.internalValue;
    }
    if (this._gcs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.gcs = this._gcs?.internalValue;
    }
    if (this._s3?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.s3 = this._s3?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProvider | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._filestore.internalValue = undefined;
      this._gcs.internalValue = undefined;
      this._s3.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._filestore.internalValue = value.filestore;
      this._gcs.internalValue = value.gcs;
      this._s3.internalValue = value.s3;
    }
  }

  // filestore - computed: false, optional: true, required: false
  private _filestore = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderFilestoreOutputReference(this, "filestore");
  public get filestore() {
    return this._filestore;
  }
  public putFilestore(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderFilestore) {
    this._filestore.internalValue = value;
  }
  public resetFilestore() {
    this._filestore.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get filestoreInput() {
    return this._filestore.internalValue;
  }

  // gcs - computed: false, optional: true, required: false
  private _gcs = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderGcsOutputReference(this, "gcs");
  public get gcs() {
    return this._gcs;
  }
  public putGcs(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderGcs) {
    this._gcs.internalValue = value;
  }
  public resetGcs() {
    this._gcs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gcsInput() {
    return this._gcs.internalValue;
  }

  // s3 - computed: false, optional: true, required: false
  private _s3 = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderS3OutputReference(this, "s3");
  public get s3() {
    return this._s3;
  }
  public putS3(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderS3) {
    this._s3.internalValue = value;
  }
  public resetS3() {
    this._s3.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get s3Input() {
    return this._s3.internalValue;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalVisibility {
  /**
  * EnableRead allows temporal to read from the archived Event History.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#enable_read DataK8STemporalIoTemporalClusterV1Beta1Manifest#enable_read}
  */
  readonly enableRead: boolean | cdktf.IResolvable;
  /**
  * Enabled defines if the archival is enabled by default for all namespaces or for a particular namespace (depends if it's for a TemporalCluster or a TemporalNamespace).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#enabled DataK8STemporalIoTemporalClusterV1Beta1Manifest#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
  /**
  * Path is ...
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#path DataK8STemporalIoTemporalClusterV1Beta1Manifest#path}
  */
  readonly path: string;
  /**
  * Paused defines if the archival is paused.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#paused DataK8STemporalIoTemporalClusterV1Beta1Manifest#paused}
  */
  readonly paused: boolean | cdktf.IResolvable;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalVisibilityToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalVisibility | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enable_read: cdktf.booleanToTerraform(struct!.enableRead),
    enabled: cdktf.booleanToTerraform(struct!.enabled),
    path: cdktf.stringToTerraform(struct!.path),
    paused: cdktf.booleanToTerraform(struct!.paused),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalVisibilityToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalVisibility | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enable_read: {
      value: cdktf.booleanToHclTerraform(struct!.enableRead),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    paused: {
      value: cdktf.booleanToHclTerraform(struct!.paused),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalVisibilityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalVisibility | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enableRead !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableRead = this._enableRead;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._paused !== undefined) {
      hasAnyValues = true;
      internalValueResult.paused = this._paused;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalVisibility | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enableRead = undefined;
      this._enabled = undefined;
      this._path = undefined;
      this._paused = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enableRead = value.enableRead;
      this._enabled = value.enabled;
      this._path = value.path;
      this._paused = value.paused;
    }
  }

  // enable_read - computed: false, optional: false, required: true
  private _enableRead?: boolean | cdktf.IResolvable; 
  public get enableRead() {
    return this.getBooleanAttribute('enable_read');
  }
  public set enableRead(value: boolean | cdktf.IResolvable) {
    this._enableRead = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enableReadInput() {
    return this._enableRead;
  }

  // enabled - computed: false, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // paused - computed: false, optional: false, required: true
  private _paused?: boolean | cdktf.IResolvable; 
  public get paused() {
    return this.getBooleanAttribute('paused');
  }
  public set paused(value: boolean | cdktf.IResolvable) {
    this._paused = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pausedInput() {
    return this._paused;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchival {
  /**
  * Enabled defines if the archival is enabled for the cluster.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#enabled DataK8STemporalIoTemporalClusterV1Beta1Manifest#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
  /**
  * History is the default config for the history archival.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#history DataK8STemporalIoTemporalClusterV1Beta1Manifest#history}
  */
  readonly history?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalHistory;
  /**
  * Provider defines the archival provider for the cluster. The same provider is used for both history and visibility, but some config can be changed using spec.archival.[history|visibility].config.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#provider DataK8STemporalIoTemporalClusterV1Beta1Manifest#provider}
  */
  readonly provider?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProvider;
  /**
  * Visibility is the default config for visibility archival.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#visibility DataK8STemporalIoTemporalClusterV1Beta1Manifest#visibility}
  */
  readonly visibility?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalVisibility;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchival | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.booleanToTerraform(struct!.enabled),
    history: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalHistoryToTerraform(struct!.history),
    provider: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderToTerraform(struct!.provider),
    visibility: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalVisibilityToTerraform(struct!.visibility),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchival | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    history: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalHistoryToHclTerraform(struct!.history),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalHistory",
    },
    provider: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderToHclTerraform(struct!.provider),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProvider",
    },
    visibility: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalVisibilityToHclTerraform(struct!.visibility),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalVisibility",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchival | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._history?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.history = this._history?.internalValue;
    }
    if (this._provider?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.provider = this._provider?.internalValue;
    }
    if (this._visibility?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.visibility = this._visibility?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchival | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._history.internalValue = undefined;
      this._provider.internalValue = undefined;
      this._visibility.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._history.internalValue = value.history;
      this._provider.internalValue = value.provider;
      this._visibility.internalValue = value.visibility;
    }
  }

  // enabled - computed: false, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // history - computed: false, optional: true, required: false
  private _history = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalHistoryOutputReference(this, "history");
  public get history() {
    return this._history;
  }
  public putHistory(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalHistory) {
    this._history.internalValue = value;
  }
  public resetHistory() {
    this._history.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get historyInput() {
    return this._history.internalValue;
  }

  // provider - computed: false, optional: true, required: false
  private _provider = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProviderOutputReference(this, "provider");
  public get provider() {
    return this._provider;
  }
  public putProvider(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalProvider) {
    this._provider.internalValue = value;
  }
  public resetProvider() {
    this._provider.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get providerInput() {
    return this._provider.internalValue;
  }

  // visibility - computed: false, optional: true, required: false
  private _visibility = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalVisibilityOutputReference(this, "visibility");
  public get visibility() {
    return this._visibility;
  }
  public putVisibility(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalVisibility) {
    this._visibility.internalValue = value;
  }
  public resetVisibility() {
    this._visibility.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get visibilityInput() {
    return this._visibility.internalValue;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAuthorizationJwtKeyProvider {
  /**
  * KeySourceURIs is a list of URIs where the JWT signing keys can be obtained. These URIs are used by the authorization system to fetch the public keys necessary for validating JWT tokens.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#key_source_ur_is DataK8STemporalIoTemporalClusterV1Beta1Manifest#key_source_ur_is}
  */
  readonly keySourceUrIs?: string[];
  /**
  * RefreshInterval defines the time interval at which temporal should refresh the JWT signing keys from the specified URIs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#refresh_interval DataK8STemporalIoTemporalClusterV1Beta1Manifest#refresh_interval}
  */
  readonly refreshInterval?: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAuthorizationJwtKeyProviderToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAuthorizationJwtKeyProvider | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key_source_ur_is: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.keySourceUrIs),
    refresh_interval: cdktf.stringToTerraform(struct!.refreshInterval),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAuthorizationJwtKeyProviderToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAuthorizationJwtKeyProvider | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key_source_ur_is: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.keySourceUrIs),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    refresh_interval: {
      value: cdktf.stringToHclTerraform(struct!.refreshInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAuthorizationJwtKeyProviderOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAuthorizationJwtKeyProvider | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._keySourceUrIs !== undefined) {
      hasAnyValues = true;
      internalValueResult.keySourceUrIs = this._keySourceUrIs;
    }
    if (this._refreshInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.refreshInterval = this._refreshInterval;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAuthorizationJwtKeyProvider | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._keySourceUrIs = undefined;
      this._refreshInterval = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._keySourceUrIs = value.keySourceUrIs;
      this._refreshInterval = value.refreshInterval;
    }
  }

  // key_source_ur_is - computed: false, optional: true, required: false
  private _keySourceUrIs?: string[]; 
  public get keySourceUrIs() {
    return this.getListAttribute('key_source_ur_is');
  }
  public set keySourceUrIs(value: string[]) {
    this._keySourceUrIs = value;
  }
  public resetKeySourceUrIs() {
    this._keySourceUrIs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keySourceUrIsInput() {
    return this._keySourceUrIs;
  }

  // refresh_interval - computed: false, optional: true, required: false
  private _refreshInterval?: string; 
  public get refreshInterval() {
    return this.getStringAttribute('refresh_interval');
  }
  public set refreshInterval(value: string) {
    this._refreshInterval = value;
  }
  public resetRefreshInterval() {
    this._refreshInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get refreshIntervalInput() {
    return this._refreshInterval;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAuthorization {
  /**
  * Authorizer defines the authorization mechanism to be used. It can be left as an empty string to use a no-operation authorizer (noopAuthorizer), or set to 'default' to use the temporal's default authorizer (defaultAuthorizer).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#authorizer DataK8STemporalIoTemporalClusterV1Beta1Manifest#authorizer}
  */
  readonly authorizer?: string;
  /**
  * ClaimMapper specifies the claim mapping mechanism used for handling JWT claims. Similar to the Authorizer, it can be left as an empty string to use a no-operation claim mapper (noopClaimMapper), or set to 'default' to use the default JWT claim mapper (defaultJWTClaimMapper).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#claim_mapper DataK8STemporalIoTemporalClusterV1Beta1Manifest#claim_mapper}
  */
  readonly claimMapper?: string;
  /**
  * JWTKeyProvider specifies the signing key provider used for validating JWT tokens.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#jwt_key_provider DataK8STemporalIoTemporalClusterV1Beta1Manifest#jwt_key_provider}
  */
  readonly jwtKeyProvider?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAuthorizationJwtKeyProvider;
  /**
  * PermissionsClaimName is the name of the claim within the JWT token that contains the user's permissions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#permissions_claim_name DataK8STemporalIoTemporalClusterV1Beta1Manifest#permissions_claim_name}
  */
  readonly permissionsClaimName?: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAuthorizationToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAuthorization | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    authorizer: cdktf.stringToTerraform(struct!.authorizer),
    claim_mapper: cdktf.stringToTerraform(struct!.claimMapper),
    jwt_key_provider: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAuthorizationJwtKeyProviderToTerraform(struct!.jwtKeyProvider),
    permissions_claim_name: cdktf.stringToTerraform(struct!.permissionsClaimName),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAuthorizationToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAuthorization | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    authorizer: {
      value: cdktf.stringToHclTerraform(struct!.authorizer),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    claim_mapper: {
      value: cdktf.stringToHclTerraform(struct!.claimMapper),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    jwt_key_provider: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAuthorizationJwtKeyProviderToHclTerraform(struct!.jwtKeyProvider),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAuthorizationJwtKeyProvider",
    },
    permissions_claim_name: {
      value: cdktf.stringToHclTerraform(struct!.permissionsClaimName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAuthorizationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAuthorization | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authorizer !== undefined) {
      hasAnyValues = true;
      internalValueResult.authorizer = this._authorizer;
    }
    if (this._claimMapper !== undefined) {
      hasAnyValues = true;
      internalValueResult.claimMapper = this._claimMapper;
    }
    if (this._jwtKeyProvider?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.jwtKeyProvider = this._jwtKeyProvider?.internalValue;
    }
    if (this._permissionsClaimName !== undefined) {
      hasAnyValues = true;
      internalValueResult.permissionsClaimName = this._permissionsClaimName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAuthorization | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authorizer = undefined;
      this._claimMapper = undefined;
      this._jwtKeyProvider.internalValue = undefined;
      this._permissionsClaimName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authorizer = value.authorizer;
      this._claimMapper = value.claimMapper;
      this._jwtKeyProvider.internalValue = value.jwtKeyProvider;
      this._permissionsClaimName = value.permissionsClaimName;
    }
  }

  // authorizer - computed: false, optional: true, required: false
  private _authorizer?: string; 
  public get authorizer() {
    return this.getStringAttribute('authorizer');
  }
  public set authorizer(value: string) {
    this._authorizer = value;
  }
  public resetAuthorizer() {
    this._authorizer = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authorizerInput() {
    return this._authorizer;
  }

  // claim_mapper - computed: false, optional: true, required: false
  private _claimMapper?: string; 
  public get claimMapper() {
    return this.getStringAttribute('claim_mapper');
  }
  public set claimMapper(value: string) {
    this._claimMapper = value;
  }
  public resetClaimMapper() {
    this._claimMapper = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get claimMapperInput() {
    return this._claimMapper;
  }

  // jwt_key_provider - computed: false, optional: true, required: false
  private _jwtKeyProvider = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAuthorizationJwtKeyProviderOutputReference(this, "jwt_key_provider");
  public get jwtKeyProvider() {
    return this._jwtKeyProvider;
  }
  public putJwtKeyProvider(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAuthorizationJwtKeyProvider) {
    this._jwtKeyProvider.internalValue = value;
  }
  public resetJwtKeyProvider() {
    this._jwtKeyProvider.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jwtKeyProviderInput() {
    return this._jwtKeyProvider.internalValue;
  }

  // permissions_claim_name - computed: false, optional: true, required: false
  private _permissionsClaimName?: string; 
  public get permissionsClaimName() {
    return this.getStringAttribute('permissions_claim_name');
  }
  public set permissionsClaimName(value: string) {
    this._permissionsClaimName = value;
  }
  public resetPermissionsClaimName() {
    this._permissionsClaimName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get permissionsClaimNameInput() {
    return this._permissionsClaimName;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecDynamicConfig {
  /**
  * PollInterval defines how often the config should be updated by checking provided values. Defaults to 10s.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#poll_interval DataK8STemporalIoTemporalClusterV1Beta1Manifest#poll_interval}
  */
  readonly pollInterval?: string;
  /**
  * Values contains all dynamic config keys and their constrained values.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#values DataK8STemporalIoTemporalClusterV1Beta1Manifest#values}
  */
  readonly values: { [key: string]: string };
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecDynamicConfigToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecDynamicConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    poll_interval: cdktf.stringToTerraform(struct!.pollInterval),
    values: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.values),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecDynamicConfigToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecDynamicConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    poll_interval: {
      value: cdktf.stringToHclTerraform(struct!.pollInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.values),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecDynamicConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecDynamicConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._pollInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.pollInterval = this._pollInterval;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecDynamicConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._pollInterval = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._pollInterval = value.pollInterval;
      this._values = value.values;
    }
  }

  // poll_interval - computed: false, optional: true, required: false
  private _pollInterval?: string; 
  public get pollInterval() {
    return this.getStringAttribute('poll_interval');
  }
  public set pollInterval(value: string) {
    this._pollInterval = value;
  }
  public resetPollInterval() {
    this._pollInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pollIntervalInput() {
    return this._pollInterval;
  }

  // values - computed: false, optional: false, required: true
  private _values?: { [key: string]: string }; 
  public get values() {
    return this.getStringMapAttribute('values');
  }
  public set values(value: { [key: string]: string }) {
    this._values = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecImagePullSecrets {
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#name DataK8STemporalIoTemporalClusterV1Beta1Manifest#name}
  */
  readonly name?: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecImagePullSecretsToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecImagePullSecrets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecImagePullSecretsToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecImagePullSecrets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecImagePullSecretsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecImagePullSecrets | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecImagePullSecrets | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecImagePullSecretsList extends cdktf.ComplexList {
  public internalValue? : DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecImagePullSecrets[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecImagePullSecretsOutputReference {
    return new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecImagePullSecretsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecJobResourcesClaims {
  /**
  * Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#name DataK8STemporalIoTemporalClusterV1Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * Request is the name chosen for a request in the referenced claim. If empty, everything from the claim is made available, otherwise only the result of this request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#request DataK8STemporalIoTemporalClusterV1Beta1Manifest#request}
  */
  readonly request?: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecJobResourcesClaimsToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecJobResourcesClaims | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    request: cdktf.stringToTerraform(struct!.request),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecJobResourcesClaimsToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecJobResourcesClaims | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request: {
      value: cdktf.stringToHclTerraform(struct!.request),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecJobResourcesClaimsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecJobResourcesClaims | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._request !== undefined) {
      hasAnyValues = true;
      internalValueResult.request = this._request;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecJobResourcesClaims | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._request = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._request = value.request;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // request - computed: false, optional: true, required: false
  private _request?: string; 
  public get request() {
    return this.getStringAttribute('request');
  }
  public set request(value: string) {
    this._request = value;
  }
  public resetRequest() {
    this._request = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestInput() {
    return this._request;
  }
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecJobResourcesClaimsList extends cdktf.ComplexList {
  public internalValue? : DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecJobResourcesClaims[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecJobResourcesClaimsOutputReference {
    return new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecJobResourcesClaimsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecJobResources {
  /**
  * Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container. This is an alpha field and requires enabling the DynamicResourceAllocation feature gate. This field is immutable. It can only be set for containers.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#claims DataK8STemporalIoTemporalClusterV1Beta1Manifest#claims}
  */
  readonly claims?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecJobResourcesClaims[] | cdktf.IResolvable;
  /**
  * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#limits DataK8STemporalIoTemporalClusterV1Beta1Manifest#limits}
  */
  readonly limits?: { [key: string]: string };
  /**
  * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. Requests cannot exceed Limits. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#requests DataK8STemporalIoTemporalClusterV1Beta1Manifest#requests}
  */
  readonly requests?: { [key: string]: string };
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecJobResourcesToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecJobResources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    claims: cdktf.listMapper(dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecJobResourcesClaimsToTerraform, false)(struct!.claims),
    limits: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.limits),
    requests: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.requests),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecJobResourcesToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecJobResources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    claims: {
      value: cdktf.listMapperHcl(dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecJobResourcesClaimsToHclTerraform, false)(struct!.claims),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecJobResourcesClaimsList",
    },
    limits: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.limits),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    requests: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.requests),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecJobResourcesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecJobResources | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._claims?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.claims = this._claims?.internalValue;
    }
    if (this._limits !== undefined) {
      hasAnyValues = true;
      internalValueResult.limits = this._limits;
    }
    if (this._requests !== undefined) {
      hasAnyValues = true;
      internalValueResult.requests = this._requests;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecJobResources | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._claims.internalValue = undefined;
      this._limits = undefined;
      this._requests = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._claims.internalValue = value.claims;
      this._limits = value.limits;
      this._requests = value.requests;
    }
  }

  // claims - computed: false, optional: true, required: false
  private _claims = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecJobResourcesClaimsList(this, "claims", false);
  public get claims() {
    return this._claims;
  }
  public putClaims(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecJobResourcesClaims[] | cdktf.IResolvable) {
    this._claims.internalValue = value;
  }
  public resetClaims() {
    this._claims.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get claimsInput() {
    return this._claims.internalValue;
  }

  // limits - computed: false, optional: true, required: false
  private _limits?: { [key: string]: string }; 
  public get limits() {
    return this.getStringMapAttribute('limits');
  }
  public set limits(value: { [key: string]: string }) {
    this._limits = value;
  }
  public resetLimits() {
    this._limits = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get limitsInput() {
    return this._limits;
  }

  // requests - computed: false, optional: true, required: false
  private _requests?: { [key: string]: string }; 
  public get requests() {
    return this.getStringMapAttribute('requests');
  }
  public set requests(value: { [key: string]: string }) {
    this._requests = value;
  }
  public resetRequests() {
    this._requests = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestsInput() {
    return this._requests;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecLog {
  /**
  * Development determines whether the logger is run in Development (== Test) or in Production mode. Default is Production. Production-stage disables panics from DPanic logging.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#development DataK8STemporalIoTemporalClusterV1Beta1Manifest#development}
  */
  readonly development?: boolean | cdktf.IResolvable;
  /**
  * Format determines the format of each log file printed to the output. Use 'console' if you want stack traces to appear on multiple lines.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#format DataK8STemporalIoTemporalClusterV1Beta1Manifest#format}
  */
  readonly format?: string;
  /**
  * Level is the desired log level; see colocated zap_logger.go::parseZapLevel()
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#level DataK8STemporalIoTemporalClusterV1Beta1Manifest#level}
  */
  readonly level?: string;
  /**
  * OutputFile is the path to the log output file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#output_file DataK8STemporalIoTemporalClusterV1Beta1Manifest#output_file}
  */
  readonly outputFile?: string;
  /**
  * Stdout is true if the output needs to goto standard out; default is stderr.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#stdout DataK8STemporalIoTemporalClusterV1Beta1Manifest#stdout}
  */
  readonly stdout?: boolean | cdktf.IResolvable;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecLogToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecLog | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    development: cdktf.booleanToTerraform(struct!.development),
    format: cdktf.stringToTerraform(struct!.format),
    level: cdktf.stringToTerraform(struct!.level),
    output_file: cdktf.stringToTerraform(struct!.outputFile),
    stdout: cdktf.booleanToTerraform(struct!.stdout),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecLogToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecLog | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    development: {
      value: cdktf.booleanToHclTerraform(struct!.development),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    level: {
      value: cdktf.stringToHclTerraform(struct!.level),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    output_file: {
      value: cdktf.stringToHclTerraform(struct!.outputFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    stdout: {
      value: cdktf.booleanToHclTerraform(struct!.stdout),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecLogOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecLog | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._development !== undefined) {
      hasAnyValues = true;
      internalValueResult.development = this._development;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._level !== undefined) {
      hasAnyValues = true;
      internalValueResult.level = this._level;
    }
    if (this._outputFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.outputFile = this._outputFile;
    }
    if (this._stdout !== undefined) {
      hasAnyValues = true;
      internalValueResult.stdout = this._stdout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecLog | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._development = undefined;
      this._format = undefined;
      this._level = undefined;
      this._outputFile = undefined;
      this._stdout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._development = value.development;
      this._format = value.format;
      this._level = value.level;
      this._outputFile = value.outputFile;
      this._stdout = value.stdout;
    }
  }

  // development - computed: false, optional: true, required: false
  private _development?: boolean | cdktf.IResolvable; 
  public get development() {
    return this.getBooleanAttribute('development');
  }
  public set development(value: boolean | cdktf.IResolvable) {
    this._development = value;
  }
  public resetDevelopment() {
    this._development = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get developmentInput() {
    return this._development;
  }

  // format - computed: false, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // level - computed: false, optional: true, required: false
  private _level?: string; 
  public get level() {
    return this.getStringAttribute('level');
  }
  public set level(value: string) {
    this._level = value;
  }
  public resetLevel() {
    this._level = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get levelInput() {
    return this._level;
  }

  // output_file - computed: false, optional: true, required: false
  private _outputFile?: string; 
  public get outputFile() {
    return this.getStringAttribute('output_file');
  }
  public set outputFile(value: string) {
    this._outputFile = value;
  }
  public resetOutputFile() {
    this._outputFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get outputFileInput() {
    return this._outputFile;
  }

  // stdout - computed: false, optional: true, required: false
  private _stdout?: boolean | cdktf.IResolvable; 
  public get stdout() {
    return this.getBooleanAttribute('stdout');
  }
  public set stdout(value: boolean | cdktf.IResolvable) {
    this._stdout = value;
  }
  public resetStdout() {
    this._stdout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stdoutInput() {
    return this._stdout;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMTlsCertificatesDuration {
  /**
  * ClientCertificates is the 'duration' (i.e. lifetime) of the client certificates. It defaults to 1 year.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#client_certificates DataK8STemporalIoTemporalClusterV1Beta1Manifest#client_certificates}
  */
  readonly clientCertificates?: string;
  /**
  * FrontendCertificate is the 'duration' (i.e. lifetime) of the frontend certificate. It defaults to 1 year.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#frontend_certificate DataK8STemporalIoTemporalClusterV1Beta1Manifest#frontend_certificate}
  */
  readonly frontendCertificate?: string;
  /**
  * IntermediateCACertificates is the 'duration' (i.e. lifetime) of the intermediate CAs Certificates. It defaults to 5 years.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#intermediate_c_as_certificates DataK8STemporalIoTemporalClusterV1Beta1Manifest#intermediate_c_as_certificates}
  */
  readonly intermediateCAsCertificates?: string;
  /**
  * InternodeCertificate is the 'duration' (i.e. lifetime) of the internode certificate. It defaults to 1 year.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#internode_certificate DataK8STemporalIoTemporalClusterV1Beta1Manifest#internode_certificate}
  */
  readonly internodeCertificate?: string;
  /**
  * RootCACertificate is the 'duration' (i.e. lifetime) of the Root CA Certificate. It defaults to 10 years.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#root_ca_certificate DataK8STemporalIoTemporalClusterV1Beta1Manifest#root_ca_certificate}
  */
  readonly rootCaCertificate?: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMTlsCertificatesDurationToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMTlsCertificatesDuration | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    client_certificates: cdktf.stringToTerraform(struct!.clientCertificates),
    frontend_certificate: cdktf.stringToTerraform(struct!.frontendCertificate),
    intermediate_c_as_certificates: cdktf.stringToTerraform(struct!.intermediateCAsCertificates),
    internode_certificate: cdktf.stringToTerraform(struct!.internodeCertificate),
    root_ca_certificate: cdktf.stringToTerraform(struct!.rootCaCertificate),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMTlsCertificatesDurationToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMTlsCertificatesDuration | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    client_certificates: {
      value: cdktf.stringToHclTerraform(struct!.clientCertificates),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    frontend_certificate: {
      value: cdktf.stringToHclTerraform(struct!.frontendCertificate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    intermediate_c_as_certificates: {
      value: cdktf.stringToHclTerraform(struct!.intermediateCAsCertificates),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    internode_certificate: {
      value: cdktf.stringToHclTerraform(struct!.internodeCertificate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    root_ca_certificate: {
      value: cdktf.stringToHclTerraform(struct!.rootCaCertificate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMTlsCertificatesDurationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMTlsCertificatesDuration | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clientCertificates !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientCertificates = this._clientCertificates;
    }
    if (this._frontendCertificate !== undefined) {
      hasAnyValues = true;
      internalValueResult.frontendCertificate = this._frontendCertificate;
    }
    if (this._intermediateCAsCertificates !== undefined) {
      hasAnyValues = true;
      internalValueResult.intermediateCAsCertificates = this._intermediateCAsCertificates;
    }
    if (this._internodeCertificate !== undefined) {
      hasAnyValues = true;
      internalValueResult.internodeCertificate = this._internodeCertificate;
    }
    if (this._rootCaCertificate !== undefined) {
      hasAnyValues = true;
      internalValueResult.rootCaCertificate = this._rootCaCertificate;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMTlsCertificatesDuration | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clientCertificates = undefined;
      this._frontendCertificate = undefined;
      this._intermediateCAsCertificates = undefined;
      this._internodeCertificate = undefined;
      this._rootCaCertificate = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clientCertificates = value.clientCertificates;
      this._frontendCertificate = value.frontendCertificate;
      this._intermediateCAsCertificates = value.intermediateCAsCertificates;
      this._internodeCertificate = value.internodeCertificate;
      this._rootCaCertificate = value.rootCaCertificate;
    }
  }

  // client_certificates - computed: false, optional: true, required: false
  private _clientCertificates?: string; 
  public get clientCertificates() {
    return this.getStringAttribute('client_certificates');
  }
  public set clientCertificates(value: string) {
    this._clientCertificates = value;
  }
  public resetClientCertificates() {
    this._clientCertificates = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientCertificatesInput() {
    return this._clientCertificates;
  }

  // frontend_certificate - computed: false, optional: true, required: false
  private _frontendCertificate?: string; 
  public get frontendCertificate() {
    return this.getStringAttribute('frontend_certificate');
  }
  public set frontendCertificate(value: string) {
    this._frontendCertificate = value;
  }
  public resetFrontendCertificate() {
    this._frontendCertificate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get frontendCertificateInput() {
    return this._frontendCertificate;
  }

  // intermediate_c_as_certificates - computed: false, optional: true, required: false
  private _intermediateCAsCertificates?: string; 
  public get intermediateCAsCertificates() {
    return this.getStringAttribute('intermediate_c_as_certificates');
  }
  public set intermediateCAsCertificates(value: string) {
    this._intermediateCAsCertificates = value;
  }
  public resetIntermediateCAsCertificates() {
    this._intermediateCAsCertificates = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get intermediateCAsCertificatesInput() {
    return this._intermediateCAsCertificates;
  }

  // internode_certificate - computed: false, optional: true, required: false
  private _internodeCertificate?: string; 
  public get internodeCertificate() {
    return this.getStringAttribute('internode_certificate');
  }
  public set internodeCertificate(value: string) {
    this._internodeCertificate = value;
  }
  public resetInternodeCertificate() {
    this._internodeCertificate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get internodeCertificateInput() {
    return this._internodeCertificate;
  }

  // root_ca_certificate - computed: false, optional: true, required: false
  private _rootCaCertificate?: string; 
  public get rootCaCertificate() {
    return this.getStringAttribute('root_ca_certificate');
  }
  public set rootCaCertificate(value: string) {
    this._rootCaCertificate = value;
  }
  public resetRootCaCertificate() {
    this._rootCaCertificate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rootCaCertificateInput() {
    return this._rootCaCertificate;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMTlsFrontend {
  /**
  * Enabled defines if the operator should enable mTLS for cluster's public endpoints.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#enabled DataK8STemporalIoTemporalClusterV1Beta1Manifest#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
  /**
  * ExtraDNSNames is a list of additional DNS names associated with the TemporalCluster. These DNS names can be used for accessing the TemporalCluster from external services. The DNS names specified here will be added to the TLS certificate for secure communication.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#extra_dns_names DataK8STemporalIoTemporalClusterV1Beta1Manifest#extra_dns_names}
  */
  readonly extraDnsNames?: string[];
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMTlsFrontendToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMTlsFrontend | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.booleanToTerraform(struct!.enabled),
    extra_dns_names: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.extraDnsNames),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMTlsFrontendToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMTlsFrontend | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    extra_dns_names: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.extraDnsNames),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMTlsFrontendOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMTlsFrontend | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._extraDnsNames !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraDnsNames = this._extraDnsNames;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMTlsFrontend | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._extraDnsNames = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._extraDnsNames = value.extraDnsNames;
    }
  }

  // enabled - computed: false, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // extra_dns_names - computed: false, optional: true, required: false
  private _extraDnsNames?: string[]; 
  public get extraDnsNames() {
    return this.getListAttribute('extra_dns_names');
  }
  public set extraDnsNames(value: string[]) {
    this._extraDnsNames = value;
  }
  public resetExtraDnsNames() {
    this._extraDnsNames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraDnsNamesInput() {
    return this._extraDnsNames;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMTlsInternode {
  /**
  * Enabled defines if the operator should enable mTLS for network between cluster nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#enabled DataK8STemporalIoTemporalClusterV1Beta1Manifest#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMTlsInternodeToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMTlsInternode | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.booleanToTerraform(struct!.enabled),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMTlsInternodeToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMTlsInternode | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMTlsInternodeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMTlsInternode | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMTlsInternode | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
    }
  }

  // enabled - computed: false, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMTls {
  /**
  * CertificatesDuration allows configuration of maximum certificates lifetime. Useless if mTLS provider is not cert-manager.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#certificates_duration DataK8STemporalIoTemporalClusterV1Beta1Manifest#certificates_duration}
  */
  readonly certificatesDuration?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMTlsCertificatesDuration;
  /**
  * Frontend allows configuration of the frontend's public endpoint traffic encryption. Useless if mTLS provider is not cert-manager.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#frontend DataK8STemporalIoTemporalClusterV1Beta1Manifest#frontend}
  */
  readonly frontend?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMTlsFrontend;
  /**
  * Internode allows configuration of the internode traffic encryption. Useless if mTLS provider is not cert-manager.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#internode DataK8STemporalIoTemporalClusterV1Beta1Manifest#internode}
  */
  readonly internode?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMTlsInternode;
  /**
  * Provider defines the tool used to manage mTLS certificates.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#provider DataK8STemporalIoTemporalClusterV1Beta1Manifest#provider}
  */
  readonly provider?: string;
  /**
  * RefreshInterval defines interval between refreshes of certificates in the cluster components. Defaults to 1 hour. Useless if mTLS provider is not cert-manager.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#refresh_interval DataK8STemporalIoTemporalClusterV1Beta1Manifest#refresh_interval}
  */
  readonly refreshInterval?: string;
  /**
  * RenewBefore is defines how long before the currently issued certificate's expiry cert-manager should renew the certificate. The default is 2/3 of the issued certificate's duration. Minimum accepted value is 5 minutes. Useless if mTLS provider is not cert-manager.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#renew_before DataK8STemporalIoTemporalClusterV1Beta1Manifest#renew_before}
  */
  readonly renewBefore?: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMTlsToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    certificates_duration: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMTlsCertificatesDurationToTerraform(struct!.certificatesDuration),
    frontend: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMTlsFrontendToTerraform(struct!.frontend),
    internode: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMTlsInternodeToTerraform(struct!.internode),
    provider: cdktf.stringToTerraform(struct!.provider),
    refresh_interval: cdktf.stringToTerraform(struct!.refreshInterval),
    renew_before: cdktf.stringToTerraform(struct!.renewBefore),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMTlsToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    certificates_duration: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMTlsCertificatesDurationToHclTerraform(struct!.certificatesDuration),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMTlsCertificatesDuration",
    },
    frontend: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMTlsFrontendToHclTerraform(struct!.frontend),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMTlsFrontend",
    },
    internode: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMTlsInternodeToHclTerraform(struct!.internode),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMTlsInternode",
    },
    provider: {
      value: cdktf.stringToHclTerraform(struct!.provider),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    refresh_interval: {
      value: cdktf.stringToHclTerraform(struct!.refreshInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    renew_before: {
      value: cdktf.stringToHclTerraform(struct!.renewBefore),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._certificatesDuration?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificatesDuration = this._certificatesDuration?.internalValue;
    }
    if (this._frontend?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.frontend = this._frontend?.internalValue;
    }
    if (this._internode?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.internode = this._internode?.internalValue;
    }
    if (this._provider !== undefined) {
      hasAnyValues = true;
      internalValueResult.provider = this._provider;
    }
    if (this._refreshInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.refreshInterval = this._refreshInterval;
    }
    if (this._renewBefore !== undefined) {
      hasAnyValues = true;
      internalValueResult.renewBefore = this._renewBefore;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._certificatesDuration.internalValue = undefined;
      this._frontend.internalValue = undefined;
      this._internode.internalValue = undefined;
      this._provider = undefined;
      this._refreshInterval = undefined;
      this._renewBefore = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._certificatesDuration.internalValue = value.certificatesDuration;
      this._frontend.internalValue = value.frontend;
      this._internode.internalValue = value.internode;
      this._provider = value.provider;
      this._refreshInterval = value.refreshInterval;
      this._renewBefore = value.renewBefore;
    }
  }

  // certificates_duration - computed: false, optional: true, required: false
  private _certificatesDuration = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMTlsCertificatesDurationOutputReference(this, "certificates_duration");
  public get certificatesDuration() {
    return this._certificatesDuration;
  }
  public putCertificatesDuration(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMTlsCertificatesDuration) {
    this._certificatesDuration.internalValue = value;
  }
  public resetCertificatesDuration() {
    this._certificatesDuration.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificatesDurationInput() {
    return this._certificatesDuration.internalValue;
  }

  // frontend - computed: false, optional: true, required: false
  private _frontend = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMTlsFrontendOutputReference(this, "frontend");
  public get frontend() {
    return this._frontend;
  }
  public putFrontend(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMTlsFrontend) {
    this._frontend.internalValue = value;
  }
  public resetFrontend() {
    this._frontend.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get frontendInput() {
    return this._frontend.internalValue;
  }

  // internode - computed: false, optional: true, required: false
  private _internode = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMTlsInternodeOutputReference(this, "internode");
  public get internode() {
    return this._internode;
  }
  public putInternode(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMTlsInternode) {
    this._internode.internalValue = value;
  }
  public resetInternode() {
    this._internode.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get internodeInput() {
    return this._internode.internalValue;
  }

  // provider - computed: false, optional: true, required: false
  private _provider?: string; 
  public get provider() {
    return this.getStringAttribute('provider');
  }
  public set provider(value: string) {
    this._provider = value;
  }
  public resetProvider() {
    this._provider = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get providerInput() {
    return this._provider;
  }

  // refresh_interval - computed: false, optional: true, required: false
  private _refreshInterval?: string; 
  public get refreshInterval() {
    return this.getStringAttribute('refresh_interval');
  }
  public set refreshInterval(value: string) {
    this._refreshInterval = value;
  }
  public resetRefreshInterval() {
    this._refreshInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get refreshIntervalInput() {
    return this._refreshInterval;
  }

  // renew_before - computed: false, optional: true, required: false
  private _renewBefore?: string; 
  public get renewBefore() {
    return this.getStringAttribute('renew_before');
  }
  public set renewBefore(value: string) {
    this._renewBefore = value;
  }
  public resetRenewBefore() {
    this._renewBefore = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get renewBeforeInput() {
    return this._renewBefore;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorMetricRelabelings {
  /**
  * Action to perform based on the regex matching. 'Uppercase' and 'Lowercase' actions require Prometheus >= v2.36.0. 'DropEqual' and 'KeepEqual' actions require Prometheus >= v2.41.0. Default: 'Replace'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#action DataK8STemporalIoTemporalClusterV1Beta1Manifest#action}
  */
  readonly action?: string;
  /**
  * Modulus to take of the hash of the source label values. Only applicable when the action is 'HashMod'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#modulus DataK8STemporalIoTemporalClusterV1Beta1Manifest#modulus}
  */
  readonly modulus?: number;
  /**
  * Regular expression against which the extracted value is matched.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#regex DataK8STemporalIoTemporalClusterV1Beta1Manifest#regex}
  */
  readonly regex?: string;
  /**
  * Replacement value against which a Replace action is performed if the regular expression matches. Regex capture groups are available.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#replacement DataK8STemporalIoTemporalClusterV1Beta1Manifest#replacement}
  */
  readonly replacement?: string;
  /**
  * Separator is the string between concatenated SourceLabels.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#separator DataK8STemporalIoTemporalClusterV1Beta1Manifest#separator}
  */
  readonly separator?: string;
  /**
  * The source labels select values from existing labels. Their content is concatenated using the configured Separator and matched against the configured regular expression.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#source_labels DataK8STemporalIoTemporalClusterV1Beta1Manifest#source_labels}
  */
  readonly sourceLabels?: string[];
  /**
  * Label to which the resulting string is written in a replacement. It is mandatory for 'Replace', 'HashMod', 'Lowercase', 'Uppercase', 'KeepEqual' and 'DropEqual' actions. Regex capture groups are available.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#target_label DataK8STemporalIoTemporalClusterV1Beta1Manifest#target_label}
  */
  readonly targetLabel?: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorMetricRelabelingsToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorMetricRelabelings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    modulus: cdktf.numberToTerraform(struct!.modulus),
    regex: cdktf.stringToTerraform(struct!.regex),
    replacement: cdktf.stringToTerraform(struct!.replacement),
    separator: cdktf.stringToTerraform(struct!.separator),
    source_labels: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.sourceLabels),
    target_label: cdktf.stringToTerraform(struct!.targetLabel),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorMetricRelabelingsToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorMetricRelabelings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    modulus: {
      value: cdktf.numberToHclTerraform(struct!.modulus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    replacement: {
      value: cdktf.stringToHclTerraform(struct!.replacement),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    separator: {
      value: cdktf.stringToHclTerraform(struct!.separator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    source_labels: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.sourceLabels),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    target_label: {
      value: cdktf.stringToHclTerraform(struct!.targetLabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorMetricRelabelingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorMetricRelabelings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._modulus !== undefined) {
      hasAnyValues = true;
      internalValueResult.modulus = this._modulus;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    if (this._replacement !== undefined) {
      hasAnyValues = true;
      internalValueResult.replacement = this._replacement;
    }
    if (this._separator !== undefined) {
      hasAnyValues = true;
      internalValueResult.separator = this._separator;
    }
    if (this._sourceLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceLabels = this._sourceLabels;
    }
    if (this._targetLabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.targetLabel = this._targetLabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorMetricRelabelings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._modulus = undefined;
      this._regex = undefined;
      this._replacement = undefined;
      this._separator = undefined;
      this._sourceLabels = undefined;
      this._targetLabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._modulus = value.modulus;
      this._regex = value.regex;
      this._replacement = value.replacement;
      this._separator = value.separator;
      this._sourceLabels = value.sourceLabels;
      this._targetLabel = value.targetLabel;
    }
  }

  // action - computed: false, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // modulus - computed: false, optional: true, required: false
  private _modulus?: number; 
  public get modulus() {
    return this.getNumberAttribute('modulus');
  }
  public set modulus(value: number) {
    this._modulus = value;
  }
  public resetModulus() {
    this._modulus = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modulusInput() {
    return this._modulus;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }

  // replacement - computed: false, optional: true, required: false
  private _replacement?: string; 
  public get replacement() {
    return this.getStringAttribute('replacement');
  }
  public set replacement(value: string) {
    this._replacement = value;
  }
  public resetReplacement() {
    this._replacement = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get replacementInput() {
    return this._replacement;
  }

  // separator - computed: false, optional: true, required: false
  private _separator?: string; 
  public get separator() {
    return this.getStringAttribute('separator');
  }
  public set separator(value: string) {
    this._separator = value;
  }
  public resetSeparator() {
    this._separator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get separatorInput() {
    return this._separator;
  }

  // source_labels - computed: false, optional: true, required: false
  private _sourceLabels?: string[]; 
  public get sourceLabels() {
    return this.getListAttribute('source_labels');
  }
  public set sourceLabels(value: string[]) {
    this._sourceLabels = value;
  }
  public resetSourceLabels() {
    this._sourceLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceLabelsInput() {
    return this._sourceLabels;
  }

  // target_label - computed: false, optional: true, required: false
  private _targetLabel?: string; 
  public get targetLabel() {
    return this.getStringAttribute('target_label');
  }
  public set targetLabel(value: string) {
    this._targetLabel = value;
  }
  public resetTargetLabel() {
    this._targetLabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetLabelInput() {
    return this._targetLabel;
  }
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorMetricRelabelingsList extends cdktf.ComplexList {
  public internalValue? : DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorMetricRelabelings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorMetricRelabelingsOutputReference {
    return new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorMetricRelabelingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideAttachMetadata {
  /**
  * When set to true, Prometheus attaches node metadata to the discovered targets. The Prometheus service account must have the 'list' and 'watch' permissions on the 'Nodes' objects.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#node DataK8STemporalIoTemporalClusterV1Beta1Manifest#node}
  */
  readonly nodeAttribute?: boolean | cdktf.IResolvable;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideAttachMetadataToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideAttachMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    node: cdktf.booleanToTerraform(struct!.nodeAttribute),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideAttachMetadataToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideAttachMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    node: {
      value: cdktf.booleanToHclTerraform(struct!.nodeAttribute),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideAttachMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideAttachMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._node !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeAttribute = this._node;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideAttachMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._node = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._node = value.nodeAttribute;
    }
  }

  // node - computed: false, optional: true, required: false
  private _node?: boolean | cdktf.IResolvable; 
  public get nodeAttribute() {
    return this.getBooleanAttribute('node');
  }
  public set nodeAttribute(value: boolean | cdktf.IResolvable) {
    this._node = value;
  }
  public resetNodeAttribute() {
    this._node = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeAttributeInput() {
    return this._node;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsAuthorizationCredentials {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#key DataK8STemporalIoTemporalClusterV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#name DataK8STemporalIoTemporalClusterV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#optional DataK8STemporalIoTemporalClusterV1Beta1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsAuthorizationCredentialsToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsAuthorizationCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsAuthorizationCredentialsToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsAuthorizationCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsAuthorizationCredentialsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsAuthorizationCredentials | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsAuthorizationCredentials | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsAuthorization {
  /**
  * Selects a key of a Secret in the namespace that contains the credentials for authentication.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#credentials DataK8STemporalIoTemporalClusterV1Beta1Manifest#credentials}
  */
  readonly credentials?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsAuthorizationCredentials;
  /**
  * Defines the authentication type. The value is case-insensitive. 'Basic' is not a supported value. Default: 'Bearer'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#type DataK8STemporalIoTemporalClusterV1Beta1Manifest#type}
  */
  readonly type?: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsAuthorizationToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsAuthorization | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    credentials: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsAuthorizationCredentialsToTerraform(struct!.credentials),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsAuthorizationToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsAuthorization | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    credentials: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsAuthorizationCredentialsToHclTerraform(struct!.credentials),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsAuthorizationCredentials",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsAuthorizationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsAuthorization | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._credentials?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentials = this._credentials?.internalValue;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsAuthorization | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._credentials.internalValue = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._credentials.internalValue = value.credentials;
      this._type = value.type;
    }
  }

  // credentials - computed: false, optional: true, required: false
  private _credentials = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsAuthorizationCredentialsOutputReference(this, "credentials");
  public get credentials() {
    return this._credentials;
  }
  public putCredentials(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsAuthorizationCredentials) {
    this._credentials.internalValue = value;
  }
  public resetCredentials() {
    this._credentials.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsInput() {
    return this._credentials.internalValue;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBasicAuthPassword {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#key DataK8STemporalIoTemporalClusterV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#name DataK8STemporalIoTemporalClusterV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#optional DataK8STemporalIoTemporalClusterV1Beta1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBasicAuthPasswordToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBasicAuthPassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBasicAuthPasswordToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBasicAuthPassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBasicAuthPasswordOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBasicAuthPassword | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBasicAuthPassword | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBasicAuthUsername {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#key DataK8STemporalIoTemporalClusterV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#name DataK8STemporalIoTemporalClusterV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#optional DataK8STemporalIoTemporalClusterV1Beta1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBasicAuthUsernameToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBasicAuthUsername | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBasicAuthUsernameToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBasicAuthUsername | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBasicAuthUsernameOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBasicAuthUsername | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBasicAuthUsername | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBasicAuth {
  /**
  * 'password' specifies a key of a Secret containing the password for authentication.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#password DataK8STemporalIoTemporalClusterV1Beta1Manifest#password}
  */
  readonly password?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBasicAuthPassword;
  /**
  * 'username' specifies a key of a Secret containing the username for authentication.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#username DataK8STemporalIoTemporalClusterV1Beta1Manifest#username}
  */
  readonly username?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBasicAuthUsername;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBasicAuthToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBasicAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    password: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBasicAuthPasswordToTerraform(struct!.password),
    username: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBasicAuthUsernameToTerraform(struct!.username),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBasicAuthToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBasicAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    password: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBasicAuthPasswordToHclTerraform(struct!.password),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBasicAuthPassword",
    },
    username: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBasicAuthUsernameToHclTerraform(struct!.username),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBasicAuthUsername",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBasicAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBasicAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._password?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password?.internalValue;
    }
    if (this._username?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBasicAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._password.internalValue = undefined;
      this._username.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._password.internalValue = value.password;
      this._username.internalValue = value.username;
    }
  }

  // password - computed: false, optional: true, required: false
  private _password = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBasicAuthPasswordOutputReference(this, "password");
  public get password() {
    return this._password;
  }
  public putPassword(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBasicAuthPassword) {
    this._password.internalValue = value;
  }
  public resetPassword() {
    this._password.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password.internalValue;
  }

  // username - computed: false, optional: true, required: false
  private _username = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBasicAuthUsernameOutputReference(this, "username");
  public get username() {
    return this._username;
  }
  public putUsername(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBasicAuthUsername) {
    this._username.internalValue = value;
  }
  public resetUsername() {
    this._username.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username.internalValue;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBearerTokenSecret {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#key DataK8STemporalIoTemporalClusterV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#name DataK8STemporalIoTemporalClusterV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#optional DataK8STemporalIoTemporalClusterV1Beta1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBearerTokenSecretToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBearerTokenSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBearerTokenSecretToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBearerTokenSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBearerTokenSecretOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBearerTokenSecret | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBearerTokenSecret | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsMetricRelabelings {
  /**
  * Action to perform based on the regex matching. 'Uppercase' and 'Lowercase' actions require Prometheus >= v2.36.0. 'DropEqual' and 'KeepEqual' actions require Prometheus >= v2.41.0. Default: 'Replace'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#action DataK8STemporalIoTemporalClusterV1Beta1Manifest#action}
  */
  readonly action?: string;
  /**
  * Modulus to take of the hash of the source label values. Only applicable when the action is 'HashMod'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#modulus DataK8STemporalIoTemporalClusterV1Beta1Manifest#modulus}
  */
  readonly modulus?: number;
  /**
  * Regular expression against which the extracted value is matched.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#regex DataK8STemporalIoTemporalClusterV1Beta1Manifest#regex}
  */
  readonly regex?: string;
  /**
  * Replacement value against which a Replace action is performed if the regular expression matches. Regex capture groups are available.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#replacement DataK8STemporalIoTemporalClusterV1Beta1Manifest#replacement}
  */
  readonly replacement?: string;
  /**
  * Separator is the string between concatenated SourceLabels.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#separator DataK8STemporalIoTemporalClusterV1Beta1Manifest#separator}
  */
  readonly separator?: string;
  /**
  * The source labels select values from existing labels. Their content is concatenated using the configured Separator and matched against the configured regular expression.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#source_labels DataK8STemporalIoTemporalClusterV1Beta1Manifest#source_labels}
  */
  readonly sourceLabels?: string[];
  /**
  * Label to which the resulting string is written in a replacement. It is mandatory for 'Replace', 'HashMod', 'Lowercase', 'Uppercase', 'KeepEqual' and 'DropEqual' actions. Regex capture groups are available.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#target_label DataK8STemporalIoTemporalClusterV1Beta1Manifest#target_label}
  */
  readonly targetLabel?: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsMetricRelabelingsToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsMetricRelabelings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    modulus: cdktf.numberToTerraform(struct!.modulus),
    regex: cdktf.stringToTerraform(struct!.regex),
    replacement: cdktf.stringToTerraform(struct!.replacement),
    separator: cdktf.stringToTerraform(struct!.separator),
    source_labels: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.sourceLabels),
    target_label: cdktf.stringToTerraform(struct!.targetLabel),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsMetricRelabelingsToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsMetricRelabelings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    modulus: {
      value: cdktf.numberToHclTerraform(struct!.modulus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    replacement: {
      value: cdktf.stringToHclTerraform(struct!.replacement),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    separator: {
      value: cdktf.stringToHclTerraform(struct!.separator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    source_labels: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.sourceLabels),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    target_label: {
      value: cdktf.stringToHclTerraform(struct!.targetLabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsMetricRelabelingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsMetricRelabelings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._modulus !== undefined) {
      hasAnyValues = true;
      internalValueResult.modulus = this._modulus;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    if (this._replacement !== undefined) {
      hasAnyValues = true;
      internalValueResult.replacement = this._replacement;
    }
    if (this._separator !== undefined) {
      hasAnyValues = true;
      internalValueResult.separator = this._separator;
    }
    if (this._sourceLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceLabels = this._sourceLabels;
    }
    if (this._targetLabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.targetLabel = this._targetLabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsMetricRelabelings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._modulus = undefined;
      this._regex = undefined;
      this._replacement = undefined;
      this._separator = undefined;
      this._sourceLabels = undefined;
      this._targetLabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._modulus = value.modulus;
      this._regex = value.regex;
      this._replacement = value.replacement;
      this._separator = value.separator;
      this._sourceLabels = value.sourceLabels;
      this._targetLabel = value.targetLabel;
    }
  }

  // action - computed: false, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // modulus - computed: false, optional: true, required: false
  private _modulus?: number; 
  public get modulus() {
    return this.getNumberAttribute('modulus');
  }
  public set modulus(value: number) {
    this._modulus = value;
  }
  public resetModulus() {
    this._modulus = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modulusInput() {
    return this._modulus;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }

  // replacement - computed: false, optional: true, required: false
  private _replacement?: string; 
  public get replacement() {
    return this.getStringAttribute('replacement');
  }
  public set replacement(value: string) {
    this._replacement = value;
  }
  public resetReplacement() {
    this._replacement = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get replacementInput() {
    return this._replacement;
  }

  // separator - computed: false, optional: true, required: false
  private _separator?: string; 
  public get separator() {
    return this.getStringAttribute('separator');
  }
  public set separator(value: string) {
    this._separator = value;
  }
  public resetSeparator() {
    this._separator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get separatorInput() {
    return this._separator;
  }

  // source_labels - computed: false, optional: true, required: false
  private _sourceLabels?: string[]; 
  public get sourceLabels() {
    return this.getListAttribute('source_labels');
  }
  public set sourceLabels(value: string[]) {
    this._sourceLabels = value;
  }
  public resetSourceLabels() {
    this._sourceLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceLabelsInput() {
    return this._sourceLabels;
  }

  // target_label - computed: false, optional: true, required: false
  private _targetLabel?: string; 
  public get targetLabel() {
    return this.getStringAttribute('target_label');
  }
  public set targetLabel(value: string) {
    this._targetLabel = value;
  }
  public resetTargetLabel() {
    this._targetLabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetLabelInput() {
    return this._targetLabel;
  }
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsMetricRelabelingsList extends cdktf.ComplexList {
  public internalValue? : DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsMetricRelabelings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsMetricRelabelingsOutputReference {
    return new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsMetricRelabelingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientIdConfigMap {
  /**
  * The key to select.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#key DataK8STemporalIoTemporalClusterV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#name DataK8STemporalIoTemporalClusterV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the ConfigMap or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#optional DataK8STemporalIoTemporalClusterV1Beta1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientIdConfigMapToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientIdConfigMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientIdConfigMapToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientIdConfigMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientIdConfigMapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientIdConfigMap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientIdConfigMap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientIdSecret {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#key DataK8STemporalIoTemporalClusterV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#name DataK8STemporalIoTemporalClusterV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#optional DataK8STemporalIoTemporalClusterV1Beta1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientIdSecretToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientIdSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientIdSecretToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientIdSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientIdSecretOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientIdSecret | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientIdSecret | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientId {
  /**
  * ConfigMap containing data to use for the targets.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#config_map DataK8STemporalIoTemporalClusterV1Beta1Manifest#config_map}
  */
  readonly configMap?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientIdConfigMap;
  /**
  * Secret containing data to use for the targets.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#secret DataK8STemporalIoTemporalClusterV1Beta1Manifest#secret}
  */
  readonly secret?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientIdSecret;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientIdToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientId | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    config_map: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientIdConfigMapToTerraform(struct!.configMap),
    secret: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientIdSecretToTerraform(struct!.secret),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientIdToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientId | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    config_map: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientIdConfigMapToHclTerraform(struct!.configMap),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientIdConfigMap",
    },
    secret: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientIdSecretToHclTerraform(struct!.secret),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientIdSecret",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientIdOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientId | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._configMap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.configMap = this._configMap?.internalValue;
    }
    if (this._secret?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secret = this._secret?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientId | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._configMap.internalValue = undefined;
      this._secret.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._configMap.internalValue = value.configMap;
      this._secret.internalValue = value.secret;
    }
  }

  // config_map - computed: false, optional: true, required: false
  private _configMap = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientIdConfigMapOutputReference(this, "config_map");
  public get configMap() {
    return this._configMap;
  }
  public putConfigMap(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientIdConfigMap) {
    this._configMap.internalValue = value;
  }
  public resetConfigMap() {
    this._configMap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configMapInput() {
    return this._configMap.internalValue;
  }

  // secret - computed: false, optional: true, required: false
  private _secret = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientIdSecretOutputReference(this, "secret");
  public get secret() {
    return this._secret;
  }
  public putSecret(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientIdSecret) {
    this._secret.internalValue = value;
  }
  public resetSecret() {
    this._secret.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretInput() {
    return this._secret.internalValue;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientSecret {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#key DataK8STemporalIoTemporalClusterV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#name DataK8STemporalIoTemporalClusterV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#optional DataK8STemporalIoTemporalClusterV1Beta1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientSecretToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientSecretToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientSecretOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientSecret | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientSecret | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCaConfigMap {
  /**
  * The key to select.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#key DataK8STemporalIoTemporalClusterV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#name DataK8STemporalIoTemporalClusterV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the ConfigMap or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#optional DataK8STemporalIoTemporalClusterV1Beta1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCaConfigMapToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCaConfigMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCaConfigMapToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCaConfigMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCaConfigMapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCaConfigMap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCaConfigMap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCaSecret {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#key DataK8STemporalIoTemporalClusterV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#name DataK8STemporalIoTemporalClusterV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#optional DataK8STemporalIoTemporalClusterV1Beta1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCaSecretToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCaSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCaSecretToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCaSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCaSecretOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCaSecret | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCaSecret | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCa {
  /**
  * ConfigMap containing data to use for the targets.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#config_map DataK8STemporalIoTemporalClusterV1Beta1Manifest#config_map}
  */
  readonly configMap?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCaConfigMap;
  /**
  * Secret containing data to use for the targets.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#secret DataK8STemporalIoTemporalClusterV1Beta1Manifest#secret}
  */
  readonly secret?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCaSecret;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCaToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCa | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    config_map: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCaConfigMapToTerraform(struct!.configMap),
    secret: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCaSecretToTerraform(struct!.secret),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCaToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCa | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    config_map: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCaConfigMapToHclTerraform(struct!.configMap),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCaConfigMap",
    },
    secret: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCaSecretToHclTerraform(struct!.secret),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCaSecret",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCaOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCa | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._configMap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.configMap = this._configMap?.internalValue;
    }
    if (this._secret?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secret = this._secret?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCa | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._configMap.internalValue = undefined;
      this._secret.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._configMap.internalValue = value.configMap;
      this._secret.internalValue = value.secret;
    }
  }

  // config_map - computed: false, optional: true, required: false
  private _configMap = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCaConfigMapOutputReference(this, "config_map");
  public get configMap() {
    return this._configMap;
  }
  public putConfigMap(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCaConfigMap) {
    this._configMap.internalValue = value;
  }
  public resetConfigMap() {
    this._configMap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configMapInput() {
    return this._configMap.internalValue;
  }

  // secret - computed: false, optional: true, required: false
  private _secret = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCaSecretOutputReference(this, "secret");
  public get secret() {
    return this._secret;
  }
  public putSecret(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCaSecret) {
    this._secret.internalValue = value;
  }
  public resetSecret() {
    this._secret.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretInput() {
    return this._secret.internalValue;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCertConfigMap {
  /**
  * The key to select.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#key DataK8STemporalIoTemporalClusterV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#name DataK8STemporalIoTemporalClusterV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the ConfigMap or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#optional DataK8STemporalIoTemporalClusterV1Beta1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCertConfigMapToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCertConfigMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCertConfigMapToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCertConfigMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCertConfigMapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCertConfigMap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCertConfigMap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCertSecret {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#key DataK8STemporalIoTemporalClusterV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#name DataK8STemporalIoTemporalClusterV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#optional DataK8STemporalIoTemporalClusterV1Beta1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCertSecretToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCertSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCertSecretToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCertSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCertSecretOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCertSecret | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCertSecret | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCert {
  /**
  * ConfigMap containing data to use for the targets.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#config_map DataK8STemporalIoTemporalClusterV1Beta1Manifest#config_map}
  */
  readonly configMap?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCertConfigMap;
  /**
  * Secret containing data to use for the targets.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#secret DataK8STemporalIoTemporalClusterV1Beta1Manifest#secret}
  */
  readonly secret?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCertSecret;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCertToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCert | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    config_map: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCertConfigMapToTerraform(struct!.configMap),
    secret: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCertSecretToTerraform(struct!.secret),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCertToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCert | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    config_map: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCertConfigMapToHclTerraform(struct!.configMap),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCertConfigMap",
    },
    secret: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCertSecretToHclTerraform(struct!.secret),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCertSecret",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCertOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCert | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._configMap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.configMap = this._configMap?.internalValue;
    }
    if (this._secret?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secret = this._secret?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCert | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._configMap.internalValue = undefined;
      this._secret.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._configMap.internalValue = value.configMap;
      this._secret.internalValue = value.secret;
    }
  }

  // config_map - computed: false, optional: true, required: false
  private _configMap = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCertConfigMapOutputReference(this, "config_map");
  public get configMap() {
    return this._configMap;
  }
  public putConfigMap(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCertConfigMap) {
    this._configMap.internalValue = value;
  }
  public resetConfigMap() {
    this._configMap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configMapInput() {
    return this._configMap.internalValue;
  }

  // secret - computed: false, optional: true, required: false
  private _secret = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCertSecretOutputReference(this, "secret");
  public get secret() {
    return this._secret;
  }
  public putSecret(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCertSecret) {
    this._secret.internalValue = value;
  }
  public resetSecret() {
    this._secret.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretInput() {
    return this._secret.internalValue;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigKeySecret {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#key DataK8STemporalIoTemporalClusterV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#name DataK8STemporalIoTemporalClusterV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#optional DataK8STemporalIoTemporalClusterV1Beta1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigKeySecretToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigKeySecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigKeySecretToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigKeySecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigKeySecretOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigKeySecret | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigKeySecret | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfig {
  /**
  * Certificate authority used when verifying server certificates.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#ca DataK8STemporalIoTemporalClusterV1Beta1Manifest#ca}
  */
  readonly ca?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCa;
  /**
  * Client certificate to present when doing client-authentication.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#cert DataK8STemporalIoTemporalClusterV1Beta1Manifest#cert}
  */
  readonly cert?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCert;
  /**
  * Disable target certificate validation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#insecure_skip_verify DataK8STemporalIoTemporalClusterV1Beta1Manifest#insecure_skip_verify}
  */
  readonly insecureSkipVerify?: boolean | cdktf.IResolvable;
  /**
  * Secret containing the client key file for the targets.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#key_secret DataK8STemporalIoTemporalClusterV1Beta1Manifest#key_secret}
  */
  readonly keySecret?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigKeySecret;
  /**
  * Maximum acceptable TLS version. It requires Prometheus >= v2.41.0.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#max_version DataK8STemporalIoTemporalClusterV1Beta1Manifest#max_version}
  */
  readonly maxVersion?: string;
  /**
  * Minimum acceptable TLS version. It requires Prometheus >= v2.35.0.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#min_version DataK8STemporalIoTemporalClusterV1Beta1Manifest#min_version}
  */
  readonly minVersion?: string;
  /**
  * Used to verify the hostname for the targets.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#server_name DataK8STemporalIoTemporalClusterV1Beta1Manifest#server_name}
  */
  readonly serverName?: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCaToTerraform(struct!.ca),
    cert: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCertToTerraform(struct!.cert),
    insecure_skip_verify: cdktf.booleanToTerraform(struct!.insecureSkipVerify),
    key_secret: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigKeySecretToTerraform(struct!.keySecret),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    server_name: cdktf.stringToTerraform(struct!.serverName),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCaToHclTerraform(struct!.ca),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCa",
    },
    cert: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCertToHclTerraform(struct!.cert),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCert",
    },
    insecure_skip_verify: {
      value: cdktf.booleanToHclTerraform(struct!.insecureSkipVerify),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    key_secret: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigKeySecretToHclTerraform(struct!.keySecret),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigKeySecret",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server_name: {
      value: cdktf.stringToHclTerraform(struct!.serverName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ca?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ca = this._ca?.internalValue;
    }
    if (this._cert?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cert = this._cert?.internalValue;
    }
    if (this._insecureSkipVerify !== undefined) {
      hasAnyValues = true;
      internalValueResult.insecureSkipVerify = this._insecureSkipVerify;
    }
    if (this._keySecret?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.keySecret = this._keySecret?.internalValue;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._serverName !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverName = this._serverName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ca.internalValue = undefined;
      this._cert.internalValue = undefined;
      this._insecureSkipVerify = undefined;
      this._keySecret.internalValue = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._serverName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ca.internalValue = value.ca;
      this._cert.internalValue = value.cert;
      this._insecureSkipVerify = value.insecureSkipVerify;
      this._keySecret.internalValue = value.keySecret;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._serverName = value.serverName;
    }
  }

  // ca - computed: false, optional: true, required: false
  private _ca = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCaOutputReference(this, "ca");
  public get ca() {
    return this._ca;
  }
  public putCa(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCa) {
    this._ca.internalValue = value;
  }
  public resetCa() {
    this._ca.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caInput() {
    return this._ca.internalValue;
  }

  // cert - computed: false, optional: true, required: false
  private _cert = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCertOutputReference(this, "cert");
  public get cert() {
    return this._cert;
  }
  public putCert(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigCert) {
    this._cert.internalValue = value;
  }
  public resetCert() {
    this._cert.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certInput() {
    return this._cert.internalValue;
  }

  // insecure_skip_verify - computed: false, optional: true, required: false
  private _insecureSkipVerify?: boolean | cdktf.IResolvable; 
  public get insecureSkipVerify() {
    return this.getBooleanAttribute('insecure_skip_verify');
  }
  public set insecureSkipVerify(value: boolean | cdktf.IResolvable) {
    this._insecureSkipVerify = value;
  }
  public resetInsecureSkipVerify() {
    this._insecureSkipVerify = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get insecureSkipVerifyInput() {
    return this._insecureSkipVerify;
  }

  // key_secret - computed: false, optional: true, required: false
  private _keySecret = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigKeySecretOutputReference(this, "key_secret");
  public get keySecret() {
    return this._keySecret;
  }
  public putKeySecret(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigKeySecret) {
    this._keySecret.internalValue = value;
  }
  public resetKeySecret() {
    this._keySecret.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keySecretInput() {
    return this._keySecret.internalValue;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // server_name - computed: false, optional: true, required: false
  private _serverName?: string; 
  public get serverName() {
    return this.getStringAttribute('server_name');
  }
  public set serverName(value: string) {
    this._serverName = value;
  }
  public resetServerName() {
    this._serverName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverNameInput() {
    return this._serverName;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2 {
  /**
  * 'clientId' specifies a key of a Secret or ConfigMap containing the OAuth2 client's ID.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#client_id DataK8STemporalIoTemporalClusterV1Beta1Manifest#client_id}
  */
  readonly clientId: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientId;
  /**
  * 'clientSecret' specifies a key of a Secret containing the OAuth2 client's secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#client_secret DataK8STemporalIoTemporalClusterV1Beta1Manifest#client_secret}
  */
  readonly clientSecret: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientSecret;
  /**
  * 'endpointParams' configures the HTTP parameters to append to the token URL.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#endpoint_params DataK8STemporalIoTemporalClusterV1Beta1Manifest#endpoint_params}
  */
  readonly endpointParams?: { [key: string]: string };
  /**
  * 'noProxy' is a comma-separated string that can contain IPs, CIDR notation, domain names that should be excluded from proxying. IP and domain names can contain port numbers. It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#no_proxy DataK8STemporalIoTemporalClusterV1Beta1Manifest#no_proxy}
  */
  readonly noProxy?: string;
  /**
  * ProxyConnectHeader optionally specifies headers to send to proxies during CONNECT requests. It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#proxy_connect_header DataK8STemporalIoTemporalClusterV1Beta1Manifest#proxy_connect_header}
  */
  readonly proxyConnectHeader?: { [key: string]: string };
  /**
  * Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY). It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#proxy_from_environment DataK8STemporalIoTemporalClusterV1Beta1Manifest#proxy_from_environment}
  */
  readonly proxyFromEnvironment?: boolean | cdktf.IResolvable;
  /**
  * 'proxyURL' defines the HTTP proxy server to use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#proxy_url DataK8STemporalIoTemporalClusterV1Beta1Manifest#proxy_url}
  */
  readonly proxyUrl?: string;
  /**
  * 'scopes' defines the OAuth2 scopes used for the token request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#scopes DataK8STemporalIoTemporalClusterV1Beta1Manifest#scopes}
  */
  readonly scopes?: string[];
  /**
  * TLS configuration to use when connecting to the OAuth2 server. It requires Prometheus >= v2.43.0.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#tls_config DataK8STemporalIoTemporalClusterV1Beta1Manifest#tls_config}
  */
  readonly tlsConfig?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfig;
  /**
  * 'tokenURL' configures the URL to fetch the token from.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#token_url DataK8STemporalIoTemporalClusterV1Beta1Manifest#token_url}
  */
  readonly tokenUrl: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    client_id: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientIdToTerraform(struct!.clientId),
    client_secret: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientSecretToTerraform(struct!.clientSecret),
    endpoint_params: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.endpointParams),
    no_proxy: cdktf.stringToTerraform(struct!.noProxy),
    proxy_connect_header: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.proxyConnectHeader),
    proxy_from_environment: cdktf.booleanToTerraform(struct!.proxyFromEnvironment),
    proxy_url: cdktf.stringToTerraform(struct!.proxyUrl),
    scopes: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.scopes),
    tls_config: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigToTerraform(struct!.tlsConfig),
    token_url: cdktf.stringToTerraform(struct!.tokenUrl),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    client_id: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientIdToHclTerraform(struct!.clientId),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientId",
    },
    client_secret: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientSecretToHclTerraform(struct!.clientSecret),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientSecret",
    },
    endpoint_params: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.endpointParams),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    no_proxy: {
      value: cdktf.stringToHclTerraform(struct!.noProxy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    proxy_connect_header: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.proxyConnectHeader),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    proxy_from_environment: {
      value: cdktf.booleanToHclTerraform(struct!.proxyFromEnvironment),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    proxy_url: {
      value: cdktf.stringToHclTerraform(struct!.proxyUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    scopes: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.scopes),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tls_config: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigToHclTerraform(struct!.tlsConfig),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfig",
    },
    token_url: {
      value: cdktf.stringToHclTerraform(struct!.tokenUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clientId?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientId = this._clientId?.internalValue;
    }
    if (this._clientSecret?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientSecret = this._clientSecret?.internalValue;
    }
    if (this._endpointParams !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpointParams = this._endpointParams;
    }
    if (this._noProxy !== undefined) {
      hasAnyValues = true;
      internalValueResult.noProxy = this._noProxy;
    }
    if (this._proxyConnectHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyConnectHeader = this._proxyConnectHeader;
    }
    if (this._proxyFromEnvironment !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyFromEnvironment = this._proxyFromEnvironment;
    }
    if (this._proxyUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyUrl = this._proxyUrl;
    }
    if (this._scopes !== undefined) {
      hasAnyValues = true;
      internalValueResult.scopes = this._scopes;
    }
    if (this._tlsConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsConfig = this._tlsConfig?.internalValue;
    }
    if (this._tokenUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenUrl = this._tokenUrl;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clientId.internalValue = undefined;
      this._clientSecret.internalValue = undefined;
      this._endpointParams = undefined;
      this._noProxy = undefined;
      this._proxyConnectHeader = undefined;
      this._proxyFromEnvironment = undefined;
      this._proxyUrl = undefined;
      this._scopes = undefined;
      this._tlsConfig.internalValue = undefined;
      this._tokenUrl = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clientId.internalValue = value.clientId;
      this._clientSecret.internalValue = value.clientSecret;
      this._endpointParams = value.endpointParams;
      this._noProxy = value.noProxy;
      this._proxyConnectHeader = value.proxyConnectHeader;
      this._proxyFromEnvironment = value.proxyFromEnvironment;
      this._proxyUrl = value.proxyUrl;
      this._scopes = value.scopes;
      this._tlsConfig.internalValue = value.tlsConfig;
      this._tokenUrl = value.tokenUrl;
    }
  }

  // client_id - computed: false, optional: false, required: true
  private _clientId = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientIdOutputReference(this, "client_id");
  public get clientId() {
    return this._clientId;
  }
  public putClientId(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientId) {
    this._clientId.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get clientIdInput() {
    return this._clientId.internalValue;
  }

  // client_secret - computed: false, optional: false, required: true
  private _clientSecret = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientSecretOutputReference(this, "client_secret");
  public get clientSecret() {
    return this._clientSecret;
  }
  public putClientSecret(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ClientSecret) {
    this._clientSecret.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get clientSecretInput() {
    return this._clientSecret.internalValue;
  }

  // endpoint_params - computed: false, optional: true, required: false
  private _endpointParams?: { [key: string]: string }; 
  public get endpointParams() {
    return this.getStringMapAttribute('endpoint_params');
  }
  public set endpointParams(value: { [key: string]: string }) {
    this._endpointParams = value;
  }
  public resetEndpointParams() {
    this._endpointParams = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointParamsInput() {
    return this._endpointParams;
  }

  // no_proxy - computed: false, optional: true, required: false
  private _noProxy?: string; 
  public get noProxy() {
    return this.getStringAttribute('no_proxy');
  }
  public set noProxy(value: string) {
    this._noProxy = value;
  }
  public resetNoProxy() {
    this._noProxy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get noProxyInput() {
    return this._noProxy;
  }

  // proxy_connect_header - computed: false, optional: true, required: false
  private _proxyConnectHeader?: { [key: string]: string }; 
  public get proxyConnectHeader() {
    return this.getStringMapAttribute('proxy_connect_header');
  }
  public set proxyConnectHeader(value: { [key: string]: string }) {
    this._proxyConnectHeader = value;
  }
  public resetProxyConnectHeader() {
    this._proxyConnectHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyConnectHeaderInput() {
    return this._proxyConnectHeader;
  }

  // proxy_from_environment - computed: false, optional: true, required: false
  private _proxyFromEnvironment?: boolean | cdktf.IResolvable; 
  public get proxyFromEnvironment() {
    return this.getBooleanAttribute('proxy_from_environment');
  }
  public set proxyFromEnvironment(value: boolean | cdktf.IResolvable) {
    this._proxyFromEnvironment = value;
  }
  public resetProxyFromEnvironment() {
    this._proxyFromEnvironment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyFromEnvironmentInput() {
    return this._proxyFromEnvironment;
  }

  // proxy_url - computed: false, optional: true, required: false
  private _proxyUrl?: string; 
  public get proxyUrl() {
    return this.getStringAttribute('proxy_url');
  }
  public set proxyUrl(value: string) {
    this._proxyUrl = value;
  }
  public resetProxyUrl() {
    this._proxyUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyUrlInput() {
    return this._proxyUrl;
  }

  // scopes - computed: false, optional: true, required: false
  private _scopes?: string[]; 
  public get scopes() {
    return this.getListAttribute('scopes');
  }
  public set scopes(value: string[]) {
    this._scopes = value;
  }
  public resetScopes() {
    this._scopes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scopesInput() {
    return this._scopes;
  }

  // tls_config - computed: false, optional: true, required: false
  private _tlsConfig = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfigOutputReference(this, "tls_config");
  public get tlsConfig() {
    return this._tlsConfig;
  }
  public putTlsConfig(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2TlsConfig) {
    this._tlsConfig.internalValue = value;
  }
  public resetTlsConfig() {
    this._tlsConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsConfigInput() {
    return this._tlsConfig.internalValue;
  }

  // token_url - computed: false, optional: false, required: true
  private _tokenUrl?: string; 
  public get tokenUrl() {
    return this.getStringAttribute('token_url');
  }
  public set tokenUrl(value: string) {
    this._tokenUrl = value;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenUrlInput() {
    return this._tokenUrl;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsRelabelings {
  /**
  * Action to perform based on the regex matching. 'Uppercase' and 'Lowercase' actions require Prometheus >= v2.36.0. 'DropEqual' and 'KeepEqual' actions require Prometheus >= v2.41.0. Default: 'Replace'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#action DataK8STemporalIoTemporalClusterV1Beta1Manifest#action}
  */
  readonly action?: string;
  /**
  * Modulus to take of the hash of the source label values. Only applicable when the action is 'HashMod'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#modulus DataK8STemporalIoTemporalClusterV1Beta1Manifest#modulus}
  */
  readonly modulus?: number;
  /**
  * Regular expression against which the extracted value is matched.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#regex DataK8STemporalIoTemporalClusterV1Beta1Manifest#regex}
  */
  readonly regex?: string;
  /**
  * Replacement value against which a Replace action is performed if the regular expression matches. Regex capture groups are available.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#replacement DataK8STemporalIoTemporalClusterV1Beta1Manifest#replacement}
  */
  readonly replacement?: string;
  /**
  * Separator is the string between concatenated SourceLabels.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#separator DataK8STemporalIoTemporalClusterV1Beta1Manifest#separator}
  */
  readonly separator?: string;
  /**
  * The source labels select values from existing labels. Their content is concatenated using the configured Separator and matched against the configured regular expression.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#source_labels DataK8STemporalIoTemporalClusterV1Beta1Manifest#source_labels}
  */
  readonly sourceLabels?: string[];
  /**
  * Label to which the resulting string is written in a replacement. It is mandatory for 'Replace', 'HashMod', 'Lowercase', 'Uppercase', 'KeepEqual' and 'DropEqual' actions. Regex capture groups are available.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#target_label DataK8STemporalIoTemporalClusterV1Beta1Manifest#target_label}
  */
  readonly targetLabel?: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsRelabelingsToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsRelabelings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    modulus: cdktf.numberToTerraform(struct!.modulus),
    regex: cdktf.stringToTerraform(struct!.regex),
    replacement: cdktf.stringToTerraform(struct!.replacement),
    separator: cdktf.stringToTerraform(struct!.separator),
    source_labels: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.sourceLabels),
    target_label: cdktf.stringToTerraform(struct!.targetLabel),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsRelabelingsToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsRelabelings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    modulus: {
      value: cdktf.numberToHclTerraform(struct!.modulus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    replacement: {
      value: cdktf.stringToHclTerraform(struct!.replacement),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    separator: {
      value: cdktf.stringToHclTerraform(struct!.separator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    source_labels: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.sourceLabels),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    target_label: {
      value: cdktf.stringToHclTerraform(struct!.targetLabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsRelabelingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsRelabelings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._modulus !== undefined) {
      hasAnyValues = true;
      internalValueResult.modulus = this._modulus;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    if (this._replacement !== undefined) {
      hasAnyValues = true;
      internalValueResult.replacement = this._replacement;
    }
    if (this._separator !== undefined) {
      hasAnyValues = true;
      internalValueResult.separator = this._separator;
    }
    if (this._sourceLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceLabels = this._sourceLabels;
    }
    if (this._targetLabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.targetLabel = this._targetLabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsRelabelings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._modulus = undefined;
      this._regex = undefined;
      this._replacement = undefined;
      this._separator = undefined;
      this._sourceLabels = undefined;
      this._targetLabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._modulus = value.modulus;
      this._regex = value.regex;
      this._replacement = value.replacement;
      this._separator = value.separator;
      this._sourceLabels = value.sourceLabels;
      this._targetLabel = value.targetLabel;
    }
  }

  // action - computed: false, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // modulus - computed: false, optional: true, required: false
  private _modulus?: number; 
  public get modulus() {
    return this.getNumberAttribute('modulus');
  }
  public set modulus(value: number) {
    this._modulus = value;
  }
  public resetModulus() {
    this._modulus = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modulusInput() {
    return this._modulus;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }

  // replacement - computed: false, optional: true, required: false
  private _replacement?: string; 
  public get replacement() {
    return this.getStringAttribute('replacement');
  }
  public set replacement(value: string) {
    this._replacement = value;
  }
  public resetReplacement() {
    this._replacement = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get replacementInput() {
    return this._replacement;
  }

  // separator - computed: false, optional: true, required: false
  private _separator?: string; 
  public get separator() {
    return this.getStringAttribute('separator');
  }
  public set separator(value: string) {
    this._separator = value;
  }
  public resetSeparator() {
    this._separator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get separatorInput() {
    return this._separator;
  }

  // source_labels - computed: false, optional: true, required: false
  private _sourceLabels?: string[]; 
  public get sourceLabels() {
    return this.getListAttribute('source_labels');
  }
  public set sourceLabels(value: string[]) {
    this._sourceLabels = value;
  }
  public resetSourceLabels() {
    this._sourceLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceLabelsInput() {
    return this._sourceLabels;
  }

  // target_label - computed: false, optional: true, required: false
  private _targetLabel?: string; 
  public get targetLabel() {
    return this.getStringAttribute('target_label');
  }
  public set targetLabel(value: string) {
    this._targetLabel = value;
  }
  public resetTargetLabel() {
    this._targetLabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetLabelInput() {
    return this._targetLabel;
  }
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsRelabelingsList extends cdktf.ComplexList {
  public internalValue? : DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsRelabelings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsRelabelingsOutputReference {
    return new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsRelabelingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCaConfigMap {
  /**
  * The key to select.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#key DataK8STemporalIoTemporalClusterV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#name DataK8STemporalIoTemporalClusterV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the ConfigMap or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#optional DataK8STemporalIoTemporalClusterV1Beta1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCaConfigMapToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCaConfigMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCaConfigMapToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCaConfigMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCaConfigMapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCaConfigMap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCaConfigMap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCaSecret {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#key DataK8STemporalIoTemporalClusterV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#name DataK8STemporalIoTemporalClusterV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#optional DataK8STemporalIoTemporalClusterV1Beta1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCaSecretToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCaSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCaSecretToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCaSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCaSecretOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCaSecret | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCaSecret | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCa {
  /**
  * ConfigMap containing data to use for the targets.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#config_map DataK8STemporalIoTemporalClusterV1Beta1Manifest#config_map}
  */
  readonly configMap?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCaConfigMap;
  /**
  * Secret containing data to use for the targets.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#secret DataK8STemporalIoTemporalClusterV1Beta1Manifest#secret}
  */
  readonly secret?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCaSecret;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCaToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCa | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    config_map: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCaConfigMapToTerraform(struct!.configMap),
    secret: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCaSecretToTerraform(struct!.secret),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCaToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCa | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    config_map: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCaConfigMapToHclTerraform(struct!.configMap),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCaConfigMap",
    },
    secret: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCaSecretToHclTerraform(struct!.secret),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCaSecret",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCaOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCa | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._configMap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.configMap = this._configMap?.internalValue;
    }
    if (this._secret?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secret = this._secret?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCa | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._configMap.internalValue = undefined;
      this._secret.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._configMap.internalValue = value.configMap;
      this._secret.internalValue = value.secret;
    }
  }

  // config_map - computed: false, optional: true, required: false
  private _configMap = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCaConfigMapOutputReference(this, "config_map");
  public get configMap() {
    return this._configMap;
  }
  public putConfigMap(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCaConfigMap) {
    this._configMap.internalValue = value;
  }
  public resetConfigMap() {
    this._configMap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configMapInput() {
    return this._configMap.internalValue;
  }

  // secret - computed: false, optional: true, required: false
  private _secret = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCaSecretOutputReference(this, "secret");
  public get secret() {
    return this._secret;
  }
  public putSecret(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCaSecret) {
    this._secret.internalValue = value;
  }
  public resetSecret() {
    this._secret.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretInput() {
    return this._secret.internalValue;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCertConfigMap {
  /**
  * The key to select.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#key DataK8STemporalIoTemporalClusterV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#name DataK8STemporalIoTemporalClusterV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the ConfigMap or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#optional DataK8STemporalIoTemporalClusterV1Beta1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCertConfigMapToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCertConfigMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCertConfigMapToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCertConfigMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCertConfigMapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCertConfigMap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCertConfigMap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCertSecret {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#key DataK8STemporalIoTemporalClusterV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#name DataK8STemporalIoTemporalClusterV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#optional DataK8STemporalIoTemporalClusterV1Beta1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCertSecretToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCertSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCertSecretToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCertSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCertSecretOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCertSecret | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCertSecret | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCert {
  /**
  * ConfigMap containing data to use for the targets.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#config_map DataK8STemporalIoTemporalClusterV1Beta1Manifest#config_map}
  */
  readonly configMap?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCertConfigMap;
  /**
  * Secret containing data to use for the targets.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#secret DataK8STemporalIoTemporalClusterV1Beta1Manifest#secret}
  */
  readonly secret?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCertSecret;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCertToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCert | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    config_map: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCertConfigMapToTerraform(struct!.configMap),
    secret: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCertSecretToTerraform(struct!.secret),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCertToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCert | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    config_map: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCertConfigMapToHclTerraform(struct!.configMap),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCertConfigMap",
    },
    secret: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCertSecretToHclTerraform(struct!.secret),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCertSecret",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCertOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCert | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._configMap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.configMap = this._configMap?.internalValue;
    }
    if (this._secret?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secret = this._secret?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCert | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._configMap.internalValue = undefined;
      this._secret.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._configMap.internalValue = value.configMap;
      this._secret.internalValue = value.secret;
    }
  }

  // config_map - computed: false, optional: true, required: false
  private _configMap = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCertConfigMapOutputReference(this, "config_map");
  public get configMap() {
    return this._configMap;
  }
  public putConfigMap(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCertConfigMap) {
    this._configMap.internalValue = value;
  }
  public resetConfigMap() {
    this._configMap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configMapInput() {
    return this._configMap.internalValue;
  }

  // secret - computed: false, optional: true, required: false
  private _secret = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCertSecretOutputReference(this, "secret");
  public get secret() {
    return this._secret;
  }
  public putSecret(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCertSecret) {
    this._secret.internalValue = value;
  }
  public resetSecret() {
    this._secret.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretInput() {
    return this._secret.internalValue;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigKeySecret {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#key DataK8STemporalIoTemporalClusterV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#name DataK8STemporalIoTemporalClusterV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#optional DataK8STemporalIoTemporalClusterV1Beta1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigKeySecretToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigKeySecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigKeySecretToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigKeySecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigKeySecretOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigKeySecret | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigKeySecret | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfig {
  /**
  * Certificate authority used when verifying server certificates.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#ca DataK8STemporalIoTemporalClusterV1Beta1Manifest#ca}
  */
  readonly ca?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCa;
  /**
  * Path to the CA cert in the Prometheus container to use for the targets.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#ca_file DataK8STemporalIoTemporalClusterV1Beta1Manifest#ca_file}
  */
  readonly caFile?: string;
  /**
  * Client certificate to present when doing client-authentication.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#cert DataK8STemporalIoTemporalClusterV1Beta1Manifest#cert}
  */
  readonly cert?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCert;
  /**
  * Path to the client cert file in the Prometheus container for the targets.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#cert_file DataK8STemporalIoTemporalClusterV1Beta1Manifest#cert_file}
  */
  readonly certFile?: string;
  /**
  * Disable target certificate validation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#insecure_skip_verify DataK8STemporalIoTemporalClusterV1Beta1Manifest#insecure_skip_verify}
  */
  readonly insecureSkipVerify?: boolean | cdktf.IResolvable;
  /**
  * Path to the client key file in the Prometheus container for the targets.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#key_file DataK8STemporalIoTemporalClusterV1Beta1Manifest#key_file}
  */
  readonly keyFile?: string;
  /**
  * Secret containing the client key file for the targets.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#key_secret DataK8STemporalIoTemporalClusterV1Beta1Manifest#key_secret}
  */
  readonly keySecret?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigKeySecret;
  /**
  * Maximum acceptable TLS version. It requires Prometheus >= v2.41.0.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#max_version DataK8STemporalIoTemporalClusterV1Beta1Manifest#max_version}
  */
  readonly maxVersion?: string;
  /**
  * Minimum acceptable TLS version. It requires Prometheus >= v2.35.0.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#min_version DataK8STemporalIoTemporalClusterV1Beta1Manifest#min_version}
  */
  readonly minVersion?: string;
  /**
  * Used to verify the hostname for the targets.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#server_name DataK8STemporalIoTemporalClusterV1Beta1Manifest#server_name}
  */
  readonly serverName?: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCaToTerraform(struct!.ca),
    ca_file: cdktf.stringToTerraform(struct!.caFile),
    cert: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCertToTerraform(struct!.cert),
    cert_file: cdktf.stringToTerraform(struct!.certFile),
    insecure_skip_verify: cdktf.booleanToTerraform(struct!.insecureSkipVerify),
    key_file: cdktf.stringToTerraform(struct!.keyFile),
    key_secret: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigKeySecretToTerraform(struct!.keySecret),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    server_name: cdktf.stringToTerraform(struct!.serverName),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCaToHclTerraform(struct!.ca),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCa",
    },
    ca_file: {
      value: cdktf.stringToHclTerraform(struct!.caFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCertToHclTerraform(struct!.cert),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCert",
    },
    cert_file: {
      value: cdktf.stringToHclTerraform(struct!.certFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    insecure_skip_verify: {
      value: cdktf.booleanToHclTerraform(struct!.insecureSkipVerify),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    key_file: {
      value: cdktf.stringToHclTerraform(struct!.keyFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    key_secret: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigKeySecretToHclTerraform(struct!.keySecret),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigKeySecret",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server_name: {
      value: cdktf.stringToHclTerraform(struct!.serverName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ca?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ca = this._ca?.internalValue;
    }
    if (this._caFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.caFile = this._caFile;
    }
    if (this._cert?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cert = this._cert?.internalValue;
    }
    if (this._certFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.certFile = this._certFile;
    }
    if (this._insecureSkipVerify !== undefined) {
      hasAnyValues = true;
      internalValueResult.insecureSkipVerify = this._insecureSkipVerify;
    }
    if (this._keyFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyFile = this._keyFile;
    }
    if (this._keySecret?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.keySecret = this._keySecret?.internalValue;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._serverName !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverName = this._serverName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ca.internalValue = undefined;
      this._caFile = undefined;
      this._cert.internalValue = undefined;
      this._certFile = undefined;
      this._insecureSkipVerify = undefined;
      this._keyFile = undefined;
      this._keySecret.internalValue = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._serverName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ca.internalValue = value.ca;
      this._caFile = value.caFile;
      this._cert.internalValue = value.cert;
      this._certFile = value.certFile;
      this._insecureSkipVerify = value.insecureSkipVerify;
      this._keyFile = value.keyFile;
      this._keySecret.internalValue = value.keySecret;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._serverName = value.serverName;
    }
  }

  // ca - computed: false, optional: true, required: false
  private _ca = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCaOutputReference(this, "ca");
  public get ca() {
    return this._ca;
  }
  public putCa(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCa) {
    this._ca.internalValue = value;
  }
  public resetCa() {
    this._ca.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caInput() {
    return this._ca.internalValue;
  }

  // ca_file - computed: false, optional: true, required: false
  private _caFile?: string; 
  public get caFile() {
    return this.getStringAttribute('ca_file');
  }
  public set caFile(value: string) {
    this._caFile = value;
  }
  public resetCaFile() {
    this._caFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caFileInput() {
    return this._caFile;
  }

  // cert - computed: false, optional: true, required: false
  private _cert = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCertOutputReference(this, "cert");
  public get cert() {
    return this._cert;
  }
  public putCert(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigCert) {
    this._cert.internalValue = value;
  }
  public resetCert() {
    this._cert.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certInput() {
    return this._cert.internalValue;
  }

  // cert_file - computed: false, optional: true, required: false
  private _certFile?: string; 
  public get certFile() {
    return this.getStringAttribute('cert_file');
  }
  public set certFile(value: string) {
    this._certFile = value;
  }
  public resetCertFile() {
    this._certFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certFileInput() {
    return this._certFile;
  }

  // insecure_skip_verify - computed: false, optional: true, required: false
  private _insecureSkipVerify?: boolean | cdktf.IResolvable; 
  public get insecureSkipVerify() {
    return this.getBooleanAttribute('insecure_skip_verify');
  }
  public set insecureSkipVerify(value: boolean | cdktf.IResolvable) {
    this._insecureSkipVerify = value;
  }
  public resetInsecureSkipVerify() {
    this._insecureSkipVerify = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get insecureSkipVerifyInput() {
    return this._insecureSkipVerify;
  }

  // key_file - computed: false, optional: true, required: false
  private _keyFile?: string; 
  public get keyFile() {
    return this.getStringAttribute('key_file');
  }
  public set keyFile(value: string) {
    this._keyFile = value;
  }
  public resetKeyFile() {
    this._keyFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyFileInput() {
    return this._keyFile;
  }

  // key_secret - computed: false, optional: true, required: false
  private _keySecret = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigKeySecretOutputReference(this, "key_secret");
  public get keySecret() {
    return this._keySecret;
  }
  public putKeySecret(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigKeySecret) {
    this._keySecret.internalValue = value;
  }
  public resetKeySecret() {
    this._keySecret.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keySecretInput() {
    return this._keySecret.internalValue;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // server_name - computed: false, optional: true, required: false
  private _serverName?: string; 
  public get serverName() {
    return this.getStringAttribute('server_name');
  }
  public set serverName(value: string) {
    this._serverName = value;
  }
  public resetServerName() {
    this._serverName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverNameInput() {
    return this._serverName;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpoints {
  /**
  * 'authorization' configures the Authorization header credentials to use when scraping the target. Cannot be set at the same time as 'basicAuth', or 'oauth2'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#authorization DataK8STemporalIoTemporalClusterV1Beta1Manifest#authorization}
  */
  readonly authorization?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsAuthorization;
  /**
  * 'basicAuth' configures the Basic Authentication credentials to use when scraping the target. Cannot be set at the same time as 'authorization', or 'oauth2'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#basic_auth DataK8STemporalIoTemporalClusterV1Beta1Manifest#basic_auth}
  */
  readonly basicAuth?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBasicAuth;
  /**
  * File to read bearer token for scraping the target. Deprecated: use 'authorization' instead.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#bearer_token_file DataK8STemporalIoTemporalClusterV1Beta1Manifest#bearer_token_file}
  */
  readonly bearerTokenFile?: string;
  /**
  * 'bearerTokenSecret' specifies a key of a Secret containing the bearer token for scraping targets. The secret needs to be in the same namespace as the ServiceMonitor object and readable by the Prometheus Operator. Deprecated: use 'authorization' instead.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#bearer_token_secret DataK8STemporalIoTemporalClusterV1Beta1Manifest#bearer_token_secret}
  */
  readonly bearerTokenSecret?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBearerTokenSecret;
  /**
  * 'enableHttp2' can be used to disable HTTP2 when scraping the target.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#enable_http2 DataK8STemporalIoTemporalClusterV1Beta1Manifest#enable_http2}
  */
  readonly enableHttp2?: boolean | cdktf.IResolvable;
  /**
  * When true, the pods which are not running (e.g. either in Failed or Succeeded state) are dropped during the target discovery. If unset, the filtering is enabled. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#filter_running DataK8STemporalIoTemporalClusterV1Beta1Manifest#filter_running}
  */
  readonly filterRunning?: boolean | cdktf.IResolvable;
  /**
  * 'followRedirects' defines whether the scrape requests should follow HTTP 3xx redirects.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#follow_redirects DataK8STemporalIoTemporalClusterV1Beta1Manifest#follow_redirects}
  */
  readonly followRedirects?: boolean | cdktf.IResolvable;
  /**
  * When true, 'honorLabels' preserves the metric's labels when they collide with the target's labels.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#honor_labels DataK8STemporalIoTemporalClusterV1Beta1Manifest#honor_labels}
  */
  readonly honorLabels?: boolean | cdktf.IResolvable;
  /**
  * 'honorTimestamps' controls whether Prometheus preserves the timestamps when exposed by the target.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#honor_timestamps DataK8STemporalIoTemporalClusterV1Beta1Manifest#honor_timestamps}
  */
  readonly honorTimestamps?: boolean | cdktf.IResolvable;
  /**
  * Interval at which Prometheus scrapes the metrics from the target. If empty, Prometheus uses the global scrape interval.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#interval DataK8STemporalIoTemporalClusterV1Beta1Manifest#interval}
  */
  readonly interval?: string;
  /**
  * 'metricRelabelings' configures the relabeling rules to apply to the samples before ingestion.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#metric_relabelings DataK8STemporalIoTemporalClusterV1Beta1Manifest#metric_relabelings}
  */
  readonly metricRelabelings?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsMetricRelabelings[] | cdktf.IResolvable;
  /**
  * 'oauth2' configures the OAuth2 settings to use when scraping the target. It requires Prometheus >= 2.27.0. Cannot be set at the same time as 'authorization', or 'basicAuth'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#oauth2 DataK8STemporalIoTemporalClusterV1Beta1Manifest#oauth2}
  */
  readonly oauth2?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2;
  /**
  * params define optional HTTP URL parameters.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#params DataK8STemporalIoTemporalClusterV1Beta1Manifest#params}
  */
  readonly params?: { [key: string]: string[] } | cdktf.IResolvable;
  /**
  * HTTP path from which to scrape for metrics. If empty, Prometheus uses the default value (e.g. '/metrics').
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#path DataK8STemporalIoTemporalClusterV1Beta1Manifest#path}
  */
  readonly path?: string;
  /**
  * Name of the Service port which this endpoint refers to. It takes precedence over 'targetPort'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#port DataK8STemporalIoTemporalClusterV1Beta1Manifest#port}
  */
  readonly port?: string;
  /**
  * 'proxyURL' configures the HTTP Proxy URL (e.g. 'http://proxyserver:2195') to go through when scraping the target.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#proxy_url DataK8STemporalIoTemporalClusterV1Beta1Manifest#proxy_url}
  */
  readonly proxyUrl?: string;
  /**
  * 'relabelings' configures the relabeling rules to apply the target's metadata labels. The Operator automatically adds relabelings for a few standard Kubernetes fields. The original scrape job's name is available via the '__tmp_prometheus_job_name' label. More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#relabelings DataK8STemporalIoTemporalClusterV1Beta1Manifest#relabelings}
  */
  readonly relabelings?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsRelabelings[] | cdktf.IResolvable;
  /**
  * HTTP scheme to use for scraping. 'http' and 'https' are the expected values unless you rewrite the '__scheme__' label via relabeling. If empty, Prometheus uses the default value 'http'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#scheme DataK8STemporalIoTemporalClusterV1Beta1Manifest#scheme}
  */
  readonly scheme?: string;
  /**
  * Timeout after which Prometheus considers the scrape to be failed. If empty, Prometheus uses the global scrape timeout unless it is less than the target's scrape interval value in which the latter is used.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#scrape_timeout DataK8STemporalIoTemporalClusterV1Beta1Manifest#scrape_timeout}
  */
  readonly scrapeTimeout?: string;
  /**
  * Name or number of the target port of the 'Pod' object behind the Service. The port must be specified with the container's port property.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#target_port DataK8STemporalIoTemporalClusterV1Beta1Manifest#target_port}
  */
  readonly targetPort?: string;
  /**
  * TLS configuration to use when scraping the target.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#tls_config DataK8STemporalIoTemporalClusterV1Beta1Manifest#tls_config}
  */
  readonly tlsConfig?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfig;
  /**
  * 'trackTimestampsStaleness' defines whether Prometheus tracks staleness of the metrics that have an explicit timestamp present in scraped data. Has no effect if 'honorTimestamps' is false. It requires Prometheus >= v2.48.0.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#track_timestamps_staleness DataK8STemporalIoTemporalClusterV1Beta1Manifest#track_timestamps_staleness}
  */
  readonly trackTimestampsStaleness?: boolean | cdktf.IResolvable;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpoints | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    authorization: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsAuthorizationToTerraform(struct!.authorization),
    basic_auth: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBasicAuthToTerraform(struct!.basicAuth),
    bearer_token_file: cdktf.stringToTerraform(struct!.bearerTokenFile),
    bearer_token_secret: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBearerTokenSecretToTerraform(struct!.bearerTokenSecret),
    enable_http2: cdktf.booleanToTerraform(struct!.enableHttp2),
    filter_running: cdktf.booleanToTerraform(struct!.filterRunning),
    follow_redirects: cdktf.booleanToTerraform(struct!.followRedirects),
    honor_labels: cdktf.booleanToTerraform(struct!.honorLabels),
    honor_timestamps: cdktf.booleanToTerraform(struct!.honorTimestamps),
    interval: cdktf.stringToTerraform(struct!.interval),
    metric_relabelings: cdktf.listMapper(dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsMetricRelabelingsToTerraform, false)(struct!.metricRelabelings),
    oauth2: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ToTerraform(struct!.oauth2),
    params: cdktf.hashMapper(cdktf.listMapper(cdktf.stringToTerraform, false))(struct!.params),
    path: cdktf.stringToTerraform(struct!.path),
    port: cdktf.stringToTerraform(struct!.port),
    proxy_url: cdktf.stringToTerraform(struct!.proxyUrl),
    relabelings: cdktf.listMapper(dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsRelabelingsToTerraform, false)(struct!.relabelings),
    scheme: cdktf.stringToTerraform(struct!.scheme),
    scrape_timeout: cdktf.stringToTerraform(struct!.scrapeTimeout),
    target_port: cdktf.stringToTerraform(struct!.targetPort),
    tls_config: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigToTerraform(struct!.tlsConfig),
    track_timestamps_staleness: cdktf.booleanToTerraform(struct!.trackTimestampsStaleness),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpoints | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    authorization: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsAuthorizationToHclTerraform(struct!.authorization),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsAuthorization",
    },
    basic_auth: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBasicAuthToHclTerraform(struct!.basicAuth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBasicAuth",
    },
    bearer_token_file: {
      value: cdktf.stringToHclTerraform(struct!.bearerTokenFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bearer_token_secret: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBearerTokenSecretToHclTerraform(struct!.bearerTokenSecret),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBearerTokenSecret",
    },
    enable_http2: {
      value: cdktf.booleanToHclTerraform(struct!.enableHttp2),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    filter_running: {
      value: cdktf.booleanToHclTerraform(struct!.filterRunning),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    follow_redirects: {
      value: cdktf.booleanToHclTerraform(struct!.followRedirects),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    honor_labels: {
      value: cdktf.booleanToHclTerraform(struct!.honorLabels),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    honor_timestamps: {
      value: cdktf.booleanToHclTerraform(struct!.honorTimestamps),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    interval: {
      value: cdktf.stringToHclTerraform(struct!.interval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metric_relabelings: {
      value: cdktf.listMapperHcl(dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsMetricRelabelingsToHclTerraform, false)(struct!.metricRelabelings),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsMetricRelabelingsList",
    },
    oauth2: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2ToHclTerraform(struct!.oauth2),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2",
    },
    params: {
      value: cdktf.hashMapperHcl(cdktf.listMapperHcl(cdktf.stringToHclTerraform, false))(struct!.params),
      isBlock: false,
      type: "map",
      storageClassType: "stringListMap",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.stringToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    proxy_url: {
      value: cdktf.stringToHclTerraform(struct!.proxyUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    relabelings: {
      value: cdktf.listMapperHcl(dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsRelabelingsToHclTerraform, false)(struct!.relabelings),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsRelabelingsList",
    },
    scheme: {
      value: cdktf.stringToHclTerraform(struct!.scheme),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    scrape_timeout: {
      value: cdktf.stringToHclTerraform(struct!.scrapeTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    target_port: {
      value: cdktf.stringToHclTerraform(struct!.targetPort),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls_config: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigToHclTerraform(struct!.tlsConfig),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfig",
    },
    track_timestamps_staleness: {
      value: cdktf.booleanToHclTerraform(struct!.trackTimestampsStaleness),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpoints | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authorization?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authorization = this._authorization?.internalValue;
    }
    if (this._basicAuth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.basicAuth = this._basicAuth?.internalValue;
    }
    if (this._bearerTokenFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.bearerTokenFile = this._bearerTokenFile;
    }
    if (this._bearerTokenSecret?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.bearerTokenSecret = this._bearerTokenSecret?.internalValue;
    }
    if (this._enableHttp2 !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHttp2 = this._enableHttp2;
    }
    if (this._filterRunning !== undefined) {
      hasAnyValues = true;
      internalValueResult.filterRunning = this._filterRunning;
    }
    if (this._followRedirects !== undefined) {
      hasAnyValues = true;
      internalValueResult.followRedirects = this._followRedirects;
    }
    if (this._honorLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.honorLabels = this._honorLabels;
    }
    if (this._honorTimestamps !== undefined) {
      hasAnyValues = true;
      internalValueResult.honorTimestamps = this._honorTimestamps;
    }
    if (this._interval !== undefined) {
      hasAnyValues = true;
      internalValueResult.interval = this._interval;
    }
    if (this._metricRelabelings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metricRelabelings = this._metricRelabelings?.internalValue;
    }
    if (this._oauth2?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauth2 = this._oauth2?.internalValue;
    }
    if (this._params !== undefined) {
      hasAnyValues = true;
      internalValueResult.params = this._params;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._proxyUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyUrl = this._proxyUrl;
    }
    if (this._relabelings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.relabelings = this._relabelings?.internalValue;
    }
    if (this._scheme !== undefined) {
      hasAnyValues = true;
      internalValueResult.scheme = this._scheme;
    }
    if (this._scrapeTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.scrapeTimeout = this._scrapeTimeout;
    }
    if (this._targetPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.targetPort = this._targetPort;
    }
    if (this._tlsConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsConfig = this._tlsConfig?.internalValue;
    }
    if (this._trackTimestampsStaleness !== undefined) {
      hasAnyValues = true;
      internalValueResult.trackTimestampsStaleness = this._trackTimestampsStaleness;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpoints | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authorization.internalValue = undefined;
      this._basicAuth.internalValue = undefined;
      this._bearerTokenFile = undefined;
      this._bearerTokenSecret.internalValue = undefined;
      this._enableHttp2 = undefined;
      this._filterRunning = undefined;
      this._followRedirects = undefined;
      this._honorLabels = undefined;
      this._honorTimestamps = undefined;
      this._interval = undefined;
      this._metricRelabelings.internalValue = undefined;
      this._oauth2.internalValue = undefined;
      this._params = undefined;
      this._path = undefined;
      this._port = undefined;
      this._proxyUrl = undefined;
      this._relabelings.internalValue = undefined;
      this._scheme = undefined;
      this._scrapeTimeout = undefined;
      this._targetPort = undefined;
      this._tlsConfig.internalValue = undefined;
      this._trackTimestampsStaleness = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authorization.internalValue = value.authorization;
      this._basicAuth.internalValue = value.basicAuth;
      this._bearerTokenFile = value.bearerTokenFile;
      this._bearerTokenSecret.internalValue = value.bearerTokenSecret;
      this._enableHttp2 = value.enableHttp2;
      this._filterRunning = value.filterRunning;
      this._followRedirects = value.followRedirects;
      this._honorLabels = value.honorLabels;
      this._honorTimestamps = value.honorTimestamps;
      this._interval = value.interval;
      this._metricRelabelings.internalValue = value.metricRelabelings;
      this._oauth2.internalValue = value.oauth2;
      this._params = value.params;
      this._path = value.path;
      this._port = value.port;
      this._proxyUrl = value.proxyUrl;
      this._relabelings.internalValue = value.relabelings;
      this._scheme = value.scheme;
      this._scrapeTimeout = value.scrapeTimeout;
      this._targetPort = value.targetPort;
      this._tlsConfig.internalValue = value.tlsConfig;
      this._trackTimestampsStaleness = value.trackTimestampsStaleness;
    }
  }

  // authorization - computed: false, optional: true, required: false
  private _authorization = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsAuthorizationOutputReference(this, "authorization");
  public get authorization() {
    return this._authorization;
  }
  public putAuthorization(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsAuthorization) {
    this._authorization.internalValue = value;
  }
  public resetAuthorization() {
    this._authorization.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authorizationInput() {
    return this._authorization.internalValue;
  }

  // basic_auth - computed: false, optional: true, required: false
  private _basicAuth = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBasicAuthOutputReference(this, "basic_auth");
  public get basicAuth() {
    return this._basicAuth;
  }
  public putBasicAuth(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBasicAuth) {
    this._basicAuth.internalValue = value;
  }
  public resetBasicAuth() {
    this._basicAuth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get basicAuthInput() {
    return this._basicAuth.internalValue;
  }

  // bearer_token_file - computed: false, optional: true, required: false
  private _bearerTokenFile?: string; 
  public get bearerTokenFile() {
    return this.getStringAttribute('bearer_token_file');
  }
  public set bearerTokenFile(value: string) {
    this._bearerTokenFile = value;
  }
  public resetBearerTokenFile() {
    this._bearerTokenFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bearerTokenFileInput() {
    return this._bearerTokenFile;
  }

  // bearer_token_secret - computed: false, optional: true, required: false
  private _bearerTokenSecret = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBearerTokenSecretOutputReference(this, "bearer_token_secret");
  public get bearerTokenSecret() {
    return this._bearerTokenSecret;
  }
  public putBearerTokenSecret(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsBearerTokenSecret) {
    this._bearerTokenSecret.internalValue = value;
  }
  public resetBearerTokenSecret() {
    this._bearerTokenSecret.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bearerTokenSecretInput() {
    return this._bearerTokenSecret.internalValue;
  }

  // enable_http2 - computed: false, optional: true, required: false
  private _enableHttp2?: boolean | cdktf.IResolvable; 
  public get enableHttp2() {
    return this.getBooleanAttribute('enable_http2');
  }
  public set enableHttp2(value: boolean | cdktf.IResolvable) {
    this._enableHttp2 = value;
  }
  public resetEnableHttp2() {
    this._enableHttp2 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHttp2Input() {
    return this._enableHttp2;
  }

  // filter_running - computed: false, optional: true, required: false
  private _filterRunning?: boolean | cdktf.IResolvable; 
  public get filterRunning() {
    return this.getBooleanAttribute('filter_running');
  }
  public set filterRunning(value: boolean | cdktf.IResolvable) {
    this._filterRunning = value;
  }
  public resetFilterRunning() {
    this._filterRunning = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get filterRunningInput() {
    return this._filterRunning;
  }

  // follow_redirects - computed: false, optional: true, required: false
  private _followRedirects?: boolean | cdktf.IResolvable; 
  public get followRedirects() {
    return this.getBooleanAttribute('follow_redirects');
  }
  public set followRedirects(value: boolean | cdktf.IResolvable) {
    this._followRedirects = value;
  }
  public resetFollowRedirects() {
    this._followRedirects = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get followRedirectsInput() {
    return this._followRedirects;
  }

  // honor_labels - computed: false, optional: true, required: false
  private _honorLabels?: boolean | cdktf.IResolvable; 
  public get honorLabels() {
    return this.getBooleanAttribute('honor_labels');
  }
  public set honorLabels(value: boolean | cdktf.IResolvable) {
    this._honorLabels = value;
  }
  public resetHonorLabels() {
    this._honorLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get honorLabelsInput() {
    return this._honorLabels;
  }

  // honor_timestamps - computed: false, optional: true, required: false
  private _honorTimestamps?: boolean | cdktf.IResolvable; 
  public get honorTimestamps() {
    return this.getBooleanAttribute('honor_timestamps');
  }
  public set honorTimestamps(value: boolean | cdktf.IResolvable) {
    this._honorTimestamps = value;
  }
  public resetHonorTimestamps() {
    this._honorTimestamps = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get honorTimestampsInput() {
    return this._honorTimestamps;
  }

  // interval - computed: false, optional: true, required: false
  private _interval?: string; 
  public get interval() {
    return this.getStringAttribute('interval');
  }
  public set interval(value: string) {
    this._interval = value;
  }
  public resetInterval() {
    this._interval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get intervalInput() {
    return this._interval;
  }

  // metric_relabelings - computed: false, optional: true, required: false
  private _metricRelabelings = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsMetricRelabelingsList(this, "metric_relabelings", false);
  public get metricRelabelings() {
    return this._metricRelabelings;
  }
  public putMetricRelabelings(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsMetricRelabelings[] | cdktf.IResolvable) {
    this._metricRelabelings.internalValue = value;
  }
  public resetMetricRelabelings() {
    this._metricRelabelings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricRelabelingsInput() {
    return this._metricRelabelings.internalValue;
  }

  // oauth2 - computed: false, optional: true, required: false
  private _oauth2 = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2OutputReference(this, "oauth2");
  public get oauth2() {
    return this._oauth2;
  }
  public putOauth2(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOauth2) {
    this._oauth2.internalValue = value;
  }
  public resetOauth2() {
    this._oauth2.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauth2Input() {
    return this._oauth2.internalValue;
  }

  // params - computed: false, optional: true, required: false
  private _params?: { [key: string]: string[] } | cdktf.IResolvable; 
  public get params() {
    return this.interpolationForAttribute('params');
  }
  public set params(value: { [key: string]: string[] } | cdktf.IResolvable) {
    this._params = value;
  }
  public resetParams() {
    this._params = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get paramsInput() {
    return this._params;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // port - computed: false, optional: true, required: false
  private _port?: string; 
  public get port() {
    return this.getStringAttribute('port');
  }
  public set port(value: string) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // proxy_url - computed: false, optional: true, required: false
  private _proxyUrl?: string; 
  public get proxyUrl() {
    return this.getStringAttribute('proxy_url');
  }
  public set proxyUrl(value: string) {
    this._proxyUrl = value;
  }
  public resetProxyUrl() {
    this._proxyUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyUrlInput() {
    return this._proxyUrl;
  }

  // relabelings - computed: false, optional: true, required: false
  private _relabelings = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsRelabelingsList(this, "relabelings", false);
  public get relabelings() {
    return this._relabelings;
  }
  public putRelabelings(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsRelabelings[] | cdktf.IResolvable) {
    this._relabelings.internalValue = value;
  }
  public resetRelabelings() {
    this._relabelings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relabelingsInput() {
    return this._relabelings.internalValue;
  }

  // scheme - computed: false, optional: true, required: false
  private _scheme?: string; 
  public get scheme() {
    return this.getStringAttribute('scheme');
  }
  public set scheme(value: string) {
    this._scheme = value;
  }
  public resetScheme() {
    this._scheme = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get schemeInput() {
    return this._scheme;
  }

  // scrape_timeout - computed: false, optional: true, required: false
  private _scrapeTimeout?: string; 
  public get scrapeTimeout() {
    return this.getStringAttribute('scrape_timeout');
  }
  public set scrapeTimeout(value: string) {
    this._scrapeTimeout = value;
  }
  public resetScrapeTimeout() {
    this._scrapeTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scrapeTimeoutInput() {
    return this._scrapeTimeout;
  }

  // target_port - computed: false, optional: true, required: false
  private _targetPort?: string; 
  public get targetPort() {
    return this.getStringAttribute('target_port');
  }
  public set targetPort(value: string) {
    this._targetPort = value;
  }
  public resetTargetPort() {
    this._targetPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetPortInput() {
    return this._targetPort;
  }

  // tls_config - computed: false, optional: true, required: false
  private _tlsConfig = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfigOutputReference(this, "tls_config");
  public get tlsConfig() {
    return this._tlsConfig;
  }
  public putTlsConfig(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsTlsConfig) {
    this._tlsConfig.internalValue = value;
  }
  public resetTlsConfig() {
    this._tlsConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsConfigInput() {
    return this._tlsConfig.internalValue;
  }

  // track_timestamps_staleness - computed: false, optional: true, required: false
  private _trackTimestampsStaleness?: boolean | cdktf.IResolvable; 
  public get trackTimestampsStaleness() {
    return this.getBooleanAttribute('track_timestamps_staleness');
  }
  public set trackTimestampsStaleness(value: boolean | cdktf.IResolvable) {
    this._trackTimestampsStaleness = value;
  }
  public resetTrackTimestampsStaleness() {
    this._trackTimestampsStaleness = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get trackTimestampsStalenessInput() {
    return this._trackTimestampsStaleness;
  }
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsList extends cdktf.ComplexList {
  public internalValue? : DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpoints[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOutputReference {
    return new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideNamespaceSelector {
  /**
  * Boolean describing whether all namespaces are selected in contrast to a list restricting them.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#any DataK8STemporalIoTemporalClusterV1Beta1Manifest#any}
  */
  readonly any?: boolean | cdktf.IResolvable;
  /**
  * List of namespace names to select from.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#match_names DataK8STemporalIoTemporalClusterV1Beta1Manifest#match_names}
  */
  readonly matchNames?: string[];
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideNamespaceSelectorToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    any: cdktf.booleanToTerraform(struct!.any),
    match_names: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.matchNames),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideNamespaceSelectorToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    any: {
      value: cdktf.booleanToHclTerraform(struct!.any),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    match_names: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.matchNames),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideNamespaceSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideNamespaceSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._any !== undefined) {
      hasAnyValues = true;
      internalValueResult.any = this._any;
    }
    if (this._matchNames !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchNames = this._matchNames;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideNamespaceSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._any = undefined;
      this._matchNames = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._any = value.any;
      this._matchNames = value.matchNames;
    }
  }

  // any - computed: false, optional: true, required: false
  private _any?: boolean | cdktf.IResolvable; 
  public get any() {
    return this.getBooleanAttribute('any');
  }
  public set any(value: boolean | cdktf.IResolvable) {
    this._any = value;
  }
  public resetAny() {
    this._any = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get anyInput() {
    return this._any;
  }

  // match_names - computed: false, optional: true, required: false
  private _matchNames?: string[]; 
  public get matchNames() {
    return this.getListAttribute('match_names');
  }
  public set matchNames(value: string[]) {
    this._matchNames = value;
  }
  public resetMatchNames() {
    this._matchNames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchNamesInput() {
    return this._matchNames;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#key DataK8STemporalIoTemporalClusterV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#operator DataK8STemporalIoTemporalClusterV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#values DataK8STemporalIoTemporalClusterV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideSelectorMatchExpressionsToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideSelectorMatchExpressionsToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideSelectorMatchExpressionsOutputReference {
    return new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#match_expressions DataK8STemporalIoTemporalClusterV1Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#match_labels DataK8STemporalIoTemporalClusterV1Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideSelectorToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideSelectorToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverride {
  /**
  * 'attachMetadata' defines additional metadata which is added to the discovered targets. It requires Prometheus >= v2.37.0.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#attach_metadata DataK8STemporalIoTemporalClusterV1Beta1Manifest#attach_metadata}
  */
  readonly attachMetadata?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideAttachMetadata;
  /**
  * When defined, bodySizeLimit specifies a job level limit on the size of uncompressed response body that will be accepted by Prometheus. It requires Prometheus >= v2.28.0.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#body_size_limit DataK8STemporalIoTemporalClusterV1Beta1Manifest#body_size_limit}
  */
  readonly bodySizeLimit?: string;
  /**
  * List of endpoints part of this ServiceMonitor. Defines how to scrape metrics from Kubernetes [Endpoints](https://kubernetes.io/docs/concepts/services-networking/service/#endpoints) objects. In most cases, an Endpoints object is backed by a Kubernetes [Service](https://kubernetes.io/docs/concepts/services-networking/service/) object with the same name and labels.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#endpoints DataK8STemporalIoTemporalClusterV1Beta1Manifest#endpoints}
  */
  readonly endpoints: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpoints[] | cdktf.IResolvable;
  /**
  * 'jobLabel' selects the label from the associated Kubernetes 'Service' object which will be used as the 'job' label for all metrics. For example if 'jobLabel' is set to 'foo' and the Kubernetes 'Service' object is labeled with 'foo: bar', then Prometheus adds the 'job='bar'' label to all ingested metrics. If the value of this field is empty or if the label doesn't exist for the given Service, the 'job' label of the metrics defaults to the name of the associated Kubernetes 'Service'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#job_label DataK8STemporalIoTemporalClusterV1Beta1Manifest#job_label}
  */
  readonly jobLabel?: string;
  /**
  * Per-scrape limit on the number of targets dropped by relabeling that will be kept in memory. 0 means no limit. It requires Prometheus >= v2.47.0.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#keep_dropped_targets DataK8STemporalIoTemporalClusterV1Beta1Manifest#keep_dropped_targets}
  */
  readonly keepDroppedTargets?: number;
  /**
  * Per-scrape limit on number of labels that will be accepted for a sample. It requires Prometheus >= v2.27.0.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#label_limit DataK8STemporalIoTemporalClusterV1Beta1Manifest#label_limit}
  */
  readonly labelLimit?: number;
  /**
  * Per-scrape limit on length of labels name that will be accepted for a sample. It requires Prometheus >= v2.27.0.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#label_name_length_limit DataK8STemporalIoTemporalClusterV1Beta1Manifest#label_name_length_limit}
  */
  readonly labelNameLengthLimit?: number;
  /**
  * Per-scrape limit on length of labels value that will be accepted for a sample. It requires Prometheus >= v2.27.0.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#label_value_length_limit DataK8STemporalIoTemporalClusterV1Beta1Manifest#label_value_length_limit}
  */
  readonly labelValueLengthLimit?: number;
  /**
  * 'namespaceSelector' defines in which namespace(s) Prometheus should discover the services. By default, the services are discovered in the same namespace as the 'ServiceMonitor' object but it is possible to select pods across different/all namespaces.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#namespace_selector DataK8STemporalIoTemporalClusterV1Beta1Manifest#namespace_selector}
  */
  readonly namespaceSelector?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideNamespaceSelector;
  /**
  * 'podTargetLabels' defines the labels which are transferred from the associated Kubernetes 'Pod' object onto the ingested metrics.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#pod_target_labels DataK8STemporalIoTemporalClusterV1Beta1Manifest#pod_target_labels}
  */
  readonly podTargetLabels?: string[];
  /**
  * 'sampleLimit' defines a per-scrape limit on the number of scraped samples that will be accepted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#sample_limit DataK8STemporalIoTemporalClusterV1Beta1Manifest#sample_limit}
  */
  readonly sampleLimit?: number;
  /**
  * The scrape class to apply.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#scrape_class DataK8STemporalIoTemporalClusterV1Beta1Manifest#scrape_class}
  */
  readonly scrapeClass?: string;
  /**
  * 'scrapeProtocols' defines the protocols to negotiate during a scrape. It tells clients the protocols supported by Prometheus in order of preference (from most to least preferred). If unset, Prometheus uses its default value. It requires Prometheus >= v2.49.0.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#scrape_protocols DataK8STemporalIoTemporalClusterV1Beta1Manifest#scrape_protocols}
  */
  readonly scrapeProtocols?: string[];
  /**
  * Label selector to select the Kubernetes 'Endpoints' objects to scrape metrics from.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#selector DataK8STemporalIoTemporalClusterV1Beta1Manifest#selector}
  */
  readonly selector: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideSelector;
  /**
  * 'targetLabels' defines the labels which are transferred from the associated Kubernetes 'Service' object onto the ingested metrics.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#target_labels DataK8STemporalIoTemporalClusterV1Beta1Manifest#target_labels}
  */
  readonly targetLabels?: string[];
  /**
  * 'targetLimit' defines a limit on the number of scraped targets that will be accepted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#target_limit DataK8STemporalIoTemporalClusterV1Beta1Manifest#target_limit}
  */
  readonly targetLimit?: number;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverride | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    attach_metadata: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideAttachMetadataToTerraform(struct!.attachMetadata),
    body_size_limit: cdktf.stringToTerraform(struct!.bodySizeLimit),
    endpoints: cdktf.listMapper(dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsToTerraform, false)(struct!.endpoints),
    job_label: cdktf.stringToTerraform(struct!.jobLabel),
    keep_dropped_targets: cdktf.numberToTerraform(struct!.keepDroppedTargets),
    label_limit: cdktf.numberToTerraform(struct!.labelLimit),
    label_name_length_limit: cdktf.numberToTerraform(struct!.labelNameLengthLimit),
    label_value_length_limit: cdktf.numberToTerraform(struct!.labelValueLengthLimit),
    namespace_selector: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideNamespaceSelectorToTerraform(struct!.namespaceSelector),
    pod_target_labels: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.podTargetLabels),
    sample_limit: cdktf.numberToTerraform(struct!.sampleLimit),
    scrape_class: cdktf.stringToTerraform(struct!.scrapeClass),
    scrape_protocols: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.scrapeProtocols),
    selector: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideSelectorToTerraform(struct!.selector),
    target_labels: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.targetLabels),
    target_limit: cdktf.numberToTerraform(struct!.targetLimit),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverride | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    attach_metadata: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideAttachMetadataToHclTerraform(struct!.attachMetadata),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideAttachMetadata",
    },
    body_size_limit: {
      value: cdktf.stringToHclTerraform(struct!.bodySizeLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoints: {
      value: cdktf.listMapperHcl(dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsToHclTerraform, false)(struct!.endpoints),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsList",
    },
    job_label: {
      value: cdktf.stringToHclTerraform(struct!.jobLabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keep_dropped_targets: {
      value: cdktf.numberToHclTerraform(struct!.keepDroppedTargets),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    label_limit: {
      value: cdktf.numberToHclTerraform(struct!.labelLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    label_name_length_limit: {
      value: cdktf.numberToHclTerraform(struct!.labelNameLengthLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    label_value_length_limit: {
      value: cdktf.numberToHclTerraform(struct!.labelValueLengthLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    namespace_selector: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideNamespaceSelectorToHclTerraform(struct!.namespaceSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideNamespaceSelector",
    },
    pod_target_labels: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.podTargetLabels),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    sample_limit: {
      value: cdktf.numberToHclTerraform(struct!.sampleLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    scrape_class: {
      value: cdktf.stringToHclTerraform(struct!.scrapeClass),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    scrape_protocols: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.scrapeProtocols),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    selector: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideSelectorToHclTerraform(struct!.selector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideSelector",
    },
    target_labels: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.targetLabels),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    target_limit: {
      value: cdktf.numberToHclTerraform(struct!.targetLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverride | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._attachMetadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.attachMetadata = this._attachMetadata?.internalValue;
    }
    if (this._bodySizeLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.bodySizeLimit = this._bodySizeLimit;
    }
    if (this._endpoints?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoints = this._endpoints?.internalValue;
    }
    if (this._jobLabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.jobLabel = this._jobLabel;
    }
    if (this._keepDroppedTargets !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepDroppedTargets = this._keepDroppedTargets;
    }
    if (this._labelLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelLimit = this._labelLimit;
    }
    if (this._labelNameLengthLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelNameLengthLimit = this._labelNameLengthLimit;
    }
    if (this._labelValueLengthLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelValueLengthLimit = this._labelValueLengthLimit;
    }
    if (this._namespaceSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaceSelector = this._namespaceSelector?.internalValue;
    }
    if (this._podTargetLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.podTargetLabels = this._podTargetLabels;
    }
    if (this._sampleLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.sampleLimit = this._sampleLimit;
    }
    if (this._scrapeClass !== undefined) {
      hasAnyValues = true;
      internalValueResult.scrapeClass = this._scrapeClass;
    }
    if (this._scrapeProtocols !== undefined) {
      hasAnyValues = true;
      internalValueResult.scrapeProtocols = this._scrapeProtocols;
    }
    if (this._selector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector?.internalValue;
    }
    if (this._targetLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.targetLabels = this._targetLabels;
    }
    if (this._targetLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.targetLimit = this._targetLimit;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverride | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._attachMetadata.internalValue = undefined;
      this._bodySizeLimit = undefined;
      this._endpoints.internalValue = undefined;
      this._jobLabel = undefined;
      this._keepDroppedTargets = undefined;
      this._labelLimit = undefined;
      this._labelNameLengthLimit = undefined;
      this._labelValueLengthLimit = undefined;
      this._namespaceSelector.internalValue = undefined;
      this._podTargetLabels = undefined;
      this._sampleLimit = undefined;
      this._scrapeClass = undefined;
      this._scrapeProtocols = undefined;
      this._selector.internalValue = undefined;
      this._targetLabels = undefined;
      this._targetLimit = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._attachMetadata.internalValue = value.attachMetadata;
      this._bodySizeLimit = value.bodySizeLimit;
      this._endpoints.internalValue = value.endpoints;
      this._jobLabel = value.jobLabel;
      this._keepDroppedTargets = value.keepDroppedTargets;
      this._labelLimit = value.labelLimit;
      this._labelNameLengthLimit = value.labelNameLengthLimit;
      this._labelValueLengthLimit = value.labelValueLengthLimit;
      this._namespaceSelector.internalValue = value.namespaceSelector;
      this._podTargetLabels = value.podTargetLabels;
      this._sampleLimit = value.sampleLimit;
      this._scrapeClass = value.scrapeClass;
      this._scrapeProtocols = value.scrapeProtocols;
      this._selector.internalValue = value.selector;
      this._targetLabels = value.targetLabels;
      this._targetLimit = value.targetLimit;
    }
  }

  // attach_metadata - computed: false, optional: true, required: false
  private _attachMetadata = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideAttachMetadataOutputReference(this, "attach_metadata");
  public get attachMetadata() {
    return this._attachMetadata;
  }
  public putAttachMetadata(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideAttachMetadata) {
    this._attachMetadata.internalValue = value;
  }
  public resetAttachMetadata() {
    this._attachMetadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get attachMetadataInput() {
    return this._attachMetadata.internalValue;
  }

  // body_size_limit - computed: false, optional: true, required: false
  private _bodySizeLimit?: string; 
  public get bodySizeLimit() {
    return this.getStringAttribute('body_size_limit');
  }
  public set bodySizeLimit(value: string) {
    this._bodySizeLimit = value;
  }
  public resetBodySizeLimit() {
    this._bodySizeLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bodySizeLimitInput() {
    return this._bodySizeLimit;
  }

  // endpoints - computed: false, optional: false, required: true
  private _endpoints = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpointsList(this, "endpoints", false);
  public get endpoints() {
    return this._endpoints;
  }
  public putEndpoints(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideEndpoints[] | cdktf.IResolvable) {
    this._endpoints.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointsInput() {
    return this._endpoints.internalValue;
  }

  // job_label - computed: false, optional: true, required: false
  private _jobLabel?: string; 
  public get jobLabel() {
    return this.getStringAttribute('job_label');
  }
  public set jobLabel(value: string) {
    this._jobLabel = value;
  }
  public resetJobLabel() {
    this._jobLabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jobLabelInput() {
    return this._jobLabel;
  }

  // keep_dropped_targets - computed: false, optional: true, required: false
  private _keepDroppedTargets?: number; 
  public get keepDroppedTargets() {
    return this.getNumberAttribute('keep_dropped_targets');
  }
  public set keepDroppedTargets(value: number) {
    this._keepDroppedTargets = value;
  }
  public resetKeepDroppedTargets() {
    this._keepDroppedTargets = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepDroppedTargetsInput() {
    return this._keepDroppedTargets;
  }

  // label_limit - computed: false, optional: true, required: false
  private _labelLimit?: number; 
  public get labelLimit() {
    return this.getNumberAttribute('label_limit');
  }
  public set labelLimit(value: number) {
    this._labelLimit = value;
  }
  public resetLabelLimit() {
    this._labelLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelLimitInput() {
    return this._labelLimit;
  }

  // label_name_length_limit - computed: false, optional: true, required: false
  private _labelNameLengthLimit?: number; 
  public get labelNameLengthLimit() {
    return this.getNumberAttribute('label_name_length_limit');
  }
  public set labelNameLengthLimit(value: number) {
    this._labelNameLengthLimit = value;
  }
  public resetLabelNameLengthLimit() {
    this._labelNameLengthLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelNameLengthLimitInput() {
    return this._labelNameLengthLimit;
  }

  // label_value_length_limit - computed: false, optional: true, required: false
  private _labelValueLengthLimit?: number; 
  public get labelValueLengthLimit() {
    return this.getNumberAttribute('label_value_length_limit');
  }
  public set labelValueLengthLimit(value: number) {
    this._labelValueLengthLimit = value;
  }
  public resetLabelValueLengthLimit() {
    this._labelValueLengthLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelValueLengthLimitInput() {
    return this._labelValueLengthLimit;
  }

  // namespace_selector - computed: false, optional: true, required: false
  private _namespaceSelector = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideNamespaceSelectorOutputReference(this, "namespace_selector");
  public get namespaceSelector() {
    return this._namespaceSelector;
  }
  public putNamespaceSelector(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideNamespaceSelector) {
    this._namespaceSelector.internalValue = value;
  }
  public resetNamespaceSelector() {
    this._namespaceSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceSelectorInput() {
    return this._namespaceSelector.internalValue;
  }

  // pod_target_labels - computed: false, optional: true, required: false
  private _podTargetLabels?: string[]; 
  public get podTargetLabels() {
    return this.getListAttribute('pod_target_labels');
  }
  public set podTargetLabels(value: string[]) {
    this._podTargetLabels = value;
  }
  public resetPodTargetLabels() {
    this._podTargetLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podTargetLabelsInput() {
    return this._podTargetLabels;
  }

  // sample_limit - computed: false, optional: true, required: false
  private _sampleLimit?: number; 
  public get sampleLimit() {
    return this.getNumberAttribute('sample_limit');
  }
  public set sampleLimit(value: number) {
    this._sampleLimit = value;
  }
  public resetSampleLimit() {
    this._sampleLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sampleLimitInput() {
    return this._sampleLimit;
  }

  // scrape_class - computed: false, optional: true, required: false
  private _scrapeClass?: string; 
  public get scrapeClass() {
    return this.getStringAttribute('scrape_class');
  }
  public set scrapeClass(value: string) {
    this._scrapeClass = value;
  }
  public resetScrapeClass() {
    this._scrapeClass = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scrapeClassInput() {
    return this._scrapeClass;
  }

  // scrape_protocols - computed: false, optional: true, required: false
  private _scrapeProtocols?: string[]; 
  public get scrapeProtocols() {
    return this.getListAttribute('scrape_protocols');
  }
  public set scrapeProtocols(value: string[]) {
    this._scrapeProtocols = value;
  }
  public resetScrapeProtocols() {
    this._scrapeProtocols = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scrapeProtocolsInput() {
    return this._scrapeProtocols;
  }

  // selector - computed: false, optional: false, required: true
  private _selector = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideSelectorOutputReference(this, "selector");
  public get selector() {
    return this._selector;
  }
  public putSelector(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideSelector) {
    this._selector.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector.internalValue;
  }

  // target_labels - computed: false, optional: true, required: false
  private _targetLabels?: string[]; 
  public get targetLabels() {
    return this.getListAttribute('target_labels');
  }
  public set targetLabels(value: string[]) {
    this._targetLabels = value;
  }
  public resetTargetLabels() {
    this._targetLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetLabelsInput() {
    return this._targetLabels;
  }

  // target_limit - computed: false, optional: true, required: false
  private _targetLimit?: number; 
  public get targetLimit() {
    return this.getNumberAttribute('target_limit');
  }
  public set targetLimit(value: number) {
    this._targetLimit = value;
  }
  public resetTargetLimit() {
    this._targetLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetLimitInput() {
    return this._targetLimit;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitor {
  /**
  * Enabled defines if the operator should create a ServiceMonitor for each services.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#enabled DataK8STemporalIoTemporalClusterV1Beta1Manifest#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
  /**
  * Labels adds extra labels to the ServiceMonitor.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#labels DataK8STemporalIoTemporalClusterV1Beta1Manifest#labels}
  */
  readonly labels?: { [key: string]: string };
  /**
  * MetricRelabelConfigs to apply to samples before ingestion.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#metric_relabelings DataK8STemporalIoTemporalClusterV1Beta1Manifest#metric_relabelings}
  */
  readonly metricRelabelings?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorMetricRelabelings[] | cdktf.IResolvable;
  /**
  * Override allows customization of the created ServiceMonitor. All fields can be overwritten except 'endpoints', 'selector' and 'namespaceSelector'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#override DataK8STemporalIoTemporalClusterV1Beta1Manifest#override}
  */
  readonly override?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverride;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitor | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.booleanToTerraform(struct!.enabled),
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
    metric_relabelings: cdktf.listMapper(dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorMetricRelabelingsToTerraform, false)(struct!.metricRelabelings),
    override: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideToTerraform(struct!.override),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitor | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    metric_relabelings: {
      value: cdktf.listMapperHcl(dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorMetricRelabelingsToHclTerraform, false)(struct!.metricRelabelings),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorMetricRelabelingsList",
    },
    override: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideToHclTerraform(struct!.override),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverride",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitor | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    if (this._metricRelabelings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metricRelabelings = this._metricRelabelings?.internalValue;
    }
    if (this._override?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.override = this._override?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitor | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._labels = undefined;
      this._metricRelabelings.internalValue = undefined;
      this._override.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._labels = value.labels;
      this._metricRelabelings.internalValue = value.metricRelabelings;
      this._override.internalValue = value.override;
    }
  }

  // enabled - computed: false, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }

  // metric_relabelings - computed: false, optional: true, required: false
  private _metricRelabelings = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorMetricRelabelingsList(this, "metric_relabelings", false);
  public get metricRelabelings() {
    return this._metricRelabelings;
  }
  public putMetricRelabelings(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorMetricRelabelings[] | cdktf.IResolvable) {
    this._metricRelabelings.internalValue = value;
  }
  public resetMetricRelabelings() {
    this._metricRelabelings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricRelabelingsInput() {
    return this._metricRelabelings.internalValue;
  }

  // override - computed: false, optional: true, required: false
  private _override = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverrideOutputReference(this, "override");
  public get override() {
    return this._override;
  }
  public putOverride(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOverride) {
    this._override.internalValue = value;
  }
  public resetOverride() {
    this._override.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overrideInput() {
    return this._override.internalValue;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfig {
  /**
  * Annotations defines if the operator should add prometheus scrape annotations to the services pods.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#annotations DataK8STemporalIoTemporalClusterV1Beta1Manifest#annotations}
  */
  readonly annotations?: boolean | cdktf.IResolvable;
  /**
  * PrometheusScrapeConfigServiceMonitor is the configuration for prometheus operator ServiceMonitor.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#service_monitor DataK8STemporalIoTemporalClusterV1Beta1Manifest#service_monitor}
  */
  readonly serviceMonitor?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitor;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.booleanToTerraform(struct!.annotations),
    service_monitor: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorToTerraform(struct!.serviceMonitor),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.booleanToHclTerraform(struct!.annotations),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    service_monitor: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorToHclTerraform(struct!.serviceMonitor),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitor",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._serviceMonitor?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceMonitor = this._serviceMonitor?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotations = undefined;
      this._serviceMonitor.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotations = value.annotations;
      this._serviceMonitor.internalValue = value.serviceMonitor;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: boolean | cdktf.IResolvable; 
  public get annotations() {
    return this.getBooleanAttribute('annotations');
  }
  public set annotations(value: boolean | cdktf.IResolvable) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // service_monitor - computed: false, optional: true, required: false
  private _serviceMonitor = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitorOutputReference(this, "service_monitor");
  public get serviceMonitor() {
    return this._serviceMonitor;
  }
  public putServiceMonitor(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigServiceMonitor) {
    this._serviceMonitor.internalValue = value;
  }
  public resetServiceMonitor() {
    this._serviceMonitor.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceMonitorInput() {
    return this._serviceMonitor.internalValue;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheus {
  /**
  * Deprecated. Address for prometheus to serve metrics from.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#listen_address DataK8STemporalIoTemporalClusterV1Beta1Manifest#listen_address}
  */
  readonly listenAddress?: string;
  /**
  * ListenPort for prometheus to serve metrics from.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#listen_port DataK8STemporalIoTemporalClusterV1Beta1Manifest#listen_port}
  */
  readonly listenPort?: number;
  /**
  * ScrapeConfig is the prometheus scrape configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#scrape_config DataK8STemporalIoTemporalClusterV1Beta1Manifest#scrape_config}
  */
  readonly scrapeConfig?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfig;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheus | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    listen_address: cdktf.stringToTerraform(struct!.listenAddress),
    listen_port: cdktf.numberToTerraform(struct!.listenPort),
    scrape_config: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigToTerraform(struct!.scrapeConfig),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheus | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    listen_address: {
      value: cdktf.stringToHclTerraform(struct!.listenAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    listen_port: {
      value: cdktf.numberToHclTerraform(struct!.listenPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    scrape_config: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigToHclTerraform(struct!.scrapeConfig),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfig",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheus | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._listenAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.listenAddress = this._listenAddress;
    }
    if (this._listenPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.listenPort = this._listenPort;
    }
    if (this._scrapeConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.scrapeConfig = this._scrapeConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheus | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._listenAddress = undefined;
      this._listenPort = undefined;
      this._scrapeConfig.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._listenAddress = value.listenAddress;
      this._listenPort = value.listenPort;
      this._scrapeConfig.internalValue = value.scrapeConfig;
    }
  }

  // listen_address - computed: false, optional: true, required: false
  private _listenAddress?: string; 
  public get listenAddress() {
    return this.getStringAttribute('listen_address');
  }
  public set listenAddress(value: string) {
    this._listenAddress = value;
  }
  public resetListenAddress() {
    this._listenAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get listenAddressInput() {
    return this._listenAddress;
  }

  // listen_port - computed: false, optional: true, required: false
  private _listenPort?: number; 
  public get listenPort() {
    return this.getNumberAttribute('listen_port');
  }
  public set listenPort(value: number) {
    this._listenPort = value;
  }
  public resetListenPort() {
    this._listenPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get listenPortInput() {
    return this._listenPort;
  }

  // scrape_config - computed: false, optional: true, required: false
  private _scrapeConfig = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfigOutputReference(this, "scrape_config");
  public get scrapeConfig() {
    return this._scrapeConfig;
  }
  public putScrapeConfig(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusScrapeConfig) {
    this._scrapeConfig.internalValue = value;
  }
  public resetScrapeConfig() {
    this._scrapeConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scrapeConfigInput() {
    return this._scrapeConfig.internalValue;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetrics {
  /**
  * Enabled defines if the operator should enable metrics exposition on temporal components.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#enabled DataK8STemporalIoTemporalClusterV1Beta1Manifest#enabled}
  */
  readonly enabled: boolean | cdktf.IResolvable;
  /**
  * ExcludeTags is a map from tag name string to tag values string list. Each value present in keys will have relevant tag value replaced with '_tag_excluded_' Each value in values list will white-list tag values to be reported as usual.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#exclude_tags DataK8STemporalIoTemporalClusterV1Beta1Manifest#exclude_tags}
  */
  readonly excludeTags?: { [key: string]: string[] } | cdktf.IResolvable;
  /**
  * PerUnitHistogramBoundaries defines the default histogram bucket boundaries. Configuration of histogram boundaries for given metric unit. Supported values: - 'dimensionless' - 'milliseconds' - 'bytes'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#per_unit_histogram_boundaries DataK8STemporalIoTemporalClusterV1Beta1Manifest#per_unit_histogram_boundaries}
  */
  readonly perUnitHistogramBoundaries?: { [key: string]: string[] } | cdktf.IResolvable;
  /**
  * Prefix sets the prefix to all outgoing metrics
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#prefix DataK8STemporalIoTemporalClusterV1Beta1Manifest#prefix}
  */
  readonly prefix?: string;
  /**
  * Prometheus reporter configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#prometheus DataK8STemporalIoTemporalClusterV1Beta1Manifest#prometheus}
  */
  readonly prometheus?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheus;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetrics | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.booleanToTerraform(struct!.enabled),
    exclude_tags: cdktf.hashMapper(cdktf.listMapper(cdktf.stringToTerraform, false))(struct!.excludeTags),
    per_unit_histogram_boundaries: cdktf.hashMapper(cdktf.listMapper(cdktf.stringToTerraform, false))(struct!.perUnitHistogramBoundaries),
    prefix: cdktf.stringToTerraform(struct!.prefix),
    prometheus: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusToTerraform(struct!.prometheus),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetrics | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    exclude_tags: {
      value: cdktf.hashMapperHcl(cdktf.listMapperHcl(cdktf.stringToHclTerraform, false))(struct!.excludeTags),
      isBlock: false,
      type: "map",
      storageClassType: "stringListMap",
    },
    per_unit_histogram_boundaries: {
      value: cdktf.hashMapperHcl(cdktf.listMapperHcl(cdktf.stringToHclTerraform, false))(struct!.perUnitHistogramBoundaries),
      isBlock: false,
      type: "map",
      storageClassType: "stringListMap",
    },
    prefix: {
      value: cdktf.stringToHclTerraform(struct!.prefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prometheus: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusToHclTerraform(struct!.prometheus),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheus",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetrics | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._excludeTags !== undefined) {
      hasAnyValues = true;
      internalValueResult.excludeTags = this._excludeTags;
    }
    if (this._perUnitHistogramBoundaries !== undefined) {
      hasAnyValues = true;
      internalValueResult.perUnitHistogramBoundaries = this._perUnitHistogramBoundaries;
    }
    if (this._prefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefix = this._prefix;
    }
    if (this._prometheus?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.prometheus = this._prometheus?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetrics | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._excludeTags = undefined;
      this._perUnitHistogramBoundaries = undefined;
      this._prefix = undefined;
      this._prometheus.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._excludeTags = value.excludeTags;
      this._perUnitHistogramBoundaries = value.perUnitHistogramBoundaries;
      this._prefix = value.prefix;
      this._prometheus.internalValue = value.prometheus;
    }
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // exclude_tags - computed: false, optional: true, required: false
  private _excludeTags?: { [key: string]: string[] } | cdktf.IResolvable; 
  public get excludeTags() {
    return this.interpolationForAttribute('exclude_tags');
  }
  public set excludeTags(value: { [key: string]: string[] } | cdktf.IResolvable) {
    this._excludeTags = value;
  }
  public resetExcludeTags() {
    this._excludeTags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get excludeTagsInput() {
    return this._excludeTags;
  }

  // per_unit_histogram_boundaries - computed: false, optional: true, required: false
  private _perUnitHistogramBoundaries?: { [key: string]: string[] } | cdktf.IResolvable; 
  public get perUnitHistogramBoundaries() {
    return this.interpolationForAttribute('per_unit_histogram_boundaries');
  }
  public set perUnitHistogramBoundaries(value: { [key: string]: string[] } | cdktf.IResolvable) {
    this._perUnitHistogramBoundaries = value;
  }
  public resetPerUnitHistogramBoundaries() {
    this._perUnitHistogramBoundaries = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get perUnitHistogramBoundariesInput() {
    return this._perUnitHistogramBoundaries;
  }

  // prefix - computed: false, optional: true, required: false
  private _prefix?: string; 
  public get prefix() {
    return this.getStringAttribute('prefix');
  }
  public set prefix(value: string) {
    this._prefix = value;
  }
  public resetPrefix() {
    this._prefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixInput() {
    return this._prefix;
  }

  // prometheus - computed: false, optional: true, required: false
  private _prometheus = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheusOutputReference(this, "prometheus");
  public get prometheus() {
    return this._prometheus;
  }
  public putPrometheus(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsPrometheus) {
    this._prometheus.internalValue = value;
  }
  public resetPrometheus() {
    this._prometheus.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prometheusInput() {
    return this._prometheus.internalValue;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreCassandraConsistency {
  /**
  * Consistency sets the default consistency level. Values identical to gocql Consistency values. (defaults to LOCAL_QUORUM if not set).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#consistency DataK8STemporalIoTemporalClusterV1Beta1Manifest#consistency}
  */
  readonly consistency?: number;
  /**
  * SerialConsistency sets the consistency for the serial prtion of queries. Values identical to gocql SerialConsistency values. (defaults to LOCAL_SERIAL if not set)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#serial_consistency DataK8STemporalIoTemporalClusterV1Beta1Manifest#serial_consistency}
  */
  readonly serialConsistency?: number;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreCassandraConsistencyToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreCassandraConsistency | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    consistency: cdktf.numberToTerraform(struct!.consistency),
    serial_consistency: cdktf.numberToTerraform(struct!.serialConsistency),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreCassandraConsistencyToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreCassandraConsistency | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    consistency: {
      value: cdktf.numberToHclTerraform(struct!.consistency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    serial_consistency: {
      value: cdktf.numberToHclTerraform(struct!.serialConsistency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreCassandraConsistencyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreCassandraConsistency | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._consistency !== undefined) {
      hasAnyValues = true;
      internalValueResult.consistency = this._consistency;
    }
    if (this._serialConsistency !== undefined) {
      hasAnyValues = true;
      internalValueResult.serialConsistency = this._serialConsistency;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreCassandraConsistency | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._consistency = undefined;
      this._serialConsistency = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._consistency = value.consistency;
      this._serialConsistency = value.serialConsistency;
    }
  }

  // consistency - computed: false, optional: true, required: false
  private _consistency?: number; 
  public get consistency() {
    return this.getNumberAttribute('consistency');
  }
  public set consistency(value: number) {
    this._consistency = value;
  }
  public resetConsistency() {
    this._consistency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get consistencyInput() {
    return this._consistency;
  }

  // serial_consistency - computed: false, optional: true, required: false
  private _serialConsistency?: number; 
  public get serialConsistency() {
    return this.getNumberAttribute('serial_consistency');
  }
  public set serialConsistency(value: number) {
    this._serialConsistency = value;
  }
  public resetSerialConsistency() {
    this._serialConsistency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serialConsistencyInput() {
    return this._serialConsistency;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreCassandra {
  /**
  * ConnectTimeout is a timeout for initial dial to cassandra server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#connect_timeout DataK8STemporalIoTemporalClusterV1Beta1Manifest#connect_timeout}
  */
  readonly connectTimeout?: string;
  /**
  * Consistency configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#consistency DataK8STemporalIoTemporalClusterV1Beta1Manifest#consistency}
  */
  readonly consistency?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreCassandraConsistency;
  /**
  * Datacenter is the data center filter arg for cassandra.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#datacenter DataK8STemporalIoTemporalClusterV1Beta1Manifest#datacenter}
  */
  readonly datacenter?: string;
  /**
  * DisableInitialHostLookup instructs the gocql client to connect only using the supplied hosts.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#disable_initial_host_lookup DataK8STemporalIoTemporalClusterV1Beta1Manifest#disable_initial_host_lookup}
  */
  readonly disableInitialHostLookup?: boolean | cdktf.IResolvable;
  /**
  * Hosts is a list of cassandra endpoints.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#hosts DataK8STemporalIoTemporalClusterV1Beta1Manifest#hosts}
  */
  readonly hosts: string[];
  /**
  * Keyspace is the cassandra keyspace.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#keyspace DataK8STemporalIoTemporalClusterV1Beta1Manifest#keyspace}
  */
  readonly keyspace: string;
  /**
  * MaxConns is the max number of connections to this datastore for a single keyspace.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#max_conns DataK8STemporalIoTemporalClusterV1Beta1Manifest#max_conns}
  */
  readonly maxConns?: number;
  /**
  * Port is the cassandra port used for connection by gocql client.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#port DataK8STemporalIoTemporalClusterV1Beta1Manifest#port}
  */
  readonly port: number;
  /**
  * User is the cassandra user used for authentication by gocql client.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#user DataK8STemporalIoTemporalClusterV1Beta1Manifest#user}
  */
  readonly user: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreCassandraToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreCassandra | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connect_timeout: cdktf.stringToTerraform(struct!.connectTimeout),
    consistency: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreCassandraConsistencyToTerraform(struct!.consistency),
    datacenter: cdktf.stringToTerraform(struct!.datacenter),
    disable_initial_host_lookup: cdktf.booleanToTerraform(struct!.disableInitialHostLookup),
    hosts: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.hosts),
    keyspace: cdktf.stringToTerraform(struct!.keyspace),
    max_conns: cdktf.numberToTerraform(struct!.maxConns),
    port: cdktf.numberToTerraform(struct!.port),
    user: cdktf.stringToTerraform(struct!.user),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreCassandraToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreCassandra | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connect_timeout: {
      value: cdktf.stringToHclTerraform(struct!.connectTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    consistency: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreCassandraConsistencyToHclTerraform(struct!.consistency),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreCassandraConsistency",
    },
    datacenter: {
      value: cdktf.stringToHclTerraform(struct!.datacenter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disable_initial_host_lookup: {
      value: cdktf.booleanToHclTerraform(struct!.disableInitialHostLookup),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    hosts: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.hosts),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    keyspace: {
      value: cdktf.stringToHclTerraform(struct!.keyspace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_conns: {
      value: cdktf.numberToHclTerraform(struct!.maxConns),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    user: {
      value: cdktf.stringToHclTerraform(struct!.user),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreCassandraOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreCassandra | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connectTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectTimeout = this._connectTimeout;
    }
    if (this._consistency?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.consistency = this._consistency?.internalValue;
    }
    if (this._datacenter !== undefined) {
      hasAnyValues = true;
      internalValueResult.datacenter = this._datacenter;
    }
    if (this._disableInitialHostLookup !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableInitialHostLookup = this._disableInitialHostLookup;
    }
    if (this._hosts !== undefined) {
      hasAnyValues = true;
      internalValueResult.hosts = this._hosts;
    }
    if (this._keyspace !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyspace = this._keyspace;
    }
    if (this._maxConns !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxConns = this._maxConns;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._user !== undefined) {
      hasAnyValues = true;
      internalValueResult.user = this._user;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreCassandra | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connectTimeout = undefined;
      this._consistency.internalValue = undefined;
      this._datacenter = undefined;
      this._disableInitialHostLookup = undefined;
      this._hosts = undefined;
      this._keyspace = undefined;
      this._maxConns = undefined;
      this._port = undefined;
      this._user = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connectTimeout = value.connectTimeout;
      this._consistency.internalValue = value.consistency;
      this._datacenter = value.datacenter;
      this._disableInitialHostLookup = value.disableInitialHostLookup;
      this._hosts = value.hosts;
      this._keyspace = value.keyspace;
      this._maxConns = value.maxConns;
      this._port = value.port;
      this._user = value.user;
    }
  }

  // connect_timeout - computed: false, optional: true, required: false
  private _connectTimeout?: string; 
  public get connectTimeout() {
    return this.getStringAttribute('connect_timeout');
  }
  public set connectTimeout(value: string) {
    this._connectTimeout = value;
  }
  public resetConnectTimeout() {
    this._connectTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectTimeoutInput() {
    return this._connectTimeout;
  }

  // consistency - computed: false, optional: true, required: false
  private _consistency = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreCassandraConsistencyOutputReference(this, "consistency");
  public get consistency() {
    return this._consistency;
  }
  public putConsistency(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreCassandraConsistency) {
    this._consistency.internalValue = value;
  }
  public resetConsistency() {
    this._consistency.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get consistencyInput() {
    return this._consistency.internalValue;
  }

  // datacenter - computed: false, optional: true, required: false
  private _datacenter?: string; 
  public get datacenter() {
    return this.getStringAttribute('datacenter');
  }
  public set datacenter(value: string) {
    this._datacenter = value;
  }
  public resetDatacenter() {
    this._datacenter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get datacenterInput() {
    return this._datacenter;
  }

  // disable_initial_host_lookup - computed: false, optional: true, required: false
  private _disableInitialHostLookup?: boolean | cdktf.IResolvable; 
  public get disableInitialHostLookup() {
    return this.getBooleanAttribute('disable_initial_host_lookup');
  }
  public set disableInitialHostLookup(value: boolean | cdktf.IResolvable) {
    this._disableInitialHostLookup = value;
  }
  public resetDisableInitialHostLookup() {
    this._disableInitialHostLookup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableInitialHostLookupInput() {
    return this._disableInitialHostLookup;
  }

  // hosts - computed: false, optional: false, required: true
  private _hosts?: string[]; 
  public get hosts() {
    return this.getListAttribute('hosts');
  }
  public set hosts(value: string[]) {
    this._hosts = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostsInput() {
    return this._hosts;
  }

  // keyspace - computed: false, optional: false, required: true
  private _keyspace?: string; 
  public get keyspace() {
    return this.getStringAttribute('keyspace');
  }
  public set keyspace(value: string) {
    this._keyspace = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyspaceInput() {
    return this._keyspace;
  }

  // max_conns - computed: false, optional: true, required: false
  private _maxConns?: number; 
  public get maxConns() {
    return this.getNumberAttribute('max_conns');
  }
  public set maxConns(value: number) {
    this._maxConns = value;
  }
  public resetMaxConns() {
    this._maxConns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxConnsInput() {
    return this._maxConns;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // user - computed: false, optional: false, required: true
  private _user?: string; 
  public get user() {
    return this.getStringAttribute('user');
  }
  public set user(value: string) {
    this._user = value;
  }
  // Temporarily expose input value. Use with caution.
  public get userInput() {
    return this._user;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreElasticsearchIndices {
  /**
  * SecondaryVisibility defines secondary visibility's index name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#secondary_visibility DataK8STemporalIoTemporalClusterV1Beta1Manifest#secondary_visibility}
  */
  readonly secondaryVisibility?: string;
  /**
  * Visibility defines visibility's index name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#visibility DataK8STemporalIoTemporalClusterV1Beta1Manifest#visibility}
  */
  readonly visibility: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreElasticsearchIndicesToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreElasticsearchIndices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secondary_visibility: cdktf.stringToTerraform(struct!.secondaryVisibility),
    visibility: cdktf.stringToTerraform(struct!.visibility),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreElasticsearchIndicesToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreElasticsearchIndices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secondary_visibility: {
      value: cdktf.stringToHclTerraform(struct!.secondaryVisibility),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    visibility: {
      value: cdktf.stringToHclTerraform(struct!.visibility),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreElasticsearchIndicesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreElasticsearchIndices | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secondaryVisibility !== undefined) {
      hasAnyValues = true;
      internalValueResult.secondaryVisibility = this._secondaryVisibility;
    }
    if (this._visibility !== undefined) {
      hasAnyValues = true;
      internalValueResult.visibility = this._visibility;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreElasticsearchIndices | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secondaryVisibility = undefined;
      this._visibility = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secondaryVisibility = value.secondaryVisibility;
      this._visibility = value.visibility;
    }
  }

  // secondary_visibility - computed: false, optional: true, required: false
  private _secondaryVisibility?: string; 
  public get secondaryVisibility() {
    return this.getStringAttribute('secondary_visibility');
  }
  public set secondaryVisibility(value: string) {
    this._secondaryVisibility = value;
  }
  public resetSecondaryVisibility() {
    this._secondaryVisibility = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secondaryVisibilityInput() {
    return this._secondaryVisibility;
  }

  // visibility - computed: false, optional: false, required: true
  private _visibility?: string; 
  public get visibility() {
    return this.getStringAttribute('visibility');
  }
  public set visibility(value: string) {
    this._visibility = value;
  }
  // Temporarily expose input value. Use with caution.
  public get visibilityInput() {
    return this._visibility;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreElasticsearch {
  /**
  * CloseIdleConnectionsInterval is the max duration a connection stay open while idle.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#close_idle_connections_interval DataK8STemporalIoTemporalClusterV1Beta1Manifest#close_idle_connections_interval}
  */
  readonly closeIdleConnectionsInterval?: string;
  /**
  * EnableHealthcheck enables or disables healthcheck on the temporal cluster's es client.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#enable_healthcheck DataK8STemporalIoTemporalClusterV1Beta1Manifest#enable_healthcheck}
  */
  readonly enableHealthcheck?: boolean | cdktf.IResolvable;
  /**
  * EnableSniff enables or disables sniffer on the temporal cluster's es client.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#enable_sniff DataK8STemporalIoTemporalClusterV1Beta1Manifest#enable_sniff}
  */
  readonly enableSniff?: boolean | cdktf.IResolvable;
  /**
  * Indices holds visibility index names.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#indices DataK8STemporalIoTemporalClusterV1Beta1Manifest#indices}
  */
  readonly indices: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreElasticsearchIndices;
  /**
  * LogLevel defines the temporal cluster's es client logger level.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#log_level DataK8STemporalIoTemporalClusterV1Beta1Manifest#log_level}
  */
  readonly logLevel?: string;
  /**
  * URL is the connection url to connect to the instance.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#url DataK8STemporalIoTemporalClusterV1Beta1Manifest#url}
  */
  readonly url: string;
  /**
  * Username is the username to be used for the connection.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#username DataK8STemporalIoTemporalClusterV1Beta1Manifest#username}
  */
  readonly username: string;
  /**
  * Version defines the elasticsearch version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#version DataK8STemporalIoTemporalClusterV1Beta1Manifest#version}
  */
  readonly version: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreElasticsearchToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreElasticsearch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    close_idle_connections_interval: cdktf.stringToTerraform(struct!.closeIdleConnectionsInterval),
    enable_healthcheck: cdktf.booleanToTerraform(struct!.enableHealthcheck),
    enable_sniff: cdktf.booleanToTerraform(struct!.enableSniff),
    indices: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreElasticsearchIndicesToTerraform(struct!.indices),
    log_level: cdktf.stringToTerraform(struct!.logLevel),
    url: cdktf.stringToTerraform(struct!.url),
    username: cdktf.stringToTerraform(struct!.username),
    version: cdktf.stringToTerraform(struct!.version),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreElasticsearchToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreElasticsearch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    close_idle_connections_interval: {
      value: cdktf.stringToHclTerraform(struct!.closeIdleConnectionsInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enable_healthcheck: {
      value: cdktf.booleanToHclTerraform(struct!.enableHealthcheck),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_sniff: {
      value: cdktf.booleanToHclTerraform(struct!.enableSniff),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    indices: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreElasticsearchIndicesToHclTerraform(struct!.indices),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreElasticsearchIndices",
    },
    log_level: {
      value: cdktf.stringToHclTerraform(struct!.logLevel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    version: {
      value: cdktf.stringToHclTerraform(struct!.version),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreElasticsearchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreElasticsearch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._closeIdleConnectionsInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.closeIdleConnectionsInterval = this._closeIdleConnectionsInterval;
    }
    if (this._enableHealthcheck !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHealthcheck = this._enableHealthcheck;
    }
    if (this._enableSniff !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableSniff = this._enableSniff;
    }
    if (this._indices?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.indices = this._indices?.internalValue;
    }
    if (this._logLevel !== undefined) {
      hasAnyValues = true;
      internalValueResult.logLevel = this._logLevel;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    if (this._version !== undefined) {
      hasAnyValues = true;
      internalValueResult.version = this._version;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreElasticsearch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._closeIdleConnectionsInterval = undefined;
      this._enableHealthcheck = undefined;
      this._enableSniff = undefined;
      this._indices.internalValue = undefined;
      this._logLevel = undefined;
      this._url = undefined;
      this._username = undefined;
      this._version = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._closeIdleConnectionsInterval = value.closeIdleConnectionsInterval;
      this._enableHealthcheck = value.enableHealthcheck;
      this._enableSniff = value.enableSniff;
      this._indices.internalValue = value.indices;
      this._logLevel = value.logLevel;
      this._url = value.url;
      this._username = value.username;
      this._version = value.version;
    }
  }

  // close_idle_connections_interval - computed: false, optional: true, required: false
  private _closeIdleConnectionsInterval?: string; 
  public get closeIdleConnectionsInterval() {
    return this.getStringAttribute('close_idle_connections_interval');
  }
  public set closeIdleConnectionsInterval(value: string) {
    this._closeIdleConnectionsInterval = value;
  }
  public resetCloseIdleConnectionsInterval() {
    this._closeIdleConnectionsInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get closeIdleConnectionsIntervalInput() {
    return this._closeIdleConnectionsInterval;
  }

  // enable_healthcheck - computed: false, optional: true, required: false
  private _enableHealthcheck?: boolean | cdktf.IResolvable; 
  public get enableHealthcheck() {
    return this.getBooleanAttribute('enable_healthcheck');
  }
  public set enableHealthcheck(value: boolean | cdktf.IResolvable) {
    this._enableHealthcheck = value;
  }
  public resetEnableHealthcheck() {
    this._enableHealthcheck = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHealthcheckInput() {
    return this._enableHealthcheck;
  }

  // enable_sniff - computed: false, optional: true, required: false
  private _enableSniff?: boolean | cdktf.IResolvable; 
  public get enableSniff() {
    return this.getBooleanAttribute('enable_sniff');
  }
  public set enableSniff(value: boolean | cdktf.IResolvable) {
    this._enableSniff = value;
  }
  public resetEnableSniff() {
    this._enableSniff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableSniffInput() {
    return this._enableSniff;
  }

  // indices - computed: false, optional: false, required: true
  private _indices = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreElasticsearchIndicesOutputReference(this, "indices");
  public get indices() {
    return this._indices;
  }
  public putIndices(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreElasticsearchIndices) {
    this._indices.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get indicesInput() {
    return this._indices.internalValue;
  }

  // log_level - computed: false, optional: true, required: false
  private _logLevel?: string; 
  public get logLevel() {
    return this.getStringAttribute('log_level');
  }
  public set logLevel(value: string) {
    this._logLevel = value;
  }
  public resetLogLevel() {
    this._logLevel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logLevelInput() {
    return this._logLevel;
  }

  // url - computed: false, optional: false, required: true
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }

  // username - computed: false, optional: false, required: true
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }

  // version - computed: false, optional: false, required: true
  private _version?: string; 
  public get version() {
    return this.getStringAttribute('version');
  }
  public set version(value: string) {
    this._version = value;
  }
  // Temporarily expose input value. Use with caution.
  public get versionInput() {
    return this._version;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStorePasswordSecretRef {
  /**
  * Key in the Secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#key DataK8STemporalIoTemporalClusterV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * Name of the Secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#name DataK8STemporalIoTemporalClusterV1Beta1Manifest#name}
  */
  readonly name: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStorePasswordSecretRefToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStorePasswordSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStorePasswordSecretRefToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStorePasswordSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStorePasswordSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStorePasswordSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStorePasswordSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreSql {
  /**
  * ConnectAddr is the remote addr of the database.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#connect_addr DataK8STemporalIoTemporalClusterV1Beta1Manifest#connect_addr}
  */
  readonly connectAddr: string;
  /**
  * ConnectAttributes is a set of key-value attributes to be sent as part of connect data_source_name url
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#connect_attributes DataK8STemporalIoTemporalClusterV1Beta1Manifest#connect_attributes}
  */
  readonly connectAttributes?: { [key: string]: string };
  /**
  * ConnectProtocol is the protocol that goes with the ConnectAddr.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#connect_protocol DataK8STemporalIoTemporalClusterV1Beta1Manifest#connect_protocol}
  */
  readonly connectProtocol?: string;
  /**
  * DatabaseName is the name of SQL database to connect to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#database_name DataK8STemporalIoTemporalClusterV1Beta1Manifest#database_name}
  */
  readonly databaseName: string;
  /**
  * GCPServiceAccount is the service account to use to authenticate with GCP CloudSQL.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#gcp_service_account DataK8STemporalIoTemporalClusterV1Beta1Manifest#gcp_service_account}
  */
  readonly gcpServiceAccount?: string;
  /**
  * MaxConnLifetime is the maximum time a connection can be alive
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#max_conn_lifetime DataK8STemporalIoTemporalClusterV1Beta1Manifest#max_conn_lifetime}
  */
  readonly maxConnLifetime?: string;
  /**
  * MaxConns the max number of connections to this datastore.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#max_conns DataK8STemporalIoTemporalClusterV1Beta1Manifest#max_conns}
  */
  readonly maxConns?: number;
  /**
  * MaxIdleConns is the max number of idle connections to this datastore.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#max_idle_conns DataK8STemporalIoTemporalClusterV1Beta1Manifest#max_idle_conns}
  */
  readonly maxIdleConns?: number;
  /**
  * PluginName is the name of SQL plugin.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#plugin_name DataK8STemporalIoTemporalClusterV1Beta1Manifest#plugin_name}
  */
  readonly pluginName: string;
  /**
  * TaskScanPartitions is the number of partitions to sequentially scan during ListTaskQueue operations.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#task_scan_partitions DataK8STemporalIoTemporalClusterV1Beta1Manifest#task_scan_partitions}
  */
  readonly taskScanPartitions?: number;
  /**
  * User is the username to be used for the connection.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#user DataK8STemporalIoTemporalClusterV1Beta1Manifest#user}
  */
  readonly user: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreSqlToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreSql | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connect_addr: cdktf.stringToTerraform(struct!.connectAddr),
    connect_attributes: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.connectAttributes),
    connect_protocol: cdktf.stringToTerraform(struct!.connectProtocol),
    database_name: cdktf.stringToTerraform(struct!.databaseName),
    gcp_service_account: cdktf.stringToTerraform(struct!.gcpServiceAccount),
    max_conn_lifetime: cdktf.stringToTerraform(struct!.maxConnLifetime),
    max_conns: cdktf.numberToTerraform(struct!.maxConns),
    max_idle_conns: cdktf.numberToTerraform(struct!.maxIdleConns),
    plugin_name: cdktf.stringToTerraform(struct!.pluginName),
    task_scan_partitions: cdktf.numberToTerraform(struct!.taskScanPartitions),
    user: cdktf.stringToTerraform(struct!.user),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreSqlToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreSql | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connect_addr: {
      value: cdktf.stringToHclTerraform(struct!.connectAddr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connect_attributes: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.connectAttributes),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    connect_protocol: {
      value: cdktf.stringToHclTerraform(struct!.connectProtocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    database_name: {
      value: cdktf.stringToHclTerraform(struct!.databaseName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    gcp_service_account: {
      value: cdktf.stringToHclTerraform(struct!.gcpServiceAccount),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_conn_lifetime: {
      value: cdktf.stringToHclTerraform(struct!.maxConnLifetime),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_conns: {
      value: cdktf.numberToHclTerraform(struct!.maxConns),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_idle_conns: {
      value: cdktf.numberToHclTerraform(struct!.maxIdleConns),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    plugin_name: {
      value: cdktf.stringToHclTerraform(struct!.pluginName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    task_scan_partitions: {
      value: cdktf.numberToHclTerraform(struct!.taskScanPartitions),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    user: {
      value: cdktf.stringToHclTerraform(struct!.user),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreSqlOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreSql | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connectAddr !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectAddr = this._connectAddr;
    }
    if (this._connectAttributes !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectAttributes = this._connectAttributes;
    }
    if (this._connectProtocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectProtocol = this._connectProtocol;
    }
    if (this._databaseName !== undefined) {
      hasAnyValues = true;
      internalValueResult.databaseName = this._databaseName;
    }
    if (this._gcpServiceAccount !== undefined) {
      hasAnyValues = true;
      internalValueResult.gcpServiceAccount = this._gcpServiceAccount;
    }
    if (this._maxConnLifetime !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxConnLifetime = this._maxConnLifetime;
    }
    if (this._maxConns !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxConns = this._maxConns;
    }
    if (this._maxIdleConns !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxIdleConns = this._maxIdleConns;
    }
    if (this._pluginName !== undefined) {
      hasAnyValues = true;
      internalValueResult.pluginName = this._pluginName;
    }
    if (this._taskScanPartitions !== undefined) {
      hasAnyValues = true;
      internalValueResult.taskScanPartitions = this._taskScanPartitions;
    }
    if (this._user !== undefined) {
      hasAnyValues = true;
      internalValueResult.user = this._user;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreSql | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connectAddr = undefined;
      this._connectAttributes = undefined;
      this._connectProtocol = undefined;
      this._databaseName = undefined;
      this._gcpServiceAccount = undefined;
      this._maxConnLifetime = undefined;
      this._maxConns = undefined;
      this._maxIdleConns = undefined;
      this._pluginName = undefined;
      this._taskScanPartitions = undefined;
      this._user = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connectAddr = value.connectAddr;
      this._connectAttributes = value.connectAttributes;
      this._connectProtocol = value.connectProtocol;
      this._databaseName = value.databaseName;
      this._gcpServiceAccount = value.gcpServiceAccount;
      this._maxConnLifetime = value.maxConnLifetime;
      this._maxConns = value.maxConns;
      this._maxIdleConns = value.maxIdleConns;
      this._pluginName = value.pluginName;
      this._taskScanPartitions = value.taskScanPartitions;
      this._user = value.user;
    }
  }

  // connect_addr - computed: false, optional: false, required: true
  private _connectAddr?: string; 
  public get connectAddr() {
    return this.getStringAttribute('connect_addr');
  }
  public set connectAddr(value: string) {
    this._connectAddr = value;
  }
  // Temporarily expose input value. Use with caution.
  public get connectAddrInput() {
    return this._connectAddr;
  }

  // connect_attributes - computed: false, optional: true, required: false
  private _connectAttributes?: { [key: string]: string }; 
  public get connectAttributes() {
    return this.getStringMapAttribute('connect_attributes');
  }
  public set connectAttributes(value: { [key: string]: string }) {
    this._connectAttributes = value;
  }
  public resetConnectAttributes() {
    this._connectAttributes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectAttributesInput() {
    return this._connectAttributes;
  }

  // connect_protocol - computed: false, optional: true, required: false
  private _connectProtocol?: string; 
  public get connectProtocol() {
    return this.getStringAttribute('connect_protocol');
  }
  public set connectProtocol(value: string) {
    this._connectProtocol = value;
  }
  public resetConnectProtocol() {
    this._connectProtocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectProtocolInput() {
    return this._connectProtocol;
  }

  // database_name - computed: false, optional: false, required: true
  private _databaseName?: string; 
  public get databaseName() {
    return this.getStringAttribute('database_name');
  }
  public set databaseName(value: string) {
    this._databaseName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseNameInput() {
    return this._databaseName;
  }

  // gcp_service_account - computed: false, optional: true, required: false
  private _gcpServiceAccount?: string; 
  public get gcpServiceAccount() {
    return this.getStringAttribute('gcp_service_account');
  }
  public set gcpServiceAccount(value: string) {
    this._gcpServiceAccount = value;
  }
  public resetGcpServiceAccount() {
    this._gcpServiceAccount = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gcpServiceAccountInput() {
    return this._gcpServiceAccount;
  }

  // max_conn_lifetime - computed: false, optional: true, required: false
  private _maxConnLifetime?: string; 
  public get maxConnLifetime() {
    return this.getStringAttribute('max_conn_lifetime');
  }
  public set maxConnLifetime(value: string) {
    this._maxConnLifetime = value;
  }
  public resetMaxConnLifetime() {
    this._maxConnLifetime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxConnLifetimeInput() {
    return this._maxConnLifetime;
  }

  // max_conns - computed: false, optional: true, required: false
  private _maxConns?: number; 
  public get maxConns() {
    return this.getNumberAttribute('max_conns');
  }
  public set maxConns(value: number) {
    this._maxConns = value;
  }
  public resetMaxConns() {
    this._maxConns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxConnsInput() {
    return this._maxConns;
  }

  // max_idle_conns - computed: false, optional: true, required: false
  private _maxIdleConns?: number; 
  public get maxIdleConns() {
    return this.getNumberAttribute('max_idle_conns');
  }
  public set maxIdleConns(value: number) {
    this._maxIdleConns = value;
  }
  public resetMaxIdleConns() {
    this._maxIdleConns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxIdleConnsInput() {
    return this._maxIdleConns;
  }

  // plugin_name - computed: false, optional: false, required: true
  private _pluginName?: string; 
  public get pluginName() {
    return this.getStringAttribute('plugin_name');
  }
  public set pluginName(value: string) {
    this._pluginName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pluginNameInput() {
    return this._pluginName;
  }

  // task_scan_partitions - computed: false, optional: true, required: false
  private _taskScanPartitions?: number; 
  public get taskScanPartitions() {
    return this.getNumberAttribute('task_scan_partitions');
  }
  public set taskScanPartitions(value: number) {
    this._taskScanPartitions = value;
  }
  public resetTaskScanPartitions() {
    this._taskScanPartitions = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get taskScanPartitionsInput() {
    return this._taskScanPartitions;
  }

  // user - computed: false, optional: false, required: true
  private _user?: string; 
  public get user() {
    return this.getStringAttribute('user');
  }
  public set user(value: string) {
    this._user = value;
  }
  // Temporarily expose input value. Use with caution.
  public get userInput() {
    return this._user;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreTlsCaFileRef {
  /**
  * Key in the Secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#key DataK8STemporalIoTemporalClusterV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * Name of the Secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#name DataK8STemporalIoTemporalClusterV1Beta1Manifest#name}
  */
  readonly name: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreTlsCaFileRefToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreTlsCaFileRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreTlsCaFileRefToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreTlsCaFileRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreTlsCaFileRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreTlsCaFileRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreTlsCaFileRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreTlsCertFileRef {
  /**
  * Key in the Secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#key DataK8STemporalIoTemporalClusterV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * Name of the Secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#name DataK8STemporalIoTemporalClusterV1Beta1Manifest#name}
  */
  readonly name: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreTlsCertFileRefToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreTlsCertFileRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreTlsCertFileRefToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreTlsCertFileRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreTlsCertFileRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreTlsCertFileRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreTlsCertFileRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreTlsKeyFileRef {
  /**
  * Key in the Secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#key DataK8STemporalIoTemporalClusterV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * Name of the Secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#name DataK8STemporalIoTemporalClusterV1Beta1Manifest#name}
  */
  readonly name: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreTlsKeyFileRefToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreTlsKeyFileRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreTlsKeyFileRefToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreTlsKeyFileRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreTlsKeyFileRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreTlsKeyFileRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreTlsKeyFileRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreTls {
  /**
  * CaFileRef is a reference to a secret containing the ca file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#ca_file_ref DataK8STemporalIoTemporalClusterV1Beta1Manifest#ca_file_ref}
  */
  readonly caFileRef?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreTlsCaFileRef;
  /**
  * CertFileRef is a reference to a secret containing the cert file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#cert_file_ref DataK8STemporalIoTemporalClusterV1Beta1Manifest#cert_file_ref}
  */
  readonly certFileRef?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreTlsCertFileRef;
  /**
  * EnableHostVerification defines if the hostname should be verified when connecting to the datastore.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#enable_host_verification DataK8STemporalIoTemporalClusterV1Beta1Manifest#enable_host_verification}
  */
  readonly enableHostVerification: boolean | cdktf.IResolvable;
  /**
  * Enabled defines if the cluster should use a TLS connection to connect to the datastore.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#enabled DataK8STemporalIoTemporalClusterV1Beta1Manifest#enabled}
  */
  readonly enabled: boolean | cdktf.IResolvable;
  /**
  * KeyFileRef is a reference to a secret containing the key file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#key_file_ref DataK8STemporalIoTemporalClusterV1Beta1Manifest#key_file_ref}
  */
  readonly keyFileRef?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreTlsKeyFileRef;
  /**
  * ServerName the datastore should present.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#server_name DataK8STemporalIoTemporalClusterV1Beta1Manifest#server_name}
  */
  readonly serverName?: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreTlsToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_file_ref: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreTlsCaFileRefToTerraform(struct!.caFileRef),
    cert_file_ref: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreTlsCertFileRefToTerraform(struct!.certFileRef),
    enable_host_verification: cdktf.booleanToTerraform(struct!.enableHostVerification),
    enabled: cdktf.booleanToTerraform(struct!.enabled),
    key_file_ref: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreTlsKeyFileRefToTerraform(struct!.keyFileRef),
    server_name: cdktf.stringToTerraform(struct!.serverName),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreTlsToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_file_ref: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreTlsCaFileRefToHclTerraform(struct!.caFileRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreTlsCaFileRef",
    },
    cert_file_ref: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreTlsCertFileRefToHclTerraform(struct!.certFileRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreTlsCertFileRef",
    },
    enable_host_verification: {
      value: cdktf.booleanToHclTerraform(struct!.enableHostVerification),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    key_file_ref: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreTlsKeyFileRefToHclTerraform(struct!.keyFileRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreTlsKeyFileRef",
    },
    server_name: {
      value: cdktf.stringToHclTerraform(struct!.serverName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caFileRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.caFileRef = this._caFileRef?.internalValue;
    }
    if (this._certFileRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.certFileRef = this._certFileRef?.internalValue;
    }
    if (this._enableHostVerification !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHostVerification = this._enableHostVerification;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._keyFileRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyFileRef = this._keyFileRef?.internalValue;
    }
    if (this._serverName !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverName = this._serverName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caFileRef.internalValue = undefined;
      this._certFileRef.internalValue = undefined;
      this._enableHostVerification = undefined;
      this._enabled = undefined;
      this._keyFileRef.internalValue = undefined;
      this._serverName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caFileRef.internalValue = value.caFileRef;
      this._certFileRef.internalValue = value.certFileRef;
      this._enableHostVerification = value.enableHostVerification;
      this._enabled = value.enabled;
      this._keyFileRef.internalValue = value.keyFileRef;
      this._serverName = value.serverName;
    }
  }

  // ca_file_ref - computed: false, optional: true, required: false
  private _caFileRef = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreTlsCaFileRefOutputReference(this, "ca_file_ref");
  public get caFileRef() {
    return this._caFileRef;
  }
  public putCaFileRef(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreTlsCaFileRef) {
    this._caFileRef.internalValue = value;
  }
  public resetCaFileRef() {
    this._caFileRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caFileRefInput() {
    return this._caFileRef.internalValue;
  }

  // cert_file_ref - computed: false, optional: true, required: false
  private _certFileRef = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreTlsCertFileRefOutputReference(this, "cert_file_ref");
  public get certFileRef() {
    return this._certFileRef;
  }
  public putCertFileRef(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreTlsCertFileRef) {
    this._certFileRef.internalValue = value;
  }
  public resetCertFileRef() {
    this._certFileRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certFileRefInput() {
    return this._certFileRef.internalValue;
  }

  // enable_host_verification - computed: false, optional: false, required: true
  private _enableHostVerification?: boolean | cdktf.IResolvable; 
  public get enableHostVerification() {
    return this.getBooleanAttribute('enable_host_verification');
  }
  public set enableHostVerification(value: boolean | cdktf.IResolvable) {
    this._enableHostVerification = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHostVerificationInput() {
    return this._enableHostVerification;
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // key_file_ref - computed: false, optional: true, required: false
  private _keyFileRef = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreTlsKeyFileRefOutputReference(this, "key_file_ref");
  public get keyFileRef() {
    return this._keyFileRef;
  }
  public putKeyFileRef(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreTlsKeyFileRef) {
    this._keyFileRef.internalValue = value;
  }
  public resetKeyFileRef() {
    this._keyFileRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyFileRefInput() {
    return this._keyFileRef.internalValue;
  }

  // server_name - computed: false, optional: true, required: false
  private _serverName?: string; 
  public get serverName() {
    return this.getStringAttribute('server_name');
  }
  public set serverName(value: string) {
    this._serverName = value;
  }
  public resetServerName() {
    this._serverName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverNameInput() {
    return this._serverName;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStore {
  /**
  * Cassandra holds all connection parameters for Cassandra datastore. Note that cassandra is now deprecated for visibility store.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#cassandra DataK8STemporalIoTemporalClusterV1Beta1Manifest#cassandra}
  */
  readonly cassandra?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreCassandra;
  /**
  * Elasticsearch holds all connection parameters for Elasticsearch datastores.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#elasticsearch DataK8STemporalIoTemporalClusterV1Beta1Manifest#elasticsearch}
  */
  readonly elasticsearch?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreElasticsearch;
  /**
  * Name is the name of the datastore. It should be unique and will be referenced within the persistence spec. Defaults to 'default' for default sore, 'visibility' for visibility store, 'secondaryVisibility' for secondary visibility store and 'advancedVisibility' for advanced visibility store.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#name DataK8STemporalIoTemporalClusterV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * PasswordSecret is the reference to the secret holding the password.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#password_secret_ref DataK8STemporalIoTemporalClusterV1Beta1Manifest#password_secret_ref}
  */
  readonly passwordSecretRef?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStorePasswordSecretRef;
  /**
  * SkipCreate instructs the operator to skip creating the database for SQL datastores or to skip creating keyspace for Cassandra. Use this option if your database or keyspace has already been provisioned by an administrator.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#skip_create DataK8STemporalIoTemporalClusterV1Beta1Manifest#skip_create}
  */
  readonly skipCreate?: boolean | cdktf.IResolvable;
  /**
  * SQL holds all connection parameters for SQL datastores.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#sql DataK8STemporalIoTemporalClusterV1Beta1Manifest#sql}
  */
  readonly sql?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreSql;
  /**
  * TLS is an optional option to connect to the datastore using TLS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#tls DataK8STemporalIoTemporalClusterV1Beta1Manifest#tls}
  */
  readonly tls?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreTls;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStore | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cassandra: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreCassandraToTerraform(struct!.cassandra),
    elasticsearch: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreElasticsearchToTerraform(struct!.elasticsearch),
    name: cdktf.stringToTerraform(struct!.name),
    password_secret_ref: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStorePasswordSecretRefToTerraform(struct!.passwordSecretRef),
    skip_create: cdktf.booleanToTerraform(struct!.skipCreate),
    sql: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreSqlToTerraform(struct!.sql),
    tls: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreTlsToTerraform(struct!.tls),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStore | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cassandra: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreCassandraToHclTerraform(struct!.cassandra),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreCassandra",
    },
    elasticsearch: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreElasticsearchToHclTerraform(struct!.elasticsearch),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreElasticsearch",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password_secret_ref: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStorePasswordSecretRefToHclTerraform(struct!.passwordSecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStorePasswordSecretRef",
    },
    skip_create: {
      value: cdktf.booleanToHclTerraform(struct!.skipCreate),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    sql: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreSqlToHclTerraform(struct!.sql),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreSql",
    },
    tls: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreTls",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStore | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cassandra?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cassandra = this._cassandra?.internalValue;
    }
    if (this._elasticsearch?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.elasticsearch = this._elasticsearch?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._passwordSecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.passwordSecretRef = this._passwordSecretRef?.internalValue;
    }
    if (this._skipCreate !== undefined) {
      hasAnyValues = true;
      internalValueResult.skipCreate = this._skipCreate;
    }
    if (this._sql?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sql = this._sql?.internalValue;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStore | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cassandra.internalValue = undefined;
      this._elasticsearch.internalValue = undefined;
      this._name = undefined;
      this._passwordSecretRef.internalValue = undefined;
      this._skipCreate = undefined;
      this._sql.internalValue = undefined;
      this._tls.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cassandra.internalValue = value.cassandra;
      this._elasticsearch.internalValue = value.elasticsearch;
      this._name = value.name;
      this._passwordSecretRef.internalValue = value.passwordSecretRef;
      this._skipCreate = value.skipCreate;
      this._sql.internalValue = value.sql;
      this._tls.internalValue = value.tls;
    }
  }

  // cassandra - computed: false, optional: true, required: false
  private _cassandra = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreCassandraOutputReference(this, "cassandra");
  public get cassandra() {
    return this._cassandra;
  }
  public putCassandra(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreCassandra) {
    this._cassandra.internalValue = value;
  }
  public resetCassandra() {
    this._cassandra.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cassandraInput() {
    return this._cassandra.internalValue;
  }

  // elasticsearch - computed: false, optional: true, required: false
  private _elasticsearch = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreElasticsearchOutputReference(this, "elasticsearch");
  public get elasticsearch() {
    return this._elasticsearch;
  }
  public putElasticsearch(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreElasticsearch) {
    this._elasticsearch.internalValue = value;
  }
  public resetElasticsearch() {
    this._elasticsearch.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get elasticsearchInput() {
    return this._elasticsearch.internalValue;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // password_secret_ref - computed: false, optional: true, required: false
  private _passwordSecretRef = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStorePasswordSecretRefOutputReference(this, "password_secret_ref");
  public get passwordSecretRef() {
    return this._passwordSecretRef;
  }
  public putPasswordSecretRef(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStorePasswordSecretRef) {
    this._passwordSecretRef.internalValue = value;
  }
  public resetPasswordSecretRef() {
    this._passwordSecretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordSecretRefInput() {
    return this._passwordSecretRef.internalValue;
  }

  // skip_create - computed: false, optional: true, required: false
  private _skipCreate?: boolean | cdktf.IResolvable; 
  public get skipCreate() {
    return this.getBooleanAttribute('skip_create');
  }
  public set skipCreate(value: boolean | cdktf.IResolvable) {
    this._skipCreate = value;
  }
  public resetSkipCreate() {
    this._skipCreate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get skipCreateInput() {
    return this._skipCreate;
  }

  // sql - computed: false, optional: true, required: false
  private _sql = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreSqlOutputReference(this, "sql");
  public get sql() {
    return this._sql;
  }
  public putSql(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreSql) {
    this._sql.internalValue = value;
  }
  public resetSql() {
    this._sql.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sqlInput() {
    return this._sql.internalValue;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreCassandraConsistency {
  /**
  * Consistency sets the default consistency level. Values identical to gocql Consistency values. (defaults to LOCAL_QUORUM if not set).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#consistency DataK8STemporalIoTemporalClusterV1Beta1Manifest#consistency}
  */
  readonly consistency?: number;
  /**
  * SerialConsistency sets the consistency for the serial prtion of queries. Values identical to gocql SerialConsistency values. (defaults to LOCAL_SERIAL if not set)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#serial_consistency DataK8STemporalIoTemporalClusterV1Beta1Manifest#serial_consistency}
  */
  readonly serialConsistency?: number;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreCassandraConsistencyToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreCassandraConsistency | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    consistency: cdktf.numberToTerraform(struct!.consistency),
    serial_consistency: cdktf.numberToTerraform(struct!.serialConsistency),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreCassandraConsistencyToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreCassandraConsistency | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    consistency: {
      value: cdktf.numberToHclTerraform(struct!.consistency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    serial_consistency: {
      value: cdktf.numberToHclTerraform(struct!.serialConsistency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreCassandraConsistencyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreCassandraConsistency | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._consistency !== undefined) {
      hasAnyValues = true;
      internalValueResult.consistency = this._consistency;
    }
    if (this._serialConsistency !== undefined) {
      hasAnyValues = true;
      internalValueResult.serialConsistency = this._serialConsistency;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreCassandraConsistency | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._consistency = undefined;
      this._serialConsistency = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._consistency = value.consistency;
      this._serialConsistency = value.serialConsistency;
    }
  }

  // consistency - computed: false, optional: true, required: false
  private _consistency?: number; 
  public get consistency() {
    return this.getNumberAttribute('consistency');
  }
  public set consistency(value: number) {
    this._consistency = value;
  }
  public resetConsistency() {
    this._consistency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get consistencyInput() {
    return this._consistency;
  }

  // serial_consistency - computed: false, optional: true, required: false
  private _serialConsistency?: number; 
  public get serialConsistency() {
    return this.getNumberAttribute('serial_consistency');
  }
  public set serialConsistency(value: number) {
    this._serialConsistency = value;
  }
  public resetSerialConsistency() {
    this._serialConsistency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serialConsistencyInput() {
    return this._serialConsistency;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreCassandra {
  /**
  * ConnectTimeout is a timeout for initial dial to cassandra server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#connect_timeout DataK8STemporalIoTemporalClusterV1Beta1Manifest#connect_timeout}
  */
  readonly connectTimeout?: string;
  /**
  * Consistency configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#consistency DataK8STemporalIoTemporalClusterV1Beta1Manifest#consistency}
  */
  readonly consistency?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreCassandraConsistency;
  /**
  * Datacenter is the data center filter arg for cassandra.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#datacenter DataK8STemporalIoTemporalClusterV1Beta1Manifest#datacenter}
  */
  readonly datacenter?: string;
  /**
  * DisableInitialHostLookup instructs the gocql client to connect only using the supplied hosts.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#disable_initial_host_lookup DataK8STemporalIoTemporalClusterV1Beta1Manifest#disable_initial_host_lookup}
  */
  readonly disableInitialHostLookup?: boolean | cdktf.IResolvable;
  /**
  * Hosts is a list of cassandra endpoints.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#hosts DataK8STemporalIoTemporalClusterV1Beta1Manifest#hosts}
  */
  readonly hosts: string[];
  /**
  * Keyspace is the cassandra keyspace.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#keyspace DataK8STemporalIoTemporalClusterV1Beta1Manifest#keyspace}
  */
  readonly keyspace: string;
  /**
  * MaxConns is the max number of connections to this datastore for a single keyspace.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#max_conns DataK8STemporalIoTemporalClusterV1Beta1Manifest#max_conns}
  */
  readonly maxConns?: number;
  /**
  * Port is the cassandra port used for connection by gocql client.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#port DataK8STemporalIoTemporalClusterV1Beta1Manifest#port}
  */
  readonly port: number;
  /**
  * User is the cassandra user used for authentication by gocql client.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#user DataK8STemporalIoTemporalClusterV1Beta1Manifest#user}
  */
  readonly user: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreCassandraToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreCassandra | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connect_timeout: cdktf.stringToTerraform(struct!.connectTimeout),
    consistency: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreCassandraConsistencyToTerraform(struct!.consistency),
    datacenter: cdktf.stringToTerraform(struct!.datacenter),
    disable_initial_host_lookup: cdktf.booleanToTerraform(struct!.disableInitialHostLookup),
    hosts: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.hosts),
    keyspace: cdktf.stringToTerraform(struct!.keyspace),
    max_conns: cdktf.numberToTerraform(struct!.maxConns),
    port: cdktf.numberToTerraform(struct!.port),
    user: cdktf.stringToTerraform(struct!.user),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreCassandraToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreCassandra | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connect_timeout: {
      value: cdktf.stringToHclTerraform(struct!.connectTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    consistency: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreCassandraConsistencyToHclTerraform(struct!.consistency),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreCassandraConsistency",
    },
    datacenter: {
      value: cdktf.stringToHclTerraform(struct!.datacenter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disable_initial_host_lookup: {
      value: cdktf.booleanToHclTerraform(struct!.disableInitialHostLookup),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    hosts: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.hosts),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    keyspace: {
      value: cdktf.stringToHclTerraform(struct!.keyspace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_conns: {
      value: cdktf.numberToHclTerraform(struct!.maxConns),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    user: {
      value: cdktf.stringToHclTerraform(struct!.user),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreCassandraOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreCassandra | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connectTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectTimeout = this._connectTimeout;
    }
    if (this._consistency?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.consistency = this._consistency?.internalValue;
    }
    if (this._datacenter !== undefined) {
      hasAnyValues = true;
      internalValueResult.datacenter = this._datacenter;
    }
    if (this._disableInitialHostLookup !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableInitialHostLookup = this._disableInitialHostLookup;
    }
    if (this._hosts !== undefined) {
      hasAnyValues = true;
      internalValueResult.hosts = this._hosts;
    }
    if (this._keyspace !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyspace = this._keyspace;
    }
    if (this._maxConns !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxConns = this._maxConns;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._user !== undefined) {
      hasAnyValues = true;
      internalValueResult.user = this._user;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreCassandra | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connectTimeout = undefined;
      this._consistency.internalValue = undefined;
      this._datacenter = undefined;
      this._disableInitialHostLookup = undefined;
      this._hosts = undefined;
      this._keyspace = undefined;
      this._maxConns = undefined;
      this._port = undefined;
      this._user = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connectTimeout = value.connectTimeout;
      this._consistency.internalValue = value.consistency;
      this._datacenter = value.datacenter;
      this._disableInitialHostLookup = value.disableInitialHostLookup;
      this._hosts = value.hosts;
      this._keyspace = value.keyspace;
      this._maxConns = value.maxConns;
      this._port = value.port;
      this._user = value.user;
    }
  }

  // connect_timeout - computed: false, optional: true, required: false
  private _connectTimeout?: string; 
  public get connectTimeout() {
    return this.getStringAttribute('connect_timeout');
  }
  public set connectTimeout(value: string) {
    this._connectTimeout = value;
  }
  public resetConnectTimeout() {
    this._connectTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectTimeoutInput() {
    return this._connectTimeout;
  }

  // consistency - computed: false, optional: true, required: false
  private _consistency = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreCassandraConsistencyOutputReference(this, "consistency");
  public get consistency() {
    return this._consistency;
  }
  public putConsistency(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreCassandraConsistency) {
    this._consistency.internalValue = value;
  }
  public resetConsistency() {
    this._consistency.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get consistencyInput() {
    return this._consistency.internalValue;
  }

  // datacenter - computed: false, optional: true, required: false
  private _datacenter?: string; 
  public get datacenter() {
    return this.getStringAttribute('datacenter');
  }
  public set datacenter(value: string) {
    this._datacenter = value;
  }
  public resetDatacenter() {
    this._datacenter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get datacenterInput() {
    return this._datacenter;
  }

  // disable_initial_host_lookup - computed: false, optional: true, required: false
  private _disableInitialHostLookup?: boolean | cdktf.IResolvable; 
  public get disableInitialHostLookup() {
    return this.getBooleanAttribute('disable_initial_host_lookup');
  }
  public set disableInitialHostLookup(value: boolean | cdktf.IResolvable) {
    this._disableInitialHostLookup = value;
  }
  public resetDisableInitialHostLookup() {
    this._disableInitialHostLookup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableInitialHostLookupInput() {
    return this._disableInitialHostLookup;
  }

  // hosts - computed: false, optional: false, required: true
  private _hosts?: string[]; 
  public get hosts() {
    return this.getListAttribute('hosts');
  }
  public set hosts(value: string[]) {
    this._hosts = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostsInput() {
    return this._hosts;
  }

  // keyspace - computed: false, optional: false, required: true
  private _keyspace?: string; 
  public get keyspace() {
    return this.getStringAttribute('keyspace');
  }
  public set keyspace(value: string) {
    this._keyspace = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyspaceInput() {
    return this._keyspace;
  }

  // max_conns - computed: false, optional: true, required: false
  private _maxConns?: number; 
  public get maxConns() {
    return this.getNumberAttribute('max_conns');
  }
  public set maxConns(value: number) {
    this._maxConns = value;
  }
  public resetMaxConns() {
    this._maxConns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxConnsInput() {
    return this._maxConns;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // user - computed: false, optional: false, required: true
  private _user?: string; 
  public get user() {
    return this.getStringAttribute('user');
  }
  public set user(value: string) {
    this._user = value;
  }
  // Temporarily expose input value. Use with caution.
  public get userInput() {
    return this._user;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreElasticsearchIndices {
  /**
  * SecondaryVisibility defines secondary visibility's index name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#secondary_visibility DataK8STemporalIoTemporalClusterV1Beta1Manifest#secondary_visibility}
  */
  readonly secondaryVisibility?: string;
  /**
  * Visibility defines visibility's index name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#visibility DataK8STemporalIoTemporalClusterV1Beta1Manifest#visibility}
  */
  readonly visibility: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreElasticsearchIndicesToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreElasticsearchIndices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secondary_visibility: cdktf.stringToTerraform(struct!.secondaryVisibility),
    visibility: cdktf.stringToTerraform(struct!.visibility),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreElasticsearchIndicesToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreElasticsearchIndices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secondary_visibility: {
      value: cdktf.stringToHclTerraform(struct!.secondaryVisibility),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    visibility: {
      value: cdktf.stringToHclTerraform(struct!.visibility),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreElasticsearchIndicesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreElasticsearchIndices | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secondaryVisibility !== undefined) {
      hasAnyValues = true;
      internalValueResult.secondaryVisibility = this._secondaryVisibility;
    }
    if (this._visibility !== undefined) {
      hasAnyValues = true;
      internalValueResult.visibility = this._visibility;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreElasticsearchIndices | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secondaryVisibility = undefined;
      this._visibility = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secondaryVisibility = value.secondaryVisibility;
      this._visibility = value.visibility;
    }
  }

  // secondary_visibility - computed: false, optional: true, required: false
  private _secondaryVisibility?: string; 
  public get secondaryVisibility() {
    return this.getStringAttribute('secondary_visibility');
  }
  public set secondaryVisibility(value: string) {
    this._secondaryVisibility = value;
  }
  public resetSecondaryVisibility() {
    this._secondaryVisibility = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secondaryVisibilityInput() {
    return this._secondaryVisibility;
  }

  // visibility - computed: false, optional: false, required: true
  private _visibility?: string; 
  public get visibility() {
    return this.getStringAttribute('visibility');
  }
  public set visibility(value: string) {
    this._visibility = value;
  }
  // Temporarily expose input value. Use with caution.
  public get visibilityInput() {
    return this._visibility;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreElasticsearch {
  /**
  * CloseIdleConnectionsInterval is the max duration a connection stay open while idle.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#close_idle_connections_interval DataK8STemporalIoTemporalClusterV1Beta1Manifest#close_idle_connections_interval}
  */
  readonly closeIdleConnectionsInterval?: string;
  /**
  * EnableHealthcheck enables or disables healthcheck on the temporal cluster's es client.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#enable_healthcheck DataK8STemporalIoTemporalClusterV1Beta1Manifest#enable_healthcheck}
  */
  readonly enableHealthcheck?: boolean | cdktf.IResolvable;
  /**
  * EnableSniff enables or disables sniffer on the temporal cluster's es client.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#enable_sniff DataK8STemporalIoTemporalClusterV1Beta1Manifest#enable_sniff}
  */
  readonly enableSniff?: boolean | cdktf.IResolvable;
  /**
  * Indices holds visibility index names.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#indices DataK8STemporalIoTemporalClusterV1Beta1Manifest#indices}
  */
  readonly indices: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreElasticsearchIndices;
  /**
  * LogLevel defines the temporal cluster's es client logger level.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#log_level DataK8STemporalIoTemporalClusterV1Beta1Manifest#log_level}
  */
  readonly logLevel?: string;
  /**
  * URL is the connection url to connect to the instance.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#url DataK8STemporalIoTemporalClusterV1Beta1Manifest#url}
  */
  readonly url: string;
  /**
  * Username is the username to be used for the connection.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#username DataK8STemporalIoTemporalClusterV1Beta1Manifest#username}
  */
  readonly username: string;
  /**
  * Version defines the elasticsearch version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#version DataK8STemporalIoTemporalClusterV1Beta1Manifest#version}
  */
  readonly version: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreElasticsearchToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreElasticsearch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    close_idle_connections_interval: cdktf.stringToTerraform(struct!.closeIdleConnectionsInterval),
    enable_healthcheck: cdktf.booleanToTerraform(struct!.enableHealthcheck),
    enable_sniff: cdktf.booleanToTerraform(struct!.enableSniff),
    indices: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreElasticsearchIndicesToTerraform(struct!.indices),
    log_level: cdktf.stringToTerraform(struct!.logLevel),
    url: cdktf.stringToTerraform(struct!.url),
    username: cdktf.stringToTerraform(struct!.username),
    version: cdktf.stringToTerraform(struct!.version),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreElasticsearchToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreElasticsearch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    close_idle_connections_interval: {
      value: cdktf.stringToHclTerraform(struct!.closeIdleConnectionsInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enable_healthcheck: {
      value: cdktf.booleanToHclTerraform(struct!.enableHealthcheck),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_sniff: {
      value: cdktf.booleanToHclTerraform(struct!.enableSniff),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    indices: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreElasticsearchIndicesToHclTerraform(struct!.indices),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreElasticsearchIndices",
    },
    log_level: {
      value: cdktf.stringToHclTerraform(struct!.logLevel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    version: {
      value: cdktf.stringToHclTerraform(struct!.version),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreElasticsearchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreElasticsearch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._closeIdleConnectionsInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.closeIdleConnectionsInterval = this._closeIdleConnectionsInterval;
    }
    if (this._enableHealthcheck !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHealthcheck = this._enableHealthcheck;
    }
    if (this._enableSniff !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableSniff = this._enableSniff;
    }
    if (this._indices?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.indices = this._indices?.internalValue;
    }
    if (this._logLevel !== undefined) {
      hasAnyValues = true;
      internalValueResult.logLevel = this._logLevel;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    if (this._version !== undefined) {
      hasAnyValues = true;
      internalValueResult.version = this._version;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreElasticsearch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._closeIdleConnectionsInterval = undefined;
      this._enableHealthcheck = undefined;
      this._enableSniff = undefined;
      this._indices.internalValue = undefined;
      this._logLevel = undefined;
      this._url = undefined;
      this._username = undefined;
      this._version = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._closeIdleConnectionsInterval = value.closeIdleConnectionsInterval;
      this._enableHealthcheck = value.enableHealthcheck;
      this._enableSniff = value.enableSniff;
      this._indices.internalValue = value.indices;
      this._logLevel = value.logLevel;
      this._url = value.url;
      this._username = value.username;
      this._version = value.version;
    }
  }

  // close_idle_connections_interval - computed: false, optional: true, required: false
  private _closeIdleConnectionsInterval?: string; 
  public get closeIdleConnectionsInterval() {
    return this.getStringAttribute('close_idle_connections_interval');
  }
  public set closeIdleConnectionsInterval(value: string) {
    this._closeIdleConnectionsInterval = value;
  }
  public resetCloseIdleConnectionsInterval() {
    this._closeIdleConnectionsInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get closeIdleConnectionsIntervalInput() {
    return this._closeIdleConnectionsInterval;
  }

  // enable_healthcheck - computed: false, optional: true, required: false
  private _enableHealthcheck?: boolean | cdktf.IResolvable; 
  public get enableHealthcheck() {
    return this.getBooleanAttribute('enable_healthcheck');
  }
  public set enableHealthcheck(value: boolean | cdktf.IResolvable) {
    this._enableHealthcheck = value;
  }
  public resetEnableHealthcheck() {
    this._enableHealthcheck = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHealthcheckInput() {
    return this._enableHealthcheck;
  }

  // enable_sniff - computed: false, optional: true, required: false
  private _enableSniff?: boolean | cdktf.IResolvable; 
  public get enableSniff() {
    return this.getBooleanAttribute('enable_sniff');
  }
  public set enableSniff(value: boolean | cdktf.IResolvable) {
    this._enableSniff = value;
  }
  public resetEnableSniff() {
    this._enableSniff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableSniffInput() {
    return this._enableSniff;
  }

  // indices - computed: false, optional: false, required: true
  private _indices = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreElasticsearchIndicesOutputReference(this, "indices");
  public get indices() {
    return this._indices;
  }
  public putIndices(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreElasticsearchIndices) {
    this._indices.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get indicesInput() {
    return this._indices.internalValue;
  }

  // log_level - computed: false, optional: true, required: false
  private _logLevel?: string; 
  public get logLevel() {
    return this.getStringAttribute('log_level');
  }
  public set logLevel(value: string) {
    this._logLevel = value;
  }
  public resetLogLevel() {
    this._logLevel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logLevelInput() {
    return this._logLevel;
  }

  // url - computed: false, optional: false, required: true
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }

  // username - computed: false, optional: false, required: true
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }

  // version - computed: false, optional: false, required: true
  private _version?: string; 
  public get version() {
    return this.getStringAttribute('version');
  }
  public set version(value: string) {
    this._version = value;
  }
  // Temporarily expose input value. Use with caution.
  public get versionInput() {
    return this._version;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStorePasswordSecretRef {
  /**
  * Key in the Secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#key DataK8STemporalIoTemporalClusterV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * Name of the Secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#name DataK8STemporalIoTemporalClusterV1Beta1Manifest#name}
  */
  readonly name: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStorePasswordSecretRefToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStorePasswordSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStorePasswordSecretRefToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStorePasswordSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStorePasswordSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStorePasswordSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStorePasswordSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreSql {
  /**
  * ConnectAddr is the remote addr of the database.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#connect_addr DataK8STemporalIoTemporalClusterV1Beta1Manifest#connect_addr}
  */
  readonly connectAddr: string;
  /**
  * ConnectAttributes is a set of key-value attributes to be sent as part of connect data_source_name url
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#connect_attributes DataK8STemporalIoTemporalClusterV1Beta1Manifest#connect_attributes}
  */
  readonly connectAttributes?: { [key: string]: string };
  /**
  * ConnectProtocol is the protocol that goes with the ConnectAddr.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#connect_protocol DataK8STemporalIoTemporalClusterV1Beta1Manifest#connect_protocol}
  */
  readonly connectProtocol?: string;
  /**
  * DatabaseName is the name of SQL database to connect to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#database_name DataK8STemporalIoTemporalClusterV1Beta1Manifest#database_name}
  */
  readonly databaseName: string;
  /**
  * GCPServiceAccount is the service account to use to authenticate with GCP CloudSQL.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#gcp_service_account DataK8STemporalIoTemporalClusterV1Beta1Manifest#gcp_service_account}
  */
  readonly gcpServiceAccount?: string;
  /**
  * MaxConnLifetime is the maximum time a connection can be alive
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#max_conn_lifetime DataK8STemporalIoTemporalClusterV1Beta1Manifest#max_conn_lifetime}
  */
  readonly maxConnLifetime?: string;
  /**
  * MaxConns the max number of connections to this datastore.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#max_conns DataK8STemporalIoTemporalClusterV1Beta1Manifest#max_conns}
  */
  readonly maxConns?: number;
  /**
  * MaxIdleConns is the max number of idle connections to this datastore.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#max_idle_conns DataK8STemporalIoTemporalClusterV1Beta1Manifest#max_idle_conns}
  */
  readonly maxIdleConns?: number;
  /**
  * PluginName is the name of SQL plugin.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#plugin_name DataK8STemporalIoTemporalClusterV1Beta1Manifest#plugin_name}
  */
  readonly pluginName: string;
  /**
  * TaskScanPartitions is the number of partitions to sequentially scan during ListTaskQueue operations.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#task_scan_partitions DataK8STemporalIoTemporalClusterV1Beta1Manifest#task_scan_partitions}
  */
  readonly taskScanPartitions?: number;
  /**
  * User is the username to be used for the connection.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#user DataK8STemporalIoTemporalClusterV1Beta1Manifest#user}
  */
  readonly user: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreSqlToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreSql | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connect_addr: cdktf.stringToTerraform(struct!.connectAddr),
    connect_attributes: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.connectAttributes),
    connect_protocol: cdktf.stringToTerraform(struct!.connectProtocol),
    database_name: cdktf.stringToTerraform(struct!.databaseName),
    gcp_service_account: cdktf.stringToTerraform(struct!.gcpServiceAccount),
    max_conn_lifetime: cdktf.stringToTerraform(struct!.maxConnLifetime),
    max_conns: cdktf.numberToTerraform(struct!.maxConns),
    max_idle_conns: cdktf.numberToTerraform(struct!.maxIdleConns),
    plugin_name: cdktf.stringToTerraform(struct!.pluginName),
    task_scan_partitions: cdktf.numberToTerraform(struct!.taskScanPartitions),
    user: cdktf.stringToTerraform(struct!.user),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreSqlToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreSql | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connect_addr: {
      value: cdktf.stringToHclTerraform(struct!.connectAddr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connect_attributes: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.connectAttributes),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    connect_protocol: {
      value: cdktf.stringToHclTerraform(struct!.connectProtocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    database_name: {
      value: cdktf.stringToHclTerraform(struct!.databaseName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    gcp_service_account: {
      value: cdktf.stringToHclTerraform(struct!.gcpServiceAccount),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_conn_lifetime: {
      value: cdktf.stringToHclTerraform(struct!.maxConnLifetime),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_conns: {
      value: cdktf.numberToHclTerraform(struct!.maxConns),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_idle_conns: {
      value: cdktf.numberToHclTerraform(struct!.maxIdleConns),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    plugin_name: {
      value: cdktf.stringToHclTerraform(struct!.pluginName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    task_scan_partitions: {
      value: cdktf.numberToHclTerraform(struct!.taskScanPartitions),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    user: {
      value: cdktf.stringToHclTerraform(struct!.user),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreSqlOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreSql | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connectAddr !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectAddr = this._connectAddr;
    }
    if (this._connectAttributes !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectAttributes = this._connectAttributes;
    }
    if (this._connectProtocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectProtocol = this._connectProtocol;
    }
    if (this._databaseName !== undefined) {
      hasAnyValues = true;
      internalValueResult.databaseName = this._databaseName;
    }
    if (this._gcpServiceAccount !== undefined) {
      hasAnyValues = true;
      internalValueResult.gcpServiceAccount = this._gcpServiceAccount;
    }
    if (this._maxConnLifetime !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxConnLifetime = this._maxConnLifetime;
    }
    if (this._maxConns !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxConns = this._maxConns;
    }
    if (this._maxIdleConns !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxIdleConns = this._maxIdleConns;
    }
    if (this._pluginName !== undefined) {
      hasAnyValues = true;
      internalValueResult.pluginName = this._pluginName;
    }
    if (this._taskScanPartitions !== undefined) {
      hasAnyValues = true;
      internalValueResult.taskScanPartitions = this._taskScanPartitions;
    }
    if (this._user !== undefined) {
      hasAnyValues = true;
      internalValueResult.user = this._user;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreSql | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connectAddr = undefined;
      this._connectAttributes = undefined;
      this._connectProtocol = undefined;
      this._databaseName = undefined;
      this._gcpServiceAccount = undefined;
      this._maxConnLifetime = undefined;
      this._maxConns = undefined;
      this._maxIdleConns = undefined;
      this._pluginName = undefined;
      this._taskScanPartitions = undefined;
      this._user = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connectAddr = value.connectAddr;
      this._connectAttributes = value.connectAttributes;
      this._connectProtocol = value.connectProtocol;
      this._databaseName = value.databaseName;
      this._gcpServiceAccount = value.gcpServiceAccount;
      this._maxConnLifetime = value.maxConnLifetime;
      this._maxConns = value.maxConns;
      this._maxIdleConns = value.maxIdleConns;
      this._pluginName = value.pluginName;
      this._taskScanPartitions = value.taskScanPartitions;
      this._user = value.user;
    }
  }

  // connect_addr - computed: false, optional: false, required: true
  private _connectAddr?: string; 
  public get connectAddr() {
    return this.getStringAttribute('connect_addr');
  }
  public set connectAddr(value: string) {
    this._connectAddr = value;
  }
  // Temporarily expose input value. Use with caution.
  public get connectAddrInput() {
    return this._connectAddr;
  }

  // connect_attributes - computed: false, optional: true, required: false
  private _connectAttributes?: { [key: string]: string }; 
  public get connectAttributes() {
    return this.getStringMapAttribute('connect_attributes');
  }
  public set connectAttributes(value: { [key: string]: string }) {
    this._connectAttributes = value;
  }
  public resetConnectAttributes() {
    this._connectAttributes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectAttributesInput() {
    return this._connectAttributes;
  }

  // connect_protocol - computed: false, optional: true, required: false
  private _connectProtocol?: string; 
  public get connectProtocol() {
    return this.getStringAttribute('connect_protocol');
  }
  public set connectProtocol(value: string) {
    this._connectProtocol = value;
  }
  public resetConnectProtocol() {
    this._connectProtocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectProtocolInput() {
    return this._connectProtocol;
  }

  // database_name - computed: false, optional: false, required: true
  private _databaseName?: string; 
  public get databaseName() {
    return this.getStringAttribute('database_name');
  }
  public set databaseName(value: string) {
    this._databaseName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseNameInput() {
    return this._databaseName;
  }

  // gcp_service_account - computed: false, optional: true, required: false
  private _gcpServiceAccount?: string; 
  public get gcpServiceAccount() {
    return this.getStringAttribute('gcp_service_account');
  }
  public set gcpServiceAccount(value: string) {
    this._gcpServiceAccount = value;
  }
  public resetGcpServiceAccount() {
    this._gcpServiceAccount = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gcpServiceAccountInput() {
    return this._gcpServiceAccount;
  }

  // max_conn_lifetime - computed: false, optional: true, required: false
  private _maxConnLifetime?: string; 
  public get maxConnLifetime() {
    return this.getStringAttribute('max_conn_lifetime');
  }
  public set maxConnLifetime(value: string) {
    this._maxConnLifetime = value;
  }
  public resetMaxConnLifetime() {
    this._maxConnLifetime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxConnLifetimeInput() {
    return this._maxConnLifetime;
  }

  // max_conns - computed: false, optional: true, required: false
  private _maxConns?: number; 
  public get maxConns() {
    return this.getNumberAttribute('max_conns');
  }
  public set maxConns(value: number) {
    this._maxConns = value;
  }
  public resetMaxConns() {
    this._maxConns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxConnsInput() {
    return this._maxConns;
  }

  // max_idle_conns - computed: false, optional: true, required: false
  private _maxIdleConns?: number; 
  public get maxIdleConns() {
    return this.getNumberAttribute('max_idle_conns');
  }
  public set maxIdleConns(value: number) {
    this._maxIdleConns = value;
  }
  public resetMaxIdleConns() {
    this._maxIdleConns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxIdleConnsInput() {
    return this._maxIdleConns;
  }

  // plugin_name - computed: false, optional: false, required: true
  private _pluginName?: string; 
  public get pluginName() {
    return this.getStringAttribute('plugin_name');
  }
  public set pluginName(value: string) {
    this._pluginName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pluginNameInput() {
    return this._pluginName;
  }

  // task_scan_partitions - computed: false, optional: true, required: false
  private _taskScanPartitions?: number; 
  public get taskScanPartitions() {
    return this.getNumberAttribute('task_scan_partitions');
  }
  public set taskScanPartitions(value: number) {
    this._taskScanPartitions = value;
  }
  public resetTaskScanPartitions() {
    this._taskScanPartitions = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get taskScanPartitionsInput() {
    return this._taskScanPartitions;
  }

  // user - computed: false, optional: false, required: true
  private _user?: string; 
  public get user() {
    return this.getStringAttribute('user');
  }
  public set user(value: string) {
    this._user = value;
  }
  // Temporarily expose input value. Use with caution.
  public get userInput() {
    return this._user;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreTlsCaFileRef {
  /**
  * Key in the Secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#key DataK8STemporalIoTemporalClusterV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * Name of the Secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#name DataK8STemporalIoTemporalClusterV1Beta1Manifest#name}
  */
  readonly name: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreTlsCaFileRefToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreTlsCaFileRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreTlsCaFileRefToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreTlsCaFileRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreTlsCaFileRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreTlsCaFileRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreTlsCaFileRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreTlsCertFileRef {
  /**
  * Key in the Secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#key DataK8STemporalIoTemporalClusterV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * Name of the Secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#name DataK8STemporalIoTemporalClusterV1Beta1Manifest#name}
  */
  readonly name: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreTlsCertFileRefToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreTlsCertFileRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreTlsCertFileRefToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreTlsCertFileRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreTlsCertFileRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreTlsCertFileRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreTlsCertFileRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreTlsKeyFileRef {
  /**
  * Key in the Secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#key DataK8STemporalIoTemporalClusterV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * Name of the Secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#name DataK8STemporalIoTemporalClusterV1Beta1Manifest#name}
  */
  readonly name: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreTlsKeyFileRefToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreTlsKeyFileRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreTlsKeyFileRefToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreTlsKeyFileRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreTlsKeyFileRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreTlsKeyFileRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreTlsKeyFileRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreTls {
  /**
  * CaFileRef is a reference to a secret containing the ca file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#ca_file_ref DataK8STemporalIoTemporalClusterV1Beta1Manifest#ca_file_ref}
  */
  readonly caFileRef?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreTlsCaFileRef;
  /**
  * CertFileRef is a reference to a secret containing the cert file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#cert_file_ref DataK8STemporalIoTemporalClusterV1Beta1Manifest#cert_file_ref}
  */
  readonly certFileRef?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreTlsCertFileRef;
  /**
  * EnableHostVerification defines if the hostname should be verified when connecting to the datastore.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#enable_host_verification DataK8STemporalIoTemporalClusterV1Beta1Manifest#enable_host_verification}
  */
  readonly enableHostVerification: boolean | cdktf.IResolvable;
  /**
  * Enabled defines if the cluster should use a TLS connection to connect to the datastore.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#enabled DataK8STemporalIoTemporalClusterV1Beta1Manifest#enabled}
  */
  readonly enabled: boolean | cdktf.IResolvable;
  /**
  * KeyFileRef is a reference to a secret containing the key file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#key_file_ref DataK8STemporalIoTemporalClusterV1Beta1Manifest#key_file_ref}
  */
  readonly keyFileRef?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreTlsKeyFileRef;
  /**
  * ServerName the datastore should present.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#server_name DataK8STemporalIoTemporalClusterV1Beta1Manifest#server_name}
  */
  readonly serverName?: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreTlsToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_file_ref: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreTlsCaFileRefToTerraform(struct!.caFileRef),
    cert_file_ref: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreTlsCertFileRefToTerraform(struct!.certFileRef),
    enable_host_verification: cdktf.booleanToTerraform(struct!.enableHostVerification),
    enabled: cdktf.booleanToTerraform(struct!.enabled),
    key_file_ref: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreTlsKeyFileRefToTerraform(struct!.keyFileRef),
    server_name: cdktf.stringToTerraform(struct!.serverName),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreTlsToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_file_ref: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreTlsCaFileRefToHclTerraform(struct!.caFileRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreTlsCaFileRef",
    },
    cert_file_ref: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreTlsCertFileRefToHclTerraform(struct!.certFileRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreTlsCertFileRef",
    },
    enable_host_verification: {
      value: cdktf.booleanToHclTerraform(struct!.enableHostVerification),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    key_file_ref: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreTlsKeyFileRefToHclTerraform(struct!.keyFileRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreTlsKeyFileRef",
    },
    server_name: {
      value: cdktf.stringToHclTerraform(struct!.serverName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caFileRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.caFileRef = this._caFileRef?.internalValue;
    }
    if (this._certFileRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.certFileRef = this._certFileRef?.internalValue;
    }
    if (this._enableHostVerification !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHostVerification = this._enableHostVerification;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._keyFileRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyFileRef = this._keyFileRef?.internalValue;
    }
    if (this._serverName !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverName = this._serverName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caFileRef.internalValue = undefined;
      this._certFileRef.internalValue = undefined;
      this._enableHostVerification = undefined;
      this._enabled = undefined;
      this._keyFileRef.internalValue = undefined;
      this._serverName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caFileRef.internalValue = value.caFileRef;
      this._certFileRef.internalValue = value.certFileRef;
      this._enableHostVerification = value.enableHostVerification;
      this._enabled = value.enabled;
      this._keyFileRef.internalValue = value.keyFileRef;
      this._serverName = value.serverName;
    }
  }

  // ca_file_ref - computed: false, optional: true, required: false
  private _caFileRef = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreTlsCaFileRefOutputReference(this, "ca_file_ref");
  public get caFileRef() {
    return this._caFileRef;
  }
  public putCaFileRef(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreTlsCaFileRef) {
    this._caFileRef.internalValue = value;
  }
  public resetCaFileRef() {
    this._caFileRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caFileRefInput() {
    return this._caFileRef.internalValue;
  }

  // cert_file_ref - computed: false, optional: true, required: false
  private _certFileRef = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreTlsCertFileRefOutputReference(this, "cert_file_ref");
  public get certFileRef() {
    return this._certFileRef;
  }
  public putCertFileRef(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreTlsCertFileRef) {
    this._certFileRef.internalValue = value;
  }
  public resetCertFileRef() {
    this._certFileRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certFileRefInput() {
    return this._certFileRef.internalValue;
  }

  // enable_host_verification - computed: false, optional: false, required: true
  private _enableHostVerification?: boolean | cdktf.IResolvable; 
  public get enableHostVerification() {
    return this.getBooleanAttribute('enable_host_verification');
  }
  public set enableHostVerification(value: boolean | cdktf.IResolvable) {
    this._enableHostVerification = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHostVerificationInput() {
    return this._enableHostVerification;
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // key_file_ref - computed: false, optional: true, required: false
  private _keyFileRef = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreTlsKeyFileRefOutputReference(this, "key_file_ref");
  public get keyFileRef() {
    return this._keyFileRef;
  }
  public putKeyFileRef(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreTlsKeyFileRef) {
    this._keyFileRef.internalValue = value;
  }
  public resetKeyFileRef() {
    this._keyFileRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyFileRefInput() {
    return this._keyFileRef.internalValue;
  }

  // server_name - computed: false, optional: true, required: false
  private _serverName?: string; 
  public get serverName() {
    return this.getStringAttribute('server_name');
  }
  public set serverName(value: string) {
    this._serverName = value;
  }
  public resetServerName() {
    this._serverName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverNameInput() {
    return this._serverName;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStore {
  /**
  * Cassandra holds all connection parameters for Cassandra datastore. Note that cassandra is now deprecated for visibility store.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#cassandra DataK8STemporalIoTemporalClusterV1Beta1Manifest#cassandra}
  */
  readonly cassandra?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreCassandra;
  /**
  * Elasticsearch holds all connection parameters for Elasticsearch datastores.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#elasticsearch DataK8STemporalIoTemporalClusterV1Beta1Manifest#elasticsearch}
  */
  readonly elasticsearch?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreElasticsearch;
  /**
  * Name is the name of the datastore. It should be unique and will be referenced within the persistence spec. Defaults to 'default' for default sore, 'visibility' for visibility store, 'secondaryVisibility' for secondary visibility store and 'advancedVisibility' for advanced visibility store.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#name DataK8STemporalIoTemporalClusterV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * PasswordSecret is the reference to the secret holding the password.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#password_secret_ref DataK8STemporalIoTemporalClusterV1Beta1Manifest#password_secret_ref}
  */
  readonly passwordSecretRef?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStorePasswordSecretRef;
  /**
  * SkipCreate instructs the operator to skip creating the database for SQL datastores or to skip creating keyspace for Cassandra. Use this option if your database or keyspace has already been provisioned by an administrator.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#skip_create DataK8STemporalIoTemporalClusterV1Beta1Manifest#skip_create}
  */
  readonly skipCreate?: boolean | cdktf.IResolvable;
  /**
  * SQL holds all connection parameters for SQL datastores.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#sql DataK8STemporalIoTemporalClusterV1Beta1Manifest#sql}
  */
  readonly sql?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreSql;
  /**
  * TLS is an optional option to connect to the datastore using TLS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#tls DataK8STemporalIoTemporalClusterV1Beta1Manifest#tls}
  */
  readonly tls?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreTls;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStore | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cassandra: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreCassandraToTerraform(struct!.cassandra),
    elasticsearch: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreElasticsearchToTerraform(struct!.elasticsearch),
    name: cdktf.stringToTerraform(struct!.name),
    password_secret_ref: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStorePasswordSecretRefToTerraform(struct!.passwordSecretRef),
    skip_create: cdktf.booleanToTerraform(struct!.skipCreate),
    sql: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreSqlToTerraform(struct!.sql),
    tls: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreTlsToTerraform(struct!.tls),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStore | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cassandra: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreCassandraToHclTerraform(struct!.cassandra),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreCassandra",
    },
    elasticsearch: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreElasticsearchToHclTerraform(struct!.elasticsearch),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreElasticsearch",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password_secret_ref: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStorePasswordSecretRefToHclTerraform(struct!.passwordSecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStorePasswordSecretRef",
    },
    skip_create: {
      value: cdktf.booleanToHclTerraform(struct!.skipCreate),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    sql: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreSqlToHclTerraform(struct!.sql),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreSql",
    },
    tls: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreTls",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStore | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cassandra?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cassandra = this._cassandra?.internalValue;
    }
    if (this._elasticsearch?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.elasticsearch = this._elasticsearch?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._passwordSecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.passwordSecretRef = this._passwordSecretRef?.internalValue;
    }
    if (this._skipCreate !== undefined) {
      hasAnyValues = true;
      internalValueResult.skipCreate = this._skipCreate;
    }
    if (this._sql?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sql = this._sql?.internalValue;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStore | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cassandra.internalValue = undefined;
      this._elasticsearch.internalValue = undefined;
      this._name = undefined;
      this._passwordSecretRef.internalValue = undefined;
      this._skipCreate = undefined;
      this._sql.internalValue = undefined;
      this._tls.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cassandra.internalValue = value.cassandra;
      this._elasticsearch.internalValue = value.elasticsearch;
      this._name = value.name;
      this._passwordSecretRef.internalValue = value.passwordSecretRef;
      this._skipCreate = value.skipCreate;
      this._sql.internalValue = value.sql;
      this._tls.internalValue = value.tls;
    }
  }

  // cassandra - computed: false, optional: true, required: false
  private _cassandra = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreCassandraOutputReference(this, "cassandra");
  public get cassandra() {
    return this._cassandra;
  }
  public putCassandra(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreCassandra) {
    this._cassandra.internalValue = value;
  }
  public resetCassandra() {
    this._cassandra.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cassandraInput() {
    return this._cassandra.internalValue;
  }

  // elasticsearch - computed: false, optional: true, required: false
  private _elasticsearch = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreElasticsearchOutputReference(this, "elasticsearch");
  public get elasticsearch() {
    return this._elasticsearch;
  }
  public putElasticsearch(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreElasticsearch) {
    this._elasticsearch.internalValue = value;
  }
  public resetElasticsearch() {
    this._elasticsearch.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get elasticsearchInput() {
    return this._elasticsearch.internalValue;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // password_secret_ref - computed: false, optional: true, required: false
  private _passwordSecretRef = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStorePasswordSecretRefOutputReference(this, "password_secret_ref");
  public get passwordSecretRef() {
    return this._passwordSecretRef;
  }
  public putPasswordSecretRef(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStorePasswordSecretRef) {
    this._passwordSecretRef.internalValue = value;
  }
  public resetPasswordSecretRef() {
    this._passwordSecretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordSecretRefInput() {
    return this._passwordSecretRef.internalValue;
  }

  // skip_create - computed: false, optional: true, required: false
  private _skipCreate?: boolean | cdktf.IResolvable; 
  public get skipCreate() {
    return this.getBooleanAttribute('skip_create');
  }
  public set skipCreate(value: boolean | cdktf.IResolvable) {
    this._skipCreate = value;
  }
  public resetSkipCreate() {
    this._skipCreate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get skipCreateInput() {
    return this._skipCreate;
  }

  // sql - computed: false, optional: true, required: false
  private _sql = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreSqlOutputReference(this, "sql");
  public get sql() {
    return this._sql;
  }
  public putSql(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreSql) {
    this._sql.internalValue = value;
  }
  public resetSql() {
    this._sql.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sqlInput() {
    return this._sql.internalValue;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreCassandraConsistency {
  /**
  * Consistency sets the default consistency level. Values identical to gocql Consistency values. (defaults to LOCAL_QUORUM if not set).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#consistency DataK8STemporalIoTemporalClusterV1Beta1Manifest#consistency}
  */
  readonly consistency?: number;
  /**
  * SerialConsistency sets the consistency for the serial prtion of queries. Values identical to gocql SerialConsistency values. (defaults to LOCAL_SERIAL if not set)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#serial_consistency DataK8STemporalIoTemporalClusterV1Beta1Manifest#serial_consistency}
  */
  readonly serialConsistency?: number;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreCassandraConsistencyToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreCassandraConsistency | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    consistency: cdktf.numberToTerraform(struct!.consistency),
    serial_consistency: cdktf.numberToTerraform(struct!.serialConsistency),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreCassandraConsistencyToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreCassandraConsistency | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    consistency: {
      value: cdktf.numberToHclTerraform(struct!.consistency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    serial_consistency: {
      value: cdktf.numberToHclTerraform(struct!.serialConsistency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreCassandraConsistencyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreCassandraConsistency | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._consistency !== undefined) {
      hasAnyValues = true;
      internalValueResult.consistency = this._consistency;
    }
    if (this._serialConsistency !== undefined) {
      hasAnyValues = true;
      internalValueResult.serialConsistency = this._serialConsistency;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreCassandraConsistency | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._consistency = undefined;
      this._serialConsistency = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._consistency = value.consistency;
      this._serialConsistency = value.serialConsistency;
    }
  }

  // consistency - computed: false, optional: true, required: false
  private _consistency?: number; 
  public get consistency() {
    return this.getNumberAttribute('consistency');
  }
  public set consistency(value: number) {
    this._consistency = value;
  }
  public resetConsistency() {
    this._consistency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get consistencyInput() {
    return this._consistency;
  }

  // serial_consistency - computed: false, optional: true, required: false
  private _serialConsistency?: number; 
  public get serialConsistency() {
    return this.getNumberAttribute('serial_consistency');
  }
  public set serialConsistency(value: number) {
    this._serialConsistency = value;
  }
  public resetSerialConsistency() {
    this._serialConsistency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serialConsistencyInput() {
    return this._serialConsistency;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreCassandra {
  /**
  * ConnectTimeout is a timeout for initial dial to cassandra server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#connect_timeout DataK8STemporalIoTemporalClusterV1Beta1Manifest#connect_timeout}
  */
  readonly connectTimeout?: string;
  /**
  * Consistency configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#consistency DataK8STemporalIoTemporalClusterV1Beta1Manifest#consistency}
  */
  readonly consistency?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreCassandraConsistency;
  /**
  * Datacenter is the data center filter arg for cassandra.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#datacenter DataK8STemporalIoTemporalClusterV1Beta1Manifest#datacenter}
  */
  readonly datacenter?: string;
  /**
  * DisableInitialHostLookup instructs the gocql client to connect only using the supplied hosts.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#disable_initial_host_lookup DataK8STemporalIoTemporalClusterV1Beta1Manifest#disable_initial_host_lookup}
  */
  readonly disableInitialHostLookup?: boolean | cdktf.IResolvable;
  /**
  * Hosts is a list of cassandra endpoints.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#hosts DataK8STemporalIoTemporalClusterV1Beta1Manifest#hosts}
  */
  readonly hosts: string[];
  /**
  * Keyspace is the cassandra keyspace.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#keyspace DataK8STemporalIoTemporalClusterV1Beta1Manifest#keyspace}
  */
  readonly keyspace: string;
  /**
  * MaxConns is the max number of connections to this datastore for a single keyspace.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#max_conns DataK8STemporalIoTemporalClusterV1Beta1Manifest#max_conns}
  */
  readonly maxConns?: number;
  /**
  * Port is the cassandra port used for connection by gocql client.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#port DataK8STemporalIoTemporalClusterV1Beta1Manifest#port}
  */
  readonly port: number;
  /**
  * User is the cassandra user used for authentication by gocql client.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#user DataK8STemporalIoTemporalClusterV1Beta1Manifest#user}
  */
  readonly user: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreCassandraToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreCassandra | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connect_timeout: cdktf.stringToTerraform(struct!.connectTimeout),
    consistency: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreCassandraConsistencyToTerraform(struct!.consistency),
    datacenter: cdktf.stringToTerraform(struct!.datacenter),
    disable_initial_host_lookup: cdktf.booleanToTerraform(struct!.disableInitialHostLookup),
    hosts: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.hosts),
    keyspace: cdktf.stringToTerraform(struct!.keyspace),
    max_conns: cdktf.numberToTerraform(struct!.maxConns),
    port: cdktf.numberToTerraform(struct!.port),
    user: cdktf.stringToTerraform(struct!.user),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreCassandraToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreCassandra | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connect_timeout: {
      value: cdktf.stringToHclTerraform(struct!.connectTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    consistency: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreCassandraConsistencyToHclTerraform(struct!.consistency),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreCassandraConsistency",
    },
    datacenter: {
      value: cdktf.stringToHclTerraform(struct!.datacenter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disable_initial_host_lookup: {
      value: cdktf.booleanToHclTerraform(struct!.disableInitialHostLookup),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    hosts: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.hosts),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    keyspace: {
      value: cdktf.stringToHclTerraform(struct!.keyspace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_conns: {
      value: cdktf.numberToHclTerraform(struct!.maxConns),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    user: {
      value: cdktf.stringToHclTerraform(struct!.user),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreCassandraOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreCassandra | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connectTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectTimeout = this._connectTimeout;
    }
    if (this._consistency?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.consistency = this._consistency?.internalValue;
    }
    if (this._datacenter !== undefined) {
      hasAnyValues = true;
      internalValueResult.datacenter = this._datacenter;
    }
    if (this._disableInitialHostLookup !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableInitialHostLookup = this._disableInitialHostLookup;
    }
    if (this._hosts !== undefined) {
      hasAnyValues = true;
      internalValueResult.hosts = this._hosts;
    }
    if (this._keyspace !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyspace = this._keyspace;
    }
    if (this._maxConns !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxConns = this._maxConns;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._user !== undefined) {
      hasAnyValues = true;
      internalValueResult.user = this._user;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreCassandra | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connectTimeout = undefined;
      this._consistency.internalValue = undefined;
      this._datacenter = undefined;
      this._disableInitialHostLookup = undefined;
      this._hosts = undefined;
      this._keyspace = undefined;
      this._maxConns = undefined;
      this._port = undefined;
      this._user = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connectTimeout = value.connectTimeout;
      this._consistency.internalValue = value.consistency;
      this._datacenter = value.datacenter;
      this._disableInitialHostLookup = value.disableInitialHostLookup;
      this._hosts = value.hosts;
      this._keyspace = value.keyspace;
      this._maxConns = value.maxConns;
      this._port = value.port;
      this._user = value.user;
    }
  }

  // connect_timeout - computed: false, optional: true, required: false
  private _connectTimeout?: string; 
  public get connectTimeout() {
    return this.getStringAttribute('connect_timeout');
  }
  public set connectTimeout(value: string) {
    this._connectTimeout = value;
  }
  public resetConnectTimeout() {
    this._connectTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectTimeoutInput() {
    return this._connectTimeout;
  }

  // consistency - computed: false, optional: true, required: false
  private _consistency = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreCassandraConsistencyOutputReference(this, "consistency");
  public get consistency() {
    return this._consistency;
  }
  public putConsistency(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreCassandraConsistency) {
    this._consistency.internalValue = value;
  }
  public resetConsistency() {
    this._consistency.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get consistencyInput() {
    return this._consistency.internalValue;
  }

  // datacenter - computed: false, optional: true, required: false
  private _datacenter?: string; 
  public get datacenter() {
    return this.getStringAttribute('datacenter');
  }
  public set datacenter(value: string) {
    this._datacenter = value;
  }
  public resetDatacenter() {
    this._datacenter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get datacenterInput() {
    return this._datacenter;
  }

  // disable_initial_host_lookup - computed: false, optional: true, required: false
  private _disableInitialHostLookup?: boolean | cdktf.IResolvable; 
  public get disableInitialHostLookup() {
    return this.getBooleanAttribute('disable_initial_host_lookup');
  }
  public set disableInitialHostLookup(value: boolean | cdktf.IResolvable) {
    this._disableInitialHostLookup = value;
  }
  public resetDisableInitialHostLookup() {
    this._disableInitialHostLookup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableInitialHostLookupInput() {
    return this._disableInitialHostLookup;
  }

  // hosts - computed: false, optional: false, required: true
  private _hosts?: string[]; 
  public get hosts() {
    return this.getListAttribute('hosts');
  }
  public set hosts(value: string[]) {
    this._hosts = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostsInput() {
    return this._hosts;
  }

  // keyspace - computed: false, optional: false, required: true
  private _keyspace?: string; 
  public get keyspace() {
    return this.getStringAttribute('keyspace');
  }
  public set keyspace(value: string) {
    this._keyspace = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyspaceInput() {
    return this._keyspace;
  }

  // max_conns - computed: false, optional: true, required: false
  private _maxConns?: number; 
  public get maxConns() {
    return this.getNumberAttribute('max_conns');
  }
  public set maxConns(value: number) {
    this._maxConns = value;
  }
  public resetMaxConns() {
    this._maxConns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxConnsInput() {
    return this._maxConns;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // user - computed: false, optional: false, required: true
  private _user?: string; 
  public get user() {
    return this.getStringAttribute('user');
  }
  public set user(value: string) {
    this._user = value;
  }
  // Temporarily expose input value. Use with caution.
  public get userInput() {
    return this._user;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreElasticsearchIndices {
  /**
  * SecondaryVisibility defines secondary visibility's index name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#secondary_visibility DataK8STemporalIoTemporalClusterV1Beta1Manifest#secondary_visibility}
  */
  readonly secondaryVisibility?: string;
  /**
  * Visibility defines visibility's index name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#visibility DataK8STemporalIoTemporalClusterV1Beta1Manifest#visibility}
  */
  readonly visibility: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreElasticsearchIndicesToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreElasticsearchIndices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secondary_visibility: cdktf.stringToTerraform(struct!.secondaryVisibility),
    visibility: cdktf.stringToTerraform(struct!.visibility),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreElasticsearchIndicesToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreElasticsearchIndices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secondary_visibility: {
      value: cdktf.stringToHclTerraform(struct!.secondaryVisibility),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    visibility: {
      value: cdktf.stringToHclTerraform(struct!.visibility),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreElasticsearchIndicesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreElasticsearchIndices | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secondaryVisibility !== undefined) {
      hasAnyValues = true;
      internalValueResult.secondaryVisibility = this._secondaryVisibility;
    }
    if (this._visibility !== undefined) {
      hasAnyValues = true;
      internalValueResult.visibility = this._visibility;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreElasticsearchIndices | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secondaryVisibility = undefined;
      this._visibility = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secondaryVisibility = value.secondaryVisibility;
      this._visibility = value.visibility;
    }
  }

  // secondary_visibility - computed: false, optional: true, required: false
  private _secondaryVisibility?: string; 
  public get secondaryVisibility() {
    return this.getStringAttribute('secondary_visibility');
  }
  public set secondaryVisibility(value: string) {
    this._secondaryVisibility = value;
  }
  public resetSecondaryVisibility() {
    this._secondaryVisibility = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secondaryVisibilityInput() {
    return this._secondaryVisibility;
  }

  // visibility - computed: false, optional: false, required: true
  private _visibility?: string; 
  public get visibility() {
    return this.getStringAttribute('visibility');
  }
  public set visibility(value: string) {
    this._visibility = value;
  }
  // Temporarily expose input value. Use with caution.
  public get visibilityInput() {
    return this._visibility;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreElasticsearch {
  /**
  * CloseIdleConnectionsInterval is the max duration a connection stay open while idle.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#close_idle_connections_interval DataK8STemporalIoTemporalClusterV1Beta1Manifest#close_idle_connections_interval}
  */
  readonly closeIdleConnectionsInterval?: string;
  /**
  * EnableHealthcheck enables or disables healthcheck on the temporal cluster's es client.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#enable_healthcheck DataK8STemporalIoTemporalClusterV1Beta1Manifest#enable_healthcheck}
  */
  readonly enableHealthcheck?: boolean | cdktf.IResolvable;
  /**
  * EnableSniff enables or disables sniffer on the temporal cluster's es client.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#enable_sniff DataK8STemporalIoTemporalClusterV1Beta1Manifest#enable_sniff}
  */
  readonly enableSniff?: boolean | cdktf.IResolvable;
  /**
  * Indices holds visibility index names.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#indices DataK8STemporalIoTemporalClusterV1Beta1Manifest#indices}
  */
  readonly indices: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreElasticsearchIndices;
  /**
  * LogLevel defines the temporal cluster's es client logger level.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#log_level DataK8STemporalIoTemporalClusterV1Beta1Manifest#log_level}
  */
  readonly logLevel?: string;
  /**
  * URL is the connection url to connect to the instance.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#url DataK8STemporalIoTemporalClusterV1Beta1Manifest#url}
  */
  readonly url: string;
  /**
  * Username is the username to be used for the connection.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#username DataK8STemporalIoTemporalClusterV1Beta1Manifest#username}
  */
  readonly username: string;
  /**
  * Version defines the elasticsearch version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#version DataK8STemporalIoTemporalClusterV1Beta1Manifest#version}
  */
  readonly version: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreElasticsearchToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreElasticsearch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    close_idle_connections_interval: cdktf.stringToTerraform(struct!.closeIdleConnectionsInterval),
    enable_healthcheck: cdktf.booleanToTerraform(struct!.enableHealthcheck),
    enable_sniff: cdktf.booleanToTerraform(struct!.enableSniff),
    indices: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreElasticsearchIndicesToTerraform(struct!.indices),
    log_level: cdktf.stringToTerraform(struct!.logLevel),
    url: cdktf.stringToTerraform(struct!.url),
    username: cdktf.stringToTerraform(struct!.username),
    version: cdktf.stringToTerraform(struct!.version),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreElasticsearchToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreElasticsearch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    close_idle_connections_interval: {
      value: cdktf.stringToHclTerraform(struct!.closeIdleConnectionsInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enable_healthcheck: {
      value: cdktf.booleanToHclTerraform(struct!.enableHealthcheck),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_sniff: {
      value: cdktf.booleanToHclTerraform(struct!.enableSniff),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    indices: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreElasticsearchIndicesToHclTerraform(struct!.indices),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreElasticsearchIndices",
    },
    log_level: {
      value: cdktf.stringToHclTerraform(struct!.logLevel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    version: {
      value: cdktf.stringToHclTerraform(struct!.version),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreElasticsearchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreElasticsearch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._closeIdleConnectionsInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.closeIdleConnectionsInterval = this._closeIdleConnectionsInterval;
    }
    if (this._enableHealthcheck !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHealthcheck = this._enableHealthcheck;
    }
    if (this._enableSniff !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableSniff = this._enableSniff;
    }
    if (this._indices?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.indices = this._indices?.internalValue;
    }
    if (this._logLevel !== undefined) {
      hasAnyValues = true;
      internalValueResult.logLevel = this._logLevel;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    if (this._version !== undefined) {
      hasAnyValues = true;
      internalValueResult.version = this._version;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreElasticsearch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._closeIdleConnectionsInterval = undefined;
      this._enableHealthcheck = undefined;
      this._enableSniff = undefined;
      this._indices.internalValue = undefined;
      this._logLevel = undefined;
      this._url = undefined;
      this._username = undefined;
      this._version = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._closeIdleConnectionsInterval = value.closeIdleConnectionsInterval;
      this._enableHealthcheck = value.enableHealthcheck;
      this._enableSniff = value.enableSniff;
      this._indices.internalValue = value.indices;
      this._logLevel = value.logLevel;
      this._url = value.url;
      this._username = value.username;
      this._version = value.version;
    }
  }

  // close_idle_connections_interval - computed: false, optional: true, required: false
  private _closeIdleConnectionsInterval?: string; 
  public get closeIdleConnectionsInterval() {
    return this.getStringAttribute('close_idle_connections_interval');
  }
  public set closeIdleConnectionsInterval(value: string) {
    this._closeIdleConnectionsInterval = value;
  }
  public resetCloseIdleConnectionsInterval() {
    this._closeIdleConnectionsInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get closeIdleConnectionsIntervalInput() {
    return this._closeIdleConnectionsInterval;
  }

  // enable_healthcheck - computed: false, optional: true, required: false
  private _enableHealthcheck?: boolean | cdktf.IResolvable; 
  public get enableHealthcheck() {
    return this.getBooleanAttribute('enable_healthcheck');
  }
  public set enableHealthcheck(value: boolean | cdktf.IResolvable) {
    this._enableHealthcheck = value;
  }
  public resetEnableHealthcheck() {
    this._enableHealthcheck = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHealthcheckInput() {
    return this._enableHealthcheck;
  }

  // enable_sniff - computed: false, optional: true, required: false
  private _enableSniff?: boolean | cdktf.IResolvable; 
  public get enableSniff() {
    return this.getBooleanAttribute('enable_sniff');
  }
  public set enableSniff(value: boolean | cdktf.IResolvable) {
    this._enableSniff = value;
  }
  public resetEnableSniff() {
    this._enableSniff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableSniffInput() {
    return this._enableSniff;
  }

  // indices - computed: false, optional: false, required: true
  private _indices = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreElasticsearchIndicesOutputReference(this, "indices");
  public get indices() {
    return this._indices;
  }
  public putIndices(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreElasticsearchIndices) {
    this._indices.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get indicesInput() {
    return this._indices.internalValue;
  }

  // log_level - computed: false, optional: true, required: false
  private _logLevel?: string; 
  public get logLevel() {
    return this.getStringAttribute('log_level');
  }
  public set logLevel(value: string) {
    this._logLevel = value;
  }
  public resetLogLevel() {
    this._logLevel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logLevelInput() {
    return this._logLevel;
  }

  // url - computed: false, optional: false, required: true
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }

  // username - computed: false, optional: false, required: true
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }

  // version - computed: false, optional: false, required: true
  private _version?: string; 
  public get version() {
    return this.getStringAttribute('version');
  }
  public set version(value: string) {
    this._version = value;
  }
  // Temporarily expose input value. Use with caution.
  public get versionInput() {
    return this._version;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStorePasswordSecretRef {
  /**
  * Key in the Secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#key DataK8STemporalIoTemporalClusterV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * Name of the Secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#name DataK8STemporalIoTemporalClusterV1Beta1Manifest#name}
  */
  readonly name: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStorePasswordSecretRefToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStorePasswordSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStorePasswordSecretRefToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStorePasswordSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStorePasswordSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStorePasswordSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStorePasswordSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreSql {
  /**
  * ConnectAddr is the remote addr of the database.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#connect_addr DataK8STemporalIoTemporalClusterV1Beta1Manifest#connect_addr}
  */
  readonly connectAddr: string;
  /**
  * ConnectAttributes is a set of key-value attributes to be sent as part of connect data_source_name url
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#connect_attributes DataK8STemporalIoTemporalClusterV1Beta1Manifest#connect_attributes}
  */
  readonly connectAttributes?: { [key: string]: string };
  /**
  * ConnectProtocol is the protocol that goes with the ConnectAddr.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#connect_protocol DataK8STemporalIoTemporalClusterV1Beta1Manifest#connect_protocol}
  */
  readonly connectProtocol?: string;
  /**
  * DatabaseName is the name of SQL database to connect to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#database_name DataK8STemporalIoTemporalClusterV1Beta1Manifest#database_name}
  */
  readonly databaseName: string;
  /**
  * GCPServiceAccount is the service account to use to authenticate with GCP CloudSQL.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#gcp_service_account DataK8STemporalIoTemporalClusterV1Beta1Manifest#gcp_service_account}
  */
  readonly gcpServiceAccount?: string;
  /**
  * MaxConnLifetime is the maximum time a connection can be alive
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#max_conn_lifetime DataK8STemporalIoTemporalClusterV1Beta1Manifest#max_conn_lifetime}
  */
  readonly maxConnLifetime?: string;
  /**
  * MaxConns the max number of connections to this datastore.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#max_conns DataK8STemporalIoTemporalClusterV1Beta1Manifest#max_conns}
  */
  readonly maxConns?: number;
  /**
  * MaxIdleConns is the max number of idle connections to this datastore.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#max_idle_conns DataK8STemporalIoTemporalClusterV1Beta1Manifest#max_idle_conns}
  */
  readonly maxIdleConns?: number;
  /**
  * PluginName is the name of SQL plugin.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#plugin_name DataK8STemporalIoTemporalClusterV1Beta1Manifest#plugin_name}
  */
  readonly pluginName: string;
  /**
  * TaskScanPartitions is the number of partitions to sequentially scan during ListTaskQueue operations.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#task_scan_partitions DataK8STemporalIoTemporalClusterV1Beta1Manifest#task_scan_partitions}
  */
  readonly taskScanPartitions?: number;
  /**
  * User is the username to be used for the connection.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#user DataK8STemporalIoTemporalClusterV1Beta1Manifest#user}
  */
  readonly user: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreSqlToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreSql | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connect_addr: cdktf.stringToTerraform(struct!.connectAddr),
    connect_attributes: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.connectAttributes),
    connect_protocol: cdktf.stringToTerraform(struct!.connectProtocol),
    database_name: cdktf.stringToTerraform(struct!.databaseName),
    gcp_service_account: cdktf.stringToTerraform(struct!.gcpServiceAccount),
    max_conn_lifetime: cdktf.stringToTerraform(struct!.maxConnLifetime),
    max_conns: cdktf.numberToTerraform(struct!.maxConns),
    max_idle_conns: cdktf.numberToTerraform(struct!.maxIdleConns),
    plugin_name: cdktf.stringToTerraform(struct!.pluginName),
    task_scan_partitions: cdktf.numberToTerraform(struct!.taskScanPartitions),
    user: cdktf.stringToTerraform(struct!.user),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreSqlToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreSql | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connect_addr: {
      value: cdktf.stringToHclTerraform(struct!.connectAddr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connect_attributes: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.connectAttributes),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    connect_protocol: {
      value: cdktf.stringToHclTerraform(struct!.connectProtocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    database_name: {
      value: cdktf.stringToHclTerraform(struct!.databaseName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    gcp_service_account: {
      value: cdktf.stringToHclTerraform(struct!.gcpServiceAccount),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_conn_lifetime: {
      value: cdktf.stringToHclTerraform(struct!.maxConnLifetime),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_conns: {
      value: cdktf.numberToHclTerraform(struct!.maxConns),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_idle_conns: {
      value: cdktf.numberToHclTerraform(struct!.maxIdleConns),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    plugin_name: {
      value: cdktf.stringToHclTerraform(struct!.pluginName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    task_scan_partitions: {
      value: cdktf.numberToHclTerraform(struct!.taskScanPartitions),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    user: {
      value: cdktf.stringToHclTerraform(struct!.user),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreSqlOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreSql | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connectAddr !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectAddr = this._connectAddr;
    }
    if (this._connectAttributes !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectAttributes = this._connectAttributes;
    }
    if (this._connectProtocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectProtocol = this._connectProtocol;
    }
    if (this._databaseName !== undefined) {
      hasAnyValues = true;
      internalValueResult.databaseName = this._databaseName;
    }
    if (this._gcpServiceAccount !== undefined) {
      hasAnyValues = true;
      internalValueResult.gcpServiceAccount = this._gcpServiceAccount;
    }
    if (this._maxConnLifetime !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxConnLifetime = this._maxConnLifetime;
    }
    if (this._maxConns !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxConns = this._maxConns;
    }
    if (this._maxIdleConns !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxIdleConns = this._maxIdleConns;
    }
    if (this._pluginName !== undefined) {
      hasAnyValues = true;
      internalValueResult.pluginName = this._pluginName;
    }
    if (this._taskScanPartitions !== undefined) {
      hasAnyValues = true;
      internalValueResult.taskScanPartitions = this._taskScanPartitions;
    }
    if (this._user !== undefined) {
      hasAnyValues = true;
      internalValueResult.user = this._user;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreSql | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connectAddr = undefined;
      this._connectAttributes = undefined;
      this._connectProtocol = undefined;
      this._databaseName = undefined;
      this._gcpServiceAccount = undefined;
      this._maxConnLifetime = undefined;
      this._maxConns = undefined;
      this._maxIdleConns = undefined;
      this._pluginName = undefined;
      this._taskScanPartitions = undefined;
      this._user = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connectAddr = value.connectAddr;
      this._connectAttributes = value.connectAttributes;
      this._connectProtocol = value.connectProtocol;
      this._databaseName = value.databaseName;
      this._gcpServiceAccount = value.gcpServiceAccount;
      this._maxConnLifetime = value.maxConnLifetime;
      this._maxConns = value.maxConns;
      this._maxIdleConns = value.maxIdleConns;
      this._pluginName = value.pluginName;
      this._taskScanPartitions = value.taskScanPartitions;
      this._user = value.user;
    }
  }

  // connect_addr - computed: false, optional: false, required: true
  private _connectAddr?: string; 
  public get connectAddr() {
    return this.getStringAttribute('connect_addr');
  }
  public set connectAddr(value: string) {
    this._connectAddr = value;
  }
  // Temporarily expose input value. Use with caution.
  public get connectAddrInput() {
    return this._connectAddr;
  }

  // connect_attributes - computed: false, optional: true, required: false
  private _connectAttributes?: { [key: string]: string }; 
  public get connectAttributes() {
    return this.getStringMapAttribute('connect_attributes');
  }
  public set connectAttributes(value: { [key: string]: string }) {
    this._connectAttributes = value;
  }
  public resetConnectAttributes() {
    this._connectAttributes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectAttributesInput() {
    return this._connectAttributes;
  }

  // connect_protocol - computed: false, optional: true, required: false
  private _connectProtocol?: string; 
  public get connectProtocol() {
    return this.getStringAttribute('connect_protocol');
  }
  public set connectProtocol(value: string) {
    this._connectProtocol = value;
  }
  public resetConnectProtocol() {
    this._connectProtocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectProtocolInput() {
    return this._connectProtocol;
  }

  // database_name - computed: false, optional: false, required: true
  private _databaseName?: string; 
  public get databaseName() {
    return this.getStringAttribute('database_name');
  }
  public set databaseName(value: string) {
    this._databaseName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseNameInput() {
    return this._databaseName;
  }

  // gcp_service_account - computed: false, optional: true, required: false
  private _gcpServiceAccount?: string; 
  public get gcpServiceAccount() {
    return this.getStringAttribute('gcp_service_account');
  }
  public set gcpServiceAccount(value: string) {
    this._gcpServiceAccount = value;
  }
  public resetGcpServiceAccount() {
    this._gcpServiceAccount = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gcpServiceAccountInput() {
    return this._gcpServiceAccount;
  }

  // max_conn_lifetime - computed: false, optional: true, required: false
  private _maxConnLifetime?: string; 
  public get maxConnLifetime() {
    return this.getStringAttribute('max_conn_lifetime');
  }
  public set maxConnLifetime(value: string) {
    this._maxConnLifetime = value;
  }
  public resetMaxConnLifetime() {
    this._maxConnLifetime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxConnLifetimeInput() {
    return this._maxConnLifetime;
  }

  // max_conns - computed: false, optional: true, required: false
  private _maxConns?: number; 
  public get maxConns() {
    return this.getNumberAttribute('max_conns');
  }
  public set maxConns(value: number) {
    this._maxConns = value;
  }
  public resetMaxConns() {
    this._maxConns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxConnsInput() {
    return this._maxConns;
  }

  // max_idle_conns - computed: false, optional: true, required: false
  private _maxIdleConns?: number; 
  public get maxIdleConns() {
    return this.getNumberAttribute('max_idle_conns');
  }
  public set maxIdleConns(value: number) {
    this._maxIdleConns = value;
  }
  public resetMaxIdleConns() {
    this._maxIdleConns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxIdleConnsInput() {
    return this._maxIdleConns;
  }

  // plugin_name - computed: false, optional: false, required: true
  private _pluginName?: string; 
  public get pluginName() {
    return this.getStringAttribute('plugin_name');
  }
  public set pluginName(value: string) {
    this._pluginName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pluginNameInput() {
    return this._pluginName;
  }

  // task_scan_partitions - computed: false, optional: true, required: false
  private _taskScanPartitions?: number; 
  public get taskScanPartitions() {
    return this.getNumberAttribute('task_scan_partitions');
  }
  public set taskScanPartitions(value: number) {
    this._taskScanPartitions = value;
  }
  public resetTaskScanPartitions() {
    this._taskScanPartitions = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get taskScanPartitionsInput() {
    return this._taskScanPartitions;
  }

  // user - computed: false, optional: false, required: true
  private _user?: string; 
  public get user() {
    return this.getStringAttribute('user');
  }
  public set user(value: string) {
    this._user = value;
  }
  // Temporarily expose input value. Use with caution.
  public get userInput() {
    return this._user;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreTlsCaFileRef {
  /**
  * Key in the Secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#key DataK8STemporalIoTemporalClusterV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * Name of the Secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#name DataK8STemporalIoTemporalClusterV1Beta1Manifest#name}
  */
  readonly name: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreTlsCaFileRefToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreTlsCaFileRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreTlsCaFileRefToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreTlsCaFileRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreTlsCaFileRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreTlsCaFileRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreTlsCaFileRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreTlsCertFileRef {
  /**
  * Key in the Secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#key DataK8STemporalIoTemporalClusterV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * Name of the Secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#name DataK8STemporalIoTemporalClusterV1Beta1Manifest#name}
  */
  readonly name: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreTlsCertFileRefToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreTlsCertFileRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreTlsCertFileRefToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreTlsCertFileRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreTlsCertFileRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreTlsCertFileRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreTlsCertFileRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreTlsKeyFileRef {
  /**
  * Key in the Secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#key DataK8STemporalIoTemporalClusterV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * Name of the Secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#name DataK8STemporalIoTemporalClusterV1Beta1Manifest#name}
  */
  readonly name: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreTlsKeyFileRefToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreTlsKeyFileRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreTlsKeyFileRefToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreTlsKeyFileRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreTlsKeyFileRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreTlsKeyFileRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreTlsKeyFileRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreTls {
  /**
  * CaFileRef is a reference to a secret containing the ca file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#ca_file_ref DataK8STemporalIoTemporalClusterV1Beta1Manifest#ca_file_ref}
  */
  readonly caFileRef?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreTlsCaFileRef;
  /**
  * CertFileRef is a reference to a secret containing the cert file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#cert_file_ref DataK8STemporalIoTemporalClusterV1Beta1Manifest#cert_file_ref}
  */
  readonly certFileRef?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreTlsCertFileRef;
  /**
  * EnableHostVerification defines if the hostname should be verified when connecting to the datastore.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#enable_host_verification DataK8STemporalIoTemporalClusterV1Beta1Manifest#enable_host_verification}
  */
  readonly enableHostVerification: boolean | cdktf.IResolvable;
  /**
  * Enabled defines if the cluster should use a TLS connection to connect to the datastore.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#enabled DataK8STemporalIoTemporalClusterV1Beta1Manifest#enabled}
  */
  readonly enabled: boolean | cdktf.IResolvable;
  /**
  * KeyFileRef is a reference to a secret containing the key file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#key_file_ref DataK8STemporalIoTemporalClusterV1Beta1Manifest#key_file_ref}
  */
  readonly keyFileRef?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreTlsKeyFileRef;
  /**
  * ServerName the datastore should present.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#server_name DataK8STemporalIoTemporalClusterV1Beta1Manifest#server_name}
  */
  readonly serverName?: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreTlsToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_file_ref: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreTlsCaFileRefToTerraform(struct!.caFileRef),
    cert_file_ref: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreTlsCertFileRefToTerraform(struct!.certFileRef),
    enable_host_verification: cdktf.booleanToTerraform(struct!.enableHostVerification),
    enabled: cdktf.booleanToTerraform(struct!.enabled),
    key_file_ref: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreTlsKeyFileRefToTerraform(struct!.keyFileRef),
    server_name: cdktf.stringToTerraform(struct!.serverName),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreTlsToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_file_ref: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreTlsCaFileRefToHclTerraform(struct!.caFileRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreTlsCaFileRef",
    },
    cert_file_ref: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreTlsCertFileRefToHclTerraform(struct!.certFileRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreTlsCertFileRef",
    },
    enable_host_verification: {
      value: cdktf.booleanToHclTerraform(struct!.enableHostVerification),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    key_file_ref: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreTlsKeyFileRefToHclTerraform(struct!.keyFileRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreTlsKeyFileRef",
    },
    server_name: {
      value: cdktf.stringToHclTerraform(struct!.serverName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caFileRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.caFileRef = this._caFileRef?.internalValue;
    }
    if (this._certFileRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.certFileRef = this._certFileRef?.internalValue;
    }
    if (this._enableHostVerification !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHostVerification = this._enableHostVerification;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._keyFileRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyFileRef = this._keyFileRef?.internalValue;
    }
    if (this._serverName !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverName = this._serverName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caFileRef.internalValue = undefined;
      this._certFileRef.internalValue = undefined;
      this._enableHostVerification = undefined;
      this._enabled = undefined;
      this._keyFileRef.internalValue = undefined;
      this._serverName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caFileRef.internalValue = value.caFileRef;
      this._certFileRef.internalValue = value.certFileRef;
      this._enableHostVerification = value.enableHostVerification;
      this._enabled = value.enabled;
      this._keyFileRef.internalValue = value.keyFileRef;
      this._serverName = value.serverName;
    }
  }

  // ca_file_ref - computed: false, optional: true, required: false
  private _caFileRef = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreTlsCaFileRefOutputReference(this, "ca_file_ref");
  public get caFileRef() {
    return this._caFileRef;
  }
  public putCaFileRef(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreTlsCaFileRef) {
    this._caFileRef.internalValue = value;
  }
  public resetCaFileRef() {
    this._caFileRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caFileRefInput() {
    return this._caFileRef.internalValue;
  }

  // cert_file_ref - computed: false, optional: true, required: false
  private _certFileRef = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreTlsCertFileRefOutputReference(this, "cert_file_ref");
  public get certFileRef() {
    return this._certFileRef;
  }
  public putCertFileRef(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreTlsCertFileRef) {
    this._certFileRef.internalValue = value;
  }
  public resetCertFileRef() {
    this._certFileRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certFileRefInput() {
    return this._certFileRef.internalValue;
  }

  // enable_host_verification - computed: false, optional: false, required: true
  private _enableHostVerification?: boolean | cdktf.IResolvable; 
  public get enableHostVerification() {
    return this.getBooleanAttribute('enable_host_verification');
  }
  public set enableHostVerification(value: boolean | cdktf.IResolvable) {
    this._enableHostVerification = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHostVerificationInput() {
    return this._enableHostVerification;
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // key_file_ref - computed: false, optional: true, required: false
  private _keyFileRef = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreTlsKeyFileRefOutputReference(this, "key_file_ref");
  public get keyFileRef() {
    return this._keyFileRef;
  }
  public putKeyFileRef(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreTlsKeyFileRef) {
    this._keyFileRef.internalValue = value;
  }
  public resetKeyFileRef() {
    this._keyFileRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyFileRefInput() {
    return this._keyFileRef.internalValue;
  }

  // server_name - computed: false, optional: true, required: false
  private _serverName?: string; 
  public get serverName() {
    return this.getStringAttribute('server_name');
  }
  public set serverName(value: string) {
    this._serverName = value;
  }
  public resetServerName() {
    this._serverName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverNameInput() {
    return this._serverName;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStore {
  /**
  * Cassandra holds all connection parameters for Cassandra datastore. Note that cassandra is now deprecated for visibility store.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#cassandra DataK8STemporalIoTemporalClusterV1Beta1Manifest#cassandra}
  */
  readonly cassandra?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreCassandra;
  /**
  * Elasticsearch holds all connection parameters for Elasticsearch datastores.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#elasticsearch DataK8STemporalIoTemporalClusterV1Beta1Manifest#elasticsearch}
  */
  readonly elasticsearch?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreElasticsearch;
  /**
  * Name is the name of the datastore. It should be unique and will be referenced within the persistence spec. Defaults to 'default' for default sore, 'visibility' for visibility store, 'secondaryVisibility' for secondary visibility store and 'advancedVisibility' for advanced visibility store.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#name DataK8STemporalIoTemporalClusterV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * PasswordSecret is the reference to the secret holding the password.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#password_secret_ref DataK8STemporalIoTemporalClusterV1Beta1Manifest#password_secret_ref}
  */
  readonly passwordSecretRef?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStorePasswordSecretRef;
  /**
  * SkipCreate instructs the operator to skip creating the database for SQL datastores or to skip creating keyspace for Cassandra. Use this option if your database or keyspace has already been provisioned by an administrator.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#skip_create DataK8STemporalIoTemporalClusterV1Beta1Manifest#skip_create}
  */
  readonly skipCreate?: boolean | cdktf.IResolvable;
  /**
  * SQL holds all connection parameters for SQL datastores.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#sql DataK8STemporalIoTemporalClusterV1Beta1Manifest#sql}
  */
  readonly sql?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreSql;
  /**
  * TLS is an optional option to connect to the datastore using TLS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#tls DataK8STemporalIoTemporalClusterV1Beta1Manifest#tls}
  */
  readonly tls?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreTls;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStore | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cassandra: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreCassandraToTerraform(struct!.cassandra),
    elasticsearch: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreElasticsearchToTerraform(struct!.elasticsearch),
    name: cdktf.stringToTerraform(struct!.name),
    password_secret_ref: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStorePasswordSecretRefToTerraform(struct!.passwordSecretRef),
    skip_create: cdktf.booleanToTerraform(struct!.skipCreate),
    sql: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreSqlToTerraform(struct!.sql),
    tls: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreTlsToTerraform(struct!.tls),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStore | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cassandra: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreCassandraToHclTerraform(struct!.cassandra),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreCassandra",
    },
    elasticsearch: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreElasticsearchToHclTerraform(struct!.elasticsearch),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreElasticsearch",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password_secret_ref: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStorePasswordSecretRefToHclTerraform(struct!.passwordSecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStorePasswordSecretRef",
    },
    skip_create: {
      value: cdktf.booleanToHclTerraform(struct!.skipCreate),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    sql: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreSqlToHclTerraform(struct!.sql),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreSql",
    },
    tls: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreTls",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStore | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cassandra?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cassandra = this._cassandra?.internalValue;
    }
    if (this._elasticsearch?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.elasticsearch = this._elasticsearch?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._passwordSecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.passwordSecretRef = this._passwordSecretRef?.internalValue;
    }
    if (this._skipCreate !== undefined) {
      hasAnyValues = true;
      internalValueResult.skipCreate = this._skipCreate;
    }
    if (this._sql?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sql = this._sql?.internalValue;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStore | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cassandra.internalValue = undefined;
      this._elasticsearch.internalValue = undefined;
      this._name = undefined;
      this._passwordSecretRef.internalValue = undefined;
      this._skipCreate = undefined;
      this._sql.internalValue = undefined;
      this._tls.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cassandra.internalValue = value.cassandra;
      this._elasticsearch.internalValue = value.elasticsearch;
      this._name = value.name;
      this._passwordSecretRef.internalValue = value.passwordSecretRef;
      this._skipCreate = value.skipCreate;
      this._sql.internalValue = value.sql;
      this._tls.internalValue = value.tls;
    }
  }

  // cassandra - computed: false, optional: true, required: false
  private _cassandra = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreCassandraOutputReference(this, "cassandra");
  public get cassandra() {
    return this._cassandra;
  }
  public putCassandra(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreCassandra) {
    this._cassandra.internalValue = value;
  }
  public resetCassandra() {
    this._cassandra.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cassandraInput() {
    return this._cassandra.internalValue;
  }

  // elasticsearch - computed: false, optional: true, required: false
  private _elasticsearch = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreElasticsearchOutputReference(this, "elasticsearch");
  public get elasticsearch() {
    return this._elasticsearch;
  }
  public putElasticsearch(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreElasticsearch) {
    this._elasticsearch.internalValue = value;
  }
  public resetElasticsearch() {
    this._elasticsearch.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get elasticsearchInput() {
    return this._elasticsearch.internalValue;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // password_secret_ref - computed: false, optional: true, required: false
  private _passwordSecretRef = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStorePasswordSecretRefOutputReference(this, "password_secret_ref");
  public get passwordSecretRef() {
    return this._passwordSecretRef;
  }
  public putPasswordSecretRef(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStorePasswordSecretRef) {
    this._passwordSecretRef.internalValue = value;
  }
  public resetPasswordSecretRef() {
    this._passwordSecretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordSecretRefInput() {
    return this._passwordSecretRef.internalValue;
  }

  // skip_create - computed: false, optional: true, required: false
  private _skipCreate?: boolean | cdktf.IResolvable; 
  public get skipCreate() {
    return this.getBooleanAttribute('skip_create');
  }
  public set skipCreate(value: boolean | cdktf.IResolvable) {
    this._skipCreate = value;
  }
  public resetSkipCreate() {
    this._skipCreate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get skipCreateInput() {
    return this._skipCreate;
  }

  // sql - computed: false, optional: true, required: false
  private _sql = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreSqlOutputReference(this, "sql");
  public get sql() {
    return this._sql;
  }
  public putSql(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreSql) {
    this._sql.internalValue = value;
  }
  public resetSql() {
    this._sql.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sqlInput() {
    return this._sql.internalValue;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreCassandraConsistency {
  /**
  * Consistency sets the default consistency level. Values identical to gocql Consistency values. (defaults to LOCAL_QUORUM if not set).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#consistency DataK8STemporalIoTemporalClusterV1Beta1Manifest#consistency}
  */
  readonly consistency?: number;
  /**
  * SerialConsistency sets the consistency for the serial prtion of queries. Values identical to gocql SerialConsistency values. (defaults to LOCAL_SERIAL if not set)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#serial_consistency DataK8STemporalIoTemporalClusterV1Beta1Manifest#serial_consistency}
  */
  readonly serialConsistency?: number;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreCassandraConsistencyToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreCassandraConsistency | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    consistency: cdktf.numberToTerraform(struct!.consistency),
    serial_consistency: cdktf.numberToTerraform(struct!.serialConsistency),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreCassandraConsistencyToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreCassandraConsistency | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    consistency: {
      value: cdktf.numberToHclTerraform(struct!.consistency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    serial_consistency: {
      value: cdktf.numberToHclTerraform(struct!.serialConsistency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreCassandraConsistencyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreCassandraConsistency | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._consistency !== undefined) {
      hasAnyValues = true;
      internalValueResult.consistency = this._consistency;
    }
    if (this._serialConsistency !== undefined) {
      hasAnyValues = true;
      internalValueResult.serialConsistency = this._serialConsistency;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreCassandraConsistency | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._consistency = undefined;
      this._serialConsistency = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._consistency = value.consistency;
      this._serialConsistency = value.serialConsistency;
    }
  }

  // consistency - computed: false, optional: true, required: false
  private _consistency?: number; 
  public get consistency() {
    return this.getNumberAttribute('consistency');
  }
  public set consistency(value: number) {
    this._consistency = value;
  }
  public resetConsistency() {
    this._consistency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get consistencyInput() {
    return this._consistency;
  }

  // serial_consistency - computed: false, optional: true, required: false
  private _serialConsistency?: number; 
  public get serialConsistency() {
    return this.getNumberAttribute('serial_consistency');
  }
  public set serialConsistency(value: number) {
    this._serialConsistency = value;
  }
  public resetSerialConsistency() {
    this._serialConsistency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serialConsistencyInput() {
    return this._serialConsistency;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreCassandra {
  /**
  * ConnectTimeout is a timeout for initial dial to cassandra server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#connect_timeout DataK8STemporalIoTemporalClusterV1Beta1Manifest#connect_timeout}
  */
  readonly connectTimeout?: string;
  /**
  * Consistency configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#consistency DataK8STemporalIoTemporalClusterV1Beta1Manifest#consistency}
  */
  readonly consistency?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreCassandraConsistency;
  /**
  * Datacenter is the data center filter arg for cassandra.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#datacenter DataK8STemporalIoTemporalClusterV1Beta1Manifest#datacenter}
  */
  readonly datacenter?: string;
  /**
  * DisableInitialHostLookup instructs the gocql client to connect only using the supplied hosts.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#disable_initial_host_lookup DataK8STemporalIoTemporalClusterV1Beta1Manifest#disable_initial_host_lookup}
  */
  readonly disableInitialHostLookup?: boolean | cdktf.IResolvable;
  /**
  * Hosts is a list of cassandra endpoints.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#hosts DataK8STemporalIoTemporalClusterV1Beta1Manifest#hosts}
  */
  readonly hosts: string[];
  /**
  * Keyspace is the cassandra keyspace.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#keyspace DataK8STemporalIoTemporalClusterV1Beta1Manifest#keyspace}
  */
  readonly keyspace: string;
  /**
  * MaxConns is the max number of connections to this datastore for a single keyspace.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#max_conns DataK8STemporalIoTemporalClusterV1Beta1Manifest#max_conns}
  */
  readonly maxConns?: number;
  /**
  * Port is the cassandra port used for connection by gocql client.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#port DataK8STemporalIoTemporalClusterV1Beta1Manifest#port}
  */
  readonly port: number;
  /**
  * User is the cassandra user used for authentication by gocql client.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#user DataK8STemporalIoTemporalClusterV1Beta1Manifest#user}
  */
  readonly user: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreCassandraToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreCassandra | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connect_timeout: cdktf.stringToTerraform(struct!.connectTimeout),
    consistency: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreCassandraConsistencyToTerraform(struct!.consistency),
    datacenter: cdktf.stringToTerraform(struct!.datacenter),
    disable_initial_host_lookup: cdktf.booleanToTerraform(struct!.disableInitialHostLookup),
    hosts: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.hosts),
    keyspace: cdktf.stringToTerraform(struct!.keyspace),
    max_conns: cdktf.numberToTerraform(struct!.maxConns),
    port: cdktf.numberToTerraform(struct!.port),
    user: cdktf.stringToTerraform(struct!.user),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreCassandraToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreCassandra | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connect_timeout: {
      value: cdktf.stringToHclTerraform(struct!.connectTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    consistency: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreCassandraConsistencyToHclTerraform(struct!.consistency),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreCassandraConsistency",
    },
    datacenter: {
      value: cdktf.stringToHclTerraform(struct!.datacenter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disable_initial_host_lookup: {
      value: cdktf.booleanToHclTerraform(struct!.disableInitialHostLookup),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    hosts: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.hosts),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    keyspace: {
      value: cdktf.stringToHclTerraform(struct!.keyspace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_conns: {
      value: cdktf.numberToHclTerraform(struct!.maxConns),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    user: {
      value: cdktf.stringToHclTerraform(struct!.user),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreCassandraOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreCassandra | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connectTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectTimeout = this._connectTimeout;
    }
    if (this._consistency?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.consistency = this._consistency?.internalValue;
    }
    if (this._datacenter !== undefined) {
      hasAnyValues = true;
      internalValueResult.datacenter = this._datacenter;
    }
    if (this._disableInitialHostLookup !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableInitialHostLookup = this._disableInitialHostLookup;
    }
    if (this._hosts !== undefined) {
      hasAnyValues = true;
      internalValueResult.hosts = this._hosts;
    }
    if (this._keyspace !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyspace = this._keyspace;
    }
    if (this._maxConns !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxConns = this._maxConns;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._user !== undefined) {
      hasAnyValues = true;
      internalValueResult.user = this._user;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreCassandra | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connectTimeout = undefined;
      this._consistency.internalValue = undefined;
      this._datacenter = undefined;
      this._disableInitialHostLookup = undefined;
      this._hosts = undefined;
      this._keyspace = undefined;
      this._maxConns = undefined;
      this._port = undefined;
      this._user = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connectTimeout = value.connectTimeout;
      this._consistency.internalValue = value.consistency;
      this._datacenter = value.datacenter;
      this._disableInitialHostLookup = value.disableInitialHostLookup;
      this._hosts = value.hosts;
      this._keyspace = value.keyspace;
      this._maxConns = value.maxConns;
      this._port = value.port;
      this._user = value.user;
    }
  }

  // connect_timeout - computed: false, optional: true, required: false
  private _connectTimeout?: string; 
  public get connectTimeout() {
    return this.getStringAttribute('connect_timeout');
  }
  public set connectTimeout(value: string) {
    this._connectTimeout = value;
  }
  public resetConnectTimeout() {
    this._connectTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectTimeoutInput() {
    return this._connectTimeout;
  }

  // consistency - computed: false, optional: true, required: false
  private _consistency = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreCassandraConsistencyOutputReference(this, "consistency");
  public get consistency() {
    return this._consistency;
  }
  public putConsistency(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreCassandraConsistency) {
    this._consistency.internalValue = value;
  }
  public resetConsistency() {
    this._consistency.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get consistencyInput() {
    return this._consistency.internalValue;
  }

  // datacenter - computed: false, optional: true, required: false
  private _datacenter?: string; 
  public get datacenter() {
    return this.getStringAttribute('datacenter');
  }
  public set datacenter(value: string) {
    this._datacenter = value;
  }
  public resetDatacenter() {
    this._datacenter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get datacenterInput() {
    return this._datacenter;
  }

  // disable_initial_host_lookup - computed: false, optional: true, required: false
  private _disableInitialHostLookup?: boolean | cdktf.IResolvable; 
  public get disableInitialHostLookup() {
    return this.getBooleanAttribute('disable_initial_host_lookup');
  }
  public set disableInitialHostLookup(value: boolean | cdktf.IResolvable) {
    this._disableInitialHostLookup = value;
  }
  public resetDisableInitialHostLookup() {
    this._disableInitialHostLookup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableInitialHostLookupInput() {
    return this._disableInitialHostLookup;
  }

  // hosts - computed: false, optional: false, required: true
  private _hosts?: string[]; 
  public get hosts() {
    return this.getListAttribute('hosts');
  }
  public set hosts(value: string[]) {
    this._hosts = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostsInput() {
    return this._hosts;
  }

  // keyspace - computed: false, optional: false, required: true
  private _keyspace?: string; 
  public get keyspace() {
    return this.getStringAttribute('keyspace');
  }
  public set keyspace(value: string) {
    this._keyspace = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyspaceInput() {
    return this._keyspace;
  }

  // max_conns - computed: false, optional: true, required: false
  private _maxConns?: number; 
  public get maxConns() {
    return this.getNumberAttribute('max_conns');
  }
  public set maxConns(value: number) {
    this._maxConns = value;
  }
  public resetMaxConns() {
    this._maxConns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxConnsInput() {
    return this._maxConns;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // user - computed: false, optional: false, required: true
  private _user?: string; 
  public get user() {
    return this.getStringAttribute('user');
  }
  public set user(value: string) {
    this._user = value;
  }
  // Temporarily expose input value. Use with caution.
  public get userInput() {
    return this._user;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreElasticsearchIndices {
  /**
  * SecondaryVisibility defines secondary visibility's index name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#secondary_visibility DataK8STemporalIoTemporalClusterV1Beta1Manifest#secondary_visibility}
  */
  readonly secondaryVisibility?: string;
  /**
  * Visibility defines visibility's index name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#visibility DataK8STemporalIoTemporalClusterV1Beta1Manifest#visibility}
  */
  readonly visibility: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreElasticsearchIndicesToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreElasticsearchIndices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secondary_visibility: cdktf.stringToTerraform(struct!.secondaryVisibility),
    visibility: cdktf.stringToTerraform(struct!.visibility),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreElasticsearchIndicesToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreElasticsearchIndices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secondary_visibility: {
      value: cdktf.stringToHclTerraform(struct!.secondaryVisibility),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    visibility: {
      value: cdktf.stringToHclTerraform(struct!.visibility),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreElasticsearchIndicesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreElasticsearchIndices | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secondaryVisibility !== undefined) {
      hasAnyValues = true;
      internalValueResult.secondaryVisibility = this._secondaryVisibility;
    }
    if (this._visibility !== undefined) {
      hasAnyValues = true;
      internalValueResult.visibility = this._visibility;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreElasticsearchIndices | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secondaryVisibility = undefined;
      this._visibility = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secondaryVisibility = value.secondaryVisibility;
      this._visibility = value.visibility;
    }
  }

  // secondary_visibility - computed: false, optional: true, required: false
  private _secondaryVisibility?: string; 
  public get secondaryVisibility() {
    return this.getStringAttribute('secondary_visibility');
  }
  public set secondaryVisibility(value: string) {
    this._secondaryVisibility = value;
  }
  public resetSecondaryVisibility() {
    this._secondaryVisibility = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secondaryVisibilityInput() {
    return this._secondaryVisibility;
  }

  // visibility - computed: false, optional: false, required: true
  private _visibility?: string; 
  public get visibility() {
    return this.getStringAttribute('visibility');
  }
  public set visibility(value: string) {
    this._visibility = value;
  }
  // Temporarily expose input value. Use with caution.
  public get visibilityInput() {
    return this._visibility;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreElasticsearch {
  /**
  * CloseIdleConnectionsInterval is the max duration a connection stay open while idle.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#close_idle_connections_interval DataK8STemporalIoTemporalClusterV1Beta1Manifest#close_idle_connections_interval}
  */
  readonly closeIdleConnectionsInterval?: string;
  /**
  * EnableHealthcheck enables or disables healthcheck on the temporal cluster's es client.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#enable_healthcheck DataK8STemporalIoTemporalClusterV1Beta1Manifest#enable_healthcheck}
  */
  readonly enableHealthcheck?: boolean | cdktf.IResolvable;
  /**
  * EnableSniff enables or disables sniffer on the temporal cluster's es client.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#enable_sniff DataK8STemporalIoTemporalClusterV1Beta1Manifest#enable_sniff}
  */
  readonly enableSniff?: boolean | cdktf.IResolvable;
  /**
  * Indices holds visibility index names.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#indices DataK8STemporalIoTemporalClusterV1Beta1Manifest#indices}
  */
  readonly indices: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreElasticsearchIndices;
  /**
  * LogLevel defines the temporal cluster's es client logger level.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#log_level DataK8STemporalIoTemporalClusterV1Beta1Manifest#log_level}
  */
  readonly logLevel?: string;
  /**
  * URL is the connection url to connect to the instance.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#url DataK8STemporalIoTemporalClusterV1Beta1Manifest#url}
  */
  readonly url: string;
  /**
  * Username is the username to be used for the connection.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#username DataK8STemporalIoTemporalClusterV1Beta1Manifest#username}
  */
  readonly username: string;
  /**
  * Version defines the elasticsearch version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#version DataK8STemporalIoTemporalClusterV1Beta1Manifest#version}
  */
  readonly version: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreElasticsearchToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreElasticsearch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    close_idle_connections_interval: cdktf.stringToTerraform(struct!.closeIdleConnectionsInterval),
    enable_healthcheck: cdktf.booleanToTerraform(struct!.enableHealthcheck),
    enable_sniff: cdktf.booleanToTerraform(struct!.enableSniff),
    indices: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreElasticsearchIndicesToTerraform(struct!.indices),
    log_level: cdktf.stringToTerraform(struct!.logLevel),
    url: cdktf.stringToTerraform(struct!.url),
    username: cdktf.stringToTerraform(struct!.username),
    version: cdktf.stringToTerraform(struct!.version),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreElasticsearchToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreElasticsearch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    close_idle_connections_interval: {
      value: cdktf.stringToHclTerraform(struct!.closeIdleConnectionsInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enable_healthcheck: {
      value: cdktf.booleanToHclTerraform(struct!.enableHealthcheck),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_sniff: {
      value: cdktf.booleanToHclTerraform(struct!.enableSniff),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    indices: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreElasticsearchIndicesToHclTerraform(struct!.indices),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreElasticsearchIndices",
    },
    log_level: {
      value: cdktf.stringToHclTerraform(struct!.logLevel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    version: {
      value: cdktf.stringToHclTerraform(struct!.version),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreElasticsearchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreElasticsearch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._closeIdleConnectionsInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.closeIdleConnectionsInterval = this._closeIdleConnectionsInterval;
    }
    if (this._enableHealthcheck !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHealthcheck = this._enableHealthcheck;
    }
    if (this._enableSniff !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableSniff = this._enableSniff;
    }
    if (this._indices?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.indices = this._indices?.internalValue;
    }
    if (this._logLevel !== undefined) {
      hasAnyValues = true;
      internalValueResult.logLevel = this._logLevel;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    if (this._version !== undefined) {
      hasAnyValues = true;
      internalValueResult.version = this._version;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreElasticsearch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._closeIdleConnectionsInterval = undefined;
      this._enableHealthcheck = undefined;
      this._enableSniff = undefined;
      this._indices.internalValue = undefined;
      this._logLevel = undefined;
      this._url = undefined;
      this._username = undefined;
      this._version = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._closeIdleConnectionsInterval = value.closeIdleConnectionsInterval;
      this._enableHealthcheck = value.enableHealthcheck;
      this._enableSniff = value.enableSniff;
      this._indices.internalValue = value.indices;
      this._logLevel = value.logLevel;
      this._url = value.url;
      this._username = value.username;
      this._version = value.version;
    }
  }

  // close_idle_connections_interval - computed: false, optional: true, required: false
  private _closeIdleConnectionsInterval?: string; 
  public get closeIdleConnectionsInterval() {
    return this.getStringAttribute('close_idle_connections_interval');
  }
  public set closeIdleConnectionsInterval(value: string) {
    this._closeIdleConnectionsInterval = value;
  }
  public resetCloseIdleConnectionsInterval() {
    this._closeIdleConnectionsInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get closeIdleConnectionsIntervalInput() {
    return this._closeIdleConnectionsInterval;
  }

  // enable_healthcheck - computed: false, optional: true, required: false
  private _enableHealthcheck?: boolean | cdktf.IResolvable; 
  public get enableHealthcheck() {
    return this.getBooleanAttribute('enable_healthcheck');
  }
  public set enableHealthcheck(value: boolean | cdktf.IResolvable) {
    this._enableHealthcheck = value;
  }
  public resetEnableHealthcheck() {
    this._enableHealthcheck = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHealthcheckInput() {
    return this._enableHealthcheck;
  }

  // enable_sniff - computed: false, optional: true, required: false
  private _enableSniff?: boolean | cdktf.IResolvable; 
  public get enableSniff() {
    return this.getBooleanAttribute('enable_sniff');
  }
  public set enableSniff(value: boolean | cdktf.IResolvable) {
    this._enableSniff = value;
  }
  public resetEnableSniff() {
    this._enableSniff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableSniffInput() {
    return this._enableSniff;
  }

  // indices - computed: false, optional: false, required: true
  private _indices = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreElasticsearchIndicesOutputReference(this, "indices");
  public get indices() {
    return this._indices;
  }
  public putIndices(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreElasticsearchIndices) {
    this._indices.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get indicesInput() {
    return this._indices.internalValue;
  }

  // log_level - computed: false, optional: true, required: false
  private _logLevel?: string; 
  public get logLevel() {
    return this.getStringAttribute('log_level');
  }
  public set logLevel(value: string) {
    this._logLevel = value;
  }
  public resetLogLevel() {
    this._logLevel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logLevelInput() {
    return this._logLevel;
  }

  // url - computed: false, optional: false, required: true
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }

  // username - computed: false, optional: false, required: true
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }

  // version - computed: false, optional: false, required: true
  private _version?: string; 
  public get version() {
    return this.getStringAttribute('version');
  }
  public set version(value: string) {
    this._version = value;
  }
  // Temporarily expose input value. Use with caution.
  public get versionInput() {
    return this._version;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStorePasswordSecretRef {
  /**
  * Key in the Secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#key DataK8STemporalIoTemporalClusterV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * Name of the Secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#name DataK8STemporalIoTemporalClusterV1Beta1Manifest#name}
  */
  readonly name: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStorePasswordSecretRefToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStorePasswordSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStorePasswordSecretRefToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStorePasswordSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStorePasswordSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStorePasswordSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStorePasswordSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreSql {
  /**
  * ConnectAddr is the remote addr of the database.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#connect_addr DataK8STemporalIoTemporalClusterV1Beta1Manifest#connect_addr}
  */
  readonly connectAddr: string;
  /**
  * ConnectAttributes is a set of key-value attributes to be sent as part of connect data_source_name url
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#connect_attributes DataK8STemporalIoTemporalClusterV1Beta1Manifest#connect_attributes}
  */
  readonly connectAttributes?: { [key: string]: string };
  /**
  * ConnectProtocol is the protocol that goes with the ConnectAddr.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#connect_protocol DataK8STemporalIoTemporalClusterV1Beta1Manifest#connect_protocol}
  */
  readonly connectProtocol?: string;
  /**
  * DatabaseName is the name of SQL database to connect to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#database_name DataK8STemporalIoTemporalClusterV1Beta1Manifest#database_name}
  */
  readonly databaseName: string;
  /**
  * GCPServiceAccount is the service account to use to authenticate with GCP CloudSQL.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#gcp_service_account DataK8STemporalIoTemporalClusterV1Beta1Manifest#gcp_service_account}
  */
  readonly gcpServiceAccount?: string;
  /**
  * MaxConnLifetime is the maximum time a connection can be alive
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#max_conn_lifetime DataK8STemporalIoTemporalClusterV1Beta1Manifest#max_conn_lifetime}
  */
  readonly maxConnLifetime?: string;
  /**
  * MaxConns the max number of connections to this datastore.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#max_conns DataK8STemporalIoTemporalClusterV1Beta1Manifest#max_conns}
  */
  readonly maxConns?: number;
  /**
  * MaxIdleConns is the max number of idle connections to this datastore.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#max_idle_conns DataK8STemporalIoTemporalClusterV1Beta1Manifest#max_idle_conns}
  */
  readonly maxIdleConns?: number;
  /**
  * PluginName is the name of SQL plugin.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#plugin_name DataK8STemporalIoTemporalClusterV1Beta1Manifest#plugin_name}
  */
  readonly pluginName: string;
  /**
  * TaskScanPartitions is the number of partitions to sequentially scan during ListTaskQueue operations.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#task_scan_partitions DataK8STemporalIoTemporalClusterV1Beta1Manifest#task_scan_partitions}
  */
  readonly taskScanPartitions?: number;
  /**
  * User is the username to be used for the connection.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#user DataK8STemporalIoTemporalClusterV1Beta1Manifest#user}
  */
  readonly user: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreSqlToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreSql | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connect_addr: cdktf.stringToTerraform(struct!.connectAddr),
    connect_attributes: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.connectAttributes),
    connect_protocol: cdktf.stringToTerraform(struct!.connectProtocol),
    database_name: cdktf.stringToTerraform(struct!.databaseName),
    gcp_service_account: cdktf.stringToTerraform(struct!.gcpServiceAccount),
    max_conn_lifetime: cdktf.stringToTerraform(struct!.maxConnLifetime),
    max_conns: cdktf.numberToTerraform(struct!.maxConns),
    max_idle_conns: cdktf.numberToTerraform(struct!.maxIdleConns),
    plugin_name: cdktf.stringToTerraform(struct!.pluginName),
    task_scan_partitions: cdktf.numberToTerraform(struct!.taskScanPartitions),
    user: cdktf.stringToTerraform(struct!.user),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreSqlToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreSql | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connect_addr: {
      value: cdktf.stringToHclTerraform(struct!.connectAddr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connect_attributes: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.connectAttributes),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    connect_protocol: {
      value: cdktf.stringToHclTerraform(struct!.connectProtocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    database_name: {
      value: cdktf.stringToHclTerraform(struct!.databaseName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    gcp_service_account: {
      value: cdktf.stringToHclTerraform(struct!.gcpServiceAccount),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_conn_lifetime: {
      value: cdktf.stringToHclTerraform(struct!.maxConnLifetime),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_conns: {
      value: cdktf.numberToHclTerraform(struct!.maxConns),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_idle_conns: {
      value: cdktf.numberToHclTerraform(struct!.maxIdleConns),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    plugin_name: {
      value: cdktf.stringToHclTerraform(struct!.pluginName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    task_scan_partitions: {
      value: cdktf.numberToHclTerraform(struct!.taskScanPartitions),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    user: {
      value: cdktf.stringToHclTerraform(struct!.user),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreSqlOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreSql | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connectAddr !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectAddr = this._connectAddr;
    }
    if (this._connectAttributes !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectAttributes = this._connectAttributes;
    }
    if (this._connectProtocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectProtocol = this._connectProtocol;
    }
    if (this._databaseName !== undefined) {
      hasAnyValues = true;
      internalValueResult.databaseName = this._databaseName;
    }
    if (this._gcpServiceAccount !== undefined) {
      hasAnyValues = true;
      internalValueResult.gcpServiceAccount = this._gcpServiceAccount;
    }
    if (this._maxConnLifetime !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxConnLifetime = this._maxConnLifetime;
    }
    if (this._maxConns !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxConns = this._maxConns;
    }
    if (this._maxIdleConns !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxIdleConns = this._maxIdleConns;
    }
    if (this._pluginName !== undefined) {
      hasAnyValues = true;
      internalValueResult.pluginName = this._pluginName;
    }
    if (this._taskScanPartitions !== undefined) {
      hasAnyValues = true;
      internalValueResult.taskScanPartitions = this._taskScanPartitions;
    }
    if (this._user !== undefined) {
      hasAnyValues = true;
      internalValueResult.user = this._user;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreSql | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connectAddr = undefined;
      this._connectAttributes = undefined;
      this._connectProtocol = undefined;
      this._databaseName = undefined;
      this._gcpServiceAccount = undefined;
      this._maxConnLifetime = undefined;
      this._maxConns = undefined;
      this._maxIdleConns = undefined;
      this._pluginName = undefined;
      this._taskScanPartitions = undefined;
      this._user = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connectAddr = value.connectAddr;
      this._connectAttributes = value.connectAttributes;
      this._connectProtocol = value.connectProtocol;
      this._databaseName = value.databaseName;
      this._gcpServiceAccount = value.gcpServiceAccount;
      this._maxConnLifetime = value.maxConnLifetime;
      this._maxConns = value.maxConns;
      this._maxIdleConns = value.maxIdleConns;
      this._pluginName = value.pluginName;
      this._taskScanPartitions = value.taskScanPartitions;
      this._user = value.user;
    }
  }

  // connect_addr - computed: false, optional: false, required: true
  private _connectAddr?: string; 
  public get connectAddr() {
    return this.getStringAttribute('connect_addr');
  }
  public set connectAddr(value: string) {
    this._connectAddr = value;
  }
  // Temporarily expose input value. Use with caution.
  public get connectAddrInput() {
    return this._connectAddr;
  }

  // connect_attributes - computed: false, optional: true, required: false
  private _connectAttributes?: { [key: string]: string }; 
  public get connectAttributes() {
    return this.getStringMapAttribute('connect_attributes');
  }
  public set connectAttributes(value: { [key: string]: string }) {
    this._connectAttributes = value;
  }
  public resetConnectAttributes() {
    this._connectAttributes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectAttributesInput() {
    return this._connectAttributes;
  }

  // connect_protocol - computed: false, optional: true, required: false
  private _connectProtocol?: string; 
  public get connectProtocol() {
    return this.getStringAttribute('connect_protocol');
  }
  public set connectProtocol(value: string) {
    this._connectProtocol = value;
  }
  public resetConnectProtocol() {
    this._connectProtocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectProtocolInput() {
    return this._connectProtocol;
  }

  // database_name - computed: false, optional: false, required: true
  private _databaseName?: string; 
  public get databaseName() {
    return this.getStringAttribute('database_name');
  }
  public set databaseName(value: string) {
    this._databaseName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseNameInput() {
    return this._databaseName;
  }

  // gcp_service_account - computed: false, optional: true, required: false
  private _gcpServiceAccount?: string; 
  public get gcpServiceAccount() {
    return this.getStringAttribute('gcp_service_account');
  }
  public set gcpServiceAccount(value: string) {
    this._gcpServiceAccount = value;
  }
  public resetGcpServiceAccount() {
    this._gcpServiceAccount = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gcpServiceAccountInput() {
    return this._gcpServiceAccount;
  }

  // max_conn_lifetime - computed: false, optional: true, required: false
  private _maxConnLifetime?: string; 
  public get maxConnLifetime() {
    return this.getStringAttribute('max_conn_lifetime');
  }
  public set maxConnLifetime(value: string) {
    this._maxConnLifetime = value;
  }
  public resetMaxConnLifetime() {
    this._maxConnLifetime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxConnLifetimeInput() {
    return this._maxConnLifetime;
  }

  // max_conns - computed: false, optional: true, required: false
  private _maxConns?: number; 
  public get maxConns() {
    return this.getNumberAttribute('max_conns');
  }
  public set maxConns(value: number) {
    this._maxConns = value;
  }
  public resetMaxConns() {
    this._maxConns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxConnsInput() {
    return this._maxConns;
  }

  // max_idle_conns - computed: false, optional: true, required: false
  private _maxIdleConns?: number; 
  public get maxIdleConns() {
    return this.getNumberAttribute('max_idle_conns');
  }
  public set maxIdleConns(value: number) {
    this._maxIdleConns = value;
  }
  public resetMaxIdleConns() {
    this._maxIdleConns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxIdleConnsInput() {
    return this._maxIdleConns;
  }

  // plugin_name - computed: false, optional: false, required: true
  private _pluginName?: string; 
  public get pluginName() {
    return this.getStringAttribute('plugin_name');
  }
  public set pluginName(value: string) {
    this._pluginName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pluginNameInput() {
    return this._pluginName;
  }

  // task_scan_partitions - computed: false, optional: true, required: false
  private _taskScanPartitions?: number; 
  public get taskScanPartitions() {
    return this.getNumberAttribute('task_scan_partitions');
  }
  public set taskScanPartitions(value: number) {
    this._taskScanPartitions = value;
  }
  public resetTaskScanPartitions() {
    this._taskScanPartitions = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get taskScanPartitionsInput() {
    return this._taskScanPartitions;
  }

  // user - computed: false, optional: false, required: true
  private _user?: string; 
  public get user() {
    return this.getStringAttribute('user');
  }
  public set user(value: string) {
    this._user = value;
  }
  // Temporarily expose input value. Use with caution.
  public get userInput() {
    return this._user;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreTlsCaFileRef {
  /**
  * Key in the Secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#key DataK8STemporalIoTemporalClusterV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * Name of the Secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#name DataK8STemporalIoTemporalClusterV1Beta1Manifest#name}
  */
  readonly name: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreTlsCaFileRefToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreTlsCaFileRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreTlsCaFileRefToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreTlsCaFileRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreTlsCaFileRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreTlsCaFileRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreTlsCaFileRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreTlsCertFileRef {
  /**
  * Key in the Secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#key DataK8STemporalIoTemporalClusterV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * Name of the Secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#name DataK8STemporalIoTemporalClusterV1Beta1Manifest#name}
  */
  readonly name: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreTlsCertFileRefToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreTlsCertFileRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreTlsCertFileRefToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreTlsCertFileRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreTlsCertFileRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreTlsCertFileRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreTlsCertFileRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreTlsKeyFileRef {
  /**
  * Key in the Secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#key DataK8STemporalIoTemporalClusterV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * Name of the Secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#name DataK8STemporalIoTemporalClusterV1Beta1Manifest#name}
  */
  readonly name: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreTlsKeyFileRefToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreTlsKeyFileRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreTlsKeyFileRefToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreTlsKeyFileRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreTlsKeyFileRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreTlsKeyFileRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreTlsKeyFileRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreTls {
  /**
  * CaFileRef is a reference to a secret containing the ca file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#ca_file_ref DataK8STemporalIoTemporalClusterV1Beta1Manifest#ca_file_ref}
  */
  readonly caFileRef?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreTlsCaFileRef;
  /**
  * CertFileRef is a reference to a secret containing the cert file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#cert_file_ref DataK8STemporalIoTemporalClusterV1Beta1Manifest#cert_file_ref}
  */
  readonly certFileRef?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreTlsCertFileRef;
  /**
  * EnableHostVerification defines if the hostname should be verified when connecting to the datastore.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#enable_host_verification DataK8STemporalIoTemporalClusterV1Beta1Manifest#enable_host_verification}
  */
  readonly enableHostVerification: boolean | cdktf.IResolvable;
  /**
  * Enabled defines if the cluster should use a TLS connection to connect to the datastore.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#enabled DataK8STemporalIoTemporalClusterV1Beta1Manifest#enabled}
  */
  readonly enabled: boolean | cdktf.IResolvable;
  /**
  * KeyFileRef is a reference to a secret containing the key file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#key_file_ref DataK8STemporalIoTemporalClusterV1Beta1Manifest#key_file_ref}
  */
  readonly keyFileRef?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreTlsKeyFileRef;
  /**
  * ServerName the datastore should present.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#server_name DataK8STemporalIoTemporalClusterV1Beta1Manifest#server_name}
  */
  readonly serverName?: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreTlsToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_file_ref: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreTlsCaFileRefToTerraform(struct!.caFileRef),
    cert_file_ref: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreTlsCertFileRefToTerraform(struct!.certFileRef),
    enable_host_verification: cdktf.booleanToTerraform(struct!.enableHostVerification),
    enabled: cdktf.booleanToTerraform(struct!.enabled),
    key_file_ref: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreTlsKeyFileRefToTerraform(struct!.keyFileRef),
    server_name: cdktf.stringToTerraform(struct!.serverName),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreTlsToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_file_ref: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreTlsCaFileRefToHclTerraform(struct!.caFileRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreTlsCaFileRef",
    },
    cert_file_ref: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreTlsCertFileRefToHclTerraform(struct!.certFileRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreTlsCertFileRef",
    },
    enable_host_verification: {
      value: cdktf.booleanToHclTerraform(struct!.enableHostVerification),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    key_file_ref: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreTlsKeyFileRefToHclTerraform(struct!.keyFileRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreTlsKeyFileRef",
    },
    server_name: {
      value: cdktf.stringToHclTerraform(struct!.serverName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caFileRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.caFileRef = this._caFileRef?.internalValue;
    }
    if (this._certFileRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.certFileRef = this._certFileRef?.internalValue;
    }
    if (this._enableHostVerification !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHostVerification = this._enableHostVerification;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._keyFileRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyFileRef = this._keyFileRef?.internalValue;
    }
    if (this._serverName !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverName = this._serverName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caFileRef.internalValue = undefined;
      this._certFileRef.internalValue = undefined;
      this._enableHostVerification = undefined;
      this._enabled = undefined;
      this._keyFileRef.internalValue = undefined;
      this._serverName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caFileRef.internalValue = value.caFileRef;
      this._certFileRef.internalValue = value.certFileRef;
      this._enableHostVerification = value.enableHostVerification;
      this._enabled = value.enabled;
      this._keyFileRef.internalValue = value.keyFileRef;
      this._serverName = value.serverName;
    }
  }

  // ca_file_ref - computed: false, optional: true, required: false
  private _caFileRef = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreTlsCaFileRefOutputReference(this, "ca_file_ref");
  public get caFileRef() {
    return this._caFileRef;
  }
  public putCaFileRef(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreTlsCaFileRef) {
    this._caFileRef.internalValue = value;
  }
  public resetCaFileRef() {
    this._caFileRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caFileRefInput() {
    return this._caFileRef.internalValue;
  }

  // cert_file_ref - computed: false, optional: true, required: false
  private _certFileRef = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreTlsCertFileRefOutputReference(this, "cert_file_ref");
  public get certFileRef() {
    return this._certFileRef;
  }
  public putCertFileRef(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreTlsCertFileRef) {
    this._certFileRef.internalValue = value;
  }
  public resetCertFileRef() {
    this._certFileRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certFileRefInput() {
    return this._certFileRef.internalValue;
  }

  // enable_host_verification - computed: false, optional: false, required: true
  private _enableHostVerification?: boolean | cdktf.IResolvable; 
  public get enableHostVerification() {
    return this.getBooleanAttribute('enable_host_verification');
  }
  public set enableHostVerification(value: boolean | cdktf.IResolvable) {
    this._enableHostVerification = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHostVerificationInput() {
    return this._enableHostVerification;
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // key_file_ref - computed: false, optional: true, required: false
  private _keyFileRef = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreTlsKeyFileRefOutputReference(this, "key_file_ref");
  public get keyFileRef() {
    return this._keyFileRef;
  }
  public putKeyFileRef(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreTlsKeyFileRef) {
    this._keyFileRef.internalValue = value;
  }
  public resetKeyFileRef() {
    this._keyFileRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyFileRefInput() {
    return this._keyFileRef.internalValue;
  }

  // server_name - computed: false, optional: true, required: false
  private _serverName?: string; 
  public get serverName() {
    return this.getStringAttribute('server_name');
  }
  public set serverName(value: string) {
    this._serverName = value;
  }
  public resetServerName() {
    this._serverName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverNameInput() {
    return this._serverName;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStore {
  /**
  * Cassandra holds all connection parameters for Cassandra datastore. Note that cassandra is now deprecated for visibility store.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#cassandra DataK8STemporalIoTemporalClusterV1Beta1Manifest#cassandra}
  */
  readonly cassandra?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreCassandra;
  /**
  * Elasticsearch holds all connection parameters for Elasticsearch datastores.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#elasticsearch DataK8STemporalIoTemporalClusterV1Beta1Manifest#elasticsearch}
  */
  readonly elasticsearch?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreElasticsearch;
  /**
  * Name is the name of the datastore. It should be unique and will be referenced within the persistence spec. Defaults to 'default' for default sore, 'visibility' for visibility store, 'secondaryVisibility' for secondary visibility store and 'advancedVisibility' for advanced visibility store.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#name DataK8STemporalIoTemporalClusterV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * PasswordSecret is the reference to the secret holding the password.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#password_secret_ref DataK8STemporalIoTemporalClusterV1Beta1Manifest#password_secret_ref}
  */
  readonly passwordSecretRef?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStorePasswordSecretRef;
  /**
  * SkipCreate instructs the operator to skip creating the database for SQL datastores or to skip creating keyspace for Cassandra. Use this option if your database or keyspace has already been provisioned by an administrator.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#skip_create DataK8STemporalIoTemporalClusterV1Beta1Manifest#skip_create}
  */
  readonly skipCreate?: boolean | cdktf.IResolvable;
  /**
  * SQL holds all connection parameters for SQL datastores.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#sql DataK8STemporalIoTemporalClusterV1Beta1Manifest#sql}
  */
  readonly sql?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreSql;
  /**
  * TLS is an optional option to connect to the datastore using TLS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#tls DataK8STemporalIoTemporalClusterV1Beta1Manifest#tls}
  */
  readonly tls?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreTls;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStore | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cassandra: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreCassandraToTerraform(struct!.cassandra),
    elasticsearch: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreElasticsearchToTerraform(struct!.elasticsearch),
    name: cdktf.stringToTerraform(struct!.name),
    password_secret_ref: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStorePasswordSecretRefToTerraform(struct!.passwordSecretRef),
    skip_create: cdktf.booleanToTerraform(struct!.skipCreate),
    sql: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreSqlToTerraform(struct!.sql),
    tls: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreTlsToTerraform(struct!.tls),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStore | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cassandra: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreCassandraToHclTerraform(struct!.cassandra),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreCassandra",
    },
    elasticsearch: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreElasticsearchToHclTerraform(struct!.elasticsearch),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreElasticsearch",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password_secret_ref: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStorePasswordSecretRefToHclTerraform(struct!.passwordSecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStorePasswordSecretRef",
    },
    skip_create: {
      value: cdktf.booleanToHclTerraform(struct!.skipCreate),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    sql: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreSqlToHclTerraform(struct!.sql),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreSql",
    },
    tls: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreTls",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStore | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cassandra?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cassandra = this._cassandra?.internalValue;
    }
    if (this._elasticsearch?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.elasticsearch = this._elasticsearch?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._passwordSecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.passwordSecretRef = this._passwordSecretRef?.internalValue;
    }
    if (this._skipCreate !== undefined) {
      hasAnyValues = true;
      internalValueResult.skipCreate = this._skipCreate;
    }
    if (this._sql?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sql = this._sql?.internalValue;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStore | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cassandra.internalValue = undefined;
      this._elasticsearch.internalValue = undefined;
      this._name = undefined;
      this._passwordSecretRef.internalValue = undefined;
      this._skipCreate = undefined;
      this._sql.internalValue = undefined;
      this._tls.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cassandra.internalValue = value.cassandra;
      this._elasticsearch.internalValue = value.elasticsearch;
      this._name = value.name;
      this._passwordSecretRef.internalValue = value.passwordSecretRef;
      this._skipCreate = value.skipCreate;
      this._sql.internalValue = value.sql;
      this._tls.internalValue = value.tls;
    }
  }

  // cassandra - computed: false, optional: true, required: false
  private _cassandra = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreCassandraOutputReference(this, "cassandra");
  public get cassandra() {
    return this._cassandra;
  }
  public putCassandra(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreCassandra) {
    this._cassandra.internalValue = value;
  }
  public resetCassandra() {
    this._cassandra.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cassandraInput() {
    return this._cassandra.internalValue;
  }

  // elasticsearch - computed: false, optional: true, required: false
  private _elasticsearch = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreElasticsearchOutputReference(this, "elasticsearch");
  public get elasticsearch() {
    return this._elasticsearch;
  }
  public putElasticsearch(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreElasticsearch) {
    this._elasticsearch.internalValue = value;
  }
  public resetElasticsearch() {
    this._elasticsearch.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get elasticsearchInput() {
    return this._elasticsearch.internalValue;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // password_secret_ref - computed: false, optional: true, required: false
  private _passwordSecretRef = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStorePasswordSecretRefOutputReference(this, "password_secret_ref");
  public get passwordSecretRef() {
    return this._passwordSecretRef;
  }
  public putPasswordSecretRef(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStorePasswordSecretRef) {
    this._passwordSecretRef.internalValue = value;
  }
  public resetPasswordSecretRef() {
    this._passwordSecretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordSecretRefInput() {
    return this._passwordSecretRef.internalValue;
  }

  // skip_create - computed: false, optional: true, required: false
  private _skipCreate?: boolean | cdktf.IResolvable; 
  public get skipCreate() {
    return this.getBooleanAttribute('skip_create');
  }
  public set skipCreate(value: boolean | cdktf.IResolvable) {
    this._skipCreate = value;
  }
  public resetSkipCreate() {
    this._skipCreate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get skipCreateInput() {
    return this._skipCreate;
  }

  // sql - computed: false, optional: true, required: false
  private _sql = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreSqlOutputReference(this, "sql");
  public get sql() {
    return this._sql;
  }
  public putSql(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreSql) {
    this._sql.internalValue = value;
  }
  public resetSql() {
    this._sql.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sqlInput() {
    return this._sql.internalValue;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistence {
  /**
  * AdvancedVisibilityStore holds the advanced visibility datastore specs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#advanced_visibility_store DataK8STemporalIoTemporalClusterV1Beta1Manifest#advanced_visibility_store}
  */
  readonly advancedVisibilityStore?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStore;
  /**
  * DefaultStore holds the default datastore specs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#default_store DataK8STemporalIoTemporalClusterV1Beta1Manifest#default_store}
  */
  readonly defaultStore: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStore;
  /**
  * SecondaryVisibilityStore holds the secondary visibility datastore specs. Feature only available for clusters >= 1.21.0.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#secondary_visibility_store DataK8STemporalIoTemporalClusterV1Beta1Manifest#secondary_visibility_store}
  */
  readonly secondaryVisibilityStore?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStore;
  /**
  * VisibilityStore holds the visibility datastore specs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#visibility_store DataK8STemporalIoTemporalClusterV1Beta1Manifest#visibility_store}
  */
  readonly visibilityStore: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStore;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistence | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    advanced_visibility_store: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreToTerraform(struct!.advancedVisibilityStore),
    default_store: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreToTerraform(struct!.defaultStore),
    secondary_visibility_store: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreToTerraform(struct!.secondaryVisibilityStore),
    visibility_store: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreToTerraform(struct!.visibilityStore),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistence | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    advanced_visibility_store: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreToHclTerraform(struct!.advancedVisibilityStore),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStore",
    },
    default_store: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreToHclTerraform(struct!.defaultStore),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStore",
    },
    secondary_visibility_store: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreToHclTerraform(struct!.secondaryVisibilityStore),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStore",
    },
    visibility_store: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreToHclTerraform(struct!.visibilityStore),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStore",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistence | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._advancedVisibilityStore?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.advancedVisibilityStore = this._advancedVisibilityStore?.internalValue;
    }
    if (this._defaultStore?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultStore = this._defaultStore?.internalValue;
    }
    if (this._secondaryVisibilityStore?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secondaryVisibilityStore = this._secondaryVisibilityStore?.internalValue;
    }
    if (this._visibilityStore?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.visibilityStore = this._visibilityStore?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistence | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._advancedVisibilityStore.internalValue = undefined;
      this._defaultStore.internalValue = undefined;
      this._secondaryVisibilityStore.internalValue = undefined;
      this._visibilityStore.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._advancedVisibilityStore.internalValue = value.advancedVisibilityStore;
      this._defaultStore.internalValue = value.defaultStore;
      this._secondaryVisibilityStore.internalValue = value.secondaryVisibilityStore;
      this._visibilityStore.internalValue = value.visibilityStore;
    }
  }

  // advanced_visibility_store - computed: false, optional: true, required: false
  private _advancedVisibilityStore = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStoreOutputReference(this, "advanced_visibility_store");
  public get advancedVisibilityStore() {
    return this._advancedVisibilityStore;
  }
  public putAdvancedVisibilityStore(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceAdvancedVisibilityStore) {
    this._advancedVisibilityStore.internalValue = value;
  }
  public resetAdvancedVisibilityStore() {
    this._advancedVisibilityStore.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get advancedVisibilityStoreInput() {
    return this._advancedVisibilityStore.internalValue;
  }

  // default_store - computed: false, optional: false, required: true
  private _defaultStore = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStoreOutputReference(this, "default_store");
  public get defaultStore() {
    return this._defaultStore;
  }
  public putDefaultStore(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceDefaultStore) {
    this._defaultStore.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultStoreInput() {
    return this._defaultStore.internalValue;
  }

  // secondary_visibility_store - computed: false, optional: true, required: false
  private _secondaryVisibilityStore = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStoreOutputReference(this, "secondary_visibility_store");
  public get secondaryVisibilityStore() {
    return this._secondaryVisibilityStore;
  }
  public putSecondaryVisibilityStore(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceSecondaryVisibilityStore) {
    this._secondaryVisibilityStore.internalValue = value;
  }
  public resetSecondaryVisibilityStore() {
    this._secondaryVisibilityStore.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secondaryVisibilityStoreInput() {
    return this._secondaryVisibilityStore.internalValue;
  }

  // visibility_store - computed: false, optional: false, required: true
  private _visibilityStore = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStoreOutputReference(this, "visibility_store");
  public get visibilityStore() {
    return this._visibilityStore;
  }
  public putVisibilityStore(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceVisibilityStore) {
    this._visibilityStore.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get visibilityStoreInput() {
    return this._visibilityStore.internalValue;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentMetadata {
  /**
  * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#annotations DataK8STemporalIoTemporalClusterV1Beta1Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Map of string keys and values that can be used to organize and categorize (scope and select) objects.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#labels DataK8STemporalIoTemporalClusterV1Beta1Manifest#labels}
  */
  readonly labels?: { [key: string]: string };
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentMetadataToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentMetadataToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotations = undefined;
      this._labels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotations = value.annotations;
      this._labels = value.labels;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentSpecTemplateMetadata {
  /**
  * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#annotations DataK8STemporalIoTemporalClusterV1Beta1Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Map of string keys and values that can be used to organize and categorize (scope and select) objects.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#labels DataK8STemporalIoTemporalClusterV1Beta1Manifest#labels}
  */
  readonly labels?: { [key: string]: string };
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentSpecTemplateMetadataToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentSpecTemplateMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentSpecTemplateMetadataToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentSpecTemplateMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentSpecTemplateMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentSpecTemplateMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentSpecTemplateMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotations = undefined;
      this._labels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotations = value.annotations;
      this._labels = value.labels;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentSpecTemplate {
  /**
  * ObjectMetaOverride provides the ability to override an object metadata. It's a subset of the fields included in k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#metadata DataK8STemporalIoTemporalClusterV1Beta1Manifest#metadata}
  */
  readonly metadata?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentSpecTemplateMetadata;
  /**
  * Specification of the desired behavior of the pod.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#spec DataK8STemporalIoTemporalClusterV1Beta1Manifest#spec}
  */
  readonly spec?: { [key: string]: string };
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentSpecTemplateToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentSpecTemplate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    metadata: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentSpecTemplateMetadataToTerraform(struct!.metadata),
    spec: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.spec),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentSpecTemplateToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentSpecTemplate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    metadata: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentSpecTemplateMetadataToHclTerraform(struct!.metadata),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentSpecTemplateMetadata",
    },
    spec: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.spec),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentSpecTemplateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentSpecTemplate | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._spec !== undefined) {
      hasAnyValues = true;
      internalValueResult.spec = this._spec;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentSpecTemplate | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._metadata.internalValue = undefined;
      this._spec = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._metadata.internalValue = value.metadata;
      this._spec = value.spec;
    }
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentSpecTemplateMetadataOutputReference(this, "metadata");
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentSpecTemplateMetadata) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // spec - computed: false, optional: true, required: false
  private _spec?: { [key: string]: string }; 
  public get spec() {
    return this.getStringMapAttribute('spec');
  }
  public set spec(value: { [key: string]: string }) {
    this._spec = value;
  }
  public resetSpec() {
    this._spec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get specInput() {
    return this._spec;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentSpec {
  /**
  * Template describes the pods that will be created.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#template DataK8STemporalIoTemporalClusterV1Beta1Manifest#template}
  */
  readonly template?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentSpecTemplate;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentSpecToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    template: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentSpecTemplateToTerraform(struct!.template),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentSpecToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    template: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentSpecTemplateToHclTerraform(struct!.template),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentSpecTemplate",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentSpecOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentSpec | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._template?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.template = this._template?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentSpec | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._template.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._template.internalValue = value.template;
    }
  }

  // template - computed: false, optional: true, required: false
  private _template = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentSpecTemplateOutputReference(this, "template");
  public get template() {
    return this._template;
  }
  public putTemplate(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentSpecTemplate) {
    this._template.internalValue = value;
  }
  public resetTemplate() {
    this._template.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get templateInput() {
    return this._template.internalValue;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeployment {
  /**
  * ObjectMetaOverride provides the ability to override an object metadata. It's a subset of the fields included in k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#metadata DataK8STemporalIoTemporalClusterV1Beta1Manifest#metadata}
  */
  readonly metadata?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentMetadata;
  /**
  * Specification of the desired behavior of the Deployment.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#spec DataK8STemporalIoTemporalClusterV1Beta1Manifest#spec}
  */
  readonly spec?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentSpec;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeployment | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    metadata: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentMetadataToTerraform(struct!.metadata),
    spec: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentSpecToTerraform(struct!.spec),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeployment | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    metadata: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentMetadataToHclTerraform(struct!.metadata),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentMetadata",
    },
    spec: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentSpecToHclTerraform(struct!.spec),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentSpec",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeployment | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._spec?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.spec = this._spec?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeployment | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._metadata.internalValue = undefined;
      this._spec.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._metadata.internalValue = value.metadata;
      this._spec.internalValue = value.spec;
    }
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentMetadataOutputReference(this, "metadata");
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentMetadata) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // spec - computed: false, optional: true, required: false
  private _spec = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentSpecOutputReference(this, "spec");
  public get spec() {
    return this._spec;
  }
  public putSpec(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentSpec) {
    this._spec.internalValue = value;
  }
  public resetSpec() {
    this._spec.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get specInput() {
    return this._spec.internalValue;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverrides {
  /**
  * Override configuration for the temporal service Deployment.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#deployment DataK8STemporalIoTemporalClusterV1Beta1Manifest#deployment}
  */
  readonly deployment?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeployment;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverrides | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    deployment: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentToTerraform(struct!.deployment),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverrides | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    deployment: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentToHclTerraform(struct!.deployment),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeployment",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverrides | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._deployment?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.deployment = this._deployment?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverrides | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._deployment.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._deployment.internalValue = value.deployment;
    }
  }

  // deployment - computed: false, optional: true, required: false
  private _deployment = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeploymentOutputReference(this, "deployment");
  public get deployment() {
    return this._deployment;
  }
  public putDeployment(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesDeployment) {
    this._deployment.internalValue = value;
  }
  public resetDeployment() {
    this._deployment.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deploymentInput() {
    return this._deployment.internalValue;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendResourcesClaims {
  /**
  * Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#name DataK8STemporalIoTemporalClusterV1Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * Request is the name chosen for a request in the referenced claim. If empty, everything from the claim is made available, otherwise only the result of this request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#request DataK8STemporalIoTemporalClusterV1Beta1Manifest#request}
  */
  readonly request?: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendResourcesClaimsToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendResourcesClaims | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    request: cdktf.stringToTerraform(struct!.request),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendResourcesClaimsToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendResourcesClaims | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request: {
      value: cdktf.stringToHclTerraform(struct!.request),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendResourcesClaimsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendResourcesClaims | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._request !== undefined) {
      hasAnyValues = true;
      internalValueResult.request = this._request;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendResourcesClaims | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._request = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._request = value.request;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // request - computed: false, optional: true, required: false
  private _request?: string; 
  public get request() {
    return this.getStringAttribute('request');
  }
  public set request(value: string) {
    this._request = value;
  }
  public resetRequest() {
    this._request = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestInput() {
    return this._request;
  }
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendResourcesClaimsList extends cdktf.ComplexList {
  public internalValue? : DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendResourcesClaims[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendResourcesClaimsOutputReference {
    return new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendResourcesClaimsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendResources {
  /**
  * Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container. This is an alpha field and requires enabling the DynamicResourceAllocation feature gate. This field is immutable. It can only be set for containers.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#claims DataK8STemporalIoTemporalClusterV1Beta1Manifest#claims}
  */
  readonly claims?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendResourcesClaims[] | cdktf.IResolvable;
  /**
  * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#limits DataK8STemporalIoTemporalClusterV1Beta1Manifest#limits}
  */
  readonly limits?: { [key: string]: string };
  /**
  * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. Requests cannot exceed Limits. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#requests DataK8STemporalIoTemporalClusterV1Beta1Manifest#requests}
  */
  readonly requests?: { [key: string]: string };
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendResourcesToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendResources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    claims: cdktf.listMapper(dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendResourcesClaimsToTerraform, false)(struct!.claims),
    limits: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.limits),
    requests: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.requests),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendResourcesToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendResources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    claims: {
      value: cdktf.listMapperHcl(dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendResourcesClaimsToHclTerraform, false)(struct!.claims),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendResourcesClaimsList",
    },
    limits: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.limits),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    requests: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.requests),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendResourcesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendResources | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._claims?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.claims = this._claims?.internalValue;
    }
    if (this._limits !== undefined) {
      hasAnyValues = true;
      internalValueResult.limits = this._limits;
    }
    if (this._requests !== undefined) {
      hasAnyValues = true;
      internalValueResult.requests = this._requests;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendResources | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._claims.internalValue = undefined;
      this._limits = undefined;
      this._requests = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._claims.internalValue = value.claims;
      this._limits = value.limits;
      this._requests = value.requests;
    }
  }

  // claims - computed: false, optional: true, required: false
  private _claims = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendResourcesClaimsList(this, "claims", false);
  public get claims() {
    return this._claims;
  }
  public putClaims(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendResourcesClaims[] | cdktf.IResolvable) {
    this._claims.internalValue = value;
  }
  public resetClaims() {
    this._claims.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get claimsInput() {
    return this._claims.internalValue;
  }

  // limits - computed: false, optional: true, required: false
  private _limits?: { [key: string]: string }; 
  public get limits() {
    return this.getStringMapAttribute('limits');
  }
  public set limits(value: { [key: string]: string }) {
    this._limits = value;
  }
  public resetLimits() {
    this._limits = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get limitsInput() {
    return this._limits;
  }

  // requests - computed: false, optional: true, required: false
  private _requests?: { [key: string]: string }; 
  public get requests() {
    return this.getStringMapAttribute('requests');
  }
  public set requests(value: { [key: string]: string }) {
    this._requests = value;
  }
  public resetRequests() {
    this._requests = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestsInput() {
    return this._requests;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontend {
  /**
  * HTTPPort defines a custom http port for the service. Default values are: 7243 for Frontend service
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#http_port DataK8STemporalIoTemporalClusterV1Beta1Manifest#http_port}
  */
  readonly httpPort?: number;
  /**
  * InitContainers adds a list of init containers to the service's deployment.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#init_containers DataK8STemporalIoTemporalClusterV1Beta1Manifest#init_containers}
  */
  readonly initContainers?: { [key: string]: string }[] | cdktf.IResolvable;
  /**
  * MembershipPort defines a custom membership port for the service. Default values are: 6933 for Frontend service 6934 for History service 6935 for Matching service 6939 for Worker service
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#membership_port DataK8STemporalIoTemporalClusterV1Beta1Manifest#membership_port}
  */
  readonly membershipPort?: number;
  /**
  * Overrides adds some overrides to the resources deployed for the service. Those overrides takes precedence over spec.services.overrides.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#overrides DataK8STemporalIoTemporalClusterV1Beta1Manifest#overrides}
  */
  readonly overrides?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverrides;
  /**
  * Port defines a custom gRPC port for the service. Default values are: 7233 for Frontend service 7234 for History service 7235 for Matching service 7239 for Worker service
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#port DataK8STemporalIoTemporalClusterV1Beta1Manifest#port}
  */
  readonly port?: number;
  /**
  * Number of desired replicas for the service. Default to 1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#replicas DataK8STemporalIoTemporalClusterV1Beta1Manifest#replicas}
  */
  readonly replicas?: number;
  /**
  * Compute Resources required by this service. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#resources DataK8STemporalIoTemporalClusterV1Beta1Manifest#resources}
  */
  readonly resources?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendResources;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontend | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    http_port: cdktf.numberToTerraform(struct!.httpPort),
    init_containers: cdktf.listMapper(cdktf.hashMapper(cdktf.stringToTerraform), false)(struct!.initContainers),
    membership_port: cdktf.numberToTerraform(struct!.membershipPort),
    overrides: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesToTerraform(struct!.overrides),
    port: cdktf.numberToTerraform(struct!.port),
    replicas: cdktf.numberToTerraform(struct!.replicas),
    resources: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendResourcesToTerraform(struct!.resources),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontend | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    http_port: {
      value: cdktf.numberToHclTerraform(struct!.httpPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    init_containers: {
      value: cdktf.listMapperHcl(cdktf.hashMapperHcl(cdktf.stringToHclTerraform), false)(struct!.initContainers),
      isBlock: false,
      type: "list",
      storageClassType: "stringMapList",
    },
    membership_port: {
      value: cdktf.numberToHclTerraform(struct!.membershipPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    overrides: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesToHclTerraform(struct!.overrides),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverrides",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    replicas: {
      value: cdktf.numberToHclTerraform(struct!.replicas),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    resources: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendResourcesToHclTerraform(struct!.resources),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendResources",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontend | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._httpPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpPort = this._httpPort;
    }
    if (this._initContainers !== undefined) {
      hasAnyValues = true;
      internalValueResult.initContainers = this._initContainers;
    }
    if (this._membershipPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.membershipPort = this._membershipPort;
    }
    if (this._overrides?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.overrides = this._overrides?.internalValue;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._replicas !== undefined) {
      hasAnyValues = true;
      internalValueResult.replicas = this._replicas;
    }
    if (this._resources?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resources = this._resources?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontend | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._httpPort = undefined;
      this._initContainers = undefined;
      this._membershipPort = undefined;
      this._overrides.internalValue = undefined;
      this._port = undefined;
      this._replicas = undefined;
      this._resources.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._httpPort = value.httpPort;
      this._initContainers = value.initContainers;
      this._membershipPort = value.membershipPort;
      this._overrides.internalValue = value.overrides;
      this._port = value.port;
      this._replicas = value.replicas;
      this._resources.internalValue = value.resources;
    }
  }

  // http_port - computed: false, optional: true, required: false
  private _httpPort?: number; 
  public get httpPort() {
    return this.getNumberAttribute('http_port');
  }
  public set httpPort(value: number) {
    this._httpPort = value;
  }
  public resetHttpPort() {
    this._httpPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpPortInput() {
    return this._httpPort;
  }

  // init_containers - computed: false, optional: true, required: false
  private _initContainers?: { [key: string]: string }[] | cdktf.IResolvable; 
  public get initContainers() {
    return this.interpolationForAttribute('init_containers');
  }
  public set initContainers(value: { [key: string]: string }[] | cdktf.IResolvable) {
    this._initContainers = value;
  }
  public resetInitContainers() {
    this._initContainers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initContainersInput() {
    return this._initContainers;
  }

  // membership_port - computed: false, optional: true, required: false
  private _membershipPort?: number; 
  public get membershipPort() {
    return this.getNumberAttribute('membership_port');
  }
  public set membershipPort(value: number) {
    this._membershipPort = value;
  }
  public resetMembershipPort() {
    this._membershipPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get membershipPortInput() {
    return this._membershipPort;
  }

  // overrides - computed: false, optional: true, required: false
  private _overrides = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverridesOutputReference(this, "overrides");
  public get overrides() {
    return this._overrides;
  }
  public putOverrides(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOverrides) {
    this._overrides.internalValue = value;
  }
  public resetOverrides() {
    this._overrides.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overridesInput() {
    return this._overrides.internalValue;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // replicas - computed: false, optional: true, required: false
  private _replicas?: number; 
  public get replicas() {
    return this.getNumberAttribute('replicas');
  }
  public set replicas(value: number) {
    this._replicas = value;
  }
  public resetReplicas() {
    this._replicas = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get replicasInput() {
    return this._replicas;
  }

  // resources - computed: false, optional: true, required: false
  private _resources = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendResourcesOutputReference(this, "resources");
  public get resources() {
    return this._resources;
  }
  public putResources(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendResources) {
    this._resources.internalValue = value;
  }
  public resetResources() {
    this._resources.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourcesInput() {
    return this._resources.internalValue;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentMetadata {
  /**
  * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#annotations DataK8STemporalIoTemporalClusterV1Beta1Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Map of string keys and values that can be used to organize and categorize (scope and select) objects.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#labels DataK8STemporalIoTemporalClusterV1Beta1Manifest#labels}
  */
  readonly labels?: { [key: string]: string };
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentMetadataToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentMetadataToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotations = undefined;
      this._labels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotations = value.annotations;
      this._labels = value.labels;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentSpecTemplateMetadata {
  /**
  * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#annotations DataK8STemporalIoTemporalClusterV1Beta1Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Map of string keys and values that can be used to organize and categorize (scope and select) objects.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#labels DataK8STemporalIoTemporalClusterV1Beta1Manifest#labels}
  */
  readonly labels?: { [key: string]: string };
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentSpecTemplateMetadataToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentSpecTemplateMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentSpecTemplateMetadataToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentSpecTemplateMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentSpecTemplateMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentSpecTemplateMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentSpecTemplateMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotations = undefined;
      this._labels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotations = value.annotations;
      this._labels = value.labels;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentSpecTemplate {
  /**
  * ObjectMetaOverride provides the ability to override an object metadata. It's a subset of the fields included in k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#metadata DataK8STemporalIoTemporalClusterV1Beta1Manifest#metadata}
  */
  readonly metadata?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentSpecTemplateMetadata;
  /**
  * Specification of the desired behavior of the pod.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#spec DataK8STemporalIoTemporalClusterV1Beta1Manifest#spec}
  */
  readonly spec?: { [key: string]: string };
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentSpecTemplateToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentSpecTemplate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    metadata: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentSpecTemplateMetadataToTerraform(struct!.metadata),
    spec: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.spec),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentSpecTemplateToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentSpecTemplate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    metadata: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentSpecTemplateMetadataToHclTerraform(struct!.metadata),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentSpecTemplateMetadata",
    },
    spec: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.spec),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentSpecTemplateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentSpecTemplate | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._spec !== undefined) {
      hasAnyValues = true;
      internalValueResult.spec = this._spec;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentSpecTemplate | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._metadata.internalValue = undefined;
      this._spec = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._metadata.internalValue = value.metadata;
      this._spec = value.spec;
    }
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentSpecTemplateMetadataOutputReference(this, "metadata");
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentSpecTemplateMetadata) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // spec - computed: false, optional: true, required: false
  private _spec?: { [key: string]: string }; 
  public get spec() {
    return this.getStringMapAttribute('spec');
  }
  public set spec(value: { [key: string]: string }) {
    this._spec = value;
  }
  public resetSpec() {
    this._spec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get specInput() {
    return this._spec;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentSpec {
  /**
  * Template describes the pods that will be created.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#template DataK8STemporalIoTemporalClusterV1Beta1Manifest#template}
  */
  readonly template?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentSpecTemplate;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentSpecToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    template: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentSpecTemplateToTerraform(struct!.template),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentSpecToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    template: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentSpecTemplateToHclTerraform(struct!.template),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentSpecTemplate",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentSpecOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentSpec | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._template?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.template = this._template?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentSpec | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._template.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._template.internalValue = value.template;
    }
  }

  // template - computed: false, optional: true, required: false
  private _template = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentSpecTemplateOutputReference(this, "template");
  public get template() {
    return this._template;
  }
  public putTemplate(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentSpecTemplate) {
    this._template.internalValue = value;
  }
  public resetTemplate() {
    this._template.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get templateInput() {
    return this._template.internalValue;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeployment {
  /**
  * ObjectMetaOverride provides the ability to override an object metadata. It's a subset of the fields included in k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#metadata DataK8STemporalIoTemporalClusterV1Beta1Manifest#metadata}
  */
  readonly metadata?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentMetadata;
  /**
  * Specification of the desired behavior of the Deployment.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#spec DataK8STemporalIoTemporalClusterV1Beta1Manifest#spec}
  */
  readonly spec?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentSpec;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeployment | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    metadata: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentMetadataToTerraform(struct!.metadata),
    spec: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentSpecToTerraform(struct!.spec),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeployment | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    metadata: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentMetadataToHclTerraform(struct!.metadata),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentMetadata",
    },
    spec: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentSpecToHclTerraform(struct!.spec),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentSpec",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeployment | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._spec?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.spec = this._spec?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeployment | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._metadata.internalValue = undefined;
      this._spec.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._metadata.internalValue = value.metadata;
      this._spec.internalValue = value.spec;
    }
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentMetadataOutputReference(this, "metadata");
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentMetadata) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // spec - computed: false, optional: true, required: false
  private _spec = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentSpecOutputReference(this, "spec");
  public get spec() {
    return this._spec;
  }
  public putSpec(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentSpec) {
    this._spec.internalValue = value;
  }
  public resetSpec() {
    this._spec.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get specInput() {
    return this._spec.internalValue;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverrides {
  /**
  * Override configuration for the temporal service Deployment.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#deployment DataK8STemporalIoTemporalClusterV1Beta1Manifest#deployment}
  */
  readonly deployment?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeployment;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverrides | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    deployment: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentToTerraform(struct!.deployment),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverrides | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    deployment: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentToHclTerraform(struct!.deployment),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeployment",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverrides | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._deployment?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.deployment = this._deployment?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverrides | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._deployment.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._deployment.internalValue = value.deployment;
    }
  }

  // deployment - computed: false, optional: true, required: false
  private _deployment = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeploymentOutputReference(this, "deployment");
  public get deployment() {
    return this._deployment;
  }
  public putDeployment(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesDeployment) {
    this._deployment.internalValue = value;
  }
  public resetDeployment() {
    this._deployment.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deploymentInput() {
    return this._deployment.internalValue;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryResourcesClaims {
  /**
  * Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#name DataK8STemporalIoTemporalClusterV1Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * Request is the name chosen for a request in the referenced claim. If empty, everything from the claim is made available, otherwise only the result of this request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#request DataK8STemporalIoTemporalClusterV1Beta1Manifest#request}
  */
  readonly request?: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryResourcesClaimsToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryResourcesClaims | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    request: cdktf.stringToTerraform(struct!.request),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryResourcesClaimsToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryResourcesClaims | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request: {
      value: cdktf.stringToHclTerraform(struct!.request),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryResourcesClaimsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryResourcesClaims | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._request !== undefined) {
      hasAnyValues = true;
      internalValueResult.request = this._request;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryResourcesClaims | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._request = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._request = value.request;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // request - computed: false, optional: true, required: false
  private _request?: string; 
  public get request() {
    return this.getStringAttribute('request');
  }
  public set request(value: string) {
    this._request = value;
  }
  public resetRequest() {
    this._request = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestInput() {
    return this._request;
  }
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryResourcesClaimsList extends cdktf.ComplexList {
  public internalValue? : DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryResourcesClaims[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryResourcesClaimsOutputReference {
    return new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryResourcesClaimsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryResources {
  /**
  * Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container. This is an alpha field and requires enabling the DynamicResourceAllocation feature gate. This field is immutable. It can only be set for containers.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#claims DataK8STemporalIoTemporalClusterV1Beta1Manifest#claims}
  */
  readonly claims?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryResourcesClaims[] | cdktf.IResolvable;
  /**
  * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#limits DataK8STemporalIoTemporalClusterV1Beta1Manifest#limits}
  */
  readonly limits?: { [key: string]: string };
  /**
  * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. Requests cannot exceed Limits. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#requests DataK8STemporalIoTemporalClusterV1Beta1Manifest#requests}
  */
  readonly requests?: { [key: string]: string };
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryResourcesToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryResources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    claims: cdktf.listMapper(dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryResourcesClaimsToTerraform, false)(struct!.claims),
    limits: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.limits),
    requests: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.requests),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryResourcesToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryResources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    claims: {
      value: cdktf.listMapperHcl(dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryResourcesClaimsToHclTerraform, false)(struct!.claims),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryResourcesClaimsList",
    },
    limits: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.limits),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    requests: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.requests),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryResourcesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryResources | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._claims?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.claims = this._claims?.internalValue;
    }
    if (this._limits !== undefined) {
      hasAnyValues = true;
      internalValueResult.limits = this._limits;
    }
    if (this._requests !== undefined) {
      hasAnyValues = true;
      internalValueResult.requests = this._requests;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryResources | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._claims.internalValue = undefined;
      this._limits = undefined;
      this._requests = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._claims.internalValue = value.claims;
      this._limits = value.limits;
      this._requests = value.requests;
    }
  }

  // claims - computed: false, optional: true, required: false
  private _claims = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryResourcesClaimsList(this, "claims", false);
  public get claims() {
    return this._claims;
  }
  public putClaims(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryResourcesClaims[] | cdktf.IResolvable) {
    this._claims.internalValue = value;
  }
  public resetClaims() {
    this._claims.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get claimsInput() {
    return this._claims.internalValue;
  }

  // limits - computed: false, optional: true, required: false
  private _limits?: { [key: string]: string }; 
  public get limits() {
    return this.getStringMapAttribute('limits');
  }
  public set limits(value: { [key: string]: string }) {
    this._limits = value;
  }
  public resetLimits() {
    this._limits = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get limitsInput() {
    return this._limits;
  }

  // requests - computed: false, optional: true, required: false
  private _requests?: { [key: string]: string }; 
  public get requests() {
    return this.getStringMapAttribute('requests');
  }
  public set requests(value: { [key: string]: string }) {
    this._requests = value;
  }
  public resetRequests() {
    this._requests = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestsInput() {
    return this._requests;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistory {
  /**
  * HTTPPort defines a custom http port for the service. Default values are: 7243 for Frontend service
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#http_port DataK8STemporalIoTemporalClusterV1Beta1Manifest#http_port}
  */
  readonly httpPort?: number;
  /**
  * InitContainers adds a list of init containers to the service's deployment.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#init_containers DataK8STemporalIoTemporalClusterV1Beta1Manifest#init_containers}
  */
  readonly initContainers?: { [key: string]: string }[] | cdktf.IResolvable;
  /**
  * MembershipPort defines a custom membership port for the service. Default values are: 6933 for Frontend service 6934 for History service 6935 for Matching service 6939 for Worker service
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#membership_port DataK8STemporalIoTemporalClusterV1Beta1Manifest#membership_port}
  */
  readonly membershipPort?: number;
  /**
  * Overrides adds some overrides to the resources deployed for the service. Those overrides takes precedence over spec.services.overrides.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#overrides DataK8STemporalIoTemporalClusterV1Beta1Manifest#overrides}
  */
  readonly overrides?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverrides;
  /**
  * Port defines a custom gRPC port for the service. Default values are: 7233 for Frontend service 7234 for History service 7235 for Matching service 7239 for Worker service
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#port DataK8STemporalIoTemporalClusterV1Beta1Manifest#port}
  */
  readonly port?: number;
  /**
  * Number of desired replicas for the service. Default to 1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#replicas DataK8STemporalIoTemporalClusterV1Beta1Manifest#replicas}
  */
  readonly replicas?: number;
  /**
  * Compute Resources required by this service. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#resources DataK8STemporalIoTemporalClusterV1Beta1Manifest#resources}
  */
  readonly resources?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryResources;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistory | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    http_port: cdktf.numberToTerraform(struct!.httpPort),
    init_containers: cdktf.listMapper(cdktf.hashMapper(cdktf.stringToTerraform), false)(struct!.initContainers),
    membership_port: cdktf.numberToTerraform(struct!.membershipPort),
    overrides: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesToTerraform(struct!.overrides),
    port: cdktf.numberToTerraform(struct!.port),
    replicas: cdktf.numberToTerraform(struct!.replicas),
    resources: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryResourcesToTerraform(struct!.resources),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistory | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    http_port: {
      value: cdktf.numberToHclTerraform(struct!.httpPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    init_containers: {
      value: cdktf.listMapperHcl(cdktf.hashMapperHcl(cdktf.stringToHclTerraform), false)(struct!.initContainers),
      isBlock: false,
      type: "list",
      storageClassType: "stringMapList",
    },
    membership_port: {
      value: cdktf.numberToHclTerraform(struct!.membershipPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    overrides: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesToHclTerraform(struct!.overrides),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverrides",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    replicas: {
      value: cdktf.numberToHclTerraform(struct!.replicas),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    resources: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryResourcesToHclTerraform(struct!.resources),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryResources",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistory | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._httpPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpPort = this._httpPort;
    }
    if (this._initContainers !== undefined) {
      hasAnyValues = true;
      internalValueResult.initContainers = this._initContainers;
    }
    if (this._membershipPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.membershipPort = this._membershipPort;
    }
    if (this._overrides?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.overrides = this._overrides?.internalValue;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._replicas !== undefined) {
      hasAnyValues = true;
      internalValueResult.replicas = this._replicas;
    }
    if (this._resources?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resources = this._resources?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistory | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._httpPort = undefined;
      this._initContainers = undefined;
      this._membershipPort = undefined;
      this._overrides.internalValue = undefined;
      this._port = undefined;
      this._replicas = undefined;
      this._resources.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._httpPort = value.httpPort;
      this._initContainers = value.initContainers;
      this._membershipPort = value.membershipPort;
      this._overrides.internalValue = value.overrides;
      this._port = value.port;
      this._replicas = value.replicas;
      this._resources.internalValue = value.resources;
    }
  }

  // http_port - computed: false, optional: true, required: false
  private _httpPort?: number; 
  public get httpPort() {
    return this.getNumberAttribute('http_port');
  }
  public set httpPort(value: number) {
    this._httpPort = value;
  }
  public resetHttpPort() {
    this._httpPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpPortInput() {
    return this._httpPort;
  }

  // init_containers - computed: false, optional: true, required: false
  private _initContainers?: { [key: string]: string }[] | cdktf.IResolvable; 
  public get initContainers() {
    return this.interpolationForAttribute('init_containers');
  }
  public set initContainers(value: { [key: string]: string }[] | cdktf.IResolvable) {
    this._initContainers = value;
  }
  public resetInitContainers() {
    this._initContainers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initContainersInput() {
    return this._initContainers;
  }

  // membership_port - computed: false, optional: true, required: false
  private _membershipPort?: number; 
  public get membershipPort() {
    return this.getNumberAttribute('membership_port');
  }
  public set membershipPort(value: number) {
    this._membershipPort = value;
  }
  public resetMembershipPort() {
    this._membershipPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get membershipPortInput() {
    return this._membershipPort;
  }

  // overrides - computed: false, optional: true, required: false
  private _overrides = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverridesOutputReference(this, "overrides");
  public get overrides() {
    return this._overrides;
  }
  public putOverrides(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOverrides) {
    this._overrides.internalValue = value;
  }
  public resetOverrides() {
    this._overrides.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overridesInput() {
    return this._overrides.internalValue;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // replicas - computed: false, optional: true, required: false
  private _replicas?: number; 
  public get replicas() {
    return this.getNumberAttribute('replicas');
  }
  public set replicas(value: number) {
    this._replicas = value;
  }
  public resetReplicas() {
    this._replicas = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get replicasInput() {
    return this._replicas;
  }

  // resources - computed: false, optional: true, required: false
  private _resources = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryResourcesOutputReference(this, "resources");
  public get resources() {
    return this._resources;
  }
  public putResources(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryResources) {
    this._resources.internalValue = value;
  }
  public resetResources() {
    this._resources.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourcesInput() {
    return this._resources.internalValue;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentMetadata {
  /**
  * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#annotations DataK8STemporalIoTemporalClusterV1Beta1Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Map of string keys and values that can be used to organize and categorize (scope and select) objects.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#labels DataK8STemporalIoTemporalClusterV1Beta1Manifest#labels}
  */
  readonly labels?: { [key: string]: string };
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentMetadataToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentMetadataToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotations = undefined;
      this._labels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotations = value.annotations;
      this._labels = value.labels;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentSpecTemplateMetadata {
  /**
  * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#annotations DataK8STemporalIoTemporalClusterV1Beta1Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Map of string keys and values that can be used to organize and categorize (scope and select) objects.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#labels DataK8STemporalIoTemporalClusterV1Beta1Manifest#labels}
  */
  readonly labels?: { [key: string]: string };
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentSpecTemplateMetadataToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentSpecTemplateMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentSpecTemplateMetadataToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentSpecTemplateMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentSpecTemplateMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentSpecTemplateMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentSpecTemplateMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotations = undefined;
      this._labels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotations = value.annotations;
      this._labels = value.labels;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentSpecTemplate {
  /**
  * ObjectMetaOverride provides the ability to override an object metadata. It's a subset of the fields included in k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#metadata DataK8STemporalIoTemporalClusterV1Beta1Manifest#metadata}
  */
  readonly metadata?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentSpecTemplateMetadata;
  /**
  * Specification of the desired behavior of the pod.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#spec DataK8STemporalIoTemporalClusterV1Beta1Manifest#spec}
  */
  readonly spec?: { [key: string]: string };
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentSpecTemplateToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentSpecTemplate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    metadata: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentSpecTemplateMetadataToTerraform(struct!.metadata),
    spec: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.spec),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentSpecTemplateToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentSpecTemplate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    metadata: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentSpecTemplateMetadataToHclTerraform(struct!.metadata),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentSpecTemplateMetadata",
    },
    spec: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.spec),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentSpecTemplateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentSpecTemplate | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._spec !== undefined) {
      hasAnyValues = true;
      internalValueResult.spec = this._spec;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentSpecTemplate | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._metadata.internalValue = undefined;
      this._spec = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._metadata.internalValue = value.metadata;
      this._spec = value.spec;
    }
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentSpecTemplateMetadataOutputReference(this, "metadata");
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentSpecTemplateMetadata) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // spec - computed: false, optional: true, required: false
  private _spec?: { [key: string]: string }; 
  public get spec() {
    return this.getStringMapAttribute('spec');
  }
  public set spec(value: { [key: string]: string }) {
    this._spec = value;
  }
  public resetSpec() {
    this._spec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get specInput() {
    return this._spec;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentSpec {
  /**
  * Template describes the pods that will be created.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#template DataK8STemporalIoTemporalClusterV1Beta1Manifest#template}
  */
  readonly template?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentSpecTemplate;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentSpecToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    template: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentSpecTemplateToTerraform(struct!.template),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentSpecToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    template: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentSpecTemplateToHclTerraform(struct!.template),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentSpecTemplate",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentSpecOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentSpec | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._template?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.template = this._template?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentSpec | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._template.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._template.internalValue = value.template;
    }
  }

  // template - computed: false, optional: true, required: false
  private _template = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentSpecTemplateOutputReference(this, "template");
  public get template() {
    return this._template;
  }
  public putTemplate(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentSpecTemplate) {
    this._template.internalValue = value;
  }
  public resetTemplate() {
    this._template.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get templateInput() {
    return this._template.internalValue;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeployment {
  /**
  * ObjectMetaOverride provides the ability to override an object metadata. It's a subset of the fields included in k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#metadata DataK8STemporalIoTemporalClusterV1Beta1Manifest#metadata}
  */
  readonly metadata?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentMetadata;
  /**
  * Specification of the desired behavior of the Deployment.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#spec DataK8STemporalIoTemporalClusterV1Beta1Manifest#spec}
  */
  readonly spec?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentSpec;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeployment | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    metadata: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentMetadataToTerraform(struct!.metadata),
    spec: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentSpecToTerraform(struct!.spec),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeployment | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    metadata: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentMetadataToHclTerraform(struct!.metadata),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentMetadata",
    },
    spec: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentSpecToHclTerraform(struct!.spec),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentSpec",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeployment | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._spec?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.spec = this._spec?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeployment | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._metadata.internalValue = undefined;
      this._spec.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._metadata.internalValue = value.metadata;
      this._spec.internalValue = value.spec;
    }
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentMetadataOutputReference(this, "metadata");
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentMetadata) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // spec - computed: false, optional: true, required: false
  private _spec = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentSpecOutputReference(this, "spec");
  public get spec() {
    return this._spec;
  }
  public putSpec(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentSpec) {
    this._spec.internalValue = value;
  }
  public resetSpec() {
    this._spec.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get specInput() {
    return this._spec.internalValue;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverrides {
  /**
  * Override configuration for the temporal service Deployment.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#deployment DataK8STemporalIoTemporalClusterV1Beta1Manifest#deployment}
  */
  readonly deployment?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeployment;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverrides | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    deployment: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentToTerraform(struct!.deployment),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverrides | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    deployment: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentToHclTerraform(struct!.deployment),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeployment",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverrides | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._deployment?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.deployment = this._deployment?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverrides | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._deployment.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._deployment.internalValue = value.deployment;
    }
  }

  // deployment - computed: false, optional: true, required: false
  private _deployment = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeploymentOutputReference(this, "deployment");
  public get deployment() {
    return this._deployment;
  }
  public putDeployment(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesDeployment) {
    this._deployment.internalValue = value;
  }
  public resetDeployment() {
    this._deployment.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deploymentInput() {
    return this._deployment.internalValue;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendResourcesClaims {
  /**
  * Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#name DataK8STemporalIoTemporalClusterV1Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * Request is the name chosen for a request in the referenced claim. If empty, everything from the claim is made available, otherwise only the result of this request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#request DataK8STemporalIoTemporalClusterV1Beta1Manifest#request}
  */
  readonly request?: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendResourcesClaimsToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendResourcesClaims | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    request: cdktf.stringToTerraform(struct!.request),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendResourcesClaimsToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendResourcesClaims | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request: {
      value: cdktf.stringToHclTerraform(struct!.request),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendResourcesClaimsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendResourcesClaims | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._request !== undefined) {
      hasAnyValues = true;
      internalValueResult.request = this._request;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendResourcesClaims | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._request = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._request = value.request;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // request - computed: false, optional: true, required: false
  private _request?: string; 
  public get request() {
    return this.getStringAttribute('request');
  }
  public set request(value: string) {
    this._request = value;
  }
  public resetRequest() {
    this._request = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestInput() {
    return this._request;
  }
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendResourcesClaimsList extends cdktf.ComplexList {
  public internalValue? : DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendResourcesClaims[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendResourcesClaimsOutputReference {
    return new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendResourcesClaimsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendResources {
  /**
  * Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container. This is an alpha field and requires enabling the DynamicResourceAllocation feature gate. This field is immutable. It can only be set for containers.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#claims DataK8STemporalIoTemporalClusterV1Beta1Manifest#claims}
  */
  readonly claims?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendResourcesClaims[] | cdktf.IResolvable;
  /**
  * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#limits DataK8STemporalIoTemporalClusterV1Beta1Manifest#limits}
  */
  readonly limits?: { [key: string]: string };
  /**
  * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. Requests cannot exceed Limits. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#requests DataK8STemporalIoTemporalClusterV1Beta1Manifest#requests}
  */
  readonly requests?: { [key: string]: string };
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendResourcesToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendResources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    claims: cdktf.listMapper(dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendResourcesClaimsToTerraform, false)(struct!.claims),
    limits: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.limits),
    requests: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.requests),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendResourcesToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendResources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    claims: {
      value: cdktf.listMapperHcl(dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendResourcesClaimsToHclTerraform, false)(struct!.claims),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendResourcesClaimsList",
    },
    limits: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.limits),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    requests: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.requests),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendResourcesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendResources | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._claims?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.claims = this._claims?.internalValue;
    }
    if (this._limits !== undefined) {
      hasAnyValues = true;
      internalValueResult.limits = this._limits;
    }
    if (this._requests !== undefined) {
      hasAnyValues = true;
      internalValueResult.requests = this._requests;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendResources | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._claims.internalValue = undefined;
      this._limits = undefined;
      this._requests = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._claims.internalValue = value.claims;
      this._limits = value.limits;
      this._requests = value.requests;
    }
  }

  // claims - computed: false, optional: true, required: false
  private _claims = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendResourcesClaimsList(this, "claims", false);
  public get claims() {
    return this._claims;
  }
  public putClaims(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendResourcesClaims[] | cdktf.IResolvable) {
    this._claims.internalValue = value;
  }
  public resetClaims() {
    this._claims.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get claimsInput() {
    return this._claims.internalValue;
  }

  // limits - computed: false, optional: true, required: false
  private _limits?: { [key: string]: string }; 
  public get limits() {
    return this.getStringMapAttribute('limits');
  }
  public set limits(value: { [key: string]: string }) {
    this._limits = value;
  }
  public resetLimits() {
    this._limits = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get limitsInput() {
    return this._limits;
  }

  // requests - computed: false, optional: true, required: false
  private _requests?: { [key: string]: string }; 
  public get requests() {
    return this.getStringMapAttribute('requests');
  }
  public set requests(value: { [key: string]: string }) {
    this._requests = value;
  }
  public resetRequests() {
    this._requests = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestsInput() {
    return this._requests;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontend {
  /**
  * Enabled defines if we want to spawn the internal frontend service.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#enabled DataK8STemporalIoTemporalClusterV1Beta1Manifest#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
  /**
  * HTTPPort defines a custom http port for the service. Default values are: 7243 for Frontend service
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#http_port DataK8STemporalIoTemporalClusterV1Beta1Manifest#http_port}
  */
  readonly httpPort?: number;
  /**
  * InitContainers adds a list of init containers to the service's deployment.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#init_containers DataK8STemporalIoTemporalClusterV1Beta1Manifest#init_containers}
  */
  readonly initContainers?: { [key: string]: string }[] | cdktf.IResolvable;
  /**
  * MembershipPort defines a custom membership port for the service. Default values are: 6933 for Frontend service 6934 for History service 6935 for Matching service 6939 for Worker service
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#membership_port DataK8STemporalIoTemporalClusterV1Beta1Manifest#membership_port}
  */
  readonly membershipPort?: number;
  /**
  * Overrides adds some overrides to the resources deployed for the service. Those overrides takes precedence over spec.services.overrides.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#overrides DataK8STemporalIoTemporalClusterV1Beta1Manifest#overrides}
  */
  readonly overrides?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverrides;
  /**
  * Port defines a custom gRPC port for the service. Default values are: 7233 for Frontend service 7234 for History service 7235 for Matching service 7239 for Worker service
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#port DataK8STemporalIoTemporalClusterV1Beta1Manifest#port}
  */
  readonly port?: number;
  /**
  * Number of desired replicas for the service. Default to 1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#replicas DataK8STemporalIoTemporalClusterV1Beta1Manifest#replicas}
  */
  readonly replicas?: number;
  /**
  * Compute Resources required by this service. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#resources DataK8STemporalIoTemporalClusterV1Beta1Manifest#resources}
  */
  readonly resources?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendResources;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontend | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.booleanToTerraform(struct!.enabled),
    http_port: cdktf.numberToTerraform(struct!.httpPort),
    init_containers: cdktf.listMapper(cdktf.hashMapper(cdktf.stringToTerraform), false)(struct!.initContainers),
    membership_port: cdktf.numberToTerraform(struct!.membershipPort),
    overrides: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesToTerraform(struct!.overrides),
    port: cdktf.numberToTerraform(struct!.port),
    replicas: cdktf.numberToTerraform(struct!.replicas),
    resources: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendResourcesToTerraform(struct!.resources),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontend | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    http_port: {
      value: cdktf.numberToHclTerraform(struct!.httpPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    init_containers: {
      value: cdktf.listMapperHcl(cdktf.hashMapperHcl(cdktf.stringToHclTerraform), false)(struct!.initContainers),
      isBlock: false,
      type: "list",
      storageClassType: "stringMapList",
    },
    membership_port: {
      value: cdktf.numberToHclTerraform(struct!.membershipPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    overrides: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesToHclTerraform(struct!.overrides),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverrides",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    replicas: {
      value: cdktf.numberToHclTerraform(struct!.replicas),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    resources: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendResourcesToHclTerraform(struct!.resources),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendResources",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontend | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._httpPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpPort = this._httpPort;
    }
    if (this._initContainers !== undefined) {
      hasAnyValues = true;
      internalValueResult.initContainers = this._initContainers;
    }
    if (this._membershipPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.membershipPort = this._membershipPort;
    }
    if (this._overrides?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.overrides = this._overrides?.internalValue;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._replicas !== undefined) {
      hasAnyValues = true;
      internalValueResult.replicas = this._replicas;
    }
    if (this._resources?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resources = this._resources?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontend | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._httpPort = undefined;
      this._initContainers = undefined;
      this._membershipPort = undefined;
      this._overrides.internalValue = undefined;
      this._port = undefined;
      this._replicas = undefined;
      this._resources.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._httpPort = value.httpPort;
      this._initContainers = value.initContainers;
      this._membershipPort = value.membershipPort;
      this._overrides.internalValue = value.overrides;
      this._port = value.port;
      this._replicas = value.replicas;
      this._resources.internalValue = value.resources;
    }
  }

  // enabled - computed: false, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // http_port - computed: false, optional: true, required: false
  private _httpPort?: number; 
  public get httpPort() {
    return this.getNumberAttribute('http_port');
  }
  public set httpPort(value: number) {
    this._httpPort = value;
  }
  public resetHttpPort() {
    this._httpPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpPortInput() {
    return this._httpPort;
  }

  // init_containers - computed: false, optional: true, required: false
  private _initContainers?: { [key: string]: string }[] | cdktf.IResolvable; 
  public get initContainers() {
    return this.interpolationForAttribute('init_containers');
  }
  public set initContainers(value: { [key: string]: string }[] | cdktf.IResolvable) {
    this._initContainers = value;
  }
  public resetInitContainers() {
    this._initContainers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initContainersInput() {
    return this._initContainers;
  }

  // membership_port - computed: false, optional: true, required: false
  private _membershipPort?: number; 
  public get membershipPort() {
    return this.getNumberAttribute('membership_port');
  }
  public set membershipPort(value: number) {
    this._membershipPort = value;
  }
  public resetMembershipPort() {
    this._membershipPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get membershipPortInput() {
    return this._membershipPort;
  }

  // overrides - computed: false, optional: true, required: false
  private _overrides = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverridesOutputReference(this, "overrides");
  public get overrides() {
    return this._overrides;
  }
  public putOverrides(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOverrides) {
    this._overrides.internalValue = value;
  }
  public resetOverrides() {
    this._overrides.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overridesInput() {
    return this._overrides.internalValue;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // replicas - computed: false, optional: true, required: false
  private _replicas?: number; 
  public get replicas() {
    return this.getNumberAttribute('replicas');
  }
  public set replicas(value: number) {
    this._replicas = value;
  }
  public resetReplicas() {
    this._replicas = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get replicasInput() {
    return this._replicas;
  }

  // resources - computed: false, optional: true, required: false
  private _resources = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendResourcesOutputReference(this, "resources");
  public get resources() {
    return this._resources;
  }
  public putResources(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendResources) {
    this._resources.internalValue = value;
  }
  public resetResources() {
    this._resources.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourcesInput() {
    return this._resources.internalValue;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentMetadata {
  /**
  * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#annotations DataK8STemporalIoTemporalClusterV1Beta1Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Map of string keys and values that can be used to organize and categorize (scope and select) objects.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#labels DataK8STemporalIoTemporalClusterV1Beta1Manifest#labels}
  */
  readonly labels?: { [key: string]: string };
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentMetadataToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentMetadataToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotations = undefined;
      this._labels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotations = value.annotations;
      this._labels = value.labels;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentSpecTemplateMetadata {
  /**
  * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#annotations DataK8STemporalIoTemporalClusterV1Beta1Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Map of string keys and values that can be used to organize and categorize (scope and select) objects.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#labels DataK8STemporalIoTemporalClusterV1Beta1Manifest#labels}
  */
  readonly labels?: { [key: string]: string };
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentSpecTemplateMetadataToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentSpecTemplateMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentSpecTemplateMetadataToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentSpecTemplateMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentSpecTemplateMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentSpecTemplateMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentSpecTemplateMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotations = undefined;
      this._labels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotations = value.annotations;
      this._labels = value.labels;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentSpecTemplate {
  /**
  * ObjectMetaOverride provides the ability to override an object metadata. It's a subset of the fields included in k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#metadata DataK8STemporalIoTemporalClusterV1Beta1Manifest#metadata}
  */
  readonly metadata?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentSpecTemplateMetadata;
  /**
  * Specification of the desired behavior of the pod.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#spec DataK8STemporalIoTemporalClusterV1Beta1Manifest#spec}
  */
  readonly spec?: { [key: string]: string };
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentSpecTemplateToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentSpecTemplate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    metadata: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentSpecTemplateMetadataToTerraform(struct!.metadata),
    spec: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.spec),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentSpecTemplateToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentSpecTemplate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    metadata: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentSpecTemplateMetadataToHclTerraform(struct!.metadata),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentSpecTemplateMetadata",
    },
    spec: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.spec),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentSpecTemplateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentSpecTemplate | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._spec !== undefined) {
      hasAnyValues = true;
      internalValueResult.spec = this._spec;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentSpecTemplate | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._metadata.internalValue = undefined;
      this._spec = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._metadata.internalValue = value.metadata;
      this._spec = value.spec;
    }
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentSpecTemplateMetadataOutputReference(this, "metadata");
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentSpecTemplateMetadata) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // spec - computed: false, optional: true, required: false
  private _spec?: { [key: string]: string }; 
  public get spec() {
    return this.getStringMapAttribute('spec');
  }
  public set spec(value: { [key: string]: string }) {
    this._spec = value;
  }
  public resetSpec() {
    this._spec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get specInput() {
    return this._spec;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentSpec {
  /**
  * Template describes the pods that will be created.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#template DataK8STemporalIoTemporalClusterV1Beta1Manifest#template}
  */
  readonly template?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentSpecTemplate;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentSpecToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    template: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentSpecTemplateToTerraform(struct!.template),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentSpecToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    template: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentSpecTemplateToHclTerraform(struct!.template),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentSpecTemplate",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentSpecOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentSpec | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._template?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.template = this._template?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentSpec | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._template.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._template.internalValue = value.template;
    }
  }

  // template - computed: false, optional: true, required: false
  private _template = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentSpecTemplateOutputReference(this, "template");
  public get template() {
    return this._template;
  }
  public putTemplate(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentSpecTemplate) {
    this._template.internalValue = value;
  }
  public resetTemplate() {
    this._template.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get templateInput() {
    return this._template.internalValue;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeployment {
  /**
  * ObjectMetaOverride provides the ability to override an object metadata. It's a subset of the fields included in k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#metadata DataK8STemporalIoTemporalClusterV1Beta1Manifest#metadata}
  */
  readonly metadata?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentMetadata;
  /**
  * Specification of the desired behavior of the Deployment.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#spec DataK8STemporalIoTemporalClusterV1Beta1Manifest#spec}
  */
  readonly spec?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentSpec;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeployment | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    metadata: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentMetadataToTerraform(struct!.metadata),
    spec: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentSpecToTerraform(struct!.spec),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeployment | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    metadata: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentMetadataToHclTerraform(struct!.metadata),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentMetadata",
    },
    spec: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentSpecToHclTerraform(struct!.spec),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentSpec",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeployment | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._spec?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.spec = this._spec?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeployment | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._metadata.internalValue = undefined;
      this._spec.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._metadata.internalValue = value.metadata;
      this._spec.internalValue = value.spec;
    }
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentMetadataOutputReference(this, "metadata");
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentMetadata) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // spec - computed: false, optional: true, required: false
  private _spec = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentSpecOutputReference(this, "spec");
  public get spec() {
    return this._spec;
  }
  public putSpec(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentSpec) {
    this._spec.internalValue = value;
  }
  public resetSpec() {
    this._spec.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get specInput() {
    return this._spec.internalValue;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverrides {
  /**
  * Override configuration for the temporal service Deployment.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#deployment DataK8STemporalIoTemporalClusterV1Beta1Manifest#deployment}
  */
  readonly deployment?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeployment;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverrides | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    deployment: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentToTerraform(struct!.deployment),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverrides | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    deployment: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentToHclTerraform(struct!.deployment),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeployment",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverrides | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._deployment?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.deployment = this._deployment?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverrides | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._deployment.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._deployment.internalValue = value.deployment;
    }
  }

  // deployment - computed: false, optional: true, required: false
  private _deployment = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeploymentOutputReference(this, "deployment");
  public get deployment() {
    return this._deployment;
  }
  public putDeployment(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesDeployment) {
    this._deployment.internalValue = value;
  }
  public resetDeployment() {
    this._deployment.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deploymentInput() {
    return this._deployment.internalValue;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingResourcesClaims {
  /**
  * Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#name DataK8STemporalIoTemporalClusterV1Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * Request is the name chosen for a request in the referenced claim. If empty, everything from the claim is made available, otherwise only the result of this request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#request DataK8STemporalIoTemporalClusterV1Beta1Manifest#request}
  */
  readonly request?: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingResourcesClaimsToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingResourcesClaims | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    request: cdktf.stringToTerraform(struct!.request),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingResourcesClaimsToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingResourcesClaims | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request: {
      value: cdktf.stringToHclTerraform(struct!.request),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingResourcesClaimsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingResourcesClaims | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._request !== undefined) {
      hasAnyValues = true;
      internalValueResult.request = this._request;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingResourcesClaims | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._request = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._request = value.request;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // request - computed: false, optional: true, required: false
  private _request?: string; 
  public get request() {
    return this.getStringAttribute('request');
  }
  public set request(value: string) {
    this._request = value;
  }
  public resetRequest() {
    this._request = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestInput() {
    return this._request;
  }
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingResourcesClaimsList extends cdktf.ComplexList {
  public internalValue? : DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingResourcesClaims[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingResourcesClaimsOutputReference {
    return new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingResourcesClaimsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingResources {
  /**
  * Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container. This is an alpha field and requires enabling the DynamicResourceAllocation feature gate. This field is immutable. It can only be set for containers.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#claims DataK8STemporalIoTemporalClusterV1Beta1Manifest#claims}
  */
  readonly claims?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingResourcesClaims[] | cdktf.IResolvable;
  /**
  * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#limits DataK8STemporalIoTemporalClusterV1Beta1Manifest#limits}
  */
  readonly limits?: { [key: string]: string };
  /**
  * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. Requests cannot exceed Limits. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#requests DataK8STemporalIoTemporalClusterV1Beta1Manifest#requests}
  */
  readonly requests?: { [key: string]: string };
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingResourcesToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingResources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    claims: cdktf.listMapper(dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingResourcesClaimsToTerraform, false)(struct!.claims),
    limits: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.limits),
    requests: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.requests),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingResourcesToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingResources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    claims: {
      value: cdktf.listMapperHcl(dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingResourcesClaimsToHclTerraform, false)(struct!.claims),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingResourcesClaimsList",
    },
    limits: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.limits),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    requests: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.requests),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingResourcesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingResources | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._claims?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.claims = this._claims?.internalValue;
    }
    if (this._limits !== undefined) {
      hasAnyValues = true;
      internalValueResult.limits = this._limits;
    }
    if (this._requests !== undefined) {
      hasAnyValues = true;
      internalValueResult.requests = this._requests;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingResources | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._claims.internalValue = undefined;
      this._limits = undefined;
      this._requests = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._claims.internalValue = value.claims;
      this._limits = value.limits;
      this._requests = value.requests;
    }
  }

  // claims - computed: false, optional: true, required: false
  private _claims = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingResourcesClaimsList(this, "claims", false);
  public get claims() {
    return this._claims;
  }
  public putClaims(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingResourcesClaims[] | cdktf.IResolvable) {
    this._claims.internalValue = value;
  }
  public resetClaims() {
    this._claims.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get claimsInput() {
    return this._claims.internalValue;
  }

  // limits - computed: false, optional: true, required: false
  private _limits?: { [key: string]: string }; 
  public get limits() {
    return this.getStringMapAttribute('limits');
  }
  public set limits(value: { [key: string]: string }) {
    this._limits = value;
  }
  public resetLimits() {
    this._limits = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get limitsInput() {
    return this._limits;
  }

  // requests - computed: false, optional: true, required: false
  private _requests?: { [key: string]: string }; 
  public get requests() {
    return this.getStringMapAttribute('requests');
  }
  public set requests(value: { [key: string]: string }) {
    this._requests = value;
  }
  public resetRequests() {
    this._requests = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestsInput() {
    return this._requests;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatching {
  /**
  * HTTPPort defines a custom http port for the service. Default values are: 7243 for Frontend service
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#http_port DataK8STemporalIoTemporalClusterV1Beta1Manifest#http_port}
  */
  readonly httpPort?: number;
  /**
  * InitContainers adds a list of init containers to the service's deployment.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#init_containers DataK8STemporalIoTemporalClusterV1Beta1Manifest#init_containers}
  */
  readonly initContainers?: { [key: string]: string }[] | cdktf.IResolvable;
  /**
  * MembershipPort defines a custom membership port for the service. Default values are: 6933 for Frontend service 6934 for History service 6935 for Matching service 6939 for Worker service
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#membership_port DataK8STemporalIoTemporalClusterV1Beta1Manifest#membership_port}
  */
  readonly membershipPort?: number;
  /**
  * Overrides adds some overrides to the resources deployed for the service. Those overrides takes precedence over spec.services.overrides.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#overrides DataK8STemporalIoTemporalClusterV1Beta1Manifest#overrides}
  */
  readonly overrides?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverrides;
  /**
  * Port defines a custom gRPC port for the service. Default values are: 7233 for Frontend service 7234 for History service 7235 for Matching service 7239 for Worker service
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#port DataK8STemporalIoTemporalClusterV1Beta1Manifest#port}
  */
  readonly port?: number;
  /**
  * Number of desired replicas for the service. Default to 1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#replicas DataK8STemporalIoTemporalClusterV1Beta1Manifest#replicas}
  */
  readonly replicas?: number;
  /**
  * Compute Resources required by this service. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#resources DataK8STemporalIoTemporalClusterV1Beta1Manifest#resources}
  */
  readonly resources?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingResources;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatching | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    http_port: cdktf.numberToTerraform(struct!.httpPort),
    init_containers: cdktf.listMapper(cdktf.hashMapper(cdktf.stringToTerraform), false)(struct!.initContainers),
    membership_port: cdktf.numberToTerraform(struct!.membershipPort),
    overrides: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesToTerraform(struct!.overrides),
    port: cdktf.numberToTerraform(struct!.port),
    replicas: cdktf.numberToTerraform(struct!.replicas),
    resources: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingResourcesToTerraform(struct!.resources),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatching | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    http_port: {
      value: cdktf.numberToHclTerraform(struct!.httpPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    init_containers: {
      value: cdktf.listMapperHcl(cdktf.hashMapperHcl(cdktf.stringToHclTerraform), false)(struct!.initContainers),
      isBlock: false,
      type: "list",
      storageClassType: "stringMapList",
    },
    membership_port: {
      value: cdktf.numberToHclTerraform(struct!.membershipPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    overrides: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesToHclTerraform(struct!.overrides),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverrides",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    replicas: {
      value: cdktf.numberToHclTerraform(struct!.replicas),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    resources: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingResourcesToHclTerraform(struct!.resources),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingResources",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatching | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._httpPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpPort = this._httpPort;
    }
    if (this._initContainers !== undefined) {
      hasAnyValues = true;
      internalValueResult.initContainers = this._initContainers;
    }
    if (this._membershipPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.membershipPort = this._membershipPort;
    }
    if (this._overrides?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.overrides = this._overrides?.internalValue;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._replicas !== undefined) {
      hasAnyValues = true;
      internalValueResult.replicas = this._replicas;
    }
    if (this._resources?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resources = this._resources?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatching | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._httpPort = undefined;
      this._initContainers = undefined;
      this._membershipPort = undefined;
      this._overrides.internalValue = undefined;
      this._port = undefined;
      this._replicas = undefined;
      this._resources.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._httpPort = value.httpPort;
      this._initContainers = value.initContainers;
      this._membershipPort = value.membershipPort;
      this._overrides.internalValue = value.overrides;
      this._port = value.port;
      this._replicas = value.replicas;
      this._resources.internalValue = value.resources;
    }
  }

  // http_port - computed: false, optional: true, required: false
  private _httpPort?: number; 
  public get httpPort() {
    return this.getNumberAttribute('http_port');
  }
  public set httpPort(value: number) {
    this._httpPort = value;
  }
  public resetHttpPort() {
    this._httpPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpPortInput() {
    return this._httpPort;
  }

  // init_containers - computed: false, optional: true, required: false
  private _initContainers?: { [key: string]: string }[] | cdktf.IResolvable; 
  public get initContainers() {
    return this.interpolationForAttribute('init_containers');
  }
  public set initContainers(value: { [key: string]: string }[] | cdktf.IResolvable) {
    this._initContainers = value;
  }
  public resetInitContainers() {
    this._initContainers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initContainersInput() {
    return this._initContainers;
  }

  // membership_port - computed: false, optional: true, required: false
  private _membershipPort?: number; 
  public get membershipPort() {
    return this.getNumberAttribute('membership_port');
  }
  public set membershipPort(value: number) {
    this._membershipPort = value;
  }
  public resetMembershipPort() {
    this._membershipPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get membershipPortInput() {
    return this._membershipPort;
  }

  // overrides - computed: false, optional: true, required: false
  private _overrides = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverridesOutputReference(this, "overrides");
  public get overrides() {
    return this._overrides;
  }
  public putOverrides(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOverrides) {
    this._overrides.internalValue = value;
  }
  public resetOverrides() {
    this._overrides.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overridesInput() {
    return this._overrides.internalValue;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // replicas - computed: false, optional: true, required: false
  private _replicas?: number; 
  public get replicas() {
    return this.getNumberAttribute('replicas');
  }
  public set replicas(value: number) {
    this._replicas = value;
  }
  public resetReplicas() {
    this._replicas = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get replicasInput() {
    return this._replicas;
  }

  // resources - computed: false, optional: true, required: false
  private _resources = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingResourcesOutputReference(this, "resources");
  public get resources() {
    return this._resources;
  }
  public putResources(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingResources) {
    this._resources.internalValue = value;
  }
  public resetResources() {
    this._resources.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourcesInput() {
    return this._resources.internalValue;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentMetadata {
  /**
  * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#annotations DataK8STemporalIoTemporalClusterV1Beta1Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Map of string keys and values that can be used to organize and categorize (scope and select) objects.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#labels DataK8STemporalIoTemporalClusterV1Beta1Manifest#labels}
  */
  readonly labels?: { [key: string]: string };
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentMetadataToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentMetadataToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotations = undefined;
      this._labels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotations = value.annotations;
      this._labels = value.labels;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentSpecTemplateMetadata {
  /**
  * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#annotations DataK8STemporalIoTemporalClusterV1Beta1Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Map of string keys and values that can be used to organize and categorize (scope and select) objects.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#labels DataK8STemporalIoTemporalClusterV1Beta1Manifest#labels}
  */
  readonly labels?: { [key: string]: string };
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentSpecTemplateMetadataToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentSpecTemplateMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentSpecTemplateMetadataToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentSpecTemplateMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentSpecTemplateMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentSpecTemplateMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentSpecTemplateMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotations = undefined;
      this._labels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotations = value.annotations;
      this._labels = value.labels;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentSpecTemplate {
  /**
  * ObjectMetaOverride provides the ability to override an object metadata. It's a subset of the fields included in k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#metadata DataK8STemporalIoTemporalClusterV1Beta1Manifest#metadata}
  */
  readonly metadata?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentSpecTemplateMetadata;
  /**
  * Specification of the desired behavior of the pod.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#spec DataK8STemporalIoTemporalClusterV1Beta1Manifest#spec}
  */
  readonly spec?: { [key: string]: string };
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentSpecTemplateToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentSpecTemplate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    metadata: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentSpecTemplateMetadataToTerraform(struct!.metadata),
    spec: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.spec),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentSpecTemplateToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentSpecTemplate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    metadata: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentSpecTemplateMetadataToHclTerraform(struct!.metadata),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentSpecTemplateMetadata",
    },
    spec: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.spec),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentSpecTemplateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentSpecTemplate | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._spec !== undefined) {
      hasAnyValues = true;
      internalValueResult.spec = this._spec;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentSpecTemplate | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._metadata.internalValue = undefined;
      this._spec = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._metadata.internalValue = value.metadata;
      this._spec = value.spec;
    }
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentSpecTemplateMetadataOutputReference(this, "metadata");
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentSpecTemplateMetadata) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // spec - computed: false, optional: true, required: false
  private _spec?: { [key: string]: string }; 
  public get spec() {
    return this.getStringMapAttribute('spec');
  }
  public set spec(value: { [key: string]: string }) {
    this._spec = value;
  }
  public resetSpec() {
    this._spec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get specInput() {
    return this._spec;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentSpec {
  /**
  * Template describes the pods that will be created.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#template DataK8STemporalIoTemporalClusterV1Beta1Manifest#template}
  */
  readonly template?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentSpecTemplate;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentSpecToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    template: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentSpecTemplateToTerraform(struct!.template),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentSpecToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    template: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentSpecTemplateToHclTerraform(struct!.template),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentSpecTemplate",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentSpecOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentSpec | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._template?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.template = this._template?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentSpec | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._template.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._template.internalValue = value.template;
    }
  }

  // template - computed: false, optional: true, required: false
  private _template = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentSpecTemplateOutputReference(this, "template");
  public get template() {
    return this._template;
  }
  public putTemplate(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentSpecTemplate) {
    this._template.internalValue = value;
  }
  public resetTemplate() {
    this._template.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get templateInput() {
    return this._template.internalValue;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeployment {
  /**
  * ObjectMetaOverride provides the ability to override an object metadata. It's a subset of the fields included in k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#metadata DataK8STemporalIoTemporalClusterV1Beta1Manifest#metadata}
  */
  readonly metadata?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentMetadata;
  /**
  * Specification of the desired behavior of the Deployment.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#spec DataK8STemporalIoTemporalClusterV1Beta1Manifest#spec}
  */
  readonly spec?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentSpec;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeployment | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    metadata: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentMetadataToTerraform(struct!.metadata),
    spec: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentSpecToTerraform(struct!.spec),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeployment | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    metadata: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentMetadataToHclTerraform(struct!.metadata),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentMetadata",
    },
    spec: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentSpecToHclTerraform(struct!.spec),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentSpec",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeployment | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._spec?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.spec = this._spec?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeployment | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._metadata.internalValue = undefined;
      this._spec.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._metadata.internalValue = value.metadata;
      this._spec.internalValue = value.spec;
    }
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentMetadataOutputReference(this, "metadata");
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentMetadata) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // spec - computed: false, optional: true, required: false
  private _spec = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentSpecOutputReference(this, "spec");
  public get spec() {
    return this._spec;
  }
  public putSpec(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentSpec) {
    this._spec.internalValue = value;
  }
  public resetSpec() {
    this._spec.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get specInput() {
    return this._spec.internalValue;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverrides {
  /**
  * Override configuration for the temporal service Deployment.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#deployment DataK8STemporalIoTemporalClusterV1Beta1Manifest#deployment}
  */
  readonly deployment?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeployment;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverrides | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    deployment: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentToTerraform(struct!.deployment),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverrides | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    deployment: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentToHclTerraform(struct!.deployment),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeployment",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverrides | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._deployment?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.deployment = this._deployment?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverrides | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._deployment.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._deployment.internalValue = value.deployment;
    }
  }

  // deployment - computed: false, optional: true, required: false
  private _deployment = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeploymentOutputReference(this, "deployment");
  public get deployment() {
    return this._deployment;
  }
  public putDeployment(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesDeployment) {
    this._deployment.internalValue = value;
  }
  public resetDeployment() {
    this._deployment.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deploymentInput() {
    return this._deployment.internalValue;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentMetadata {
  /**
  * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#annotations DataK8STemporalIoTemporalClusterV1Beta1Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Map of string keys and values that can be used to organize and categorize (scope and select) objects.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#labels DataK8STemporalIoTemporalClusterV1Beta1Manifest#labels}
  */
  readonly labels?: { [key: string]: string };
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentMetadataToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentMetadataToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotations = undefined;
      this._labels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotations = value.annotations;
      this._labels = value.labels;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentSpecTemplateMetadata {
  /**
  * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#annotations DataK8STemporalIoTemporalClusterV1Beta1Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Map of string keys and values that can be used to organize and categorize (scope and select) objects.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#labels DataK8STemporalIoTemporalClusterV1Beta1Manifest#labels}
  */
  readonly labels?: { [key: string]: string };
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentSpecTemplateMetadataToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentSpecTemplateMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentSpecTemplateMetadataToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentSpecTemplateMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentSpecTemplateMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentSpecTemplateMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentSpecTemplateMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotations = undefined;
      this._labels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotations = value.annotations;
      this._labels = value.labels;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentSpecTemplate {
  /**
  * ObjectMetaOverride provides the ability to override an object metadata. It's a subset of the fields included in k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#metadata DataK8STemporalIoTemporalClusterV1Beta1Manifest#metadata}
  */
  readonly metadata?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentSpecTemplateMetadata;
  /**
  * Specification of the desired behavior of the pod.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#spec DataK8STemporalIoTemporalClusterV1Beta1Manifest#spec}
  */
  readonly spec?: { [key: string]: string };
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentSpecTemplateToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentSpecTemplate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    metadata: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentSpecTemplateMetadataToTerraform(struct!.metadata),
    spec: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.spec),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentSpecTemplateToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentSpecTemplate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    metadata: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentSpecTemplateMetadataToHclTerraform(struct!.metadata),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentSpecTemplateMetadata",
    },
    spec: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.spec),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentSpecTemplateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentSpecTemplate | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._spec !== undefined) {
      hasAnyValues = true;
      internalValueResult.spec = this._spec;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentSpecTemplate | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._metadata.internalValue = undefined;
      this._spec = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._metadata.internalValue = value.metadata;
      this._spec = value.spec;
    }
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentSpecTemplateMetadataOutputReference(this, "metadata");
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentSpecTemplateMetadata) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // spec - computed: false, optional: true, required: false
  private _spec?: { [key: string]: string }; 
  public get spec() {
    return this.getStringMapAttribute('spec');
  }
  public set spec(value: { [key: string]: string }) {
    this._spec = value;
  }
  public resetSpec() {
    this._spec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get specInput() {
    return this._spec;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentSpec {
  /**
  * Template describes the pods that will be created.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#template DataK8STemporalIoTemporalClusterV1Beta1Manifest#template}
  */
  readonly template?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentSpecTemplate;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentSpecToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    template: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentSpecTemplateToTerraform(struct!.template),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentSpecToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    template: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentSpecTemplateToHclTerraform(struct!.template),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentSpecTemplate",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentSpecOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentSpec | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._template?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.template = this._template?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentSpec | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._template.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._template.internalValue = value.template;
    }
  }

  // template - computed: false, optional: true, required: false
  private _template = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentSpecTemplateOutputReference(this, "template");
  public get template() {
    return this._template;
  }
  public putTemplate(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentSpecTemplate) {
    this._template.internalValue = value;
  }
  public resetTemplate() {
    this._template.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get templateInput() {
    return this._template.internalValue;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeployment {
  /**
  * ObjectMetaOverride provides the ability to override an object metadata. It's a subset of the fields included in k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#metadata DataK8STemporalIoTemporalClusterV1Beta1Manifest#metadata}
  */
  readonly metadata?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentMetadata;
  /**
  * Specification of the desired behavior of the Deployment.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#spec DataK8STemporalIoTemporalClusterV1Beta1Manifest#spec}
  */
  readonly spec?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentSpec;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeployment | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    metadata: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentMetadataToTerraform(struct!.metadata),
    spec: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentSpecToTerraform(struct!.spec),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeployment | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    metadata: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentMetadataToHclTerraform(struct!.metadata),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentMetadata",
    },
    spec: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentSpecToHclTerraform(struct!.spec),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentSpec",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeployment | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._spec?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.spec = this._spec?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeployment | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._metadata.internalValue = undefined;
      this._spec.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._metadata.internalValue = value.metadata;
      this._spec.internalValue = value.spec;
    }
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentMetadataOutputReference(this, "metadata");
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentMetadata) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // spec - computed: false, optional: true, required: false
  private _spec = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentSpecOutputReference(this, "spec");
  public get spec() {
    return this._spec;
  }
  public putSpec(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentSpec) {
    this._spec.internalValue = value;
  }
  public resetSpec() {
    this._spec.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get specInput() {
    return this._spec.internalValue;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverrides {
  /**
  * Override configuration for the temporal service Deployment.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#deployment DataK8STemporalIoTemporalClusterV1Beta1Manifest#deployment}
  */
  readonly deployment?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeployment;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverrides | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    deployment: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentToTerraform(struct!.deployment),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverrides | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    deployment: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentToHclTerraform(struct!.deployment),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeployment",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverrides | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._deployment?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.deployment = this._deployment?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverrides | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._deployment.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._deployment.internalValue = value.deployment;
    }
  }

  // deployment - computed: false, optional: true, required: false
  private _deployment = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeploymentOutputReference(this, "deployment");
  public get deployment() {
    return this._deployment;
  }
  public putDeployment(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesDeployment) {
    this._deployment.internalValue = value;
  }
  public resetDeployment() {
    this._deployment.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deploymentInput() {
    return this._deployment.internalValue;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerResourcesClaims {
  /**
  * Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#name DataK8STemporalIoTemporalClusterV1Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * Request is the name chosen for a request in the referenced claim. If empty, everything from the claim is made available, otherwise only the result of this request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#request DataK8STemporalIoTemporalClusterV1Beta1Manifest#request}
  */
  readonly request?: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerResourcesClaimsToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerResourcesClaims | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    request: cdktf.stringToTerraform(struct!.request),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerResourcesClaimsToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerResourcesClaims | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request: {
      value: cdktf.stringToHclTerraform(struct!.request),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerResourcesClaimsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerResourcesClaims | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._request !== undefined) {
      hasAnyValues = true;
      internalValueResult.request = this._request;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerResourcesClaims | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._request = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._request = value.request;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // request - computed: false, optional: true, required: false
  private _request?: string; 
  public get request() {
    return this.getStringAttribute('request');
  }
  public set request(value: string) {
    this._request = value;
  }
  public resetRequest() {
    this._request = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestInput() {
    return this._request;
  }
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerResourcesClaimsList extends cdktf.ComplexList {
  public internalValue? : DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerResourcesClaims[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerResourcesClaimsOutputReference {
    return new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerResourcesClaimsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerResources {
  /**
  * Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container. This is an alpha field and requires enabling the DynamicResourceAllocation feature gate. This field is immutable. It can only be set for containers.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#claims DataK8STemporalIoTemporalClusterV1Beta1Manifest#claims}
  */
  readonly claims?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerResourcesClaims[] | cdktf.IResolvable;
  /**
  * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#limits DataK8STemporalIoTemporalClusterV1Beta1Manifest#limits}
  */
  readonly limits?: { [key: string]: string };
  /**
  * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. Requests cannot exceed Limits. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#requests DataK8STemporalIoTemporalClusterV1Beta1Manifest#requests}
  */
  readonly requests?: { [key: string]: string };
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerResourcesToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerResources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    claims: cdktf.listMapper(dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerResourcesClaimsToTerraform, false)(struct!.claims),
    limits: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.limits),
    requests: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.requests),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerResourcesToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerResources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    claims: {
      value: cdktf.listMapperHcl(dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerResourcesClaimsToHclTerraform, false)(struct!.claims),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerResourcesClaimsList",
    },
    limits: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.limits),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    requests: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.requests),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerResourcesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerResources | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._claims?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.claims = this._claims?.internalValue;
    }
    if (this._limits !== undefined) {
      hasAnyValues = true;
      internalValueResult.limits = this._limits;
    }
    if (this._requests !== undefined) {
      hasAnyValues = true;
      internalValueResult.requests = this._requests;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerResources | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._claims.internalValue = undefined;
      this._limits = undefined;
      this._requests = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._claims.internalValue = value.claims;
      this._limits = value.limits;
      this._requests = value.requests;
    }
  }

  // claims - computed: false, optional: true, required: false
  private _claims = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerResourcesClaimsList(this, "claims", false);
  public get claims() {
    return this._claims;
  }
  public putClaims(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerResourcesClaims[] | cdktf.IResolvable) {
    this._claims.internalValue = value;
  }
  public resetClaims() {
    this._claims.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get claimsInput() {
    return this._claims.internalValue;
  }

  // limits - computed: false, optional: true, required: false
  private _limits?: { [key: string]: string }; 
  public get limits() {
    return this.getStringMapAttribute('limits');
  }
  public set limits(value: { [key: string]: string }) {
    this._limits = value;
  }
  public resetLimits() {
    this._limits = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get limitsInput() {
    return this._limits;
  }

  // requests - computed: false, optional: true, required: false
  private _requests?: { [key: string]: string }; 
  public get requests() {
    return this.getStringMapAttribute('requests');
  }
  public set requests(value: { [key: string]: string }) {
    this._requests = value;
  }
  public resetRequests() {
    this._requests = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestsInput() {
    return this._requests;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorker {
  /**
  * HTTPPort defines a custom http port for the service. Default values are: 7243 for Frontend service
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#http_port DataK8STemporalIoTemporalClusterV1Beta1Manifest#http_port}
  */
  readonly httpPort?: number;
  /**
  * InitContainers adds a list of init containers to the service's deployment.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#init_containers DataK8STemporalIoTemporalClusterV1Beta1Manifest#init_containers}
  */
  readonly initContainers?: { [key: string]: string }[] | cdktf.IResolvable;
  /**
  * MembershipPort defines a custom membership port for the service. Default values are: 6933 for Frontend service 6934 for History service 6935 for Matching service 6939 for Worker service
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#membership_port DataK8STemporalIoTemporalClusterV1Beta1Manifest#membership_port}
  */
  readonly membershipPort?: number;
  /**
  * Overrides adds some overrides to the resources deployed for the service. Those overrides takes precedence over spec.services.overrides.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#overrides DataK8STemporalIoTemporalClusterV1Beta1Manifest#overrides}
  */
  readonly overrides?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverrides;
  /**
  * Port defines a custom gRPC port for the service. Default values are: 7233 for Frontend service 7234 for History service 7235 for Matching service 7239 for Worker service
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#port DataK8STemporalIoTemporalClusterV1Beta1Manifest#port}
  */
  readonly port?: number;
  /**
  * Number of desired replicas for the service. Default to 1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#replicas DataK8STemporalIoTemporalClusterV1Beta1Manifest#replicas}
  */
  readonly replicas?: number;
  /**
  * Compute Resources required by this service. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#resources DataK8STemporalIoTemporalClusterV1Beta1Manifest#resources}
  */
  readonly resources?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerResources;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorker | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    http_port: cdktf.numberToTerraform(struct!.httpPort),
    init_containers: cdktf.listMapper(cdktf.hashMapper(cdktf.stringToTerraform), false)(struct!.initContainers),
    membership_port: cdktf.numberToTerraform(struct!.membershipPort),
    overrides: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesToTerraform(struct!.overrides),
    port: cdktf.numberToTerraform(struct!.port),
    replicas: cdktf.numberToTerraform(struct!.replicas),
    resources: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerResourcesToTerraform(struct!.resources),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorker | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    http_port: {
      value: cdktf.numberToHclTerraform(struct!.httpPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    init_containers: {
      value: cdktf.listMapperHcl(cdktf.hashMapperHcl(cdktf.stringToHclTerraform), false)(struct!.initContainers),
      isBlock: false,
      type: "list",
      storageClassType: "stringMapList",
    },
    membership_port: {
      value: cdktf.numberToHclTerraform(struct!.membershipPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    overrides: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesToHclTerraform(struct!.overrides),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverrides",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    replicas: {
      value: cdktf.numberToHclTerraform(struct!.replicas),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    resources: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerResourcesToHclTerraform(struct!.resources),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerResources",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorker | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._httpPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpPort = this._httpPort;
    }
    if (this._initContainers !== undefined) {
      hasAnyValues = true;
      internalValueResult.initContainers = this._initContainers;
    }
    if (this._membershipPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.membershipPort = this._membershipPort;
    }
    if (this._overrides?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.overrides = this._overrides?.internalValue;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._replicas !== undefined) {
      hasAnyValues = true;
      internalValueResult.replicas = this._replicas;
    }
    if (this._resources?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resources = this._resources?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorker | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._httpPort = undefined;
      this._initContainers = undefined;
      this._membershipPort = undefined;
      this._overrides.internalValue = undefined;
      this._port = undefined;
      this._replicas = undefined;
      this._resources.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._httpPort = value.httpPort;
      this._initContainers = value.initContainers;
      this._membershipPort = value.membershipPort;
      this._overrides.internalValue = value.overrides;
      this._port = value.port;
      this._replicas = value.replicas;
      this._resources.internalValue = value.resources;
    }
  }

  // http_port - computed: false, optional: true, required: false
  private _httpPort?: number; 
  public get httpPort() {
    return this.getNumberAttribute('http_port');
  }
  public set httpPort(value: number) {
    this._httpPort = value;
  }
  public resetHttpPort() {
    this._httpPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpPortInput() {
    return this._httpPort;
  }

  // init_containers - computed: false, optional: true, required: false
  private _initContainers?: { [key: string]: string }[] | cdktf.IResolvable; 
  public get initContainers() {
    return this.interpolationForAttribute('init_containers');
  }
  public set initContainers(value: { [key: string]: string }[] | cdktf.IResolvable) {
    this._initContainers = value;
  }
  public resetInitContainers() {
    this._initContainers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initContainersInput() {
    return this._initContainers;
  }

  // membership_port - computed: false, optional: true, required: false
  private _membershipPort?: number; 
  public get membershipPort() {
    return this.getNumberAttribute('membership_port');
  }
  public set membershipPort(value: number) {
    this._membershipPort = value;
  }
  public resetMembershipPort() {
    this._membershipPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get membershipPortInput() {
    return this._membershipPort;
  }

  // overrides - computed: false, optional: true, required: false
  private _overrides = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverridesOutputReference(this, "overrides");
  public get overrides() {
    return this._overrides;
  }
  public putOverrides(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOverrides) {
    this._overrides.internalValue = value;
  }
  public resetOverrides() {
    this._overrides.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overridesInput() {
    return this._overrides.internalValue;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // replicas - computed: false, optional: true, required: false
  private _replicas?: number; 
  public get replicas() {
    return this.getNumberAttribute('replicas');
  }
  public set replicas(value: number) {
    this._replicas = value;
  }
  public resetReplicas() {
    this._replicas = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get replicasInput() {
    return this._replicas;
  }

  // resources - computed: false, optional: true, required: false
  private _resources = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerResourcesOutputReference(this, "resources");
  public get resources() {
    return this._resources;
  }
  public putResources(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerResources) {
    this._resources.internalValue = value;
  }
  public resetResources() {
    this._resources.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourcesInput() {
    return this._resources.internalValue;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServices {
  /**
  * Frontend service custom specifications.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#frontend DataK8STemporalIoTemporalClusterV1Beta1Manifest#frontend}
  */
  readonly frontend?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontend;
  /**
  * History service custom specifications.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#history DataK8STemporalIoTemporalClusterV1Beta1Manifest#history}
  */
  readonly history?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistory;
  /**
  * Internal Frontend service custom specifications. Only compatible with temporal >= 1.20.0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#internal_frontend DataK8STemporalIoTemporalClusterV1Beta1Manifest#internal_frontend}
  */
  readonly internalFrontend?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontend;
  /**
  * Matching service custom specifications.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#matching DataK8STemporalIoTemporalClusterV1Beta1Manifest#matching}
  */
  readonly matching?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatching;
  /**
  * Overrides adds some overrides to the resources deployed for all temporal services services. Those overrides can be customized per service using spec.services.<serviceName>.overrides.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#overrides DataK8STemporalIoTemporalClusterV1Beta1Manifest#overrides}
  */
  readonly overrides?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverrides;
  /**
  * Worker service custom specifications.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#worker DataK8STemporalIoTemporalClusterV1Beta1Manifest#worker}
  */
  readonly worker?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorker;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    frontend: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendToTerraform(struct!.frontend),
    history: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryToTerraform(struct!.history),
    internal_frontend: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendToTerraform(struct!.internalFrontend),
    matching: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingToTerraform(struct!.matching),
    overrides: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesToTerraform(struct!.overrides),
    worker: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerToTerraform(struct!.worker),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    frontend: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendToHclTerraform(struct!.frontend),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontend",
    },
    history: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryToHclTerraform(struct!.history),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistory",
    },
    internal_frontend: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendToHclTerraform(struct!.internalFrontend),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontend",
    },
    matching: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingToHclTerraform(struct!.matching),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatching",
    },
    overrides: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesToHclTerraform(struct!.overrides),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverrides",
    },
    worker: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerToHclTerraform(struct!.worker),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorker",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServices | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._frontend?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.frontend = this._frontend?.internalValue;
    }
    if (this._history?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.history = this._history?.internalValue;
    }
    if (this._internalFrontend?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.internalFrontend = this._internalFrontend?.internalValue;
    }
    if (this._matching?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matching = this._matching?.internalValue;
    }
    if (this._overrides?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.overrides = this._overrides?.internalValue;
    }
    if (this._worker?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.worker = this._worker?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServices | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._frontend.internalValue = undefined;
      this._history.internalValue = undefined;
      this._internalFrontend.internalValue = undefined;
      this._matching.internalValue = undefined;
      this._overrides.internalValue = undefined;
      this._worker.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._frontend.internalValue = value.frontend;
      this._history.internalValue = value.history;
      this._internalFrontend.internalValue = value.internalFrontend;
      this._matching.internalValue = value.matching;
      this._overrides.internalValue = value.overrides;
      this._worker.internalValue = value.worker;
    }
  }

  // frontend - computed: false, optional: true, required: false
  private _frontend = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontendOutputReference(this, "frontend");
  public get frontend() {
    return this._frontend;
  }
  public putFrontend(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesFrontend) {
    this._frontend.internalValue = value;
  }
  public resetFrontend() {
    this._frontend.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get frontendInput() {
    return this._frontend.internalValue;
  }

  // history - computed: false, optional: true, required: false
  private _history = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistoryOutputReference(this, "history");
  public get history() {
    return this._history;
  }
  public putHistory(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesHistory) {
    this._history.internalValue = value;
  }
  public resetHistory() {
    this._history.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get historyInput() {
    return this._history.internalValue;
  }

  // internal_frontend - computed: false, optional: true, required: false
  private _internalFrontend = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontendOutputReference(this, "internal_frontend");
  public get internalFrontend() {
    return this._internalFrontend;
  }
  public putInternalFrontend(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesInternalFrontend) {
    this._internalFrontend.internalValue = value;
  }
  public resetInternalFrontend() {
    this._internalFrontend.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get internalFrontendInput() {
    return this._internalFrontend.internalValue;
  }

  // matching - computed: false, optional: true, required: false
  private _matching = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatchingOutputReference(this, "matching");
  public get matching() {
    return this._matching;
  }
  public putMatching(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesMatching) {
    this._matching.internalValue = value;
  }
  public resetMatching() {
    this._matching.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchingInput() {
    return this._matching.internalValue;
  }

  // overrides - computed: false, optional: true, required: false
  private _overrides = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverridesOutputReference(this, "overrides");
  public get overrides() {
    return this._overrides;
  }
  public putOverrides(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOverrides) {
    this._overrides.internalValue = value;
  }
  public resetOverrides() {
    this._overrides.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overridesInput() {
    return this._overrides.internalValue;
  }

  // worker - computed: false, optional: true, required: false
  private _worker = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorkerOutputReference(this, "worker");
  public get worker() {
    return this._worker;
  }
  public putWorker(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesWorker) {
    this._worker.internalValue = value;
  }
  public resetWorker() {
    this._worker.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get workerInput() {
    return this._worker.internalValue;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiIngressTls {
  /**
  * hosts is a list of hosts included in the TLS certificate. The values in this list must match the name/s used in the tlsSecret. Defaults to the wildcard host setting for the loadbalancer controller fulfilling this Ingress, if left unspecified.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#hosts DataK8STemporalIoTemporalClusterV1Beta1Manifest#hosts}
  */
  readonly hosts?: string[];
  /**
  * secretName is the name of the secret used to terminate TLS traffic on port 443. Field is left optional to allow TLS routing based on SNI hostname alone. If the SNI host in a listener conflicts with the 'Host' header field used by an IngressRule, the SNI host is used for termination and value of the 'Host' header is used for routing.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#secret_name DataK8STemporalIoTemporalClusterV1Beta1Manifest#secret_name}
  */
  readonly secretName?: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiIngressTlsToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiIngressTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    hosts: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.hosts),
    secret_name: cdktf.stringToTerraform(struct!.secretName),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiIngressTlsToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiIngressTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    hosts: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.hosts),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    secret_name: {
      value: cdktf.stringToHclTerraform(struct!.secretName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiIngressTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiIngressTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._hosts !== undefined) {
      hasAnyValues = true;
      internalValueResult.hosts = this._hosts;
    }
    if (this._secretName !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretName = this._secretName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiIngressTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._hosts = undefined;
      this._secretName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._hosts = value.hosts;
      this._secretName = value.secretName;
    }
  }

  // hosts - computed: false, optional: true, required: false
  private _hosts?: string[]; 
  public get hosts() {
    return this.getListAttribute('hosts');
  }
  public set hosts(value: string[]) {
    this._hosts = value;
  }
  public resetHosts() {
    this._hosts = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostsInput() {
    return this._hosts;
  }

  // secret_name - computed: false, optional: true, required: false
  private _secretName?: string; 
  public get secretName() {
    return this.getStringAttribute('secret_name');
  }
  public set secretName(value: string) {
    this._secretName = value;
  }
  public resetSecretName() {
    this._secretName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretNameInput() {
    return this._secretName;
  }
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiIngressTlsList extends cdktf.ComplexList {
  public internalValue? : DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiIngressTls[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiIngressTlsOutputReference {
    return new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiIngressTlsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiIngress {
  /**
  * Annotations allows custom annotations on the ingress resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#annotations DataK8STemporalIoTemporalClusterV1Beta1Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Host is the list of host the ingress should use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#hosts DataK8STemporalIoTemporalClusterV1Beta1Manifest#hosts}
  */
  readonly hosts: string[];
  /**
  * IngressClassName is the name of the IngressClass the deployed ingress resource should use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#ingress_class_name DataK8STemporalIoTemporalClusterV1Beta1Manifest#ingress_class_name}
  */
  readonly ingressClassName?: string;
  /**
  * TLS configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#tls DataK8STemporalIoTemporalClusterV1Beta1Manifest#tls}
  */
  readonly tls?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiIngressTls[] | cdktf.IResolvable;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiIngressToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiIngress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    hosts: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.hosts),
    ingress_class_name: cdktf.stringToTerraform(struct!.ingressClassName),
    tls: cdktf.listMapper(dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiIngressTlsToTerraform, false)(struct!.tls),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiIngressToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiIngress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    hosts: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.hosts),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    ingress_class_name: {
      value: cdktf.stringToHclTerraform(struct!.ingressClassName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: cdktf.listMapperHcl(dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiIngressTlsToHclTerraform, false)(struct!.tls),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiIngressTlsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiIngressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiIngress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._hosts !== undefined) {
      hasAnyValues = true;
      internalValueResult.hosts = this._hosts;
    }
    if (this._ingressClassName !== undefined) {
      hasAnyValues = true;
      internalValueResult.ingressClassName = this._ingressClassName;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiIngress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotations = undefined;
      this._hosts = undefined;
      this._ingressClassName = undefined;
      this._tls.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotations = value.annotations;
      this._hosts = value.hosts;
      this._ingressClassName = value.ingressClassName;
      this._tls.internalValue = value.tls;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // hosts - computed: false, optional: false, required: true
  private _hosts?: string[]; 
  public get hosts() {
    return this.getListAttribute('hosts');
  }
  public set hosts(value: string[]) {
    this._hosts = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostsInput() {
    return this._hosts;
  }

  // ingress_class_name - computed: false, optional: true, required: false
  private _ingressClassName?: string; 
  public get ingressClassName() {
    return this.getStringAttribute('ingress_class_name');
  }
  public set ingressClassName(value: string) {
    this._ingressClassName = value;
  }
  public resetIngressClassName() {
    this._ingressClassName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ingressClassNameInput() {
    return this._ingressClassName;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiIngressTlsList(this, "tls", false);
  public get tls() {
    return this._tls;
  }
  public putTls(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiIngressTls[] | cdktf.IResolvable) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentMetadata {
  /**
  * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#annotations DataK8STemporalIoTemporalClusterV1Beta1Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Map of string keys and values that can be used to organize and categorize (scope and select) objects.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#labels DataK8STemporalIoTemporalClusterV1Beta1Manifest#labels}
  */
  readonly labels?: { [key: string]: string };
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentMetadataToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentMetadataToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotations = undefined;
      this._labels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotations = value.annotations;
      this._labels = value.labels;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentSpecTemplateMetadata {
  /**
  * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#annotations DataK8STemporalIoTemporalClusterV1Beta1Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Map of string keys and values that can be used to organize and categorize (scope and select) objects.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#labels DataK8STemporalIoTemporalClusterV1Beta1Manifest#labels}
  */
  readonly labels?: { [key: string]: string };
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentSpecTemplateMetadataToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentSpecTemplateMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentSpecTemplateMetadataToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentSpecTemplateMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentSpecTemplateMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentSpecTemplateMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentSpecTemplateMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotations = undefined;
      this._labels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotations = value.annotations;
      this._labels = value.labels;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentSpecTemplate {
  /**
  * ObjectMetaOverride provides the ability to override an object metadata. It's a subset of the fields included in k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#metadata DataK8STemporalIoTemporalClusterV1Beta1Manifest#metadata}
  */
  readonly metadata?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentSpecTemplateMetadata;
  /**
  * Specification of the desired behavior of the pod.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#spec DataK8STemporalIoTemporalClusterV1Beta1Manifest#spec}
  */
  readonly spec?: { [key: string]: string };
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentSpecTemplateToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentSpecTemplate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    metadata: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentSpecTemplateMetadataToTerraform(struct!.metadata),
    spec: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.spec),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentSpecTemplateToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentSpecTemplate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    metadata: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentSpecTemplateMetadataToHclTerraform(struct!.metadata),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentSpecTemplateMetadata",
    },
    spec: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.spec),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentSpecTemplateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentSpecTemplate | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._spec !== undefined) {
      hasAnyValues = true;
      internalValueResult.spec = this._spec;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentSpecTemplate | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._metadata.internalValue = undefined;
      this._spec = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._metadata.internalValue = value.metadata;
      this._spec = value.spec;
    }
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentSpecTemplateMetadataOutputReference(this, "metadata");
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentSpecTemplateMetadata) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // spec - computed: false, optional: true, required: false
  private _spec?: { [key: string]: string }; 
  public get spec() {
    return this.getStringMapAttribute('spec');
  }
  public set spec(value: { [key: string]: string }) {
    this._spec = value;
  }
  public resetSpec() {
    this._spec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get specInput() {
    return this._spec;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentSpec {
  /**
  * Template describes the pods that will be created.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#template DataK8STemporalIoTemporalClusterV1Beta1Manifest#template}
  */
  readonly template?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentSpecTemplate;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentSpecToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    template: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentSpecTemplateToTerraform(struct!.template),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentSpecToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    template: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentSpecTemplateToHclTerraform(struct!.template),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentSpecTemplate",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentSpecOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentSpec | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._template?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.template = this._template?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentSpec | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._template.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._template.internalValue = value.template;
    }
  }

  // template - computed: false, optional: true, required: false
  private _template = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentSpecTemplateOutputReference(this, "template");
  public get template() {
    return this._template;
  }
  public putTemplate(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentSpecTemplate) {
    this._template.internalValue = value;
  }
  public resetTemplate() {
    this._template.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get templateInput() {
    return this._template.internalValue;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeployment {
  /**
  * ObjectMetaOverride provides the ability to override an object metadata. It's a subset of the fields included in k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#metadata DataK8STemporalIoTemporalClusterV1Beta1Manifest#metadata}
  */
  readonly metadata?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentMetadata;
  /**
  * Specification of the desired behavior of the Deployment.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#spec DataK8STemporalIoTemporalClusterV1Beta1Manifest#spec}
  */
  readonly spec?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentSpec;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeployment | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    metadata: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentMetadataToTerraform(struct!.metadata),
    spec: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentSpecToTerraform(struct!.spec),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeployment | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    metadata: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentMetadataToHclTerraform(struct!.metadata),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentMetadata",
    },
    spec: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentSpecToHclTerraform(struct!.spec),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentSpec",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeployment | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._spec?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.spec = this._spec?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeployment | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._metadata.internalValue = undefined;
      this._spec.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._metadata.internalValue = value.metadata;
      this._spec.internalValue = value.spec;
    }
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentMetadataOutputReference(this, "metadata");
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentMetadata) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // spec - computed: false, optional: true, required: false
  private _spec = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentSpecOutputReference(this, "spec");
  public get spec() {
    return this._spec;
  }
  public putSpec(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentSpec) {
    this._spec.internalValue = value;
  }
  public resetSpec() {
    this._spec.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get specInput() {
    return this._spec.internalValue;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverrides {
  /**
  * Override configuration for the temporal service Deployment.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#deployment DataK8STemporalIoTemporalClusterV1Beta1Manifest#deployment}
  */
  readonly deployment?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeployment;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverrides | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    deployment: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentToTerraform(struct!.deployment),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverrides | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    deployment: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentToHclTerraform(struct!.deployment),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeployment",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverrides | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._deployment?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.deployment = this._deployment?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverrides | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._deployment.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._deployment.internalValue = value.deployment;
    }
  }

  // deployment - computed: false, optional: true, required: false
  private _deployment = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeploymentOutputReference(this, "deployment");
  public get deployment() {
    return this._deployment;
  }
  public putDeployment(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesDeployment) {
    this._deployment.internalValue = value;
  }
  public resetDeployment() {
    this._deployment.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deploymentInput() {
    return this._deployment.internalValue;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiResourcesClaims {
  /**
  * Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#name DataK8STemporalIoTemporalClusterV1Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * Request is the name chosen for a request in the referenced claim. If empty, everything from the claim is made available, otherwise only the result of this request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#request DataK8STemporalIoTemporalClusterV1Beta1Manifest#request}
  */
  readonly request?: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiResourcesClaimsToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiResourcesClaims | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    request: cdktf.stringToTerraform(struct!.request),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiResourcesClaimsToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiResourcesClaims | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request: {
      value: cdktf.stringToHclTerraform(struct!.request),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiResourcesClaimsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiResourcesClaims | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._request !== undefined) {
      hasAnyValues = true;
      internalValueResult.request = this._request;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiResourcesClaims | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._request = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._request = value.request;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // request - computed: false, optional: true, required: false
  private _request?: string; 
  public get request() {
    return this.getStringAttribute('request');
  }
  public set request(value: string) {
    this._request = value;
  }
  public resetRequest() {
    this._request = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestInput() {
    return this._request;
  }
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiResourcesClaimsList extends cdktf.ComplexList {
  public internalValue? : DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiResourcesClaims[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiResourcesClaimsOutputReference {
    return new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiResourcesClaimsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiResources {
  /**
  * Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container. This is an alpha field and requires enabling the DynamicResourceAllocation feature gate. This field is immutable. It can only be set for containers.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#claims DataK8STemporalIoTemporalClusterV1Beta1Manifest#claims}
  */
  readonly claims?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiResourcesClaims[] | cdktf.IResolvable;
  /**
  * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#limits DataK8STemporalIoTemporalClusterV1Beta1Manifest#limits}
  */
  readonly limits?: { [key: string]: string };
  /**
  * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. Requests cannot exceed Limits. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#requests DataK8STemporalIoTemporalClusterV1Beta1Manifest#requests}
  */
  readonly requests?: { [key: string]: string };
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiResourcesToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiResources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    claims: cdktf.listMapper(dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiResourcesClaimsToTerraform, false)(struct!.claims),
    limits: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.limits),
    requests: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.requests),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiResourcesToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiResources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    claims: {
      value: cdktf.listMapperHcl(dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiResourcesClaimsToHclTerraform, false)(struct!.claims),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiResourcesClaimsList",
    },
    limits: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.limits),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    requests: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.requests),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiResourcesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiResources | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._claims?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.claims = this._claims?.internalValue;
    }
    if (this._limits !== undefined) {
      hasAnyValues = true;
      internalValueResult.limits = this._limits;
    }
    if (this._requests !== undefined) {
      hasAnyValues = true;
      internalValueResult.requests = this._requests;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiResources | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._claims.internalValue = undefined;
      this._limits = undefined;
      this._requests = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._claims.internalValue = value.claims;
      this._limits = value.limits;
      this._requests = value.requests;
    }
  }

  // claims - computed: false, optional: true, required: false
  private _claims = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiResourcesClaimsList(this, "claims", false);
  public get claims() {
    return this._claims;
  }
  public putClaims(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiResourcesClaims[] | cdktf.IResolvable) {
    this._claims.internalValue = value;
  }
  public resetClaims() {
    this._claims.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get claimsInput() {
    return this._claims.internalValue;
  }

  // limits - computed: false, optional: true, required: false
  private _limits?: { [key: string]: string }; 
  public get limits() {
    return this.getStringMapAttribute('limits');
  }
  public set limits(value: { [key: string]: string }) {
    this._limits = value;
  }
  public resetLimits() {
    this._limits = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get limitsInput() {
    return this._limits;
  }

  // requests - computed: false, optional: true, required: false
  private _requests?: { [key: string]: string }; 
  public get requests() {
    return this.getStringMapAttribute('requests');
  }
  public set requests(value: { [key: string]: string }) {
    this._requests = value;
  }
  public resetRequests() {
    this._requests = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestsInput() {
    return this._requests;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiService {
  /**
  * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#annotations DataK8STemporalIoTemporalClusterV1Beta1Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Map of string keys and values that can be used to organize and categorize (scope and select) objects.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#labels DataK8STemporalIoTemporalClusterV1Beta1Manifest#labels}
  */
  readonly labels?: { [key: string]: string };
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiServiceToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiServiceToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiServiceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiService | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiService | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotations = undefined;
      this._labels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotations = value.annotations;
      this._labels = value.labels;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUi {
  /**
  * Enabled defines if the operator should deploy the web ui alongside the cluster.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#enabled DataK8STemporalIoTemporalClusterV1Beta1Manifest#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
  /**
  * Image defines the temporal ui docker image the instance should run.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#image DataK8STemporalIoTemporalClusterV1Beta1Manifest#image}
  */
  readonly image?: string;
  /**
  * Ingress is an optional ingress configuration for the UI. If lived empty, no ingress configuration will be created and the UI will only by available trough ClusterIP service.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#ingress DataK8STemporalIoTemporalClusterV1Beta1Manifest#ingress}
  */
  readonly ingress?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiIngress;
  /**
  * Overrides adds some overrides to the resources deployed for the ui.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#overrides DataK8STemporalIoTemporalClusterV1Beta1Manifest#overrides}
  */
  readonly overrides?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverrides;
  /**
  * Number of desired replicas for the ui. Default to 1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#replicas DataK8STemporalIoTemporalClusterV1Beta1Manifest#replicas}
  */
  readonly replicas?: number;
  /**
  * Compute Resources required by the ui. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#resources DataK8STemporalIoTemporalClusterV1Beta1Manifest#resources}
  */
  readonly resources?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiResources;
  /**
  * Service is an optional service resource configuration for the UI.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#service DataK8STemporalIoTemporalClusterV1Beta1Manifest#service}
  */
  readonly service?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiService;
  /**
  * Version defines the temporal ui version the instance should run.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#version DataK8STemporalIoTemporalClusterV1Beta1Manifest#version}
  */
  readonly version?: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.booleanToTerraform(struct!.enabled),
    image: cdktf.stringToTerraform(struct!.image),
    ingress: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiIngressToTerraform(struct!.ingress),
    overrides: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesToTerraform(struct!.overrides),
    replicas: cdktf.numberToTerraform(struct!.replicas),
    resources: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiResourcesToTerraform(struct!.resources),
    service: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiServiceToTerraform(struct!.service),
    version: cdktf.stringToTerraform(struct!.version),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    image: {
      value: cdktf.stringToHclTerraform(struct!.image),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ingress: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiIngressToHclTerraform(struct!.ingress),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiIngress",
    },
    overrides: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesToHclTerraform(struct!.overrides),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverrides",
    },
    replicas: {
      value: cdktf.numberToHclTerraform(struct!.replicas),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    resources: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiResourcesToHclTerraform(struct!.resources),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiResources",
    },
    service: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiServiceToHclTerraform(struct!.service),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiService",
    },
    version: {
      value: cdktf.stringToHclTerraform(struct!.version),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUi | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._image !== undefined) {
      hasAnyValues = true;
      internalValueResult.image = this._image;
    }
    if (this._ingress?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ingress = this._ingress?.internalValue;
    }
    if (this._overrides?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.overrides = this._overrides?.internalValue;
    }
    if (this._replicas !== undefined) {
      hasAnyValues = true;
      internalValueResult.replicas = this._replicas;
    }
    if (this._resources?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resources = this._resources?.internalValue;
    }
    if (this._service?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.service = this._service?.internalValue;
    }
    if (this._version !== undefined) {
      hasAnyValues = true;
      internalValueResult.version = this._version;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUi | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._image = undefined;
      this._ingress.internalValue = undefined;
      this._overrides.internalValue = undefined;
      this._replicas = undefined;
      this._resources.internalValue = undefined;
      this._service.internalValue = undefined;
      this._version = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._image = value.image;
      this._ingress.internalValue = value.ingress;
      this._overrides.internalValue = value.overrides;
      this._replicas = value.replicas;
      this._resources.internalValue = value.resources;
      this._service.internalValue = value.service;
      this._version = value.version;
    }
  }

  // enabled - computed: false, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // image - computed: false, optional: true, required: false
  private _image?: string; 
  public get image() {
    return this.getStringAttribute('image');
  }
  public set image(value: string) {
    this._image = value;
  }
  public resetImage() {
    this._image = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageInput() {
    return this._image;
  }

  // ingress - computed: false, optional: true, required: false
  private _ingress = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiIngressOutputReference(this, "ingress");
  public get ingress() {
    return this._ingress;
  }
  public putIngress(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiIngress) {
    this._ingress.internalValue = value;
  }
  public resetIngress() {
    this._ingress.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ingressInput() {
    return this._ingress.internalValue;
  }

  // overrides - computed: false, optional: true, required: false
  private _overrides = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverridesOutputReference(this, "overrides");
  public get overrides() {
    return this._overrides;
  }
  public putOverrides(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOverrides) {
    this._overrides.internalValue = value;
  }
  public resetOverrides() {
    this._overrides.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overridesInput() {
    return this._overrides.internalValue;
  }

  // replicas - computed: false, optional: true, required: false
  private _replicas?: number; 
  public get replicas() {
    return this.getNumberAttribute('replicas');
  }
  public set replicas(value: number) {
    this._replicas = value;
  }
  public resetReplicas() {
    this._replicas = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get replicasInput() {
    return this._replicas;
  }

  // resources - computed: false, optional: true, required: false
  private _resources = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiResourcesOutputReference(this, "resources");
  public get resources() {
    return this._resources;
  }
  public putResources(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiResources) {
    this._resources.internalValue = value;
  }
  public resetResources() {
    this._resources.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourcesInput() {
    return this._resources.internalValue;
  }

  // service - computed: false, optional: true, required: false
  private _service = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiServiceOutputReference(this, "service");
  public get service() {
    return this._service;
  }
  public putService(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiService) {
    this._service.internalValue = value;
  }
  public resetService() {
    this._service.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceInput() {
    return this._service.internalValue;
  }

  // version - computed: false, optional: true, required: false
  private _version?: string; 
  public get version() {
    return this.getStringAttribute('version');
  }
  public set version(value: string) {
    this._version = value;
  }
  public resetVersion() {
    this._version = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get versionInput() {
    return this._version;
  }
}
export interface DataK8STemporalIoTemporalClusterV1Beta1ManifestSpec {
  /**
  * AdminTools allows configuration of the optional admin tool pod deployed alongside the cluster.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#admintools DataK8STemporalIoTemporalClusterV1Beta1Manifest#admintools}
  */
  readonly admintools?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintools;
  /**
  * Archival allows Workflow Execution Event Histories and Visibility data backups for the temporal cluster.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#archival DataK8STemporalIoTemporalClusterV1Beta1Manifest#archival}
  */
  readonly archival?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchival;
  /**
  * Authorization allows authorization configuration for the temporal cluster.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#authorization DataK8STemporalIoTemporalClusterV1Beta1Manifest#authorization}
  */
  readonly authorization?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAuthorization;
  /**
  * DynamicConfig allows advanced configuration for the temporal cluster.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#dynamic_config DataK8STemporalIoTemporalClusterV1Beta1Manifest#dynamic_config}
  */
  readonly dynamicConfig?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecDynamicConfig;
  /**
  * Image defines the temporal server docker image the cluster should use for each services.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#image DataK8STemporalIoTemporalClusterV1Beta1Manifest#image}
  */
  readonly image?: string;
  /**
  * An optional list of references to secrets in the same namespace to use for pulling temporal images from registries.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#image_pull_secrets DataK8STemporalIoTemporalClusterV1Beta1Manifest#image_pull_secrets}
  */
  readonly imagePullSecrets?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecImagePullSecrets[] | cdktf.IResolvable;
  /**
  * JobInitContainers adds a list of init containers to the setup's jobs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#job_init_containers DataK8STemporalIoTemporalClusterV1Beta1Manifest#job_init_containers}
  */
  readonly jobInitContainers?: { [key: string]: string }[] | cdktf.IResolvable;
  /**
  * JobResources allows set resources for setup/update jobs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#job_resources DataK8STemporalIoTemporalClusterV1Beta1Manifest#job_resources}
  */
  readonly jobResources?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecJobResources;
  /**
  * JobTTLSecondsAfterFinished is amount of time to keep job pods after jobs are completed. Defaults to 300 seconds.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#job_ttl_seconds_after_finished DataK8STemporalIoTemporalClusterV1Beta1Manifest#job_ttl_seconds_after_finished}
  */
  readonly jobTtlSecondsAfterFinished?: number;
  /**
  * Log defines temporal cluster's logger configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#log DataK8STemporalIoTemporalClusterV1Beta1Manifest#log}
  */
  readonly log?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecLog;
  /**
  * MTLS allows configuration of the network traffic encryption for the cluster.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#m_tls DataK8STemporalIoTemporalClusterV1Beta1Manifest#m_tls}
  */
  readonly mTls?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMTls;
  /**
  * Metrics allows configuration of scraping endpoints for stats. prometheus or m3.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#metrics DataK8STemporalIoTemporalClusterV1Beta1Manifest#metrics}
  */
  readonly metrics?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetrics;
  /**
  * NumHistoryShards is the desired number of history shards. This field is immutable.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#num_history_shards DataK8STemporalIoTemporalClusterV1Beta1Manifest#num_history_shards}
  */
  readonly numHistoryShards: number;
  /**
  * Persistence defines temporal persistence configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#persistence DataK8STemporalIoTemporalClusterV1Beta1Manifest#persistence}
  */
  readonly persistence: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistence;
  /**
  * Services allows customizations for each temporal services deployment.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#services DataK8STemporalIoTemporalClusterV1Beta1Manifest#services}
  */
  readonly services?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServices;
  /**
  * UI allows configuration of the optional temporal web ui deployed alongside the cluster.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#ui DataK8STemporalIoTemporalClusterV1Beta1Manifest#ui}
  */
  readonly ui?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUi;
  /**
  * Version defines the temporal version the cluster to be deployed. This version impacts the underlying persistence schemas versions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#version DataK8STemporalIoTemporalClusterV1Beta1Manifest#version}
  */
  readonly version?: string;
}

export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecToTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    admintools: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsToTerraform(struct!.admintools),
    archival: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalToTerraform(struct!.archival),
    authorization: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAuthorizationToTerraform(struct!.authorization),
    dynamic_config: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecDynamicConfigToTerraform(struct!.dynamicConfig),
    image: cdktf.stringToTerraform(struct!.image),
    image_pull_secrets: cdktf.listMapper(dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecImagePullSecretsToTerraform, false)(struct!.imagePullSecrets),
    job_init_containers: cdktf.listMapper(cdktf.hashMapper(cdktf.stringToTerraform), false)(struct!.jobInitContainers),
    job_resources: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecJobResourcesToTerraform(struct!.jobResources),
    job_ttl_seconds_after_finished: cdktf.numberToTerraform(struct!.jobTtlSecondsAfterFinished),
    log: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecLogToTerraform(struct!.log),
    m_tls: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMTlsToTerraform(struct!.mTls),
    metrics: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsToTerraform(struct!.metrics),
    num_history_shards: cdktf.numberToTerraform(struct!.numHistoryShards),
    persistence: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceToTerraform(struct!.persistence),
    services: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesToTerraform(struct!.services),
    ui: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiToTerraform(struct!.ui),
    version: cdktf.stringToTerraform(struct!.version),
  }
}


export function dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecToHclTerraform(struct?: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    admintools: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsToHclTerraform(struct!.admintools),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintools",
    },
    archival: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalToHclTerraform(struct!.archival),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchival",
    },
    authorization: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAuthorizationToHclTerraform(struct!.authorization),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAuthorization",
    },
    dynamic_config: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecDynamicConfigToHclTerraform(struct!.dynamicConfig),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecDynamicConfig",
    },
    image: {
      value: cdktf.stringToHclTerraform(struct!.image),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    image_pull_secrets: {
      value: cdktf.listMapperHcl(dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecImagePullSecretsToHclTerraform, false)(struct!.imagePullSecrets),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecImagePullSecretsList",
    },
    job_init_containers: {
      value: cdktf.listMapperHcl(cdktf.hashMapperHcl(cdktf.stringToHclTerraform), false)(struct!.jobInitContainers),
      isBlock: false,
      type: "list",
      storageClassType: "stringMapList",
    },
    job_resources: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecJobResourcesToHclTerraform(struct!.jobResources),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecJobResources",
    },
    job_ttl_seconds_after_finished: {
      value: cdktf.numberToHclTerraform(struct!.jobTtlSecondsAfterFinished),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    log: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecLogToHclTerraform(struct!.log),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecLog",
    },
    m_tls: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMTlsToHclTerraform(struct!.mTls),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMTls",
    },
    metrics: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsToHclTerraform(struct!.metrics),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetrics",
    },
    num_history_shards: {
      value: cdktf.numberToHclTerraform(struct!.numHistoryShards),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    persistence: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceToHclTerraform(struct!.persistence),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistence",
    },
    services: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesToHclTerraform(struct!.services),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServices",
    },
    ui: {
      value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiToHclTerraform(struct!.ui),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUi",
    },
    version: {
      value: cdktf.stringToHclTerraform(struct!.version),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8STemporalIoTemporalClusterV1Beta1ManifestSpec | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._admintools?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.admintools = this._admintools?.internalValue;
    }
    if (this._archival?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.archival = this._archival?.internalValue;
    }
    if (this._authorization?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authorization = this._authorization?.internalValue;
    }
    if (this._dynamicConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dynamicConfig = this._dynamicConfig?.internalValue;
    }
    if (this._image !== undefined) {
      hasAnyValues = true;
      internalValueResult.image = this._image;
    }
    if (this._imagePullSecrets?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.imagePullSecrets = this._imagePullSecrets?.internalValue;
    }
    if (this._jobInitContainers !== undefined) {
      hasAnyValues = true;
      internalValueResult.jobInitContainers = this._jobInitContainers;
    }
    if (this._jobResources?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.jobResources = this._jobResources?.internalValue;
    }
    if (this._jobTtlSecondsAfterFinished !== undefined) {
      hasAnyValues = true;
      internalValueResult.jobTtlSecondsAfterFinished = this._jobTtlSecondsAfterFinished;
    }
    if (this._log?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.log = this._log?.internalValue;
    }
    if (this._mTls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.mTls = this._mTls?.internalValue;
    }
    if (this._metrics?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metrics = this._metrics?.internalValue;
    }
    if (this._numHistoryShards !== undefined) {
      hasAnyValues = true;
      internalValueResult.numHistoryShards = this._numHistoryShards;
    }
    if (this._persistence?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.persistence = this._persistence?.internalValue;
    }
    if (this._services?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.services = this._services?.internalValue;
    }
    if (this._ui?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ui = this._ui?.internalValue;
    }
    if (this._version !== undefined) {
      hasAnyValues = true;
      internalValueResult.version = this._version;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpec | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._admintools.internalValue = undefined;
      this._archival.internalValue = undefined;
      this._authorization.internalValue = undefined;
      this._dynamicConfig.internalValue = undefined;
      this._image = undefined;
      this._imagePullSecrets.internalValue = undefined;
      this._jobInitContainers = undefined;
      this._jobResources.internalValue = undefined;
      this._jobTtlSecondsAfterFinished = undefined;
      this._log.internalValue = undefined;
      this._mTls.internalValue = undefined;
      this._metrics.internalValue = undefined;
      this._numHistoryShards = undefined;
      this._persistence.internalValue = undefined;
      this._services.internalValue = undefined;
      this._ui.internalValue = undefined;
      this._version = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._admintools.internalValue = value.admintools;
      this._archival.internalValue = value.archival;
      this._authorization.internalValue = value.authorization;
      this._dynamicConfig.internalValue = value.dynamicConfig;
      this._image = value.image;
      this._imagePullSecrets.internalValue = value.imagePullSecrets;
      this._jobInitContainers = value.jobInitContainers;
      this._jobResources.internalValue = value.jobResources;
      this._jobTtlSecondsAfterFinished = value.jobTtlSecondsAfterFinished;
      this._log.internalValue = value.log;
      this._mTls.internalValue = value.mTls;
      this._metrics.internalValue = value.metrics;
      this._numHistoryShards = value.numHistoryShards;
      this._persistence.internalValue = value.persistence;
      this._services.internalValue = value.services;
      this._ui.internalValue = value.ui;
      this._version = value.version;
    }
  }

  // admintools - computed: false, optional: true, required: false
  private _admintools = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintoolsOutputReference(this, "admintools");
  public get admintools() {
    return this._admintools;
  }
  public putAdmintools(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAdmintools) {
    this._admintools.internalValue = value;
  }
  public resetAdmintools() {
    this._admintools.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get admintoolsInput() {
    return this._admintools.internalValue;
  }

  // archival - computed: false, optional: true, required: false
  private _archival = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchivalOutputReference(this, "archival");
  public get archival() {
    return this._archival;
  }
  public putArchival(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecArchival) {
    this._archival.internalValue = value;
  }
  public resetArchival() {
    this._archival.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get archivalInput() {
    return this._archival.internalValue;
  }

  // authorization - computed: false, optional: true, required: false
  private _authorization = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAuthorizationOutputReference(this, "authorization");
  public get authorization() {
    return this._authorization;
  }
  public putAuthorization(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecAuthorization) {
    this._authorization.internalValue = value;
  }
  public resetAuthorization() {
    this._authorization.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authorizationInput() {
    return this._authorization.internalValue;
  }

  // dynamic_config - computed: false, optional: true, required: false
  private _dynamicConfig = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecDynamicConfigOutputReference(this, "dynamic_config");
  public get dynamicConfig() {
    return this._dynamicConfig;
  }
  public putDynamicConfig(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecDynamicConfig) {
    this._dynamicConfig.internalValue = value;
  }
  public resetDynamicConfig() {
    this._dynamicConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dynamicConfigInput() {
    return this._dynamicConfig.internalValue;
  }

  // image - computed: false, optional: true, required: false
  private _image?: string; 
  public get image() {
    return this.getStringAttribute('image');
  }
  public set image(value: string) {
    this._image = value;
  }
  public resetImage() {
    this._image = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageInput() {
    return this._image;
  }

  // image_pull_secrets - computed: false, optional: true, required: false
  private _imagePullSecrets = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecImagePullSecretsList(this, "image_pull_secrets", false);
  public get imagePullSecrets() {
    return this._imagePullSecrets;
  }
  public putImagePullSecrets(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecImagePullSecrets[] | cdktf.IResolvable) {
    this._imagePullSecrets.internalValue = value;
  }
  public resetImagePullSecrets() {
    this._imagePullSecrets.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imagePullSecretsInput() {
    return this._imagePullSecrets.internalValue;
  }

  // job_init_containers - computed: false, optional: true, required: false
  private _jobInitContainers?: { [key: string]: string }[] | cdktf.IResolvable; 
  public get jobInitContainers() {
    return this.interpolationForAttribute('job_init_containers');
  }
  public set jobInitContainers(value: { [key: string]: string }[] | cdktf.IResolvable) {
    this._jobInitContainers = value;
  }
  public resetJobInitContainers() {
    this._jobInitContainers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jobInitContainersInput() {
    return this._jobInitContainers;
  }

  // job_resources - computed: false, optional: true, required: false
  private _jobResources = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecJobResourcesOutputReference(this, "job_resources");
  public get jobResources() {
    return this._jobResources;
  }
  public putJobResources(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecJobResources) {
    this._jobResources.internalValue = value;
  }
  public resetJobResources() {
    this._jobResources.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jobResourcesInput() {
    return this._jobResources.internalValue;
  }

  // job_ttl_seconds_after_finished - computed: false, optional: true, required: false
  private _jobTtlSecondsAfterFinished?: number; 
  public get jobTtlSecondsAfterFinished() {
    return this.getNumberAttribute('job_ttl_seconds_after_finished');
  }
  public set jobTtlSecondsAfterFinished(value: number) {
    this._jobTtlSecondsAfterFinished = value;
  }
  public resetJobTtlSecondsAfterFinished() {
    this._jobTtlSecondsAfterFinished = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jobTtlSecondsAfterFinishedInput() {
    return this._jobTtlSecondsAfterFinished;
  }

  // log - computed: false, optional: true, required: false
  private _log = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecLogOutputReference(this, "log");
  public get log() {
    return this._log;
  }
  public putLog(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecLog) {
    this._log.internalValue = value;
  }
  public resetLog() {
    this._log.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logInput() {
    return this._log.internalValue;
  }

  // m_tls - computed: false, optional: true, required: false
  private _mTls = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMTlsOutputReference(this, "m_tls");
  public get mTls() {
    return this._mTls;
  }
  public putMTls(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMTls) {
    this._mTls.internalValue = value;
  }
  public resetMTls() {
    this._mTls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mTlsInput() {
    return this._mTls.internalValue;
  }

  // metrics - computed: false, optional: true, required: false
  private _metrics = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetricsOutputReference(this, "metrics");
  public get metrics() {
    return this._metrics;
  }
  public putMetrics(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecMetrics) {
    this._metrics.internalValue = value;
  }
  public resetMetrics() {
    this._metrics.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricsInput() {
    return this._metrics.internalValue;
  }

  // num_history_shards - computed: false, optional: false, required: true
  private _numHistoryShards?: number; 
  public get numHistoryShards() {
    return this.getNumberAttribute('num_history_shards');
  }
  public set numHistoryShards(value: number) {
    this._numHistoryShards = value;
  }
  // Temporarily expose input value. Use with caution.
  public get numHistoryShardsInput() {
    return this._numHistoryShards;
  }

  // persistence - computed: false, optional: false, required: true
  private _persistence = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistenceOutputReference(this, "persistence");
  public get persistence() {
    return this._persistence;
  }
  public putPersistence(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecPersistence) {
    this._persistence.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get persistenceInput() {
    return this._persistence.internalValue;
  }

  // services - computed: false, optional: true, required: false
  private _services = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServicesOutputReference(this, "services");
  public get services() {
    return this._services;
  }
  public putServices(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecServices) {
    this._services.internalValue = value;
  }
  public resetServices() {
    this._services.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servicesInput() {
    return this._services.internalValue;
  }

  // ui - computed: false, optional: true, required: false
  private _ui = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUiOutputReference(this, "ui");
  public get ui() {
    return this._ui;
  }
  public putUi(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecUi) {
    this._ui.internalValue = value;
  }
  public resetUi() {
    this._ui.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get uiInput() {
    return this._ui.internalValue;
  }

  // version - computed: false, optional: true, required: false
  private _version?: string; 
  public get version() {
    return this.getStringAttribute('version');
  }
  public set version(value: string) {
    this._version = value;
  }
  public resetVersion() {
    this._version = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get versionInput() {
    return this._version;
  }
}

/**
* Represents a {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest k8s_temporal_io_temporal_cluster_v1beta1_manifest}
*/
export class DataK8STemporalIoTemporalClusterV1Beta1Manifest extends cdktf.TerraformDataSource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType = "k8s_temporal_io_temporal_cluster_v1beta1_manifest";

  // ==============
  // STATIC Methods
  // ==============
  /**
  * Generates CDKTF code for importing a DataK8STemporalIoTemporalClusterV1Beta1Manifest resource upon running "cdktf plan <stack-name>"
  * @param scope The scope in which to define this construct
  * @param importToId The construct id used in the generated config for the DataK8STemporalIoTemporalClusterV1Beta1Manifest to import
  * @param importFromId The id of the existing DataK8STemporalIoTemporalClusterV1Beta1Manifest that should be imported. Refer to the {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest#import import section} in the documentation of this resource for the id to use
  * @param provider? Optional instance of the provider where the DataK8STemporalIoTemporalClusterV1Beta1Manifest to import is found
  */
  public static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider) {
        return new cdktf.ImportableResource(scope, importToId, { terraformResourceType: "k8s_temporal_io_temporal_cluster_v1beta1_manifest", importId: importFromId, provider });
      }

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/temporal_io_temporal_cluster_v1beta1_manifest k8s_temporal_io_temporal_cluster_v1beta1_manifest} Data Source
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options DataK8STemporalIoTemporalClusterV1Beta1ManifestConfig
  */
  public constructor(scope: Construct, id: string, config: DataK8STemporalIoTemporalClusterV1Beta1ManifestConfig) {
    super(scope, id, {
      terraformResourceType: 'k8s_temporal_io_temporal_cluster_v1beta1_manifest',
      terraformGeneratorMetadata: {
        providerName: 'k8s',
        providerVersion: '2025.10.20'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle,
      provisioners: config.provisioners,
      connection: config.connection,
      forEach: config.forEach
    });
    this._metadata.internalValue = config.metadata;
    this._spec.internalValue = config.spec;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // metadata - computed: false, optional: false, required: true
  private _metadata = new DataK8STemporalIoTemporalClusterV1Beta1ManifestMetadataOutputReference(this, "metadata");
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestMetadata) {
    this._metadata.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // spec - computed: false, optional: true, required: false
  private _spec = new DataK8STemporalIoTemporalClusterV1Beta1ManifestSpecOutputReference(this, "spec");
  public get spec() {
    return this._spec;
  }
  public putSpec(value: DataK8STemporalIoTemporalClusterV1Beta1ManifestSpec) {
    this._spec.internalValue = value;
  }
  public resetSpec() {
    this._spec.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get specInput() {
    return this._spec.internalValue;
  }

  // yaml - computed: true, optional: false, required: false
  public get yaml() {
    return this.getStringAttribute('yaml');
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      metadata: dataK8STemporalIoTemporalClusterV1Beta1ManifestMetadataToTerraform(this._metadata.internalValue),
      spec: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecToTerraform(this._spec.internalValue),
    };
  }

  protected synthesizeHclAttributes(): { [name: string]: any } {
    const attrs = {
      metadata: {
        value: dataK8STemporalIoTemporalClusterV1Beta1ManifestMetadataToHclTerraform(this._metadata.internalValue),
        isBlock: true,
        type: "struct",
        storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestMetadata",
      },
      spec: {
        value: dataK8STemporalIoTemporalClusterV1Beta1ManifestSpecToHclTerraform(this._spec.internalValue),
        isBlock: true,
        type: "struct",
        storageClassType: "DataK8STemporalIoTemporalClusterV1Beta1ManifestSpec",
      },
    };

    // remove undefined attributes
    return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined ))
  }
}
