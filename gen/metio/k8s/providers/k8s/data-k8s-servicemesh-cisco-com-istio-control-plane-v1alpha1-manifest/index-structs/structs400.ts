import * as cdktf from 'cdktf';
import { DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecK8SResourceOverlaysGroupVersionKind,
dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecK8SResourceOverlaysGroupVersionKindToTerraform,
dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecK8SResourceOverlaysGroupVersionKindToHclTerraform,
DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecK8SResourceOverlaysGroupVersionKindOutputReference,
DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecK8SResourceOverlaysObjectKey,
dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecK8SResourceOverlaysObjectKeyToTerraform,
dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecK8SResourceOverlaysObjectKeyToHclTerraform,
DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecK8SResourceOverlaysObjectKeyOutputReference } from './structs0'
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecK8SResourceOverlaysPatches {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#parse_value DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#parse_value}
  */
  readonly parseValue?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#path DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#path}
  */
  readonly path?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#type DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#type}
  */
  readonly type?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#value DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecK8SResourceOverlaysPatchesToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecK8SResourceOverlaysPatches | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    parse_value: cdktf.booleanToTerraform(struct!.parseValue),
    path: cdktf.stringToTerraform(struct!.path),
    type: cdktf.stringToTerraform(struct!.type),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecK8SResourceOverlaysPatchesToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecK8SResourceOverlaysPatches | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    parse_value: {
      value: cdktf.booleanToHclTerraform(struct!.parseValue),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecK8SResourceOverlaysPatchesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecK8SResourceOverlaysPatches | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._parseValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.parseValue = this._parseValue;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecK8SResourceOverlaysPatches | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._parseValue = undefined;
      this._path = undefined;
      this._type = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._parseValue = value.parseValue;
      this._path = value.path;
      this._type = value.type;
      this._value = value.value;
    }
  }

  // parse_value - computed: false, optional: true, required: false
  private _parseValue?: boolean | cdktf.IResolvable; 
  public get parseValue() {
    return this.getBooleanAttribute('parse_value');
  }
  public set parseValue(value: boolean | cdktf.IResolvable) {
    this._parseValue = value;
  }
  public resetParseValue() {
    this._parseValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parseValueInput() {
    return this._parseValue;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecK8SResourceOverlaysPatchesList extends cdktf.ComplexList {
  public internalValue? : DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecK8SResourceOverlaysPatches[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecK8SResourceOverlaysPatchesOutputReference {
    return new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecK8SResourceOverlaysPatchesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecK8SResourceOverlays {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#group_version_kind DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#group_version_kind}
  */
  readonly groupVersionKind?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecK8SResourceOverlaysGroupVersionKind;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#object_key DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#object_key}
  */
  readonly objectKey?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecK8SResourceOverlaysObjectKey;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#patches DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#patches}
  */
  readonly patches?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecK8SResourceOverlaysPatches[] | cdktf.IResolvable;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecK8SResourceOverlaysToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecK8SResourceOverlays | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    group_version_kind: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecK8SResourceOverlaysGroupVersionKindToTerraform(struct!.groupVersionKind),
    object_key: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecK8SResourceOverlaysObjectKeyToTerraform(struct!.objectKey),
    patches: cdktf.listMapper(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecK8SResourceOverlaysPatchesToTerraform, false)(struct!.patches),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecK8SResourceOverlaysToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecK8SResourceOverlays | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    group_version_kind: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecK8SResourceOverlaysGroupVersionKindToHclTerraform(struct!.groupVersionKind),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecK8SResourceOverlaysGroupVersionKind",
    },
    object_key: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecK8SResourceOverlaysObjectKeyToHclTerraform(struct!.objectKey),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecK8SResourceOverlaysObjectKey",
    },
    patches: {
      value: cdktf.listMapperHcl(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecK8SResourceOverlaysPatchesToHclTerraform, false)(struct!.patches),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecK8SResourceOverlaysPatchesList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecK8SResourceOverlaysOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecK8SResourceOverlays | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._groupVersionKind?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupVersionKind = this._groupVersionKind?.internalValue;
    }
    if (this._objectKey?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.objectKey = this._objectKey?.internalValue;
    }
    if (this._patches?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.patches = this._patches?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecK8SResourceOverlays | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._groupVersionKind.internalValue = undefined;
      this._objectKey.internalValue = undefined;
      this._patches.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._groupVersionKind.internalValue = value.groupVersionKind;
      this._objectKey.internalValue = value.objectKey;
      this._patches.internalValue = value.patches;
    }
  }

  // group_version_kind - computed: false, optional: true, required: false
  private _groupVersionKind = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecK8SResourceOverlaysGroupVersionKindOutputReference(this, "group_version_kind");
  public get groupVersionKind() {
    return this._groupVersionKind;
  }
  public putGroupVersionKind(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecK8SResourceOverlaysGroupVersionKind) {
    this._groupVersionKind.internalValue = value;
  }
  public resetGroupVersionKind() {
    this._groupVersionKind.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupVersionKindInput() {
    return this._groupVersionKind.internalValue;
  }

  // object_key - computed: false, optional: true, required: false
  private _objectKey = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecK8SResourceOverlaysObjectKeyOutputReference(this, "object_key");
  public get objectKey() {
    return this._objectKey;
  }
  public putObjectKey(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecK8SResourceOverlaysObjectKey) {
    this._objectKey.internalValue = value;
  }
  public resetObjectKey() {
    this._objectKey.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get objectKeyInput() {
    return this._objectKey.internalValue;
  }

  // patches - computed: false, optional: true, required: false
  private _patches = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecK8SResourceOverlaysPatchesList(this, "patches", false);
  public get patches() {
    return this._patches;
  }
  public putPatches(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecK8SResourceOverlaysPatches[] | cdktf.IResolvable) {
    this._patches.internalValue = value;
  }
  public resetPatches() {
    this._patches.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get patchesInput() {
    return this._patches.internalValue;
  }
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecK8SResourceOverlaysList extends cdktf.ComplexList {
  public internalValue? : DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecK8SResourceOverlays[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecK8SResourceOverlaysOutputReference {
    return new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecK8SResourceOverlaysOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecLogging {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#level DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#level}
  */
  readonly level?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecLoggingToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecLogging | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    level: cdktf.stringToTerraform(struct!.level),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecLoggingToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecLogging | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    level: {
      value: cdktf.stringToHclTerraform(struct!.level),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecLoggingOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecLogging | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._level !== undefined) {
      hasAnyValues = true;
      internalValueResult.level = this._level;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecLogging | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._level = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._level = value.level;
    }
  }

  // level - computed: false, optional: true, required: false
  private _level?: string; 
  public get level() {
    return this.getStringAttribute('level');
  }
  public set level(value: string) {
    this._level = value;
  }
  public resetLevel() {
    this._level = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get levelInput() {
    return this._level;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCaTlsSettings {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#ca_certificates DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#ca_certificates}
  */
  readonly caCertificates?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#client_certificate DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#client_certificate}
  */
  readonly clientCertificate?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#credential_name DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#credential_name}
  */
  readonly credentialName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#insecure_skip_verify DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#insecure_skip_verify}
  */
  readonly insecureSkipVerify?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#mode DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#mode}
  */
  readonly mode: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#private_key DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#private_key}
  */
  readonly privateKey?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#sni DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#sni}
  */
  readonly sni?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#subject_alt_names DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#subject_alt_names}
  */
  readonly subjectAltNames?: string[];
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCaTlsSettingsToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCaTlsSettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_certificates: cdktf.stringToTerraform(struct!.caCertificates),
    client_certificate: cdktf.stringToTerraform(struct!.clientCertificate),
    credential_name: cdktf.stringToTerraform(struct!.credentialName),
    insecure_skip_verify: cdktf.booleanToTerraform(struct!.insecureSkipVerify),
    mode: cdktf.stringToTerraform(struct!.mode),
    private_key: cdktf.stringToTerraform(struct!.privateKey),
    sni: cdktf.stringToTerraform(struct!.sni),
    subject_alt_names: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.subjectAltNames),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCaTlsSettingsToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCaTlsSettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_certificates: {
      value: cdktf.stringToHclTerraform(struct!.caCertificates),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_certificate: {
      value: cdktf.stringToHclTerraform(struct!.clientCertificate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    credential_name: {
      value: cdktf.stringToHclTerraform(struct!.credentialName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    insecure_skip_verify: {
      value: cdktf.booleanToHclTerraform(struct!.insecureSkipVerify),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    private_key: {
      value: cdktf.stringToHclTerraform(struct!.privateKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sni: {
      value: cdktf.stringToHclTerraform(struct!.sni),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subject_alt_names: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.subjectAltNames),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCaTlsSettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCaTlsSettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caCertificates !== undefined) {
      hasAnyValues = true;
      internalValueResult.caCertificates = this._caCertificates;
    }
    if (this._clientCertificate !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientCertificate = this._clientCertificate;
    }
    if (this._credentialName !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialName = this._credentialName;
    }
    if (this._insecureSkipVerify !== undefined) {
      hasAnyValues = true;
      internalValueResult.insecureSkipVerify = this._insecureSkipVerify;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._privateKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.privateKey = this._privateKey;
    }
    if (this._sni !== undefined) {
      hasAnyValues = true;
      internalValueResult.sni = this._sni;
    }
    if (this._subjectAltNames !== undefined) {
      hasAnyValues = true;
      internalValueResult.subjectAltNames = this._subjectAltNames;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCaTlsSettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caCertificates = undefined;
      this._clientCertificate = undefined;
      this._credentialName = undefined;
      this._insecureSkipVerify = undefined;
      this._mode = undefined;
      this._privateKey = undefined;
      this._sni = undefined;
      this._subjectAltNames = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caCertificates = value.caCertificates;
      this._clientCertificate = value.clientCertificate;
      this._credentialName = value.credentialName;
      this._insecureSkipVerify = value.insecureSkipVerify;
      this._mode = value.mode;
      this._privateKey = value.privateKey;
      this._sni = value.sni;
      this._subjectAltNames = value.subjectAltNames;
    }
  }

  // ca_certificates - computed: false, optional: true, required: false
  private _caCertificates?: string; 
  public get caCertificates() {
    return this.getStringAttribute('ca_certificates');
  }
  public set caCertificates(value: string) {
    this._caCertificates = value;
  }
  public resetCaCertificates() {
    this._caCertificates = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caCertificatesInput() {
    return this._caCertificates;
  }

  // client_certificate - computed: false, optional: true, required: false
  private _clientCertificate?: string; 
  public get clientCertificate() {
    return this.getStringAttribute('client_certificate');
  }
  public set clientCertificate(value: string) {
    this._clientCertificate = value;
  }
  public resetClientCertificate() {
    this._clientCertificate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientCertificateInput() {
    return this._clientCertificate;
  }

  // credential_name - computed: false, optional: true, required: false
  private _credentialName?: string; 
  public get credentialName() {
    return this.getStringAttribute('credential_name');
  }
  public set credentialName(value: string) {
    this._credentialName = value;
  }
  public resetCredentialName() {
    this._credentialName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialNameInput() {
    return this._credentialName;
  }

  // insecure_skip_verify - computed: false, optional: true, required: false
  private _insecureSkipVerify?: boolean | cdktf.IResolvable; 
  public get insecureSkipVerify() {
    return this.getBooleanAttribute('insecure_skip_verify');
  }
  public set insecureSkipVerify(value: boolean | cdktf.IResolvable) {
    this._insecureSkipVerify = value;
  }
  public resetInsecureSkipVerify() {
    this._insecureSkipVerify = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get insecureSkipVerifyInput() {
    return this._insecureSkipVerify;
  }

  // mode - computed: false, optional: false, required: true
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // private_key - computed: false, optional: true, required: false
  private _privateKey?: string; 
  public get privateKey() {
    return this.getStringAttribute('private_key');
  }
  public set privateKey(value: string) {
    this._privateKey = value;
  }
  public resetPrivateKey() {
    this._privateKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privateKeyInput() {
    return this._privateKey;
  }

  // sni - computed: false, optional: true, required: false
  private _sni?: string; 
  public get sni() {
    return this.getStringAttribute('sni');
  }
  public set sni(value: string) {
    this._sni = value;
  }
  public resetSni() {
    this._sni = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sniInput() {
    return this._sni;
  }

  // subject_alt_names - computed: false, optional: true, required: false
  private _subjectAltNames?: string[]; 
  public get subjectAltNames() {
    return this.getListAttribute('subject_alt_names');
  }
  public set subjectAltNames(value: string[]) {
    this._subjectAltNames = value;
  }
  public resetSubjectAltNames() {
    this._subjectAltNames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subjectAltNamesInput() {
    return this._subjectAltNames;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCa {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#address DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#address}
  */
  readonly address?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#istiod_side DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#istiod_side}
  */
  readonly istiodSide?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#request_timeout DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#request_timeout}
  */
  readonly requestTimeout?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#tls_settings DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#tls_settings}
  */
  readonly tlsSettings?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCaTlsSettings;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCaToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCa | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: cdktf.stringToTerraform(struct!.address),
    istiod_side: cdktf.booleanToTerraform(struct!.istiodSide),
    request_timeout: cdktf.stringToTerraform(struct!.requestTimeout),
    tls_settings: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCaTlsSettingsToTerraform(struct!.tlsSettings),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCaToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCa | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: cdktf.stringToHclTerraform(struct!.address),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    istiod_side: {
      value: cdktf.booleanToHclTerraform(struct!.istiodSide),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    request_timeout: {
      value: cdktf.stringToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls_settings: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCaTlsSettingsToHclTerraform(struct!.tlsSettings),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCaTlsSettings",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCaOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCa | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address;
    }
    if (this._istiodSide !== undefined) {
      hasAnyValues = true;
      internalValueResult.istiodSide = this._istiodSide;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    if (this._tlsSettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsSettings = this._tlsSettings?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCa | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address = undefined;
      this._istiodSide = undefined;
      this._requestTimeout = undefined;
      this._tlsSettings.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address = value.address;
      this._istiodSide = value.istiodSide;
      this._requestTimeout = value.requestTimeout;
      this._tlsSettings.internalValue = value.tlsSettings;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address?: string; 
  public get address() {
    return this.getStringAttribute('address');
  }
  public set address(value: string) {
    this._address = value;
  }
  public resetAddress() {
    this._address = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address;
  }

  // istiod_side - computed: false, optional: true, required: false
  private _istiodSide?: boolean | cdktf.IResolvable; 
  public get istiodSide() {
    return this.getBooleanAttribute('istiod_side');
  }
  public set istiodSide(value: boolean | cdktf.IResolvable) {
    this._istiodSide = value;
  }
  public resetIstiodSide() {
    this._istiodSide = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get istiodSideInput() {
    return this._istiodSide;
  }

  // request_timeout - computed: false, optional: true, required: false
  private _requestTimeout?: string; 
  public get requestTimeout() {
    return this.getStringAttribute('request_timeout');
  }
  public set requestTimeout(value: string) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }

  // tls_settings - computed: false, optional: true, required: false
  private _tlsSettings = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCaTlsSettingsOutputReference(this, "tls_settings");
  public get tlsSettings() {
    return this._tlsSettings;
  }
  public putTlsSettings(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCaTlsSettings) {
    this._tlsSettings.internalValue = value;
  }
  public resetTlsSettings() {
    this._tlsSettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsSettingsInput() {
    return this._tlsSettings.internalValue;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCaCertificates {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#cert_signers DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#cert_signers}
  */
  readonly certSigners?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#pem DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#pem}
  */
  readonly pem?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#spiffe_bundle_url DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#spiffe_bundle_url}
  */
  readonly spiffeBundleUrl?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#trust_domains DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#trust_domains}
  */
  readonly trustDomains?: string[];
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCaCertificatesToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCaCertificates | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cert_signers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.certSigners),
    pem: cdktf.stringToTerraform(struct!.pem),
    spiffe_bundle_url: cdktf.stringToTerraform(struct!.spiffeBundleUrl),
    trust_domains: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.trustDomains),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCaCertificatesToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCaCertificates | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cert_signers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.certSigners),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    pem: {
      value: cdktf.stringToHclTerraform(struct!.pem),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    spiffe_bundle_url: {
      value: cdktf.stringToHclTerraform(struct!.spiffeBundleUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    trust_domains: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.trustDomains),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCaCertificatesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCaCertificates | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._certSigners !== undefined) {
      hasAnyValues = true;
      internalValueResult.certSigners = this._certSigners;
    }
    if (this._pem !== undefined) {
      hasAnyValues = true;
      internalValueResult.pem = this._pem;
    }
    if (this._spiffeBundleUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.spiffeBundleUrl = this._spiffeBundleUrl;
    }
    if (this._trustDomains !== undefined) {
      hasAnyValues = true;
      internalValueResult.trustDomains = this._trustDomains;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCaCertificates | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._certSigners = undefined;
      this._pem = undefined;
      this._spiffeBundleUrl = undefined;
      this._trustDomains = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._certSigners = value.certSigners;
      this._pem = value.pem;
      this._spiffeBundleUrl = value.spiffeBundleUrl;
      this._trustDomains = value.trustDomains;
    }
  }

  // cert_signers - computed: false, optional: true, required: false
  private _certSigners?: string[]; 
  public get certSigners() {
    return this.getListAttribute('cert_signers');
  }
  public set certSigners(value: string[]) {
    this._certSigners = value;
  }
  public resetCertSigners() {
    this._certSigners = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certSignersInput() {
    return this._certSigners;
  }

  // pem - computed: false, optional: true, required: false
  private _pem?: string; 
  public get pem() {
    return this.getStringAttribute('pem');
  }
  public set pem(value: string) {
    this._pem = value;
  }
  public resetPem() {
    this._pem = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pemInput() {
    return this._pem;
  }

  // spiffe_bundle_url - computed: false, optional: true, required: false
  private _spiffeBundleUrl?: string; 
  public get spiffeBundleUrl() {
    return this.getStringAttribute('spiffe_bundle_url');
  }
  public set spiffeBundleUrl(value: string) {
    this._spiffeBundleUrl = value;
  }
  public resetSpiffeBundleUrl() {
    this._spiffeBundleUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get spiffeBundleUrlInput() {
    return this._spiffeBundleUrl;
  }

  // trust_domains - computed: false, optional: true, required: false
  private _trustDomains?: string[]; 
  public get trustDomains() {
    return this.getListAttribute('trust_domains');
  }
  public set trustDomains(value: string[]) {
    this._trustDomains = value;
  }
  public resetTrustDomains() {
    this._trustDomains = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get trustDomainsInput() {
    return this._trustDomains;
  }
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCaCertificatesList extends cdktf.ComplexList {
  public internalValue? : DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCaCertificates[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCaCertificatesOutputReference {
    return new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCaCertificatesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCertificates {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#dns_names DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#dns_names}
  */
  readonly dnsNames?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#secret_name DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#secret_name}
  */
  readonly secretName?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCertificatesToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCertificates | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dns_names: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.dnsNames),
    secret_name: cdktf.stringToTerraform(struct!.secretName),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCertificatesToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCertificates | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dns_names: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.dnsNames),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    secret_name: {
      value: cdktf.stringToHclTerraform(struct!.secretName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCertificatesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCertificates | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dnsNames !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsNames = this._dnsNames;
    }
    if (this._secretName !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretName = this._secretName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCertificates | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dnsNames = undefined;
      this._secretName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dnsNames = value.dnsNames;
      this._secretName = value.secretName;
    }
  }

  // dns_names - computed: false, optional: true, required: false
  private _dnsNames?: string[]; 
  public get dnsNames() {
    return this.getListAttribute('dns_names');
  }
  public set dnsNames(value: string[]) {
    this._dnsNames = value;
  }
  public resetDnsNames() {
    this._dnsNames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsNamesInput() {
    return this._dnsNames;
  }

  // secret_name - computed: false, optional: true, required: false
  private _secretName?: string; 
  public get secretName() {
    return this.getStringAttribute('secret_name');
  }
  public set secretName(value: string) {
    this._secretName = value;
  }
  public resetSecretName() {
    this._secretName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretNameInput() {
    return this._secretName;
  }
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCertificatesList extends cdktf.ComplexList {
  public internalValue? : DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCertificates[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCertificatesOutputReference {
    return new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCertificatesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigConfigSourcesTlsSettings {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#ca_certificates DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#ca_certificates}
  */
  readonly caCertificates?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#client_certificate DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#client_certificate}
  */
  readonly clientCertificate?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#credential_name DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#credential_name}
  */
  readonly credentialName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#insecure_skip_verify DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#insecure_skip_verify}
  */
  readonly insecureSkipVerify?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#mode DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#mode}
  */
  readonly mode: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#private_key DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#private_key}
  */
  readonly privateKey?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#sni DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#sni}
  */
  readonly sni?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#subject_alt_names DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#subject_alt_names}
  */
  readonly subjectAltNames?: string[];
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigConfigSourcesTlsSettingsToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigConfigSourcesTlsSettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_certificates: cdktf.stringToTerraform(struct!.caCertificates),
    client_certificate: cdktf.stringToTerraform(struct!.clientCertificate),
    credential_name: cdktf.stringToTerraform(struct!.credentialName),
    insecure_skip_verify: cdktf.booleanToTerraform(struct!.insecureSkipVerify),
    mode: cdktf.stringToTerraform(struct!.mode),
    private_key: cdktf.stringToTerraform(struct!.privateKey),
    sni: cdktf.stringToTerraform(struct!.sni),
    subject_alt_names: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.subjectAltNames),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigConfigSourcesTlsSettingsToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigConfigSourcesTlsSettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_certificates: {
      value: cdktf.stringToHclTerraform(struct!.caCertificates),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_certificate: {
      value: cdktf.stringToHclTerraform(struct!.clientCertificate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    credential_name: {
      value: cdktf.stringToHclTerraform(struct!.credentialName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    insecure_skip_verify: {
      value: cdktf.booleanToHclTerraform(struct!.insecureSkipVerify),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    private_key: {
      value: cdktf.stringToHclTerraform(struct!.privateKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sni: {
      value: cdktf.stringToHclTerraform(struct!.sni),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subject_alt_names: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.subjectAltNames),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigConfigSourcesTlsSettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigConfigSourcesTlsSettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caCertificates !== undefined) {
      hasAnyValues = true;
      internalValueResult.caCertificates = this._caCertificates;
    }
    if (this._clientCertificate !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientCertificate = this._clientCertificate;
    }
    if (this._credentialName !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialName = this._credentialName;
    }
    if (this._insecureSkipVerify !== undefined) {
      hasAnyValues = true;
      internalValueResult.insecureSkipVerify = this._insecureSkipVerify;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._privateKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.privateKey = this._privateKey;
    }
    if (this._sni !== undefined) {
      hasAnyValues = true;
      internalValueResult.sni = this._sni;
    }
    if (this._subjectAltNames !== undefined) {
      hasAnyValues = true;
      internalValueResult.subjectAltNames = this._subjectAltNames;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigConfigSourcesTlsSettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caCertificates = undefined;
      this._clientCertificate = undefined;
      this._credentialName = undefined;
      this._insecureSkipVerify = undefined;
      this._mode = undefined;
      this._privateKey = undefined;
      this._sni = undefined;
      this._subjectAltNames = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caCertificates = value.caCertificates;
      this._clientCertificate = value.clientCertificate;
      this._credentialName = value.credentialName;
      this._insecureSkipVerify = value.insecureSkipVerify;
      this._mode = value.mode;
      this._privateKey = value.privateKey;
      this._sni = value.sni;
      this._subjectAltNames = value.subjectAltNames;
    }
  }

  // ca_certificates - computed: false, optional: true, required: false
  private _caCertificates?: string; 
  public get caCertificates() {
    return this.getStringAttribute('ca_certificates');
  }
  public set caCertificates(value: string) {
    this._caCertificates = value;
  }
  public resetCaCertificates() {
    this._caCertificates = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caCertificatesInput() {
    return this._caCertificates;
  }

  // client_certificate - computed: false, optional: true, required: false
  private _clientCertificate?: string; 
  public get clientCertificate() {
    return this.getStringAttribute('client_certificate');
  }
  public set clientCertificate(value: string) {
    this._clientCertificate = value;
  }
  public resetClientCertificate() {
    this._clientCertificate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientCertificateInput() {
    return this._clientCertificate;
  }

  // credential_name - computed: false, optional: true, required: false
  private _credentialName?: string; 
  public get credentialName() {
    return this.getStringAttribute('credential_name');
  }
  public set credentialName(value: string) {
    this._credentialName = value;
  }
  public resetCredentialName() {
    this._credentialName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialNameInput() {
    return this._credentialName;
  }

  // insecure_skip_verify - computed: false, optional: true, required: false
  private _insecureSkipVerify?: boolean | cdktf.IResolvable; 
  public get insecureSkipVerify() {
    return this.getBooleanAttribute('insecure_skip_verify');
  }
  public set insecureSkipVerify(value: boolean | cdktf.IResolvable) {
    this._insecureSkipVerify = value;
  }
  public resetInsecureSkipVerify() {
    this._insecureSkipVerify = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get insecureSkipVerifyInput() {
    return this._insecureSkipVerify;
  }

  // mode - computed: false, optional: false, required: true
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // private_key - computed: false, optional: true, required: false
  private _privateKey?: string; 
  public get privateKey() {
    return this.getStringAttribute('private_key');
  }
  public set privateKey(value: string) {
    this._privateKey = value;
  }
  public resetPrivateKey() {
    this._privateKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privateKeyInput() {
    return this._privateKey;
  }

  // sni - computed: false, optional: true, required: false
  private _sni?: string; 
  public get sni() {
    return this.getStringAttribute('sni');
  }
  public set sni(value: string) {
    this._sni = value;
  }
  public resetSni() {
    this._sni = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sniInput() {
    return this._sni;
  }

  // subject_alt_names - computed: false, optional: true, required: false
  private _subjectAltNames?: string[]; 
  public get subjectAltNames() {
    return this.getListAttribute('subject_alt_names');
  }
  public set subjectAltNames(value: string[]) {
    this._subjectAltNames = value;
  }
  public resetSubjectAltNames() {
    this._subjectAltNames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subjectAltNamesInput() {
    return this._subjectAltNames;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigConfigSources {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#address DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#address}
  */
  readonly address?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#subscribed_resources DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#subscribed_resources}
  */
  readonly subscribedResources?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#tls_settings DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#tls_settings}
  */
  readonly tlsSettings?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigConfigSourcesTlsSettings;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigConfigSourcesToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigConfigSources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: cdktf.stringToTerraform(struct!.address),
    subscribed_resources: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.subscribedResources),
    tls_settings: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigConfigSourcesTlsSettingsToTerraform(struct!.tlsSettings),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigConfigSourcesToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigConfigSources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: cdktf.stringToHclTerraform(struct!.address),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subscribed_resources: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.subscribedResources),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tls_settings: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigConfigSourcesTlsSettingsToHclTerraform(struct!.tlsSettings),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigConfigSourcesTlsSettings",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigConfigSourcesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigConfigSources | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address;
    }
    if (this._subscribedResources !== undefined) {
      hasAnyValues = true;
      internalValueResult.subscribedResources = this._subscribedResources;
    }
    if (this._tlsSettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsSettings = this._tlsSettings?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigConfigSources | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address = undefined;
      this._subscribedResources = undefined;
      this._tlsSettings.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address = value.address;
      this._subscribedResources = value.subscribedResources;
      this._tlsSettings.internalValue = value.tlsSettings;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address?: string; 
  public get address() {
    return this.getStringAttribute('address');
  }
  public set address(value: string) {
    this._address = value;
  }
  public resetAddress() {
    this._address = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address;
  }

  // subscribed_resources - computed: false, optional: true, required: false
  private _subscribedResources?: string[]; 
  public get subscribedResources() {
    return this.getListAttribute('subscribed_resources');
  }
  public set subscribedResources(value: string[]) {
    this._subscribedResources = value;
  }
  public resetSubscribedResources() {
    this._subscribedResources = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subscribedResourcesInput() {
    return this._subscribedResources;
  }

  // tls_settings - computed: false, optional: true, required: false
  private _tlsSettings = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigConfigSourcesTlsSettingsOutputReference(this, "tls_settings");
  public get tlsSettings() {
    return this._tlsSettings;
  }
  public putTlsSettings(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigConfigSourcesTlsSettings) {
    this._tlsSettings.internalValue = value;
  }
  public resetTlsSettings() {
    this._tlsSettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsSettingsInput() {
    return this._tlsSettings.internalValue;
  }
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigConfigSourcesList extends cdktf.ComplexList {
  public internalValue? : DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigConfigSources[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigConfigSourcesOutputReference {
    return new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigConfigSourcesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyAccessLogServiceTcpKeepalive {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#interval DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#interval}
  */
  readonly interval?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#probes DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#probes}
  */
  readonly probes?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#time DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#time}
  */
  readonly time?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyAccessLogServiceTcpKeepaliveToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyAccessLogServiceTcpKeepalive | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    interval: cdktf.stringToTerraform(struct!.interval),
    probes: cdktf.numberToTerraform(struct!.probes),
    time: cdktf.stringToTerraform(struct!.time),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyAccessLogServiceTcpKeepaliveToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyAccessLogServiceTcpKeepalive | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    interval: {
      value: cdktf.stringToHclTerraform(struct!.interval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    probes: {
      value: cdktf.numberToHclTerraform(struct!.probes),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    time: {
      value: cdktf.stringToHclTerraform(struct!.time),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyAccessLogServiceTcpKeepaliveOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyAccessLogServiceTcpKeepalive | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._interval !== undefined) {
      hasAnyValues = true;
      internalValueResult.interval = this._interval;
    }
    if (this._probes !== undefined) {
      hasAnyValues = true;
      internalValueResult.probes = this._probes;
    }
    if (this._time !== undefined) {
      hasAnyValues = true;
      internalValueResult.time = this._time;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyAccessLogServiceTcpKeepalive | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._interval = undefined;
      this._probes = undefined;
      this._time = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._interval = value.interval;
      this._probes = value.probes;
      this._time = value.time;
    }
  }

  // interval - computed: false, optional: true, required: false
  private _interval?: string; 
  public get interval() {
    return this.getStringAttribute('interval');
  }
  public set interval(value: string) {
    this._interval = value;
  }
  public resetInterval() {
    this._interval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get intervalInput() {
    return this._interval;
  }

  // probes - computed: false, optional: true, required: false
  private _probes?: number; 
  public get probes() {
    return this.getNumberAttribute('probes');
  }
  public set probes(value: number) {
    this._probes = value;
  }
  public resetProbes() {
    this._probes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get probesInput() {
    return this._probes;
  }

  // time - computed: false, optional: true, required: false
  private _time?: string; 
  public get time() {
    return this.getStringAttribute('time');
  }
  public set time(value: string) {
    this._time = value;
  }
  public resetTime() {
    this._time = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeInput() {
    return this._time;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyAccessLogServiceTlsSettings {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#ca_certificates DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#ca_certificates}
  */
  readonly caCertificates?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#client_certificate DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#client_certificate}
  */
  readonly clientCertificate?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#credential_name DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#credential_name}
  */
  readonly credentialName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#insecure_skip_verify DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#insecure_skip_verify}
  */
  readonly insecureSkipVerify?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#mode DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#mode}
  */
  readonly mode: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#private_key DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#private_key}
  */
  readonly privateKey?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#sni DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#sni}
  */
  readonly sni?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#subject_alt_names DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#subject_alt_names}
  */
  readonly subjectAltNames?: string[];
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyAccessLogServiceTlsSettingsToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyAccessLogServiceTlsSettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_certificates: cdktf.stringToTerraform(struct!.caCertificates),
    client_certificate: cdktf.stringToTerraform(struct!.clientCertificate),
    credential_name: cdktf.stringToTerraform(struct!.credentialName),
    insecure_skip_verify: cdktf.booleanToTerraform(struct!.insecureSkipVerify),
    mode: cdktf.stringToTerraform(struct!.mode),
    private_key: cdktf.stringToTerraform(struct!.privateKey),
    sni: cdktf.stringToTerraform(struct!.sni),
    subject_alt_names: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.subjectAltNames),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyAccessLogServiceTlsSettingsToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyAccessLogServiceTlsSettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_certificates: {
      value: cdktf.stringToHclTerraform(struct!.caCertificates),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_certificate: {
      value: cdktf.stringToHclTerraform(struct!.clientCertificate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    credential_name: {
      value: cdktf.stringToHclTerraform(struct!.credentialName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    insecure_skip_verify: {
      value: cdktf.booleanToHclTerraform(struct!.insecureSkipVerify),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    private_key: {
      value: cdktf.stringToHclTerraform(struct!.privateKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sni: {
      value: cdktf.stringToHclTerraform(struct!.sni),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subject_alt_names: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.subjectAltNames),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyAccessLogServiceTlsSettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyAccessLogServiceTlsSettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caCertificates !== undefined) {
      hasAnyValues = true;
      internalValueResult.caCertificates = this._caCertificates;
    }
    if (this._clientCertificate !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientCertificate = this._clientCertificate;
    }
    if (this._credentialName !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialName = this._credentialName;
    }
    if (this._insecureSkipVerify !== undefined) {
      hasAnyValues = true;
      internalValueResult.insecureSkipVerify = this._insecureSkipVerify;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._privateKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.privateKey = this._privateKey;
    }
    if (this._sni !== undefined) {
      hasAnyValues = true;
      internalValueResult.sni = this._sni;
    }
    if (this._subjectAltNames !== undefined) {
      hasAnyValues = true;
      internalValueResult.subjectAltNames = this._subjectAltNames;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyAccessLogServiceTlsSettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caCertificates = undefined;
      this._clientCertificate = undefined;
      this._credentialName = undefined;
      this._insecureSkipVerify = undefined;
      this._mode = undefined;
      this._privateKey = undefined;
      this._sni = undefined;
      this._subjectAltNames = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caCertificates = value.caCertificates;
      this._clientCertificate = value.clientCertificate;
      this._credentialName = value.credentialName;
      this._insecureSkipVerify = value.insecureSkipVerify;
      this._mode = value.mode;
      this._privateKey = value.privateKey;
      this._sni = value.sni;
      this._subjectAltNames = value.subjectAltNames;
    }
  }

  // ca_certificates - computed: false, optional: true, required: false
  private _caCertificates?: string; 
  public get caCertificates() {
    return this.getStringAttribute('ca_certificates');
  }
  public set caCertificates(value: string) {
    this._caCertificates = value;
  }
  public resetCaCertificates() {
    this._caCertificates = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caCertificatesInput() {
    return this._caCertificates;
  }

  // client_certificate - computed: false, optional: true, required: false
  private _clientCertificate?: string; 
  public get clientCertificate() {
    return this.getStringAttribute('client_certificate');
  }
  public set clientCertificate(value: string) {
    this._clientCertificate = value;
  }
  public resetClientCertificate() {
    this._clientCertificate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientCertificateInput() {
    return this._clientCertificate;
  }

  // credential_name - computed: false, optional: true, required: false
  private _credentialName?: string; 
  public get credentialName() {
    return this.getStringAttribute('credential_name');
  }
  public set credentialName(value: string) {
    this._credentialName = value;
  }
  public resetCredentialName() {
    this._credentialName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialNameInput() {
    return this._credentialName;
  }

  // insecure_skip_verify - computed: false, optional: true, required: false
  private _insecureSkipVerify?: boolean | cdktf.IResolvable; 
  public get insecureSkipVerify() {
    return this.getBooleanAttribute('insecure_skip_verify');
  }
  public set insecureSkipVerify(value: boolean | cdktf.IResolvable) {
    this._insecureSkipVerify = value;
  }
  public resetInsecureSkipVerify() {
    this._insecureSkipVerify = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get insecureSkipVerifyInput() {
    return this._insecureSkipVerify;
  }

  // mode - computed: false, optional: false, required: true
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // private_key - computed: false, optional: true, required: false
  private _privateKey?: string; 
  public get privateKey() {
    return this.getStringAttribute('private_key');
  }
  public set privateKey(value: string) {
    this._privateKey = value;
  }
  public resetPrivateKey() {
    this._privateKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privateKeyInput() {
    return this._privateKey;
  }

  // sni - computed: false, optional: true, required: false
  private _sni?: string; 
  public get sni() {
    return this.getStringAttribute('sni');
  }
  public set sni(value: string) {
    this._sni = value;
  }
  public resetSni() {
    this._sni = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sniInput() {
    return this._sni;
  }

  // subject_alt_names - computed: false, optional: true, required: false
  private _subjectAltNames?: string[]; 
  public get subjectAltNames() {
    return this.getListAttribute('subject_alt_names');
  }
  public set subjectAltNames(value: string[]) {
    this._subjectAltNames = value;
  }
  public resetSubjectAltNames() {
    this._subjectAltNames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subjectAltNamesInput() {
    return this._subjectAltNames;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyAccessLogService {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#address DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#address}
  */
  readonly address?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#tcp_keepalive DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#tcp_keepalive}
  */
  readonly tcpKeepalive?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyAccessLogServiceTcpKeepalive;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#tls_settings DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#tls_settings}
  */
  readonly tlsSettings?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyAccessLogServiceTlsSettings;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyAccessLogServiceToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyAccessLogService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: cdktf.stringToTerraform(struct!.address),
    tcp_keepalive: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyAccessLogServiceTcpKeepaliveToTerraform(struct!.tcpKeepalive),
    tls_settings: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyAccessLogServiceTlsSettingsToTerraform(struct!.tlsSettings),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyAccessLogServiceToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyAccessLogService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: cdktf.stringToHclTerraform(struct!.address),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tcp_keepalive: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyAccessLogServiceTcpKeepaliveToHclTerraform(struct!.tcpKeepalive),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyAccessLogServiceTcpKeepalive",
    },
    tls_settings: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyAccessLogServiceTlsSettingsToHclTerraform(struct!.tlsSettings),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyAccessLogServiceTlsSettings",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyAccessLogServiceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyAccessLogService | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address;
    }
    if (this._tcpKeepalive?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tcpKeepalive = this._tcpKeepalive?.internalValue;
    }
    if (this._tlsSettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsSettings = this._tlsSettings?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyAccessLogService | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address = undefined;
      this._tcpKeepalive.internalValue = undefined;
      this._tlsSettings.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address = value.address;
      this._tcpKeepalive.internalValue = value.tcpKeepalive;
      this._tlsSettings.internalValue = value.tlsSettings;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address?: string; 
  public get address() {
    return this.getStringAttribute('address');
  }
  public set address(value: string) {
    this._address = value;
  }
  public resetAddress() {
    this._address = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address;
  }

  // tcp_keepalive - computed: false, optional: true, required: false
  private _tcpKeepalive = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyAccessLogServiceTcpKeepaliveOutputReference(this, "tcp_keepalive");
  public get tcpKeepalive() {
    return this._tcpKeepalive;
  }
  public putTcpKeepalive(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyAccessLogServiceTcpKeepalive) {
    this._tcpKeepalive.internalValue = value;
  }
  public resetTcpKeepalive() {
    this._tcpKeepalive.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tcpKeepaliveInput() {
    return this._tcpKeepalive.internalValue;
  }

  // tls_settings - computed: false, optional: true, required: false
  private _tlsSettings = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyAccessLogServiceTlsSettingsOutputReference(this, "tls_settings");
  public get tlsSettings() {
    return this._tlsSettings;
  }
  public putTlsSettings(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyAccessLogServiceTlsSettings) {
    this._tlsSettings.internalValue = value;
  }
  public resetTlsSettings() {
    this._tlsSettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsSettingsInput() {
    return this._tlsSettings.internalValue;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyMetricsServiceTcpKeepalive {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#interval DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#interval}
  */
  readonly interval?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#probes DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#probes}
  */
  readonly probes?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#time DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#time}
  */
  readonly time?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyMetricsServiceTcpKeepaliveToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyMetricsServiceTcpKeepalive | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    interval: cdktf.stringToTerraform(struct!.interval),
    probes: cdktf.numberToTerraform(struct!.probes),
    time: cdktf.stringToTerraform(struct!.time),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyMetricsServiceTcpKeepaliveToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyMetricsServiceTcpKeepalive | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    interval: {
      value: cdktf.stringToHclTerraform(struct!.interval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    probes: {
      value: cdktf.numberToHclTerraform(struct!.probes),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    time: {
      value: cdktf.stringToHclTerraform(struct!.time),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyMetricsServiceTcpKeepaliveOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyMetricsServiceTcpKeepalive | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._interval !== undefined) {
      hasAnyValues = true;
      internalValueResult.interval = this._interval;
    }
    if (this._probes !== undefined) {
      hasAnyValues = true;
      internalValueResult.probes = this._probes;
    }
    if (this._time !== undefined) {
      hasAnyValues = true;
      internalValueResult.time = this._time;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyMetricsServiceTcpKeepalive | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._interval = undefined;
      this._probes = undefined;
      this._time = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._interval = value.interval;
      this._probes = value.probes;
      this._time = value.time;
    }
  }

  // interval - computed: false, optional: true, required: false
  private _interval?: string; 
  public get interval() {
    return this.getStringAttribute('interval');
  }
  public set interval(value: string) {
    this._interval = value;
  }
  public resetInterval() {
    this._interval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get intervalInput() {
    return this._interval;
  }

  // probes - computed: false, optional: true, required: false
  private _probes?: number; 
  public get probes() {
    return this.getNumberAttribute('probes');
  }
  public set probes(value: number) {
    this._probes = value;
  }
  public resetProbes() {
    this._probes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get probesInput() {
    return this._probes;
  }

  // time - computed: false, optional: true, required: false
  private _time?: string; 
  public get time() {
    return this.getStringAttribute('time');
  }
  public set time(value: string) {
    this._time = value;
  }
  public resetTime() {
    this._time = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeInput() {
    return this._time;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyMetricsServiceTlsSettings {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#ca_certificates DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#ca_certificates}
  */
  readonly caCertificates?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#client_certificate DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#client_certificate}
  */
  readonly clientCertificate?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#credential_name DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#credential_name}
  */
  readonly credentialName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#insecure_skip_verify DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#insecure_skip_verify}
  */
  readonly insecureSkipVerify?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#mode DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#mode}
  */
  readonly mode: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#private_key DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#private_key}
  */
  readonly privateKey?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#sni DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#sni}
  */
  readonly sni?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#subject_alt_names DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#subject_alt_names}
  */
  readonly subjectAltNames?: string[];
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyMetricsServiceTlsSettingsToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyMetricsServiceTlsSettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_certificates: cdktf.stringToTerraform(struct!.caCertificates),
    client_certificate: cdktf.stringToTerraform(struct!.clientCertificate),
    credential_name: cdktf.stringToTerraform(struct!.credentialName),
    insecure_skip_verify: cdktf.booleanToTerraform(struct!.insecureSkipVerify),
    mode: cdktf.stringToTerraform(struct!.mode),
    private_key: cdktf.stringToTerraform(struct!.privateKey),
    sni: cdktf.stringToTerraform(struct!.sni),
    subject_alt_names: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.subjectAltNames),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyMetricsServiceTlsSettingsToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyMetricsServiceTlsSettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_certificates: {
      value: cdktf.stringToHclTerraform(struct!.caCertificates),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_certificate: {
      value: cdktf.stringToHclTerraform(struct!.clientCertificate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    credential_name: {
      value: cdktf.stringToHclTerraform(struct!.credentialName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    insecure_skip_verify: {
      value: cdktf.booleanToHclTerraform(struct!.insecureSkipVerify),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    private_key: {
      value: cdktf.stringToHclTerraform(struct!.privateKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sni: {
      value: cdktf.stringToHclTerraform(struct!.sni),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subject_alt_names: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.subjectAltNames),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyMetricsServiceTlsSettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyMetricsServiceTlsSettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caCertificates !== undefined) {
      hasAnyValues = true;
      internalValueResult.caCertificates = this._caCertificates;
    }
    if (this._clientCertificate !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientCertificate = this._clientCertificate;
    }
    if (this._credentialName !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialName = this._credentialName;
    }
    if (this._insecureSkipVerify !== undefined) {
      hasAnyValues = true;
      internalValueResult.insecureSkipVerify = this._insecureSkipVerify;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._privateKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.privateKey = this._privateKey;
    }
    if (this._sni !== undefined) {
      hasAnyValues = true;
      internalValueResult.sni = this._sni;
    }
    if (this._subjectAltNames !== undefined) {
      hasAnyValues = true;
      internalValueResult.subjectAltNames = this._subjectAltNames;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyMetricsServiceTlsSettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caCertificates = undefined;
      this._clientCertificate = undefined;
      this._credentialName = undefined;
      this._insecureSkipVerify = undefined;
      this._mode = undefined;
      this._privateKey = undefined;
      this._sni = undefined;
      this._subjectAltNames = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caCertificates = value.caCertificates;
      this._clientCertificate = value.clientCertificate;
      this._credentialName = value.credentialName;
      this._insecureSkipVerify = value.insecureSkipVerify;
      this._mode = value.mode;
      this._privateKey = value.privateKey;
      this._sni = value.sni;
      this._subjectAltNames = value.subjectAltNames;
    }
  }

  // ca_certificates - computed: false, optional: true, required: false
  private _caCertificates?: string; 
  public get caCertificates() {
    return this.getStringAttribute('ca_certificates');
  }
  public set caCertificates(value: string) {
    this._caCertificates = value;
  }
  public resetCaCertificates() {
    this._caCertificates = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caCertificatesInput() {
    return this._caCertificates;
  }

  // client_certificate - computed: false, optional: true, required: false
  private _clientCertificate?: string; 
  public get clientCertificate() {
    return this.getStringAttribute('client_certificate');
  }
  public set clientCertificate(value: string) {
    this._clientCertificate = value;
  }
  public resetClientCertificate() {
    this._clientCertificate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientCertificateInput() {
    return this._clientCertificate;
  }

  // credential_name - computed: false, optional: true, required: false
  private _credentialName?: string; 
  public get credentialName() {
    return this.getStringAttribute('credential_name');
  }
  public set credentialName(value: string) {
    this._credentialName = value;
  }
  public resetCredentialName() {
    this._credentialName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialNameInput() {
    return this._credentialName;
  }

  // insecure_skip_verify - computed: false, optional: true, required: false
  private _insecureSkipVerify?: boolean | cdktf.IResolvable; 
  public get insecureSkipVerify() {
    return this.getBooleanAttribute('insecure_skip_verify');
  }
  public set insecureSkipVerify(value: boolean | cdktf.IResolvable) {
    this._insecureSkipVerify = value;
  }
  public resetInsecureSkipVerify() {
    this._insecureSkipVerify = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get insecureSkipVerifyInput() {
    return this._insecureSkipVerify;
  }

  // mode - computed: false, optional: false, required: true
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // private_key - computed: false, optional: true, required: false
  private _privateKey?: string; 
  public get privateKey() {
    return this.getStringAttribute('private_key');
  }
  public set privateKey(value: string) {
    this._privateKey = value;
  }
  public resetPrivateKey() {
    this._privateKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privateKeyInput() {
    return this._privateKey;
  }

  // sni - computed: false, optional: true, required: false
  private _sni?: string; 
  public get sni() {
    return this.getStringAttribute('sni');
  }
  public set sni(value: string) {
    this._sni = value;
  }
  public resetSni() {
    this._sni = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sniInput() {
    return this._sni;
  }

  // subject_alt_names - computed: false, optional: true, required: false
  private _subjectAltNames?: string[]; 
  public get subjectAltNames() {
    return this.getListAttribute('subject_alt_names');
  }
  public set subjectAltNames(value: string[]) {
    this._subjectAltNames = value;
  }
  public resetSubjectAltNames() {
    this._subjectAltNames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subjectAltNamesInput() {
    return this._subjectAltNames;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyMetricsService {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#address DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#address}
  */
  readonly address?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#tcp_keepalive DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#tcp_keepalive}
  */
  readonly tcpKeepalive?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyMetricsServiceTcpKeepalive;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#tls_settings DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#tls_settings}
  */
  readonly tlsSettings?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyMetricsServiceTlsSettings;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyMetricsServiceToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyMetricsService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: cdktf.stringToTerraform(struct!.address),
    tcp_keepalive: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyMetricsServiceTcpKeepaliveToTerraform(struct!.tcpKeepalive),
    tls_settings: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyMetricsServiceTlsSettingsToTerraform(struct!.tlsSettings),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyMetricsServiceToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyMetricsService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: cdktf.stringToHclTerraform(struct!.address),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tcp_keepalive: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyMetricsServiceTcpKeepaliveToHclTerraform(struct!.tcpKeepalive),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyMetricsServiceTcpKeepalive",
    },
    tls_settings: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyMetricsServiceTlsSettingsToHclTerraform(struct!.tlsSettings),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyMetricsServiceTlsSettings",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyMetricsServiceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyMetricsService | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address;
    }
    if (this._tcpKeepalive?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tcpKeepalive = this._tcpKeepalive?.internalValue;
    }
    if (this._tlsSettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsSettings = this._tlsSettings?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyMetricsService | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address = undefined;
      this._tcpKeepalive.internalValue = undefined;
      this._tlsSettings.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address = value.address;
      this._tcpKeepalive.internalValue = value.tcpKeepalive;
      this._tlsSettings.internalValue = value.tlsSettings;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address?: string; 
  public get address() {
    return this.getStringAttribute('address');
  }
  public set address(value: string) {
    this._address = value;
  }
  public resetAddress() {
    this._address = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address;
  }

  // tcp_keepalive - computed: false, optional: true, required: false
  private _tcpKeepalive = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyMetricsServiceTcpKeepaliveOutputReference(this, "tcp_keepalive");
  public get tcpKeepalive() {
    return this._tcpKeepalive;
  }
  public putTcpKeepalive(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyMetricsServiceTcpKeepalive) {
    this._tcpKeepalive.internalValue = value;
  }
  public resetTcpKeepalive() {
    this._tcpKeepalive.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tcpKeepaliveInput() {
    return this._tcpKeepalive.internalValue;
  }

  // tls_settings - computed: false, optional: true, required: false
  private _tlsSettings = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyMetricsServiceTlsSettingsOutputReference(this, "tls_settings");
  public get tlsSettings() {
    return this._tlsSettings;
  }
  public putTlsSettings(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyMetricsServiceTlsSettings) {
    this._tlsSettings.internalValue = value;
  }
  public resetTlsSettings() {
    this._tlsSettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsSettingsInput() {
    return this._tlsSettings.internalValue;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigGatewayTopology {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#forward_client_cert_details DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#forward_client_cert_details}
  */
  readonly forwardClientCertDetails?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#num_trusted_proxies DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#num_trusted_proxies}
  */
  readonly numTrustedProxies?: number;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigGatewayTopologyToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigGatewayTopology | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    forward_client_cert_details: cdktf.stringToTerraform(struct!.forwardClientCertDetails),
    num_trusted_proxies: cdktf.numberToTerraform(struct!.numTrustedProxies),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigGatewayTopologyToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigGatewayTopology | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    forward_client_cert_details: {
      value: cdktf.stringToHclTerraform(struct!.forwardClientCertDetails),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    num_trusted_proxies: {
      value: cdktf.numberToHclTerraform(struct!.numTrustedProxies),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigGatewayTopologyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigGatewayTopology | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._forwardClientCertDetails !== undefined) {
      hasAnyValues = true;
      internalValueResult.forwardClientCertDetails = this._forwardClientCertDetails;
    }
    if (this._numTrustedProxies !== undefined) {
      hasAnyValues = true;
      internalValueResult.numTrustedProxies = this._numTrustedProxies;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigGatewayTopology | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._forwardClientCertDetails = undefined;
      this._numTrustedProxies = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._forwardClientCertDetails = value.forwardClientCertDetails;
      this._numTrustedProxies = value.numTrustedProxies;
    }
  }

  // forward_client_cert_details - computed: false, optional: true, required: false
  private _forwardClientCertDetails?: string; 
  public get forwardClientCertDetails() {
    return this.getStringAttribute('forward_client_cert_details');
  }
  public set forwardClientCertDetails(value: string) {
    this._forwardClientCertDetails = value;
  }
  public resetForwardClientCertDetails() {
    this._forwardClientCertDetails = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get forwardClientCertDetailsInput() {
    return this._forwardClientCertDetails;
  }

  // num_trusted_proxies - computed: false, optional: true, required: false
  private _numTrustedProxies?: number; 
  public get numTrustedProxies() {
    return this.getNumberAttribute('num_trusted_proxies');
  }
  public set numTrustedProxies(value: number) {
    this._numTrustedProxies = value;
  }
  public resetNumTrustedProxies() {
    this._numTrustedProxies = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get numTrustedProxiesInput() {
    return this._numTrustedProxies;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigImage {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#image_type DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#image_type}
  */
  readonly imageType?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigImageToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigImage | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    image_type: cdktf.stringToTerraform(struct!.imageType),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigImageToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigImage | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    image_type: {
      value: cdktf.stringToHclTerraform(struct!.imageType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigImageOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigImage | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._imageType !== undefined) {
      hasAnyValues = true;
      internalValueResult.imageType = this._imageType;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigImage | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._imageType = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._imageType = value.imageType;
    }
  }

  // image_type - computed: false, optional: true, required: false
  private _imageType?: string; 
  public get imageType() {
    return this.getStringAttribute('image_type');
  }
  public set imageType(value: string) {
    this._imageType = value;
  }
  public resetImageType() {
    this._imageType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageTypeInput() {
    return this._imageType;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigPrivateKeyProviderCryptomb {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#poll_delay DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#poll_delay}
  */
  readonly pollDelay?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigPrivateKeyProviderCryptombToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigPrivateKeyProviderCryptomb | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    poll_delay: cdktf.stringToTerraform(struct!.pollDelay),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigPrivateKeyProviderCryptombToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigPrivateKeyProviderCryptomb | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    poll_delay: {
      value: cdktf.stringToHclTerraform(struct!.pollDelay),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigPrivateKeyProviderCryptombOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigPrivateKeyProviderCryptomb | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._pollDelay !== undefined) {
      hasAnyValues = true;
      internalValueResult.pollDelay = this._pollDelay;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigPrivateKeyProviderCryptomb | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._pollDelay = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._pollDelay = value.pollDelay;
    }
  }

  // poll_delay - computed: false, optional: true, required: false
  private _pollDelay?: string; 
  public get pollDelay() {
    return this.getStringAttribute('poll_delay');
  }
  public set pollDelay(value: string) {
    this._pollDelay = value;
  }
  public resetPollDelay() {
    this._pollDelay = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pollDelayInput() {
    return this._pollDelay;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigPrivateKeyProviderQat {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#poll_delay DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#poll_delay}
  */
  readonly pollDelay?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigPrivateKeyProviderQatToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigPrivateKeyProviderQat | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    poll_delay: cdktf.stringToTerraform(struct!.pollDelay),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigPrivateKeyProviderQatToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigPrivateKeyProviderQat | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    poll_delay: {
      value: cdktf.stringToHclTerraform(struct!.pollDelay),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigPrivateKeyProviderQatOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigPrivateKeyProviderQat | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._pollDelay !== undefined) {
      hasAnyValues = true;
      internalValueResult.pollDelay = this._pollDelay;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigPrivateKeyProviderQat | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._pollDelay = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._pollDelay = value.pollDelay;
    }
  }

  // poll_delay - computed: false, optional: true, required: false
  private _pollDelay?: string; 
  public get pollDelay() {
    return this.getStringAttribute('poll_delay');
  }
  public set pollDelay(value: string) {
    this._pollDelay = value;
  }
  public resetPollDelay() {
    this._pollDelay = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pollDelayInput() {
    return this._pollDelay;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigPrivateKeyProvider {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#cryptomb DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#cryptomb}
  */
  readonly cryptomb?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigPrivateKeyProviderCryptomb;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#qat DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#qat}
  */
  readonly qat?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigPrivateKeyProviderQat;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigPrivateKeyProviderToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigPrivateKeyProvider | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cryptomb: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigPrivateKeyProviderCryptombToTerraform(struct!.cryptomb),
    qat: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigPrivateKeyProviderQatToTerraform(struct!.qat),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigPrivateKeyProviderToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigPrivateKeyProvider | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cryptomb: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigPrivateKeyProviderCryptombToHclTerraform(struct!.cryptomb),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigPrivateKeyProviderCryptomb",
    },
    qat: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigPrivateKeyProviderQatToHclTerraform(struct!.qat),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigPrivateKeyProviderQat",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigPrivateKeyProviderOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigPrivateKeyProvider | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cryptomb?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cryptomb = this._cryptomb?.internalValue;
    }
    if (this._qat?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.qat = this._qat?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigPrivateKeyProvider | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cryptomb.internalValue = undefined;
      this._qat.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cryptomb.internalValue = value.cryptomb;
      this._qat.internalValue = value.qat;
    }
  }

  // cryptomb - computed: false, optional: true, required: false
  private _cryptomb = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigPrivateKeyProviderCryptombOutputReference(this, "cryptomb");
  public get cryptomb() {
    return this._cryptomb;
  }
  public putCryptomb(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigPrivateKeyProviderCryptomb) {
    this._cryptomb.internalValue = value;
  }
  public resetCryptomb() {
    this._cryptomb.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cryptombInput() {
    return this._cryptomb.internalValue;
  }

  // qat - computed: false, optional: true, required: false
  private _qat = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigPrivateKeyProviderQatOutputReference(this, "qat");
  public get qat() {
    return this._qat;
  }
  public putQat(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigPrivateKeyProviderQat) {
    this._qat.internalValue = value;
  }
  public resetQat() {
    this._qat.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get qatInput() {
    return this._qat.internalValue;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigProxyStatsMatcher {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#inclusion_prefixes DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#inclusion_prefixes}
  */
  readonly inclusionPrefixes?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#inclusion_regexps DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#inclusion_regexps}
  */
  readonly inclusionRegexps?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#inclusion_suffixes DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#inclusion_suffixes}
  */
  readonly inclusionSuffixes?: string[];
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigProxyStatsMatcherToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigProxyStatsMatcher | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    inclusion_prefixes: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.inclusionPrefixes),
    inclusion_regexps: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.inclusionRegexps),
    inclusion_suffixes: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.inclusionSuffixes),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigProxyStatsMatcherToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigProxyStatsMatcher | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    inclusion_prefixes: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.inclusionPrefixes),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    inclusion_regexps: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.inclusionRegexps),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    inclusion_suffixes: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.inclusionSuffixes),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigProxyStatsMatcherOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigProxyStatsMatcher | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._inclusionPrefixes !== undefined) {
      hasAnyValues = true;
      internalValueResult.inclusionPrefixes = this._inclusionPrefixes;
    }
    if (this._inclusionRegexps !== undefined) {
      hasAnyValues = true;
      internalValueResult.inclusionRegexps = this._inclusionRegexps;
    }
    if (this._inclusionSuffixes !== undefined) {
      hasAnyValues = true;
      internalValueResult.inclusionSuffixes = this._inclusionSuffixes;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigProxyStatsMatcher | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._inclusionPrefixes = undefined;
      this._inclusionRegexps = undefined;
      this._inclusionSuffixes = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._inclusionPrefixes = value.inclusionPrefixes;
      this._inclusionRegexps = value.inclusionRegexps;
      this._inclusionSuffixes = value.inclusionSuffixes;
    }
  }

  // inclusion_prefixes - computed: false, optional: true, required: false
  private _inclusionPrefixes?: string[]; 
  public get inclusionPrefixes() {
    return this.getListAttribute('inclusion_prefixes');
  }
  public set inclusionPrefixes(value: string[]) {
    this._inclusionPrefixes = value;
  }
  public resetInclusionPrefixes() {
    this._inclusionPrefixes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inclusionPrefixesInput() {
    return this._inclusionPrefixes;
  }

  // inclusion_regexps - computed: false, optional: true, required: false
  private _inclusionRegexps?: string[]; 
  public get inclusionRegexps() {
    return this.getListAttribute('inclusion_regexps');
  }
  public set inclusionRegexps(value: string[]) {
    this._inclusionRegexps = value;
  }
  public resetInclusionRegexps() {
    this._inclusionRegexps = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inclusionRegexpsInput() {
    return this._inclusionRegexps;
  }

  // inclusion_suffixes - computed: false, optional: true, required: false
  private _inclusionSuffixes?: string[]; 
  public get inclusionSuffixes() {
    return this.getListAttribute('inclusion_suffixes');
  }
  public set inclusionSuffixes(value: string[]) {
    this._inclusionSuffixes = value;
  }
  public resetInclusionSuffixes() {
    this._inclusionSuffixes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inclusionSuffixesInput() {
    return this._inclusionSuffixes;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeExec {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#command DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#command}
  */
  readonly command?: string[];
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeExecToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeExec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    command: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.command),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeExecToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeExec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    command: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.command),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeExecOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeExec | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._command !== undefined) {
      hasAnyValues = true;
      internalValueResult.command = this._command;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeExec | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._command = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._command = value.command;
    }
  }

  // command - computed: false, optional: true, required: false
  private _command?: string[]; 
  public get command() {
    return this.getListAttribute('command');
  }
  public set command(value: string[]) {
    this._command = value;
  }
  public resetCommand() {
    this._command = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commandInput() {
    return this._command;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeHttpGetHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#name DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#value DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeHttpGetHttpHeadersToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeHttpGetHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeHttpGetHttpHeadersToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeHttpGetHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeHttpGetHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeHttpGetHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeHttpGetHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeHttpGetHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeHttpGetHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeHttpGetHttpHeadersOutputReference {
    return new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeHttpGetHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeHttpGet {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#host DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#host}
  */
  readonly host?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#http_headers DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#http_headers}
  */
  readonly httpHeaders?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeHttpGetHttpHeaders[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#path DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#path}
  */
  readonly path?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#port DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#port}
  */
  readonly port: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#scheme DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#scheme}
  */
  readonly scheme?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeHttpGetToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeHttpGet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    host: cdktf.stringToTerraform(struct!.host),
    http_headers: cdktf.listMapper(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeHttpGetHttpHeadersToTerraform, false)(struct!.httpHeaders),
    path: cdktf.stringToTerraform(struct!.path),
    port: cdktf.numberToTerraform(struct!.port),
    scheme: cdktf.stringToTerraform(struct!.scheme),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeHttpGetToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeHttpGet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    http_headers: {
      value: cdktf.listMapperHcl(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeHttpGetHttpHeadersToHclTerraform, false)(struct!.httpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeHttpGetHttpHeadersList",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    scheme: {
      value: cdktf.stringToHclTerraform(struct!.scheme),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeHttpGetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeHttpGet | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._httpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpHeaders = this._httpHeaders?.internalValue;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._scheme !== undefined) {
      hasAnyValues = true;
      internalValueResult.scheme = this._scheme;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeHttpGet | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._host = undefined;
      this._httpHeaders.internalValue = undefined;
      this._path = undefined;
      this._port = undefined;
      this._scheme = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._host = value.host;
      this._httpHeaders.internalValue = value.httpHeaders;
      this._path = value.path;
      this._port = value.port;
      this._scheme = value.scheme;
    }
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // http_headers - computed: false, optional: true, required: false
  private _httpHeaders = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeHttpGetHttpHeadersList(this, "http_headers", false);
  public get httpHeaders() {
    return this._httpHeaders;
  }
  public putHttpHeaders(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeHttpGetHttpHeaders[] | cdktf.IResolvable) {
    this._httpHeaders.internalValue = value;
  }
  public resetHttpHeaders() {
    this._httpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpHeadersInput() {
    return this._httpHeaders.internalValue;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // scheme - computed: false, optional: true, required: false
  private _scheme?: string; 
  public get scheme() {
    return this.getStringAttribute('scheme');
  }
  public set scheme(value: string) {
    this._scheme = value;
  }
  public resetScheme() {
    this._scheme = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get schemeInput() {
    return this._scheme;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeTcpSocket {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#host DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#host}
  */
  readonly host?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#port DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#port}
  */
  readonly port: number;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeTcpSocketToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeTcpSocket | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    host: cdktf.stringToTerraform(struct!.host),
    port: cdktf.numberToTerraform(struct!.port),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeTcpSocketToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeTcpSocket | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeTcpSocketOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeTcpSocket | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeTcpSocket | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._host = undefined;
      this._port = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._host = value.host;
      this._port = value.port;
    }
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbe {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#exec DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#exec}
  */
  readonly exec?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeExec;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#failure_threshold DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#failure_threshold}
  */
  readonly failureThreshold?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#http_get DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#http_get}
  */
  readonly httpGet?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeHttpGet;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#initial_delay_seconds DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#initial_delay_seconds}
  */
  readonly initialDelaySeconds?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#period_seconds DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#period_seconds}
  */
  readonly periodSeconds?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#success_threshold DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#success_threshold}
  */
  readonly successThreshold?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#tcp_socket DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#tcp_socket}
  */
  readonly tcpSocket?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeTcpSocket;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#timeout_seconds DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#timeout_seconds}
  */
  readonly timeoutSeconds?: number;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbe | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    exec: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeExecToTerraform(struct!.exec),
    failure_threshold: cdktf.numberToTerraform(struct!.failureThreshold),
    http_get: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeHttpGetToTerraform(struct!.httpGet),
    initial_delay_seconds: cdktf.numberToTerraform(struct!.initialDelaySeconds),
    period_seconds: cdktf.numberToTerraform(struct!.periodSeconds),
    success_threshold: cdktf.numberToTerraform(struct!.successThreshold),
    tcp_socket: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeTcpSocketToTerraform(struct!.tcpSocket),
    timeout_seconds: cdktf.numberToTerraform(struct!.timeoutSeconds),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbe | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    exec: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeExecToHclTerraform(struct!.exec),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeExec",
    },
    failure_threshold: {
      value: cdktf.numberToHclTerraform(struct!.failureThreshold),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_get: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeHttpGetToHclTerraform(struct!.httpGet),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeHttpGet",
    },
    initial_delay_seconds: {
      value: cdktf.numberToHclTerraform(struct!.initialDelaySeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    period_seconds: {
      value: cdktf.numberToHclTerraform(struct!.periodSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    success_threshold: {
      value: cdktf.numberToHclTerraform(struct!.successThreshold),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    tcp_socket: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeTcpSocketToHclTerraform(struct!.tcpSocket),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeTcpSocket",
    },
    timeout_seconds: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbe | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._exec?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.exec = this._exec?.internalValue;
    }
    if (this._failureThreshold !== undefined) {
      hasAnyValues = true;
      internalValueResult.failureThreshold = this._failureThreshold;
    }
    if (this._httpGet?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpGet = this._httpGet?.internalValue;
    }
    if (this._initialDelaySeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialDelaySeconds = this._initialDelaySeconds;
    }
    if (this._periodSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.periodSeconds = this._periodSeconds;
    }
    if (this._successThreshold !== undefined) {
      hasAnyValues = true;
      internalValueResult.successThreshold = this._successThreshold;
    }
    if (this._tcpSocket?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tcpSocket = this._tcpSocket?.internalValue;
    }
    if (this._timeoutSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSeconds = this._timeoutSeconds;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbe | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._exec.internalValue = undefined;
      this._failureThreshold = undefined;
      this._httpGet.internalValue = undefined;
      this._initialDelaySeconds = undefined;
      this._periodSeconds = undefined;
      this._successThreshold = undefined;
      this._tcpSocket.internalValue = undefined;
      this._timeoutSeconds = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._exec.internalValue = value.exec;
      this._failureThreshold = value.failureThreshold;
      this._httpGet.internalValue = value.httpGet;
      this._initialDelaySeconds = value.initialDelaySeconds;
      this._periodSeconds = value.periodSeconds;
      this._successThreshold = value.successThreshold;
      this._tcpSocket.internalValue = value.tcpSocket;
      this._timeoutSeconds = value.timeoutSeconds;
    }
  }

  // exec - computed: false, optional: true, required: false
  private _exec = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeExecOutputReference(this, "exec");
  public get exec() {
    return this._exec;
  }
  public putExec(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeExec) {
    this._exec.internalValue = value;
  }
  public resetExec() {
    this._exec.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get execInput() {
    return this._exec.internalValue;
  }

  // failure_threshold - computed: false, optional: true, required: false
  private _failureThreshold?: number; 
  public get failureThreshold() {
    return this.getNumberAttribute('failure_threshold');
  }
  public set failureThreshold(value: number) {
    this._failureThreshold = value;
  }
  public resetFailureThreshold() {
    this._failureThreshold = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failureThresholdInput() {
    return this._failureThreshold;
  }

  // http_get - computed: false, optional: true, required: false
  private _httpGet = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeHttpGetOutputReference(this, "http_get");
  public get httpGet() {
    return this._httpGet;
  }
  public putHttpGet(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeHttpGet) {
    this._httpGet.internalValue = value;
  }
  public resetHttpGet() {
    this._httpGet.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpGetInput() {
    return this._httpGet.internalValue;
  }

  // initial_delay_seconds - computed: false, optional: true, required: false
  private _initialDelaySeconds?: number; 
  public get initialDelaySeconds() {
    return this.getNumberAttribute('initial_delay_seconds');
  }
  public set initialDelaySeconds(value: number) {
    this._initialDelaySeconds = value;
  }
  public resetInitialDelaySeconds() {
    this._initialDelaySeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialDelaySecondsInput() {
    return this._initialDelaySeconds;
  }

  // period_seconds - computed: false, optional: true, required: false
  private _periodSeconds?: number; 
  public get periodSeconds() {
    return this.getNumberAttribute('period_seconds');
  }
  public set periodSeconds(value: number) {
    this._periodSeconds = value;
  }
  public resetPeriodSeconds() {
    this._periodSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get periodSecondsInput() {
    return this._periodSeconds;
  }

  // success_threshold - computed: false, optional: true, required: false
  private _successThreshold?: number; 
  public get successThreshold() {
    return this.getNumberAttribute('success_threshold');
  }
  public set successThreshold(value: number) {
    this._successThreshold = value;
  }
  public resetSuccessThreshold() {
    this._successThreshold = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get successThresholdInput() {
    return this._successThreshold;
  }

  // tcp_socket - computed: false, optional: true, required: false
  private _tcpSocket = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeTcpSocketOutputReference(this, "tcp_socket");
  public get tcpSocket() {
    return this._tcpSocket;
  }
  public putTcpSocket(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeTcpSocket) {
    this._tcpSocket.internalValue = value;
  }
  public resetTcpSocket() {
    this._tcpSocket.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tcpSocketInput() {
    return this._tcpSocket.internalValue;
  }

  // timeout_seconds - computed: false, optional: true, required: false
  private _timeoutSeconds?: number; 
  public get timeoutSeconds() {
    return this.getNumberAttribute('timeout_seconds');
  }
  public set timeoutSeconds(value: number) {
    this._timeoutSeconds = value;
  }
  public resetTimeoutSeconds() {
    this._timeoutSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecondsInput() {
    return this._timeoutSeconds;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigSds {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#enabled DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#k8s_sa_jwt_path DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#k8s_sa_jwt_path}
  */
  readonly k8SSaJwtPath?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigSdsToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigSds | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.booleanToTerraform(struct!.enabled),
    k8s_sa_jwt_path: cdktf.stringToTerraform(struct!.k8SSaJwtPath),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigSdsToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigSds | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    k8s_sa_jwt_path: {
      value: cdktf.stringToHclTerraform(struct!.k8SSaJwtPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigSdsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigSds | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._k8SSaJwtPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.k8SSaJwtPath = this._k8SSaJwtPath;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigSds | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._k8SSaJwtPath = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._k8SSaJwtPath = value.k8SSaJwtPath;
    }
  }

  // enabled - computed: false, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // k8s_sa_jwt_path - computed: false, optional: true, required: false
  private _k8SSaJwtPath?: string; 
  public get k8SSaJwtPath() {
    return this.getStringAttribute('k8s_sa_jwt_path');
  }
  public set k8SSaJwtPath(value: string) {
    this._k8SSaJwtPath = value;
  }
  public resetK8SSaJwtPath() {
    this._k8SSaJwtPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get k8SSaJwtPathInput() {
    return this._k8SSaJwtPath;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingCustomTagsEnvironment {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#default_value DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#default_value}
  */
  readonly defaultValue?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#name DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#name}
  */
  readonly name?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingCustomTagsEnvironmentToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingCustomTagsEnvironment | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    default_value: cdktf.stringToTerraform(struct!.defaultValue),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingCustomTagsEnvironmentToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingCustomTagsEnvironment | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    default_value: {
      value: cdktf.stringToHclTerraform(struct!.defaultValue),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingCustomTagsEnvironmentOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingCustomTagsEnvironment | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._defaultValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultValue = this._defaultValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingCustomTagsEnvironment | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._defaultValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._defaultValue = value.defaultValue;
      this._name = value.name;
    }
  }

  // default_value - computed: false, optional: true, required: false
  private _defaultValue?: string; 
  public get defaultValue() {
    return this.getStringAttribute('default_value');
  }
  public set defaultValue(value: string) {
    this._defaultValue = value;
  }
  public resetDefaultValue() {
    this._defaultValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultValueInput() {
    return this._defaultValue;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingCustomTagsHeader {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#default_value DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#default_value}
  */
  readonly defaultValue?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#name DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#name}
  */
  readonly name?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingCustomTagsHeaderToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingCustomTagsHeader | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    default_value: cdktf.stringToTerraform(struct!.defaultValue),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingCustomTagsHeaderToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingCustomTagsHeader | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    default_value: {
      value: cdktf.stringToHclTerraform(struct!.defaultValue),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingCustomTagsHeaderOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingCustomTagsHeader | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._defaultValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultValue = this._defaultValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingCustomTagsHeader | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._defaultValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._defaultValue = value.defaultValue;
      this._name = value.name;
    }
  }

  // default_value - computed: false, optional: true, required: false
  private _defaultValue?: string; 
  public get defaultValue() {
    return this.getStringAttribute('default_value');
  }
  public set defaultValue(value: string) {
    this._defaultValue = value;
  }
  public resetDefaultValue() {
    this._defaultValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultValueInput() {
    return this._defaultValue;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingCustomTagsLiteral {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#value DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingCustomTagsLiteralToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingCustomTagsLiteral | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingCustomTagsLiteralToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingCustomTagsLiteral | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingCustomTagsLiteralOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingCustomTagsLiteral | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingCustomTagsLiteral | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._value = value.value;
    }
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingCustomTags {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#environment DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#environment}
  */
  readonly environment?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingCustomTagsEnvironment;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#header DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#header}
  */
  readonly header?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingCustomTagsHeader;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#literal DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#literal}
  */
  readonly literal?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingCustomTagsLiteral;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingCustomTagsToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingCustomTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    environment: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingCustomTagsEnvironmentToTerraform(struct!.environment),
    header: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingCustomTagsHeaderToTerraform(struct!.header),
    literal: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingCustomTagsLiteralToTerraform(struct!.literal),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingCustomTagsToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingCustomTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    environment: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingCustomTagsEnvironmentToHclTerraform(struct!.environment),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingCustomTagsEnvironment",
    },
    header: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingCustomTagsHeaderToHclTerraform(struct!.header),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingCustomTagsHeader",
    },
    literal: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingCustomTagsLiteralToHclTerraform(struct!.literal),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingCustomTagsLiteral",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingCustomTagsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingCustomTags | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._environment?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment?.internalValue;
    }
    if (this._header?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.header = this._header?.internalValue;
    }
    if (this._literal?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.literal = this._literal?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingCustomTags | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._environment.internalValue = undefined;
      this._header.internalValue = undefined;
      this._literal.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._environment.internalValue = value.environment;
      this._header.internalValue = value.header;
      this._literal.internalValue = value.literal;
    }
  }

  // environment - computed: false, optional: true, required: false
  private _environment = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingCustomTagsEnvironmentOutputReference(this, "environment");
  public get environment() {
    return this._environment;
  }
  public putEnvironment(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingCustomTagsEnvironment) {
    this._environment.internalValue = value;
  }
  public resetEnvironment() {
    this._environment.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment.internalValue;
  }

  // header - computed: false, optional: true, required: false
  private _header = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingCustomTagsHeaderOutputReference(this, "header");
  public get header() {
    return this._header;
  }
  public putHeader(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingCustomTagsHeader) {
    this._header.internalValue = value;
  }
  public resetHeader() {
    this._header.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerInput() {
    return this._header.internalValue;
  }

  // literal - computed: false, optional: true, required: false
  private _literal = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingCustomTagsLiteralOutputReference(this, "literal");
  public get literal() {
    return this._literal;
  }
  public putLiteral(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingCustomTagsLiteral) {
    this._literal.internalValue = value;
  }
  public resetLiteral() {
    this._literal.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get literalInput() {
    return this._literal.internalValue;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingDatadog {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#address DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#address}
  */
  readonly address?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingDatadogToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingDatadog | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: cdktf.stringToTerraform(struct!.address),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingDatadogToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingDatadog | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: cdktf.stringToHclTerraform(struct!.address),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingDatadogOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingDatadog | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingDatadog | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address = value.address;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address?: string; 
  public get address() {
    return this.getStringAttribute('address');
  }
  public set address(value: string) {
    this._address = value;
  }
  public resetAddress() {
    this._address = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingLightstep {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#access_token DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#access_token}
  */
  readonly accessToken?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#address DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#address}
  */
  readonly address?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingLightstepToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingLightstep | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_token: cdktf.stringToTerraform(struct!.accessToken),
    address: cdktf.stringToTerraform(struct!.address),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingLightstepToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingLightstep | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_token: {
      value: cdktf.stringToHclTerraform(struct!.accessToken),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    address: {
      value: cdktf.stringToHclTerraform(struct!.address),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingLightstepOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingLightstep | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessToken !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessToken = this._accessToken;
    }
    if (this._address !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingLightstep | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessToken = undefined;
      this._address = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessToken = value.accessToken;
      this._address = value.address;
    }
  }

  // access_token - computed: false, optional: true, required: false
  private _accessToken?: string; 
  public get accessToken() {
    return this.getStringAttribute('access_token');
  }
  public set accessToken(value: string) {
    this._accessToken = value;
  }
  public resetAccessToken() {
    this._accessToken = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessTokenInput() {
    return this._accessToken;
  }

  // address - computed: false, optional: true, required: false
  private _address?: string; 
  public get address() {
    return this.getStringAttribute('address');
  }
  public set address(value: string) {
    this._address = value;
  }
  public resetAddress() {
    this._address = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingOpenCensusAgent {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#address DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#address}
  */
  readonly address?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#context DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#context}
  */
  readonly context?: string[];
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingOpenCensusAgentToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingOpenCensusAgent | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: cdktf.stringToTerraform(struct!.address),
    context: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.context),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingOpenCensusAgentToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingOpenCensusAgent | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: cdktf.stringToHclTerraform(struct!.address),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    context: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.context),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingOpenCensusAgentOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingOpenCensusAgent | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address;
    }
    if (this._context !== undefined) {
      hasAnyValues = true;
      internalValueResult.context = this._context;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingOpenCensusAgent | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address = undefined;
      this._context = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address = value.address;
      this._context = value.context;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address?: string; 
  public get address() {
    return this.getStringAttribute('address');
  }
  public set address(value: string) {
    this._address = value;
  }
  public resetAddress() {
    this._address = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address;
  }

  // context - computed: false, optional: true, required: false
  private _context?: string[]; 
  public get context() {
    return this.getListAttribute('context');
  }
  public set context(value: string[]) {
    this._context = value;
  }
  public resetContext() {
    this._context = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contextInput() {
    return this._context;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingStackdriver {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#debug DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#debug}
  */
  readonly debug?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#max_number_of_annotations DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#max_number_of_annotations}
  */
  readonly maxNumberOfAnnotations?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#max_number_of_attributes DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#max_number_of_attributes}
  */
  readonly maxNumberOfAttributes?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#max_number_of_message_events DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#max_number_of_message_events}
  */
  readonly maxNumberOfMessageEvents?: number;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingStackdriverToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingStackdriver | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    debug: cdktf.booleanToTerraform(struct!.debug),
    max_number_of_annotations: cdktf.numberToTerraform(struct!.maxNumberOfAnnotations),
    max_number_of_attributes: cdktf.numberToTerraform(struct!.maxNumberOfAttributes),
    max_number_of_message_events: cdktf.numberToTerraform(struct!.maxNumberOfMessageEvents),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingStackdriverToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingStackdriver | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    debug: {
      value: cdktf.booleanToHclTerraform(struct!.debug),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_number_of_annotations: {
      value: cdktf.numberToHclTerraform(struct!.maxNumberOfAnnotations),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_number_of_attributes: {
      value: cdktf.numberToHclTerraform(struct!.maxNumberOfAttributes),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_number_of_message_events: {
      value: cdktf.numberToHclTerraform(struct!.maxNumberOfMessageEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingStackdriverOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingStackdriver | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._debug !== undefined) {
      hasAnyValues = true;
      internalValueResult.debug = this._debug;
    }
    if (this._maxNumberOfAnnotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxNumberOfAnnotations = this._maxNumberOfAnnotations;
    }
    if (this._maxNumberOfAttributes !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxNumberOfAttributes = this._maxNumberOfAttributes;
    }
    if (this._maxNumberOfMessageEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxNumberOfMessageEvents = this._maxNumberOfMessageEvents;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingStackdriver | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._debug = undefined;
      this._maxNumberOfAnnotations = undefined;
      this._maxNumberOfAttributes = undefined;
      this._maxNumberOfMessageEvents = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._debug = value.debug;
      this._maxNumberOfAnnotations = value.maxNumberOfAnnotations;
      this._maxNumberOfAttributes = value.maxNumberOfAttributes;
      this._maxNumberOfMessageEvents = value.maxNumberOfMessageEvents;
    }
  }

  // debug - computed: false, optional: true, required: false
  private _debug?: boolean | cdktf.IResolvable; 
  public get debug() {
    return this.getBooleanAttribute('debug');
  }
  public set debug(value: boolean | cdktf.IResolvable) {
    this._debug = value;
  }
  public resetDebug() {
    this._debug = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get debugInput() {
    return this._debug;
  }

  // max_number_of_annotations - computed: false, optional: true, required: false
  private _maxNumberOfAnnotations?: number; 
  public get maxNumberOfAnnotations() {
    return this.getNumberAttribute('max_number_of_annotations');
  }
  public set maxNumberOfAnnotations(value: number) {
    this._maxNumberOfAnnotations = value;
  }
  public resetMaxNumberOfAnnotations() {
    this._maxNumberOfAnnotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxNumberOfAnnotationsInput() {
    return this._maxNumberOfAnnotations;
  }

  // max_number_of_attributes - computed: false, optional: true, required: false
  private _maxNumberOfAttributes?: number; 
  public get maxNumberOfAttributes() {
    return this.getNumberAttribute('max_number_of_attributes');
  }
  public set maxNumberOfAttributes(value: number) {
    this._maxNumberOfAttributes = value;
  }
  public resetMaxNumberOfAttributes() {
    this._maxNumberOfAttributes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxNumberOfAttributesInput() {
    return this._maxNumberOfAttributes;
  }

  // max_number_of_message_events - computed: false, optional: true, required: false
  private _maxNumberOfMessageEvents?: number; 
  public get maxNumberOfMessageEvents() {
    return this.getNumberAttribute('max_number_of_message_events');
  }
  public set maxNumberOfMessageEvents(value: number) {
    this._maxNumberOfMessageEvents = value;
  }
  public resetMaxNumberOfMessageEvents() {
    this._maxNumberOfMessageEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxNumberOfMessageEventsInput() {
    return this._maxNumberOfMessageEvents;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingTlsSettings {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#ca_certificates DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#ca_certificates}
  */
  readonly caCertificates?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#client_certificate DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#client_certificate}
  */
  readonly clientCertificate?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#credential_name DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#credential_name}
  */
  readonly credentialName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#insecure_skip_verify DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#insecure_skip_verify}
  */
  readonly insecureSkipVerify?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#mode DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#mode}
  */
  readonly mode: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#private_key DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#private_key}
  */
  readonly privateKey?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#sni DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#sni}
  */
  readonly sni?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#subject_alt_names DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#subject_alt_names}
  */
  readonly subjectAltNames?: string[];
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingTlsSettingsToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingTlsSettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_certificates: cdktf.stringToTerraform(struct!.caCertificates),
    client_certificate: cdktf.stringToTerraform(struct!.clientCertificate),
    credential_name: cdktf.stringToTerraform(struct!.credentialName),
    insecure_skip_verify: cdktf.booleanToTerraform(struct!.insecureSkipVerify),
    mode: cdktf.stringToTerraform(struct!.mode),
    private_key: cdktf.stringToTerraform(struct!.privateKey),
    sni: cdktf.stringToTerraform(struct!.sni),
    subject_alt_names: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.subjectAltNames),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingTlsSettingsToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingTlsSettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_certificates: {
      value: cdktf.stringToHclTerraform(struct!.caCertificates),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_certificate: {
      value: cdktf.stringToHclTerraform(struct!.clientCertificate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    credential_name: {
      value: cdktf.stringToHclTerraform(struct!.credentialName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    insecure_skip_verify: {
      value: cdktf.booleanToHclTerraform(struct!.insecureSkipVerify),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    private_key: {
      value: cdktf.stringToHclTerraform(struct!.privateKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sni: {
      value: cdktf.stringToHclTerraform(struct!.sni),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subject_alt_names: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.subjectAltNames),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingTlsSettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingTlsSettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caCertificates !== undefined) {
      hasAnyValues = true;
      internalValueResult.caCertificates = this._caCertificates;
    }
    if (this._clientCertificate !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientCertificate = this._clientCertificate;
    }
    if (this._credentialName !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialName = this._credentialName;
    }
    if (this._insecureSkipVerify !== undefined) {
      hasAnyValues = true;
      internalValueResult.insecureSkipVerify = this._insecureSkipVerify;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._privateKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.privateKey = this._privateKey;
    }
    if (this._sni !== undefined) {
      hasAnyValues = true;
      internalValueResult.sni = this._sni;
    }
    if (this._subjectAltNames !== undefined) {
      hasAnyValues = true;
      internalValueResult.subjectAltNames = this._subjectAltNames;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingTlsSettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caCertificates = undefined;
      this._clientCertificate = undefined;
      this._credentialName = undefined;
      this._insecureSkipVerify = undefined;
      this._mode = undefined;
      this._privateKey = undefined;
      this._sni = undefined;
      this._subjectAltNames = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caCertificates = value.caCertificates;
      this._clientCertificate = value.clientCertificate;
      this._credentialName = value.credentialName;
      this._insecureSkipVerify = value.insecureSkipVerify;
      this._mode = value.mode;
      this._privateKey = value.privateKey;
      this._sni = value.sni;
      this._subjectAltNames = value.subjectAltNames;
    }
  }

  // ca_certificates - computed: false, optional: true, required: false
  private _caCertificates?: string; 
  public get caCertificates() {
    return this.getStringAttribute('ca_certificates');
  }
  public set caCertificates(value: string) {
    this._caCertificates = value;
  }
  public resetCaCertificates() {
    this._caCertificates = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caCertificatesInput() {
    return this._caCertificates;
  }

  // client_certificate - computed: false, optional: true, required: false
  private _clientCertificate?: string; 
  public get clientCertificate() {
    return this.getStringAttribute('client_certificate');
  }
  public set clientCertificate(value: string) {
    this._clientCertificate = value;
  }
  public resetClientCertificate() {
    this._clientCertificate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientCertificateInput() {
    return this._clientCertificate;
  }

  // credential_name - computed: false, optional: true, required: false
  private _credentialName?: string; 
  public get credentialName() {
    return this.getStringAttribute('credential_name');
  }
  public set credentialName(value: string) {
    this._credentialName = value;
  }
  public resetCredentialName() {
    this._credentialName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialNameInput() {
    return this._credentialName;
  }

  // insecure_skip_verify - computed: false, optional: true, required: false
  private _insecureSkipVerify?: boolean | cdktf.IResolvable; 
  public get insecureSkipVerify() {
    return this.getBooleanAttribute('insecure_skip_verify');
  }
  public set insecureSkipVerify(value: boolean | cdktf.IResolvable) {
    this._insecureSkipVerify = value;
  }
  public resetInsecureSkipVerify() {
    this._insecureSkipVerify = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get insecureSkipVerifyInput() {
    return this._insecureSkipVerify;
  }

  // mode - computed: false, optional: false, required: true
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // private_key - computed: false, optional: true, required: false
  private _privateKey?: string; 
  public get privateKey() {
    return this.getStringAttribute('private_key');
  }
  public set privateKey(value: string) {
    this._privateKey = value;
  }
  public resetPrivateKey() {
    this._privateKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privateKeyInput() {
    return this._privateKey;
  }

  // sni - computed: false, optional: true, required: false
  private _sni?: string; 
  public get sni() {
    return this.getStringAttribute('sni');
  }
  public set sni(value: string) {
    this._sni = value;
  }
  public resetSni() {
    this._sni = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sniInput() {
    return this._sni;
  }

  // subject_alt_names - computed: false, optional: true, required: false
  private _subjectAltNames?: string[]; 
  public get subjectAltNames() {
    return this.getListAttribute('subject_alt_names');
  }
  public set subjectAltNames(value: string[]) {
    this._subjectAltNames = value;
  }
  public resetSubjectAltNames() {
    this._subjectAltNames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subjectAltNamesInput() {
    return this._subjectAltNames;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingZipkin {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#address DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#address}
  */
  readonly address?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingZipkinToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingZipkin | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: cdktf.stringToTerraform(struct!.address),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingZipkinToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingZipkin | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: cdktf.stringToHclTerraform(struct!.address),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingZipkinOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingZipkin | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingZipkin | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address = value.address;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address?: string; 
  public get address() {
    return this.getStringAttribute('address');
  }
  public set address(value: string) {
    this._address = value;
  }
  public resetAddress() {
    this._address = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracing {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#custom_tags DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#custom_tags}
  */
  readonly customTags?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingCustomTags;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#datadog DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#datadog}
  */
  readonly datadog?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingDatadog;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#lightstep DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#lightstep}
  */
  readonly lightstep?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingLightstep;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#max_path_tag_length DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#max_path_tag_length}
  */
  readonly maxPathTagLength?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#open_census_agent DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#open_census_agent}
  */
  readonly openCensusAgent?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingOpenCensusAgent;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#sampling DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#sampling}
  */
  readonly sampling?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#stackdriver DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#stackdriver}
  */
  readonly stackdriver?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingStackdriver;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#tls_settings DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#tls_settings}
  */
  readonly tlsSettings?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingTlsSettings;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#zipkin DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#zipkin}
  */
  readonly zipkin?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingZipkin;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracing | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    custom_tags: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingCustomTagsToTerraform(struct!.customTags),
    datadog: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingDatadogToTerraform(struct!.datadog),
    lightstep: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingLightstepToTerraform(struct!.lightstep),
    max_path_tag_length: cdktf.numberToTerraform(struct!.maxPathTagLength),
    open_census_agent: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingOpenCensusAgentToTerraform(struct!.openCensusAgent),
    sampling: cdktf.numberToTerraform(struct!.sampling),
    stackdriver: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingStackdriverToTerraform(struct!.stackdriver),
    tls_settings: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingTlsSettingsToTerraform(struct!.tlsSettings),
    zipkin: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingZipkinToTerraform(struct!.zipkin),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracing | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    custom_tags: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingCustomTagsToHclTerraform(struct!.customTags),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingCustomTags",
    },
    datadog: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingDatadogToHclTerraform(struct!.datadog),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingDatadog",
    },
    lightstep: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingLightstepToHclTerraform(struct!.lightstep),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingLightstep",
    },
    max_path_tag_length: {
      value: cdktf.numberToHclTerraform(struct!.maxPathTagLength),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    open_census_agent: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingOpenCensusAgentToHclTerraform(struct!.openCensusAgent),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingOpenCensusAgent",
    },
    sampling: {
      value: cdktf.numberToHclTerraform(struct!.sampling),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    stackdriver: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingStackdriverToHclTerraform(struct!.stackdriver),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingStackdriver",
    },
    tls_settings: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingTlsSettingsToHclTerraform(struct!.tlsSettings),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingTlsSettings",
    },
    zipkin: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingZipkinToHclTerraform(struct!.zipkin),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingZipkin",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracing | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._customTags?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.customTags = this._customTags?.internalValue;
    }
    if (this._datadog?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.datadog = this._datadog?.internalValue;
    }
    if (this._lightstep?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.lightstep = this._lightstep?.internalValue;
    }
    if (this._maxPathTagLength !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPathTagLength = this._maxPathTagLength;
    }
    if (this._openCensusAgent?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.openCensusAgent = this._openCensusAgent?.internalValue;
    }
    if (this._sampling !== undefined) {
      hasAnyValues = true;
      internalValueResult.sampling = this._sampling;
    }
    if (this._stackdriver?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.stackdriver = this._stackdriver?.internalValue;
    }
    if (this._tlsSettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsSettings = this._tlsSettings?.internalValue;
    }
    if (this._zipkin?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.zipkin = this._zipkin?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracing | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._customTags.internalValue = undefined;
      this._datadog.internalValue = undefined;
      this._lightstep.internalValue = undefined;
      this._maxPathTagLength = undefined;
      this._openCensusAgent.internalValue = undefined;
      this._sampling = undefined;
      this._stackdriver.internalValue = undefined;
      this._tlsSettings.internalValue = undefined;
      this._zipkin.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._customTags.internalValue = value.customTags;
      this._datadog.internalValue = value.datadog;
      this._lightstep.internalValue = value.lightstep;
      this._maxPathTagLength = value.maxPathTagLength;
      this._openCensusAgent.internalValue = value.openCensusAgent;
      this._sampling = value.sampling;
      this._stackdriver.internalValue = value.stackdriver;
      this._tlsSettings.internalValue = value.tlsSettings;
      this._zipkin.internalValue = value.zipkin;
    }
  }

  // custom_tags - computed: false, optional: true, required: false
  private _customTags = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingCustomTagsOutputReference(this, "custom_tags");
  public get customTags() {
    return this._customTags;
  }
  public putCustomTags(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingCustomTags) {
    this._customTags.internalValue = value;
  }
  public resetCustomTags() {
    this._customTags.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customTagsInput() {
    return this._customTags.internalValue;
  }

  // datadog - computed: false, optional: true, required: false
  private _datadog = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingDatadogOutputReference(this, "datadog");
  public get datadog() {
    return this._datadog;
  }
  public putDatadog(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingDatadog) {
    this._datadog.internalValue = value;
  }
  public resetDatadog() {
    this._datadog.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get datadogInput() {
    return this._datadog.internalValue;
  }

  // lightstep - computed: false, optional: true, required: false
  private _lightstep = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingLightstepOutputReference(this, "lightstep");
  public get lightstep() {
    return this._lightstep;
  }
  public putLightstep(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingLightstep) {
    this._lightstep.internalValue = value;
  }
  public resetLightstep() {
    this._lightstep.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lightstepInput() {
    return this._lightstep.internalValue;
  }

  // max_path_tag_length - computed: false, optional: true, required: false
  private _maxPathTagLength?: number; 
  public get maxPathTagLength() {
    return this.getNumberAttribute('max_path_tag_length');
  }
  public set maxPathTagLength(value: number) {
    this._maxPathTagLength = value;
  }
  public resetMaxPathTagLength() {
    this._maxPathTagLength = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPathTagLengthInput() {
    return this._maxPathTagLength;
  }

  // open_census_agent - computed: false, optional: true, required: false
  private _openCensusAgent = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingOpenCensusAgentOutputReference(this, "open_census_agent");
  public get openCensusAgent() {
    return this._openCensusAgent;
  }
  public putOpenCensusAgent(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingOpenCensusAgent) {
    this._openCensusAgent.internalValue = value;
  }
  public resetOpenCensusAgent() {
    this._openCensusAgent.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get openCensusAgentInput() {
    return this._openCensusAgent.internalValue;
  }

  // sampling - computed: false, optional: true, required: false
  private _sampling?: number; 
  public get sampling() {
    return this.getNumberAttribute('sampling');
  }
  public set sampling(value: number) {
    this._sampling = value;
  }
  public resetSampling() {
    this._sampling = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get samplingInput() {
    return this._sampling;
  }

  // stackdriver - computed: false, optional: true, required: false
  private _stackdriver = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingStackdriverOutputReference(this, "stackdriver");
  public get stackdriver() {
    return this._stackdriver;
  }
  public putStackdriver(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingStackdriver) {
    this._stackdriver.internalValue = value;
  }
  public resetStackdriver() {
    this._stackdriver.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stackdriverInput() {
    return this._stackdriver.internalValue;
  }

  // tls_settings - computed: false, optional: true, required: false
  private _tlsSettings = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingTlsSettingsOutputReference(this, "tls_settings");
  public get tlsSettings() {
    return this._tlsSettings;
  }
  public putTlsSettings(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingTlsSettings) {
    this._tlsSettings.internalValue = value;
  }
  public resetTlsSettings() {
    this._tlsSettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsSettingsInput() {
    return this._tlsSettings.internalValue;
  }

  // zipkin - computed: false, optional: true, required: false
  private _zipkin = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingZipkinOutputReference(this, "zipkin");
  public get zipkin() {
    return this._zipkin;
  }
  public putZipkin(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingZipkin) {
    this._zipkin.internalValue = value;
  }
  public resetZipkin() {
    this._zipkin.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get zipkinInput() {
    return this._zipkin.internalValue;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#availability_zone DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#availability_zone}
  */
  readonly availabilityZone?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#binary_path DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#binary_path}
  */
  readonly binaryPath?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#ca_certificates_pem DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#ca_certificates_pem}
  */
  readonly caCertificatesPem?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#concurrency DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#config_path DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#config_path}
  */
  readonly configPath?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#control_plane_auth_policy DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#control_plane_auth_policy}
  */
  readonly controlPlaneAuthPolicy?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#custom_config_file DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#custom_config_file}
  */
  readonly customConfigFile?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#discovery_address DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#discovery_address}
  */
  readonly discoveryAddress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#discovery_refresh_delay DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#discovery_refresh_delay}
  */
  readonly discoveryRefreshDelay?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#drain_duration DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#drain_duration}
  */
  readonly drainDuration?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#envoy_access_log_service DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#envoy_access_log_service}
  */
  readonly envoyAccessLogService?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyAccessLogService;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#envoy_metrics_service DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#envoy_metrics_service}
  */
  readonly envoyMetricsService?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyMetricsService;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#envoy_metrics_service_address DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#envoy_metrics_service_address}
  */
  readonly envoyMetricsServiceAddress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#extra_stat_tags DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#extra_stat_tags}
  */
  readonly extraStatTags?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#gateway_topology DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#gateway_topology}
  */
  readonly gatewayTopology?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigGatewayTopology;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#hold_application_until_proxy_starts DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#hold_application_until_proxy_starts}
  */
  readonly holdApplicationUntilProxyStarts?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#image DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#image}
  */
  readonly image?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigImage;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#interception_mode DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#interception_mode}
  */
  readonly interceptionMode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#mesh_id DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#mesh_id}
  */
  readonly meshId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#private_key_provider DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#private_key_provider}
  */
  readonly privateKeyProvider?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigPrivateKeyProvider;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#proxy_admin_port DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#proxy_admin_port}
  */
  readonly proxyAdminPort?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#proxy_bootstrap_template_path DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#proxy_bootstrap_template_path}
  */
  readonly proxyBootstrapTemplatePath?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#proxy_metadata DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#proxy_metadata}
  */
  readonly proxyMetadata?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#proxy_stats_matcher DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#proxy_stats_matcher}
  */
  readonly proxyStatsMatcher?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigProxyStatsMatcher;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#readiness_probe DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#readiness_probe}
  */
  readonly readinessProbe?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbe;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#runtime_values DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#runtime_values}
  */
  readonly runtimeValues?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#sds DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#sds}
  */
  readonly sds?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigSds;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#service_cluster DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#service_cluster}
  */
  readonly serviceCluster?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#stat_name_length DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#stat_name_length}
  */
  readonly statNameLength?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#statsd_udp_address DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#statsd_udp_address}
  */
  readonly statsdUdpAddress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#status_port DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#status_port}
  */
  readonly statusPort?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#termination_drain_duration DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#termination_drain_duration}
  */
  readonly terminationDrainDuration?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#tracing DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#tracing}
  */
  readonly tracing?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracing;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#tracing_service_name DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#tracing_service_name}
  */
  readonly tracingServiceName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#zipkin_address DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#zipkin_address}
  */
  readonly zipkinAddress?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    availability_zone: cdktf.stringToTerraform(struct!.availabilityZone),
    binary_path: cdktf.stringToTerraform(struct!.binaryPath),
    ca_certificates_pem: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.caCertificatesPem),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    config_path: cdktf.stringToTerraform(struct!.configPath),
    control_plane_auth_policy: cdktf.stringToTerraform(struct!.controlPlaneAuthPolicy),
    custom_config_file: cdktf.stringToTerraform(struct!.customConfigFile),
    discovery_address: cdktf.stringToTerraform(struct!.discoveryAddress),
    discovery_refresh_delay: cdktf.stringToTerraform(struct!.discoveryRefreshDelay),
    drain_duration: cdktf.stringToTerraform(struct!.drainDuration),
    envoy_access_log_service: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyAccessLogServiceToTerraform(struct!.envoyAccessLogService),
    envoy_metrics_service: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyMetricsServiceToTerraform(struct!.envoyMetricsService),
    envoy_metrics_service_address: cdktf.stringToTerraform(struct!.envoyMetricsServiceAddress),
    extra_stat_tags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.extraStatTags),
    gateway_topology: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigGatewayTopologyToTerraform(struct!.gatewayTopology),
    hold_application_until_proxy_starts: cdktf.booleanToTerraform(struct!.holdApplicationUntilProxyStarts),
    image: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigImageToTerraform(struct!.image),
    interception_mode: cdktf.stringToTerraform(struct!.interceptionMode),
    mesh_id: cdktf.stringToTerraform(struct!.meshId),
    private_key_provider: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigPrivateKeyProviderToTerraform(struct!.privateKeyProvider),
    proxy_admin_port: cdktf.numberToTerraform(struct!.proxyAdminPort),
    proxy_bootstrap_template_path: cdktf.stringToTerraform(struct!.proxyBootstrapTemplatePath),
    proxy_metadata: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.proxyMetadata),
    proxy_stats_matcher: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigProxyStatsMatcherToTerraform(struct!.proxyStatsMatcher),
    readiness_probe: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeToTerraform(struct!.readinessProbe),
    runtime_values: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.runtimeValues),
    sds: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigSdsToTerraform(struct!.sds),
    service_cluster: cdktf.stringToTerraform(struct!.serviceCluster),
    stat_name_length: cdktf.numberToTerraform(struct!.statNameLength),
    statsd_udp_address: cdktf.stringToTerraform(struct!.statsdUdpAddress),
    status_port: cdktf.numberToTerraform(struct!.statusPort),
    termination_drain_duration: cdktf.stringToTerraform(struct!.terminationDrainDuration),
    tracing: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingToTerraform(struct!.tracing),
    tracing_service_name: cdktf.stringToTerraform(struct!.tracingServiceName),
    zipkin_address: cdktf.stringToTerraform(struct!.zipkinAddress),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    availability_zone: {
      value: cdktf.stringToHclTerraform(struct!.availabilityZone),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    binary_path: {
      value: cdktf.stringToHclTerraform(struct!.binaryPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ca_certificates_pem: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.caCertificatesPem),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    config_path: {
      value: cdktf.stringToHclTerraform(struct!.configPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    control_plane_auth_policy: {
      value: cdktf.stringToHclTerraform(struct!.controlPlaneAuthPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    custom_config_file: {
      value: cdktf.stringToHclTerraform(struct!.customConfigFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    discovery_address: {
      value: cdktf.stringToHclTerraform(struct!.discoveryAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    discovery_refresh_delay: {
      value: cdktf.stringToHclTerraform(struct!.discoveryRefreshDelay),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    drain_duration: {
      value: cdktf.stringToHclTerraform(struct!.drainDuration),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    envoy_access_log_service: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyAccessLogServiceToHclTerraform(struct!.envoyAccessLogService),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyAccessLogService",
    },
    envoy_metrics_service: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyMetricsServiceToHclTerraform(struct!.envoyMetricsService),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyMetricsService",
    },
    envoy_metrics_service_address: {
      value: cdktf.stringToHclTerraform(struct!.envoyMetricsServiceAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extra_stat_tags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.extraStatTags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    gateway_topology: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigGatewayTopologyToHclTerraform(struct!.gatewayTopology),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigGatewayTopology",
    },
    hold_application_until_proxy_starts: {
      value: cdktf.booleanToHclTerraform(struct!.holdApplicationUntilProxyStarts),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    image: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigImageToHclTerraform(struct!.image),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigImage",
    },
    interception_mode: {
      value: cdktf.stringToHclTerraform(struct!.interceptionMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mesh_id: {
      value: cdktf.stringToHclTerraform(struct!.meshId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    private_key_provider: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigPrivateKeyProviderToHclTerraform(struct!.privateKeyProvider),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigPrivateKeyProvider",
    },
    proxy_admin_port: {
      value: cdktf.numberToHclTerraform(struct!.proxyAdminPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_bootstrap_template_path: {
      value: cdktf.stringToHclTerraform(struct!.proxyBootstrapTemplatePath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    proxy_metadata: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.proxyMetadata),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    proxy_stats_matcher: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigProxyStatsMatcherToHclTerraform(struct!.proxyStatsMatcher),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigProxyStatsMatcher",
    },
    readiness_probe: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeToHclTerraform(struct!.readinessProbe),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbe",
    },
    runtime_values: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.runtimeValues),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    sds: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigSdsToHclTerraform(struct!.sds),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigSds",
    },
    service_cluster: {
      value: cdktf.stringToHclTerraform(struct!.serviceCluster),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    stat_name_length: {
      value: cdktf.numberToHclTerraform(struct!.statNameLength),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    statsd_udp_address: {
      value: cdktf.stringToHclTerraform(struct!.statsdUdpAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    status_port: {
      value: cdktf.numberToHclTerraform(struct!.statusPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    termination_drain_duration: {
      value: cdktf.stringToHclTerraform(struct!.terminationDrainDuration),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tracing: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingToHclTerraform(struct!.tracing),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracing",
    },
    tracing_service_name: {
      value: cdktf.stringToHclTerraform(struct!.tracingServiceName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    zipkin_address: {
      value: cdktf.stringToHclTerraform(struct!.zipkinAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._availabilityZone !== undefined) {
      hasAnyValues = true;
      internalValueResult.availabilityZone = this._availabilityZone;
    }
    if (this._binaryPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.binaryPath = this._binaryPath;
    }
    if (this._caCertificatesPem !== undefined) {
      hasAnyValues = true;
      internalValueResult.caCertificatesPem = this._caCertificatesPem;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._configPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.configPath = this._configPath;
    }
    if (this._controlPlaneAuthPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.controlPlaneAuthPolicy = this._controlPlaneAuthPolicy;
    }
    if (this._customConfigFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.customConfigFile = this._customConfigFile;
    }
    if (this._discoveryAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.discoveryAddress = this._discoveryAddress;
    }
    if (this._discoveryRefreshDelay !== undefined) {
      hasAnyValues = true;
      internalValueResult.discoveryRefreshDelay = this._discoveryRefreshDelay;
    }
    if (this._drainDuration !== undefined) {
      hasAnyValues = true;
      internalValueResult.drainDuration = this._drainDuration;
    }
    if (this._envoyAccessLogService?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.envoyAccessLogService = this._envoyAccessLogService?.internalValue;
    }
    if (this._envoyMetricsService?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.envoyMetricsService = this._envoyMetricsService?.internalValue;
    }
    if (this._envoyMetricsServiceAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.envoyMetricsServiceAddress = this._envoyMetricsServiceAddress;
    }
    if (this._extraStatTags !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraStatTags = this._extraStatTags;
    }
    if (this._gatewayTopology?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.gatewayTopology = this._gatewayTopology?.internalValue;
    }
    if (this._holdApplicationUntilProxyStarts !== undefined) {
      hasAnyValues = true;
      internalValueResult.holdApplicationUntilProxyStarts = this._holdApplicationUntilProxyStarts;
    }
    if (this._image?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.image = this._image?.internalValue;
    }
    if (this._interceptionMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.interceptionMode = this._interceptionMode;
    }
    if (this._meshId !== undefined) {
      hasAnyValues = true;
      internalValueResult.meshId = this._meshId;
    }
    if (this._privateKeyProvider?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.privateKeyProvider = this._privateKeyProvider?.internalValue;
    }
    if (this._proxyAdminPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyAdminPort = this._proxyAdminPort;
    }
    if (this._proxyBootstrapTemplatePath !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyBootstrapTemplatePath = this._proxyBootstrapTemplatePath;
    }
    if (this._proxyMetadata !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyMetadata = this._proxyMetadata;
    }
    if (this._proxyStatsMatcher?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyStatsMatcher = this._proxyStatsMatcher?.internalValue;
    }
    if (this._readinessProbe?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.readinessProbe = this._readinessProbe?.internalValue;
    }
    if (this._runtimeValues !== undefined) {
      hasAnyValues = true;
      internalValueResult.runtimeValues = this._runtimeValues;
    }
    if (this._sds?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sds = this._sds?.internalValue;
    }
    if (this._serviceCluster !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceCluster = this._serviceCluster;
    }
    if (this._statNameLength !== undefined) {
      hasAnyValues = true;
      internalValueResult.statNameLength = this._statNameLength;
    }
    if (this._statsdUdpAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.statsdUdpAddress = this._statsdUdpAddress;
    }
    if (this._statusPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.statusPort = this._statusPort;
    }
    if (this._terminationDrainDuration !== undefined) {
      hasAnyValues = true;
      internalValueResult.terminationDrainDuration = this._terminationDrainDuration;
    }
    if (this._tracing?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tracing = this._tracing?.internalValue;
    }
    if (this._tracingServiceName !== undefined) {
      hasAnyValues = true;
      internalValueResult.tracingServiceName = this._tracingServiceName;
    }
    if (this._zipkinAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.zipkinAddress = this._zipkinAddress;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._availabilityZone = undefined;
      this._binaryPath = undefined;
      this._caCertificatesPem = undefined;
      this._concurrency = undefined;
      this._configPath = undefined;
      this._controlPlaneAuthPolicy = undefined;
      this._customConfigFile = undefined;
      this._discoveryAddress = undefined;
      this._discoveryRefreshDelay = undefined;
      this._drainDuration = undefined;
      this._envoyAccessLogService.internalValue = undefined;
      this._envoyMetricsService.internalValue = undefined;
      this._envoyMetricsServiceAddress = undefined;
      this._extraStatTags = undefined;
      this._gatewayTopology.internalValue = undefined;
      this._holdApplicationUntilProxyStarts = undefined;
      this._image.internalValue = undefined;
      this._interceptionMode = undefined;
      this._meshId = undefined;
      this._privateKeyProvider.internalValue = undefined;
      this._proxyAdminPort = undefined;
      this._proxyBootstrapTemplatePath = undefined;
      this._proxyMetadata = undefined;
      this._proxyStatsMatcher.internalValue = undefined;
      this._readinessProbe.internalValue = undefined;
      this._runtimeValues = undefined;
      this._sds.internalValue = undefined;
      this._serviceCluster = undefined;
      this._statNameLength = undefined;
      this._statsdUdpAddress = undefined;
      this._statusPort = undefined;
      this._terminationDrainDuration = undefined;
      this._tracing.internalValue = undefined;
      this._tracingServiceName = undefined;
      this._zipkinAddress = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._availabilityZone = value.availabilityZone;
      this._binaryPath = value.binaryPath;
      this._caCertificatesPem = value.caCertificatesPem;
      this._concurrency = value.concurrency;
      this._configPath = value.configPath;
      this._controlPlaneAuthPolicy = value.controlPlaneAuthPolicy;
      this._customConfigFile = value.customConfigFile;
      this._discoveryAddress = value.discoveryAddress;
      this._discoveryRefreshDelay = value.discoveryRefreshDelay;
      this._drainDuration = value.drainDuration;
      this._envoyAccessLogService.internalValue = value.envoyAccessLogService;
      this._envoyMetricsService.internalValue = value.envoyMetricsService;
      this._envoyMetricsServiceAddress = value.envoyMetricsServiceAddress;
      this._extraStatTags = value.extraStatTags;
      this._gatewayTopology.internalValue = value.gatewayTopology;
      this._holdApplicationUntilProxyStarts = value.holdApplicationUntilProxyStarts;
      this._image.internalValue = value.image;
      this._interceptionMode = value.interceptionMode;
      this._meshId = value.meshId;
      this._privateKeyProvider.internalValue = value.privateKeyProvider;
      this._proxyAdminPort = value.proxyAdminPort;
      this._proxyBootstrapTemplatePath = value.proxyBootstrapTemplatePath;
      this._proxyMetadata = value.proxyMetadata;
      this._proxyStatsMatcher.internalValue = value.proxyStatsMatcher;
      this._readinessProbe.internalValue = value.readinessProbe;
      this._runtimeValues = value.runtimeValues;
      this._sds.internalValue = value.sds;
      this._serviceCluster = value.serviceCluster;
      this._statNameLength = value.statNameLength;
      this._statsdUdpAddress = value.statsdUdpAddress;
      this._statusPort = value.statusPort;
      this._terminationDrainDuration = value.terminationDrainDuration;
      this._tracing.internalValue = value.tracing;
      this._tracingServiceName = value.tracingServiceName;
      this._zipkinAddress = value.zipkinAddress;
    }
  }

  // availability_zone - computed: false, optional: true, required: false
  private _availabilityZone?: string; 
  public get availabilityZone() {
    return this.getStringAttribute('availability_zone');
  }
  public set availabilityZone(value: string) {
    this._availabilityZone = value;
  }
  public resetAvailabilityZone() {
    this._availabilityZone = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get availabilityZoneInput() {
    return this._availabilityZone;
  }

  // binary_path - computed: false, optional: true, required: false
  private _binaryPath?: string; 
  public get binaryPath() {
    return this.getStringAttribute('binary_path');
  }
  public set binaryPath(value: string) {
    this._binaryPath = value;
  }
  public resetBinaryPath() {
    this._binaryPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get binaryPathInput() {
    return this._binaryPath;
  }

  // ca_certificates_pem - computed: false, optional: true, required: false
  private _caCertificatesPem?: string[]; 
  public get caCertificatesPem() {
    return this.getListAttribute('ca_certificates_pem');
  }
  public set caCertificatesPem(value: string[]) {
    this._caCertificatesPem = value;
  }
  public resetCaCertificatesPem() {
    this._caCertificatesPem = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caCertificatesPemInput() {
    return this._caCertificatesPem;
  }

  // concurrency - computed: false, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // config_path - computed: false, optional: true, required: false
  private _configPath?: string; 
  public get configPath() {
    return this.getStringAttribute('config_path');
  }
  public set configPath(value: string) {
    this._configPath = value;
  }
  public resetConfigPath() {
    this._configPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configPathInput() {
    return this._configPath;
  }

  // control_plane_auth_policy - computed: false, optional: true, required: false
  private _controlPlaneAuthPolicy?: string; 
  public get controlPlaneAuthPolicy() {
    return this.getStringAttribute('control_plane_auth_policy');
  }
  public set controlPlaneAuthPolicy(value: string) {
    this._controlPlaneAuthPolicy = value;
  }
  public resetControlPlaneAuthPolicy() {
    this._controlPlaneAuthPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get controlPlaneAuthPolicyInput() {
    return this._controlPlaneAuthPolicy;
  }

  // custom_config_file - computed: false, optional: true, required: false
  private _customConfigFile?: string; 
  public get customConfigFile() {
    return this.getStringAttribute('custom_config_file');
  }
  public set customConfigFile(value: string) {
    this._customConfigFile = value;
  }
  public resetCustomConfigFile() {
    this._customConfigFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customConfigFileInput() {
    return this._customConfigFile;
  }

  // discovery_address - computed: false, optional: true, required: false
  private _discoveryAddress?: string; 
  public get discoveryAddress() {
    return this.getStringAttribute('discovery_address');
  }
  public set discoveryAddress(value: string) {
    this._discoveryAddress = value;
  }
  public resetDiscoveryAddress() {
    this._discoveryAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get discoveryAddressInput() {
    return this._discoveryAddress;
  }

  // discovery_refresh_delay - computed: false, optional: true, required: false
  private _discoveryRefreshDelay?: string; 
  public get discoveryRefreshDelay() {
    return this.getStringAttribute('discovery_refresh_delay');
  }
  public set discoveryRefreshDelay(value: string) {
    this._discoveryRefreshDelay = value;
  }
  public resetDiscoveryRefreshDelay() {
    this._discoveryRefreshDelay = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get discoveryRefreshDelayInput() {
    return this._discoveryRefreshDelay;
  }

  // drain_duration - computed: false, optional: true, required: false
  private _drainDuration?: string; 
  public get drainDuration() {
    return this.getStringAttribute('drain_duration');
  }
  public set drainDuration(value: string) {
    this._drainDuration = value;
  }
  public resetDrainDuration() {
    this._drainDuration = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get drainDurationInput() {
    return this._drainDuration;
  }

  // envoy_access_log_service - computed: false, optional: true, required: false
  private _envoyAccessLogService = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyAccessLogServiceOutputReference(this, "envoy_access_log_service");
  public get envoyAccessLogService() {
    return this._envoyAccessLogService;
  }
  public putEnvoyAccessLogService(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyAccessLogService) {
    this._envoyAccessLogService.internalValue = value;
  }
  public resetEnvoyAccessLogService() {
    this._envoyAccessLogService.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get envoyAccessLogServiceInput() {
    return this._envoyAccessLogService.internalValue;
  }

  // envoy_metrics_service - computed: false, optional: true, required: false
  private _envoyMetricsService = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyMetricsServiceOutputReference(this, "envoy_metrics_service");
  public get envoyMetricsService() {
    return this._envoyMetricsService;
  }
  public putEnvoyMetricsService(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigEnvoyMetricsService) {
    this._envoyMetricsService.internalValue = value;
  }
  public resetEnvoyMetricsService() {
    this._envoyMetricsService.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get envoyMetricsServiceInput() {
    return this._envoyMetricsService.internalValue;
  }

  // envoy_metrics_service_address - computed: false, optional: true, required: false
  private _envoyMetricsServiceAddress?: string; 
  public get envoyMetricsServiceAddress() {
    return this.getStringAttribute('envoy_metrics_service_address');
  }
  public set envoyMetricsServiceAddress(value: string) {
    this._envoyMetricsServiceAddress = value;
  }
  public resetEnvoyMetricsServiceAddress() {
    this._envoyMetricsServiceAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get envoyMetricsServiceAddressInput() {
    return this._envoyMetricsServiceAddress;
  }

  // extra_stat_tags - computed: false, optional: true, required: false
  private _extraStatTags?: string[]; 
  public get extraStatTags() {
    return this.getListAttribute('extra_stat_tags');
  }
  public set extraStatTags(value: string[]) {
    this._extraStatTags = value;
  }
  public resetExtraStatTags() {
    this._extraStatTags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraStatTagsInput() {
    return this._extraStatTags;
  }

  // gateway_topology - computed: false, optional: true, required: false
  private _gatewayTopology = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigGatewayTopologyOutputReference(this, "gateway_topology");
  public get gatewayTopology() {
    return this._gatewayTopology;
  }
  public putGatewayTopology(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigGatewayTopology) {
    this._gatewayTopology.internalValue = value;
  }
  public resetGatewayTopology() {
    this._gatewayTopology.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gatewayTopologyInput() {
    return this._gatewayTopology.internalValue;
  }

  // hold_application_until_proxy_starts - computed: false, optional: true, required: false
  private _holdApplicationUntilProxyStarts?: boolean | cdktf.IResolvable; 
  public get holdApplicationUntilProxyStarts() {
    return this.getBooleanAttribute('hold_application_until_proxy_starts');
  }
  public set holdApplicationUntilProxyStarts(value: boolean | cdktf.IResolvable) {
    this._holdApplicationUntilProxyStarts = value;
  }
  public resetHoldApplicationUntilProxyStarts() {
    this._holdApplicationUntilProxyStarts = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get holdApplicationUntilProxyStartsInput() {
    return this._holdApplicationUntilProxyStarts;
  }

  // image - computed: false, optional: true, required: false
  private _image = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigImageOutputReference(this, "image");
  public get image() {
    return this._image;
  }
  public putImage(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigImage) {
    this._image.internalValue = value;
  }
  public resetImage() {
    this._image.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageInput() {
    return this._image.internalValue;
  }

  // interception_mode - computed: false, optional: true, required: false
  private _interceptionMode?: string; 
  public get interceptionMode() {
    return this.getStringAttribute('interception_mode');
  }
  public set interceptionMode(value: string) {
    this._interceptionMode = value;
  }
  public resetInterceptionMode() {
    this._interceptionMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interceptionModeInput() {
    return this._interceptionMode;
  }

  // mesh_id - computed: false, optional: true, required: false
  private _meshId?: string; 
  public get meshId() {
    return this.getStringAttribute('mesh_id');
  }
  public set meshId(value: string) {
    this._meshId = value;
  }
  public resetMeshId() {
    this._meshId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get meshIdInput() {
    return this._meshId;
  }

  // private_key_provider - computed: false, optional: true, required: false
  private _privateKeyProvider = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigPrivateKeyProviderOutputReference(this, "private_key_provider");
  public get privateKeyProvider() {
    return this._privateKeyProvider;
  }
  public putPrivateKeyProvider(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigPrivateKeyProvider) {
    this._privateKeyProvider.internalValue = value;
  }
  public resetPrivateKeyProvider() {
    this._privateKeyProvider.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privateKeyProviderInput() {
    return this._privateKeyProvider.internalValue;
  }

  // proxy_admin_port - computed: false, optional: true, required: false
  private _proxyAdminPort?: number; 
  public get proxyAdminPort() {
    return this.getNumberAttribute('proxy_admin_port');
  }
  public set proxyAdminPort(value: number) {
    this._proxyAdminPort = value;
  }
  public resetProxyAdminPort() {
    this._proxyAdminPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyAdminPortInput() {
    return this._proxyAdminPort;
  }

  // proxy_bootstrap_template_path - computed: false, optional: true, required: false
  private _proxyBootstrapTemplatePath?: string; 
  public get proxyBootstrapTemplatePath() {
    return this.getStringAttribute('proxy_bootstrap_template_path');
  }
  public set proxyBootstrapTemplatePath(value: string) {
    this._proxyBootstrapTemplatePath = value;
  }
  public resetProxyBootstrapTemplatePath() {
    this._proxyBootstrapTemplatePath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyBootstrapTemplatePathInput() {
    return this._proxyBootstrapTemplatePath;
  }

  // proxy_metadata - computed: false, optional: true, required: false
  private _proxyMetadata?: { [key: string]: string }; 
  public get proxyMetadata() {
    return this.getStringMapAttribute('proxy_metadata');
  }
  public set proxyMetadata(value: { [key: string]: string }) {
    this._proxyMetadata = value;
  }
  public resetProxyMetadata() {
    this._proxyMetadata = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyMetadataInput() {
    return this._proxyMetadata;
  }

  // proxy_stats_matcher - computed: false, optional: true, required: false
  private _proxyStatsMatcher = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigProxyStatsMatcherOutputReference(this, "proxy_stats_matcher");
  public get proxyStatsMatcher() {
    return this._proxyStatsMatcher;
  }
  public putProxyStatsMatcher(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigProxyStatsMatcher) {
    this._proxyStatsMatcher.internalValue = value;
  }
  public resetProxyStatsMatcher() {
    this._proxyStatsMatcher.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyStatsMatcherInput() {
    return this._proxyStatsMatcher.internalValue;
  }

  // readiness_probe - computed: false, optional: true, required: false
  private _readinessProbe = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbeOutputReference(this, "readiness_probe");
  public get readinessProbe() {
    return this._readinessProbe;
  }
  public putReadinessProbe(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigReadinessProbe) {
    this._readinessProbe.internalValue = value;
  }
  public resetReadinessProbe() {
    this._readinessProbe.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get readinessProbeInput() {
    return this._readinessProbe.internalValue;
  }

  // runtime_values - computed: false, optional: true, required: false
  private _runtimeValues?: { [key: string]: string }; 
  public get runtimeValues() {
    return this.getStringMapAttribute('runtime_values');
  }
  public set runtimeValues(value: { [key: string]: string }) {
    this._runtimeValues = value;
  }
  public resetRuntimeValues() {
    this._runtimeValues = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get runtimeValuesInput() {
    return this._runtimeValues;
  }

  // sds - computed: false, optional: true, required: false
  private _sds = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigSdsOutputReference(this, "sds");
  public get sds() {
    return this._sds;
  }
  public putSds(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigSds) {
    this._sds.internalValue = value;
  }
  public resetSds() {
    this._sds.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sdsInput() {
    return this._sds.internalValue;
  }

  // service_cluster - computed: false, optional: true, required: false
  private _serviceCluster?: string; 
  public get serviceCluster() {
    return this.getStringAttribute('service_cluster');
  }
  public set serviceCluster(value: string) {
    this._serviceCluster = value;
  }
  public resetServiceCluster() {
    this._serviceCluster = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceClusterInput() {
    return this._serviceCluster;
  }

  // stat_name_length - computed: false, optional: true, required: false
  private _statNameLength?: number; 
  public get statNameLength() {
    return this.getNumberAttribute('stat_name_length');
  }
  public set statNameLength(value: number) {
    this._statNameLength = value;
  }
  public resetStatNameLength() {
    this._statNameLength = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get statNameLengthInput() {
    return this._statNameLength;
  }

  // statsd_udp_address - computed: false, optional: true, required: false
  private _statsdUdpAddress?: string; 
  public get statsdUdpAddress() {
    return this.getStringAttribute('statsd_udp_address');
  }
  public set statsdUdpAddress(value: string) {
    this._statsdUdpAddress = value;
  }
  public resetStatsdUdpAddress() {
    this._statsdUdpAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get statsdUdpAddressInput() {
    return this._statsdUdpAddress;
  }

  // status_port - computed: false, optional: true, required: false
  private _statusPort?: number; 
  public get statusPort() {
    return this.getNumberAttribute('status_port');
  }
  public set statusPort(value: number) {
    this._statusPort = value;
  }
  public resetStatusPort() {
    this._statusPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get statusPortInput() {
    return this._statusPort;
  }

  // termination_drain_duration - computed: false, optional: true, required: false
  private _terminationDrainDuration?: string; 
  public get terminationDrainDuration() {
    return this.getStringAttribute('termination_drain_duration');
  }
  public set terminationDrainDuration(value: string) {
    this._terminationDrainDuration = value;
  }
  public resetTerminationDrainDuration() {
    this._terminationDrainDuration = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get terminationDrainDurationInput() {
    return this._terminationDrainDuration;
  }

  // tracing - computed: false, optional: true, required: false
  private _tracing = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracingOutputReference(this, "tracing");
  public get tracing() {
    return this._tracing;
  }
  public putTracing(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigTracing) {
    this._tracing.internalValue = value;
  }
  public resetTracing() {
    this._tracing.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tracingInput() {
    return this._tracing.internalValue;
  }

  // tracing_service_name - computed: false, optional: true, required: false
  private _tracingServiceName?: string; 
  public get tracingServiceName() {
    return this.getStringAttribute('tracing_service_name');
  }
  public set tracingServiceName(value: string) {
    this._tracingServiceName = value;
  }
  public resetTracingServiceName() {
    this._tracingServiceName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tracingServiceNameInput() {
    return this._tracingServiceName;
  }

  // zipkin_address - computed: false, optional: true, required: false
  private _zipkinAddress?: string; 
  public get zipkinAddress() {
    return this.getStringAttribute('zipkin_address');
  }
  public set zipkinAddress(value: string) {
    this._zipkinAddress = value;
  }
  public resetZipkinAddress() {
    this._zipkinAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get zipkinAddressInput() {
    return this._zipkinAddress;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultHttpRetryPolicy {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#attempts DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#attempts}
  */
  readonly attempts: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#per_try_timeout DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#per_try_timeout}
  */
  readonly perTryTimeout?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#retry_on DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#retry_on}
  */
  readonly retryOn?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#retry_remote_localities DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#retry_remote_localities}
  */
  readonly retryRemoteLocalities?: boolean | cdktf.IResolvable;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultHttpRetryPolicyToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultHttpRetryPolicy | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    attempts: cdktf.numberToTerraform(struct!.attempts),
    per_try_timeout: cdktf.stringToTerraform(struct!.perTryTimeout),
    retry_on: cdktf.stringToTerraform(struct!.retryOn),
    retry_remote_localities: cdktf.booleanToTerraform(struct!.retryRemoteLocalities),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultHttpRetryPolicyToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultHttpRetryPolicy | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    attempts: {
      value: cdktf.numberToHclTerraform(struct!.attempts),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    per_try_timeout: {
      value: cdktf.stringToHclTerraform(struct!.perTryTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    retry_on: {
      value: cdktf.stringToHclTerraform(struct!.retryOn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    retry_remote_localities: {
      value: cdktf.booleanToHclTerraform(struct!.retryRemoteLocalities),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultHttpRetryPolicyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultHttpRetryPolicy | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._attempts !== undefined) {
      hasAnyValues = true;
      internalValueResult.attempts = this._attempts;
    }
    if (this._perTryTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.perTryTimeout = this._perTryTimeout;
    }
    if (this._retryOn !== undefined) {
      hasAnyValues = true;
      internalValueResult.retryOn = this._retryOn;
    }
    if (this._retryRemoteLocalities !== undefined) {
      hasAnyValues = true;
      internalValueResult.retryRemoteLocalities = this._retryRemoteLocalities;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultHttpRetryPolicy | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._attempts = undefined;
      this._perTryTimeout = undefined;
      this._retryOn = undefined;
      this._retryRemoteLocalities = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._attempts = value.attempts;
      this._perTryTimeout = value.perTryTimeout;
      this._retryOn = value.retryOn;
      this._retryRemoteLocalities = value.retryRemoteLocalities;
    }
  }

  // attempts - computed: false, optional: false, required: true
  private _attempts?: number; 
  public get attempts() {
    return this.getNumberAttribute('attempts');
  }
  public set attempts(value: number) {
    this._attempts = value;
  }
  // Temporarily expose input value. Use with caution.
  public get attemptsInput() {
    return this._attempts;
  }

  // per_try_timeout - computed: false, optional: true, required: false
  private _perTryTimeout?: string; 
  public get perTryTimeout() {
    return this.getStringAttribute('per_try_timeout');
  }
  public set perTryTimeout(value: string) {
    this._perTryTimeout = value;
  }
  public resetPerTryTimeout() {
    this._perTryTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get perTryTimeoutInput() {
    return this._perTryTimeout;
  }

  // retry_on - computed: false, optional: true, required: false
  private _retryOn?: string; 
  public get retryOn() {
    return this.getStringAttribute('retry_on');
  }
  public set retryOn(value: string) {
    this._retryOn = value;
  }
  public resetRetryOn() {
    this._retryOn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retryOnInput() {
    return this._retryOn;
  }

  // retry_remote_localities - computed: false, optional: true, required: false
  private _retryRemoteLocalities?: boolean | cdktf.IResolvable; 
  public get retryRemoteLocalities() {
    return this.getBooleanAttribute('retry_remote_localities');
  }
  public set retryRemoteLocalities(value: boolean | cdktf.IResolvable) {
    this._retryRemoteLocalities = value;
  }
  public resetRetryRemoteLocalities() {
    this._retryRemoteLocalities = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retryRemoteLocalitiesInput() {
    return this._retryRemoteLocalities;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultProviders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#access_logging DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#access_logging}
  */
  readonly accessLogging?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#metrics DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#metrics}
  */
  readonly metrics?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#tracing DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#tracing}
  */
  readonly tracing?: string[];
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultProvidersToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultProviders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_logging: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.accessLogging),
    metrics: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.metrics),
    tracing: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.tracing),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultProvidersToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultProviders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_logging: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.accessLogging),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    metrics: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.metrics),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tracing: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.tracing),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultProvidersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultProviders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessLogging !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessLogging = this._accessLogging;
    }
    if (this._metrics !== undefined) {
      hasAnyValues = true;
      internalValueResult.metrics = this._metrics;
    }
    if (this._tracing !== undefined) {
      hasAnyValues = true;
      internalValueResult.tracing = this._tracing;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultProviders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessLogging = undefined;
      this._metrics = undefined;
      this._tracing = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessLogging = value.accessLogging;
      this._metrics = value.metrics;
      this._tracing = value.tracing;
    }
  }

  // access_logging - computed: false, optional: true, required: false
  private _accessLogging?: string[]; 
  public get accessLogging() {
    return this.getListAttribute('access_logging');
  }
  public set accessLogging(value: string[]) {
    this._accessLogging = value;
  }
  public resetAccessLogging() {
    this._accessLogging = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessLoggingInput() {
    return this._accessLogging;
  }

  // metrics - computed: false, optional: true, required: false
  private _metrics?: string[]; 
  public get metrics() {
    return this.getListAttribute('metrics');
  }
  public set metrics(value: string[]) {
    this._metrics = value;
  }
  public resetMetrics() {
    this._metrics = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricsInput() {
    return this._metrics;
  }

  // tracing - computed: false, optional: true, required: false
  private _tracing?: string[]; 
  public get tracing() {
    return this.getListAttribute('tracing');
  }
  public set tracing(value: string[]) {
    this._tracing = value;
  }
  public resetTracing() {
    this._tracing = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tracingInput() {
    return this._tracing;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDiscoverySelectorsMatchExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#key DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#operator DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#operator}
  */
  readonly operator?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#values DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDiscoverySelectorsMatchExpressionsToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDiscoverySelectorsMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDiscoverySelectorsMatchExpressionsToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDiscoverySelectorsMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDiscoverySelectorsMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDiscoverySelectorsMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDiscoverySelectorsMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDiscoverySelectorsMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDiscoverySelectorsMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDiscoverySelectorsMatchExpressionsOutputReference {
    return new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDiscoverySelectorsMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDiscoverySelectors {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#match_expressions DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDiscoverySelectorsMatchExpressions[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#match_labels DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDiscoverySelectorsToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDiscoverySelectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDiscoverySelectorsMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDiscoverySelectorsToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDiscoverySelectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDiscoverySelectorsMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDiscoverySelectorsMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDiscoverySelectorsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDiscoverySelectors | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDiscoverySelectors | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDiscoverySelectorsMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDiscoverySelectorsMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDiscoverySelectorsList extends cdktf.ComplexList {
  public internalValue? : DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDiscoverySelectors[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDiscoverySelectorsOutputReference {
    return new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDiscoverySelectorsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersDatadog {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#max_tag_length DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#max_tag_length}
  */
  readonly maxTagLength?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#port DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#port}
  */
  readonly port?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#service DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#service}
  */
  readonly service?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersDatadogToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersDatadog | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    max_tag_length: cdktf.numberToTerraform(struct!.maxTagLength),
    port: cdktf.numberToTerraform(struct!.port),
    service: cdktf.stringToTerraform(struct!.service),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersDatadogToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersDatadog | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    max_tag_length: {
      value: cdktf.numberToHclTerraform(struct!.maxTagLength),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    service: {
      value: cdktf.stringToHclTerraform(struct!.service),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersDatadogOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersDatadog | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._maxTagLength !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxTagLength = this._maxTagLength;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._service !== undefined) {
      hasAnyValues = true;
      internalValueResult.service = this._service;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersDatadog | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._maxTagLength = undefined;
      this._port = undefined;
      this._service = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._maxTagLength = value.maxTagLength;
      this._port = value.port;
      this._service = value.service;
    }
  }

  // max_tag_length - computed: false, optional: true, required: false
  private _maxTagLength?: number; 
  public get maxTagLength() {
    return this.getNumberAttribute('max_tag_length');
  }
  public set maxTagLength(value: number) {
    this._maxTagLength = value;
  }
  public resetMaxTagLength() {
    this._maxTagLength = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxTagLengthInput() {
    return this._maxTagLength;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // service - computed: false, optional: true, required: false
  private _service?: string; 
  public get service() {
    return this.getStringAttribute('service');
  }
  public set service(value: string) {
    this._service = value;
  }
  public resetService() {
    this._service = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceInput() {
    return this._service;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyExtAuthzGrpcIncludeRequestBodyInCheck {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#allow_partial_message DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#allow_partial_message}
  */
  readonly allowPartialMessage?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#max_request_bytes DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#max_request_bytes}
  */
  readonly maxRequestBytes?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#pack_as_bytes DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#pack_as_bytes}
  */
  readonly packAsBytes?: boolean | cdktf.IResolvable;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyExtAuthzGrpcIncludeRequestBodyInCheckToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyExtAuthzGrpcIncludeRequestBodyInCheck | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_partial_message: cdktf.booleanToTerraform(struct!.allowPartialMessage),
    max_request_bytes: cdktf.numberToTerraform(struct!.maxRequestBytes),
    pack_as_bytes: cdktf.booleanToTerraform(struct!.packAsBytes),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyExtAuthzGrpcIncludeRequestBodyInCheckToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyExtAuthzGrpcIncludeRequestBodyInCheck | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_partial_message: {
      value: cdktf.booleanToHclTerraform(struct!.allowPartialMessage),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_request_bytes: {
      value: cdktf.numberToHclTerraform(struct!.maxRequestBytes),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pack_as_bytes: {
      value: cdktf.booleanToHclTerraform(struct!.packAsBytes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyExtAuthzGrpcIncludeRequestBodyInCheckOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyExtAuthzGrpcIncludeRequestBodyInCheck | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowPartialMessage !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowPartialMessage = this._allowPartialMessage;
    }
    if (this._maxRequestBytes !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRequestBytes = this._maxRequestBytes;
    }
    if (this._packAsBytes !== undefined) {
      hasAnyValues = true;
      internalValueResult.packAsBytes = this._packAsBytes;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyExtAuthzGrpcIncludeRequestBodyInCheck | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allowPartialMessage = undefined;
      this._maxRequestBytes = undefined;
      this._packAsBytes = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allowPartialMessage = value.allowPartialMessage;
      this._maxRequestBytes = value.maxRequestBytes;
      this._packAsBytes = value.packAsBytes;
    }
  }

  // allow_partial_message - computed: false, optional: true, required: false
  private _allowPartialMessage?: boolean | cdktf.IResolvable; 
  public get allowPartialMessage() {
    return this.getBooleanAttribute('allow_partial_message');
  }
  public set allowPartialMessage(value: boolean | cdktf.IResolvable) {
    this._allowPartialMessage = value;
  }
  public resetAllowPartialMessage() {
    this._allowPartialMessage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowPartialMessageInput() {
    return this._allowPartialMessage;
  }

  // max_request_bytes - computed: false, optional: true, required: false
  private _maxRequestBytes?: number; 
  public get maxRequestBytes() {
    return this.getNumberAttribute('max_request_bytes');
  }
  public set maxRequestBytes(value: number) {
    this._maxRequestBytes = value;
  }
  public resetMaxRequestBytes() {
    this._maxRequestBytes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRequestBytesInput() {
    return this._maxRequestBytes;
  }

  // pack_as_bytes - computed: false, optional: true, required: false
  private _packAsBytes?: boolean | cdktf.IResolvable; 
  public get packAsBytes() {
    return this.getBooleanAttribute('pack_as_bytes');
  }
  public set packAsBytes(value: boolean | cdktf.IResolvable) {
    this._packAsBytes = value;
  }
  public resetPackAsBytes() {
    this._packAsBytes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get packAsBytesInput() {
    return this._packAsBytes;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyExtAuthzGrpc {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#fail_open DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#fail_open}
  */
  readonly failOpen?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#include_request_body_in_check DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#include_request_body_in_check}
  */
  readonly includeRequestBodyInCheck?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyExtAuthzGrpcIncludeRequestBodyInCheck;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#port DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#port}
  */
  readonly port?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#service DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#service}
  */
  readonly service?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#status_on_error DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#status_on_error}
  */
  readonly statusOnError?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#timeout DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#timeout}
  */
  readonly timeout?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyExtAuthzGrpcToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyExtAuthzGrpc | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    fail_open: cdktf.booleanToTerraform(struct!.failOpen),
    include_request_body_in_check: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyExtAuthzGrpcIncludeRequestBodyInCheckToTerraform(struct!.includeRequestBodyInCheck),
    port: cdktf.numberToTerraform(struct!.port),
    service: cdktf.stringToTerraform(struct!.service),
    status_on_error: cdktf.stringToTerraform(struct!.statusOnError),
    timeout: cdktf.stringToTerraform(struct!.timeout),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyExtAuthzGrpcToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyExtAuthzGrpc | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    fail_open: {
      value: cdktf.booleanToHclTerraform(struct!.failOpen),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    include_request_body_in_check: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyExtAuthzGrpcIncludeRequestBodyInCheckToHclTerraform(struct!.includeRequestBodyInCheck),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyExtAuthzGrpcIncludeRequestBodyInCheck",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    service: {
      value: cdktf.stringToHclTerraform(struct!.service),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    status_on_error: {
      value: cdktf.stringToHclTerraform(struct!.statusOnError),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout: {
      value: cdktf.stringToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyExtAuthzGrpcOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyExtAuthzGrpc | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._failOpen !== undefined) {
      hasAnyValues = true;
      internalValueResult.failOpen = this._failOpen;
    }
    if (this._includeRequestBodyInCheck?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.includeRequestBodyInCheck = this._includeRequestBodyInCheck?.internalValue;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._service !== undefined) {
      hasAnyValues = true;
      internalValueResult.service = this._service;
    }
    if (this._statusOnError !== undefined) {
      hasAnyValues = true;
      internalValueResult.statusOnError = this._statusOnError;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyExtAuthzGrpc | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._failOpen = undefined;
      this._includeRequestBodyInCheck.internalValue = undefined;
      this._port = undefined;
      this._service = undefined;
      this._statusOnError = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._failOpen = value.failOpen;
      this._includeRequestBodyInCheck.internalValue = value.includeRequestBodyInCheck;
      this._port = value.port;
      this._service = value.service;
      this._statusOnError = value.statusOnError;
      this._timeout = value.timeout;
    }
  }

  // fail_open - computed: false, optional: true, required: false
  private _failOpen?: boolean | cdktf.IResolvable; 
  public get failOpen() {
    return this.getBooleanAttribute('fail_open');
  }
  public set failOpen(value: boolean | cdktf.IResolvable) {
    this._failOpen = value;
  }
  public resetFailOpen() {
    this._failOpen = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failOpenInput() {
    return this._failOpen;
  }

  // include_request_body_in_check - computed: false, optional: true, required: false
  private _includeRequestBodyInCheck = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyExtAuthzGrpcIncludeRequestBodyInCheckOutputReference(this, "include_request_body_in_check");
  public get includeRequestBodyInCheck() {
    return this._includeRequestBodyInCheck;
  }
  public putIncludeRequestBodyInCheck(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyExtAuthzGrpcIncludeRequestBodyInCheck) {
    this._includeRequestBodyInCheck.internalValue = value;
  }
  public resetIncludeRequestBodyInCheck() {
    this._includeRequestBodyInCheck.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get includeRequestBodyInCheckInput() {
    return this._includeRequestBodyInCheck.internalValue;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // service - computed: false, optional: true, required: false
  private _service?: string; 
  public get service() {
    return this.getStringAttribute('service');
  }
  public set service(value: string) {
    this._service = value;
  }
  public resetService() {
    this._service = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceInput() {
    return this._service;
  }

  // status_on_error - computed: false, optional: true, required: false
  private _statusOnError?: string; 
  public get statusOnError() {
    return this.getStringAttribute('status_on_error');
  }
  public set statusOnError(value: string) {
    this._statusOnError = value;
  }
  public resetStatusOnError() {
    this._statusOnError = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get statusOnErrorInput() {
    return this._statusOnError;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: string; 
  public get timeout() {
    return this.getStringAttribute('timeout');
  }
  public set timeout(value: string) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyExtAuthzHttpIncludeRequestBodyInCheck {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#allow_partial_message DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#allow_partial_message}
  */
  readonly allowPartialMessage?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#max_request_bytes DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#max_request_bytes}
  */
  readonly maxRequestBytes?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#pack_as_bytes DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#pack_as_bytes}
  */
  readonly packAsBytes?: boolean | cdktf.IResolvable;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyExtAuthzHttpIncludeRequestBodyInCheckToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyExtAuthzHttpIncludeRequestBodyInCheck | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_partial_message: cdktf.booleanToTerraform(struct!.allowPartialMessage),
    max_request_bytes: cdktf.numberToTerraform(struct!.maxRequestBytes),
    pack_as_bytes: cdktf.booleanToTerraform(struct!.packAsBytes),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyExtAuthzHttpIncludeRequestBodyInCheckToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyExtAuthzHttpIncludeRequestBodyInCheck | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_partial_message: {
      value: cdktf.booleanToHclTerraform(struct!.allowPartialMessage),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_request_bytes: {
      value: cdktf.numberToHclTerraform(struct!.maxRequestBytes),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pack_as_bytes: {
      value: cdktf.booleanToHclTerraform(struct!.packAsBytes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyExtAuthzHttpIncludeRequestBodyInCheckOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyExtAuthzHttpIncludeRequestBodyInCheck | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowPartialMessage !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowPartialMessage = this._allowPartialMessage;
    }
    if (this._maxRequestBytes !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRequestBytes = this._maxRequestBytes;
    }
    if (this._packAsBytes !== undefined) {
      hasAnyValues = true;
      internalValueResult.packAsBytes = this._packAsBytes;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyExtAuthzHttpIncludeRequestBodyInCheck | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allowPartialMessage = undefined;
      this._maxRequestBytes = undefined;
      this._packAsBytes = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allowPartialMessage = value.allowPartialMessage;
      this._maxRequestBytes = value.maxRequestBytes;
      this._packAsBytes = value.packAsBytes;
    }
  }

  // allow_partial_message - computed: false, optional: true, required: false
  private _allowPartialMessage?: boolean | cdktf.IResolvable; 
  public get allowPartialMessage() {
    return this.getBooleanAttribute('allow_partial_message');
  }
  public set allowPartialMessage(value: boolean | cdktf.IResolvable) {
    this._allowPartialMessage = value;
  }
  public resetAllowPartialMessage() {
    this._allowPartialMessage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowPartialMessageInput() {
    return this._allowPartialMessage;
  }

  // max_request_bytes - computed: false, optional: true, required: false
  private _maxRequestBytes?: number; 
  public get maxRequestBytes() {
    return this.getNumberAttribute('max_request_bytes');
  }
  public set maxRequestBytes(value: number) {
    this._maxRequestBytes = value;
  }
  public resetMaxRequestBytes() {
    this._maxRequestBytes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRequestBytesInput() {
    return this._maxRequestBytes;
  }

  // pack_as_bytes - computed: false, optional: true, required: false
  private _packAsBytes?: boolean | cdktf.IResolvable; 
  public get packAsBytes() {
    return this.getBooleanAttribute('pack_as_bytes');
  }
  public set packAsBytes(value: boolean | cdktf.IResolvable) {
    this._packAsBytes = value;
  }
  public resetPackAsBytes() {
    this._packAsBytes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get packAsBytesInput() {
    return this._packAsBytes;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyExtAuthzHttp {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#fail_open DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#fail_open}
  */
  readonly failOpen?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#headers_to_downstream_on_allow DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#headers_to_downstream_on_allow}
  */
  readonly headersToDownstreamOnAllow?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#headers_to_downstream_on_deny DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#headers_to_downstream_on_deny}
  */
  readonly headersToDownstreamOnDeny?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#headers_to_upstream_on_allow DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#headers_to_upstream_on_allow}
  */
  readonly headersToUpstreamOnAllow?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#include_additional_headers_in_check DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#include_additional_headers_in_check}
  */
  readonly includeAdditionalHeadersInCheck?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#include_headers_in_check DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#include_headers_in_check}
  */
  readonly includeHeadersInCheck?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#include_request_body_in_check DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#include_request_body_in_check}
  */
  readonly includeRequestBodyInCheck?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyExtAuthzHttpIncludeRequestBodyInCheck;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#include_request_headers_in_check DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#include_request_headers_in_check}
  */
  readonly includeRequestHeadersInCheck?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#path_prefix DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#path_prefix}
  */
  readonly pathPrefix?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#port DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#port}
  */
  readonly port?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#service DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#service}
  */
  readonly service?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#status_on_error DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#status_on_error}
  */
  readonly statusOnError?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#timeout DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#timeout}
  */
  readonly timeout?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyExtAuthzHttpToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyExtAuthzHttp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    fail_open: cdktf.booleanToTerraform(struct!.failOpen),
    headers_to_downstream_on_allow: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.headersToDownstreamOnAllow),
    headers_to_downstream_on_deny: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.headersToDownstreamOnDeny),
    headers_to_upstream_on_allow: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.headersToUpstreamOnAllow),
    include_additional_headers_in_check: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.includeAdditionalHeadersInCheck),
    include_headers_in_check: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.includeHeadersInCheck),
    include_request_body_in_check: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyExtAuthzHttpIncludeRequestBodyInCheckToTerraform(struct!.includeRequestBodyInCheck),
    include_request_headers_in_check: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.includeRequestHeadersInCheck),
    path_prefix: cdktf.stringToTerraform(struct!.pathPrefix),
    port: cdktf.numberToTerraform(struct!.port),
    service: cdktf.stringToTerraform(struct!.service),
    status_on_error: cdktf.stringToTerraform(struct!.statusOnError),
    timeout: cdktf.stringToTerraform(struct!.timeout),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyExtAuthzHttpToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyExtAuthzHttp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    fail_open: {
      value: cdktf.booleanToHclTerraform(struct!.failOpen),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    headers_to_downstream_on_allow: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.headersToDownstreamOnAllow),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    headers_to_downstream_on_deny: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.headersToDownstreamOnDeny),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    headers_to_upstream_on_allow: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.headersToUpstreamOnAllow),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    include_additional_headers_in_check: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.includeAdditionalHeadersInCheck),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    include_headers_in_check: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.includeHeadersInCheck),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    include_request_body_in_check: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyExtAuthzHttpIncludeRequestBodyInCheckToHclTerraform(struct!.includeRequestBodyInCheck),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyExtAuthzHttpIncludeRequestBodyInCheck",
    },
    include_request_headers_in_check: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.includeRequestHeadersInCheck),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    path_prefix: {
      value: cdktf.stringToHclTerraform(struct!.pathPrefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    service: {
      value: cdktf.stringToHclTerraform(struct!.service),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    status_on_error: {
      value: cdktf.stringToHclTerraform(struct!.statusOnError),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout: {
      value: cdktf.stringToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyExtAuthzHttpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyExtAuthzHttp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._failOpen !== undefined) {
      hasAnyValues = true;
      internalValueResult.failOpen = this._failOpen;
    }
    if (this._headersToDownstreamOnAllow !== undefined) {
      hasAnyValues = true;
      internalValueResult.headersToDownstreamOnAllow = this._headersToDownstreamOnAllow;
    }
    if (this._headersToDownstreamOnDeny !== undefined) {
      hasAnyValues = true;
      internalValueResult.headersToDownstreamOnDeny = this._headersToDownstreamOnDeny;
    }
    if (this._headersToUpstreamOnAllow !== undefined) {
      hasAnyValues = true;
      internalValueResult.headersToUpstreamOnAllow = this._headersToUpstreamOnAllow;
    }
    if (this._includeAdditionalHeadersInCheck !== undefined) {
      hasAnyValues = true;
      internalValueResult.includeAdditionalHeadersInCheck = this._includeAdditionalHeadersInCheck;
    }
    if (this._includeHeadersInCheck !== undefined) {
      hasAnyValues = true;
      internalValueResult.includeHeadersInCheck = this._includeHeadersInCheck;
    }
    if (this._includeRequestBodyInCheck?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.includeRequestBodyInCheck = this._includeRequestBodyInCheck?.internalValue;
    }
    if (this._includeRequestHeadersInCheck !== undefined) {
      hasAnyValues = true;
      internalValueResult.includeRequestHeadersInCheck = this._includeRequestHeadersInCheck;
    }
    if (this._pathPrefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.pathPrefix = this._pathPrefix;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._service !== undefined) {
      hasAnyValues = true;
      internalValueResult.service = this._service;
    }
    if (this._statusOnError !== undefined) {
      hasAnyValues = true;
      internalValueResult.statusOnError = this._statusOnError;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyExtAuthzHttp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._failOpen = undefined;
      this._headersToDownstreamOnAllow = undefined;
      this._headersToDownstreamOnDeny = undefined;
      this._headersToUpstreamOnAllow = undefined;
      this._includeAdditionalHeadersInCheck = undefined;
      this._includeHeadersInCheck = undefined;
      this._includeRequestBodyInCheck.internalValue = undefined;
      this._includeRequestHeadersInCheck = undefined;
      this._pathPrefix = undefined;
      this._port = undefined;
      this._service = undefined;
      this._statusOnError = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._failOpen = value.failOpen;
      this._headersToDownstreamOnAllow = value.headersToDownstreamOnAllow;
      this._headersToDownstreamOnDeny = value.headersToDownstreamOnDeny;
      this._headersToUpstreamOnAllow = value.headersToUpstreamOnAllow;
      this._includeAdditionalHeadersInCheck = value.includeAdditionalHeadersInCheck;
      this._includeHeadersInCheck = value.includeHeadersInCheck;
      this._includeRequestBodyInCheck.internalValue = value.includeRequestBodyInCheck;
      this._includeRequestHeadersInCheck = value.includeRequestHeadersInCheck;
      this._pathPrefix = value.pathPrefix;
      this._port = value.port;
      this._service = value.service;
      this._statusOnError = value.statusOnError;
      this._timeout = value.timeout;
    }
  }

  // fail_open - computed: false, optional: true, required: false
  private _failOpen?: boolean | cdktf.IResolvable; 
  public get failOpen() {
    return this.getBooleanAttribute('fail_open');
  }
  public set failOpen(value: boolean | cdktf.IResolvable) {
    this._failOpen = value;
  }
  public resetFailOpen() {
    this._failOpen = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failOpenInput() {
    return this._failOpen;
  }

  // headers_to_downstream_on_allow - computed: false, optional: true, required: false
  private _headersToDownstreamOnAllow?: string[]; 
  public get headersToDownstreamOnAllow() {
    return this.getListAttribute('headers_to_downstream_on_allow');
  }
  public set headersToDownstreamOnAllow(value: string[]) {
    this._headersToDownstreamOnAllow = value;
  }
  public resetHeadersToDownstreamOnAllow() {
    this._headersToDownstreamOnAllow = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersToDownstreamOnAllowInput() {
    return this._headersToDownstreamOnAllow;
  }

  // headers_to_downstream_on_deny - computed: false, optional: true, required: false
  private _headersToDownstreamOnDeny?: string[]; 
  public get headersToDownstreamOnDeny() {
    return this.getListAttribute('headers_to_downstream_on_deny');
  }
  public set headersToDownstreamOnDeny(value: string[]) {
    this._headersToDownstreamOnDeny = value;
  }
  public resetHeadersToDownstreamOnDeny() {
    this._headersToDownstreamOnDeny = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersToDownstreamOnDenyInput() {
    return this._headersToDownstreamOnDeny;
  }

  // headers_to_upstream_on_allow - computed: false, optional: true, required: false
  private _headersToUpstreamOnAllow?: string[]; 
  public get headersToUpstreamOnAllow() {
    return this.getListAttribute('headers_to_upstream_on_allow');
  }
  public set headersToUpstreamOnAllow(value: string[]) {
    this._headersToUpstreamOnAllow = value;
  }
  public resetHeadersToUpstreamOnAllow() {
    this._headersToUpstreamOnAllow = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersToUpstreamOnAllowInput() {
    return this._headersToUpstreamOnAllow;
  }

  // include_additional_headers_in_check - computed: false, optional: true, required: false
  private _includeAdditionalHeadersInCheck?: { [key: string]: string }; 
  public get includeAdditionalHeadersInCheck() {
    return this.getStringMapAttribute('include_additional_headers_in_check');
  }
  public set includeAdditionalHeadersInCheck(value: { [key: string]: string }) {
    this._includeAdditionalHeadersInCheck = value;
  }
  public resetIncludeAdditionalHeadersInCheck() {
    this._includeAdditionalHeadersInCheck = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get includeAdditionalHeadersInCheckInput() {
    return this._includeAdditionalHeadersInCheck;
  }

  // include_headers_in_check - computed: false, optional: true, required: false
  private _includeHeadersInCheck?: string[]; 
  public get includeHeadersInCheck() {
    return this.getListAttribute('include_headers_in_check');
  }
  public set includeHeadersInCheck(value: string[]) {
    this._includeHeadersInCheck = value;
  }
  public resetIncludeHeadersInCheck() {
    this._includeHeadersInCheck = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get includeHeadersInCheckInput() {
    return this._includeHeadersInCheck;
  }

  // include_request_body_in_check - computed: false, optional: true, required: false
  private _includeRequestBodyInCheck = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyExtAuthzHttpIncludeRequestBodyInCheckOutputReference(this, "include_request_body_in_check");
  public get includeRequestBodyInCheck() {
    return this._includeRequestBodyInCheck;
  }
  public putIncludeRequestBodyInCheck(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyExtAuthzHttpIncludeRequestBodyInCheck) {
    this._includeRequestBodyInCheck.internalValue = value;
  }
  public resetIncludeRequestBodyInCheck() {
    this._includeRequestBodyInCheck.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get includeRequestBodyInCheckInput() {
    return this._includeRequestBodyInCheck.internalValue;
  }

  // include_request_headers_in_check - computed: false, optional: true, required: false
  private _includeRequestHeadersInCheck?: string[]; 
  public get includeRequestHeadersInCheck() {
    return this.getListAttribute('include_request_headers_in_check');
  }
  public set includeRequestHeadersInCheck(value: string[]) {
    this._includeRequestHeadersInCheck = value;
  }
  public resetIncludeRequestHeadersInCheck() {
    this._includeRequestHeadersInCheck = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get includeRequestHeadersInCheckInput() {
    return this._includeRequestHeadersInCheck;
  }

  // path_prefix - computed: false, optional: true, required: false
  private _pathPrefix?: string; 
  public get pathPrefix() {
    return this.getStringAttribute('path_prefix');
  }
  public set pathPrefix(value: string) {
    this._pathPrefix = value;
  }
  public resetPathPrefix() {
    this._pathPrefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathPrefixInput() {
    return this._pathPrefix;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // service - computed: false, optional: true, required: false
  private _service?: string; 
  public get service() {
    return this.getStringAttribute('service');
  }
  public set service(value: string) {
    this._service = value;
  }
  public resetService() {
    this._service = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceInput() {
    return this._service;
  }

  // status_on_error - computed: false, optional: true, required: false
  private _statusOnError?: string; 
  public get statusOnError() {
    return this.getStringAttribute('status_on_error');
  }
  public set statusOnError(value: string) {
    this._statusOnError = value;
  }
  public resetStatusOnError() {
    this._statusOnError = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get statusOnErrorInput() {
    return this._statusOnError;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: string; 
  public get timeout() {
    return this.getStringAttribute('timeout');
  }
  public set timeout(value: string) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyFileAccessLogLogFormat {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#labels DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#labels}
  */
  readonly labels?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#text DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyFileAccessLogLogFormatToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyFileAccessLogLogFormat | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyFileAccessLogLogFormatToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyFileAccessLogLogFormat | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyFileAccessLogLogFormatOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyFileAccessLogLogFormat | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyFileAccessLogLogFormat | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._labels = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._labels = value.labels;
      this._text = value.text;
    }
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyFileAccessLog {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#log_format DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#log_format}
  */
  readonly logFormat?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyFileAccessLogLogFormat;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#path DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#path}
  */
  readonly path?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyFileAccessLogToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyFileAccessLog | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    log_format: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyFileAccessLogLogFormatToTerraform(struct!.logFormat),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyFileAccessLogToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyFileAccessLog | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    log_format: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyFileAccessLogLogFormatToHclTerraform(struct!.logFormat),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyFileAccessLogLogFormat",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyFileAccessLogOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyFileAccessLog | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._logFormat?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.logFormat = this._logFormat?.internalValue;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyFileAccessLog | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._logFormat.internalValue = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._logFormat.internalValue = value.logFormat;
      this._path = value.path;
    }
  }

  // log_format - computed: false, optional: true, required: false
  private _logFormat = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyFileAccessLogLogFormatOutputReference(this, "log_format");
  public get logFormat() {
    return this._logFormat;
  }
  public putLogFormat(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyFileAccessLogLogFormat) {
    this._logFormat.internalValue = value;
  }
  public resetLogFormat() {
    this._logFormat.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logFormatInput() {
    return this._logFormat.internalValue;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyHttpAls {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#additional_request_headers_to_log DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#additional_request_headers_to_log}
  */
  readonly additionalRequestHeadersToLog?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#additional_response_headers_to_log DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#additional_response_headers_to_log}
  */
  readonly additionalResponseHeadersToLog?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#additional_response_trailers_to_log DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#additional_response_trailers_to_log}
  */
  readonly additionalResponseTrailersToLog?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#filter_state_objects_to_log DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#filter_state_objects_to_log}
  */
  readonly filterStateObjectsToLog?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#log_name DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#log_name}
  */
  readonly logName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#port DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#port}
  */
  readonly port?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#service DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#service}
  */
  readonly service?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyHttpAlsToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyHttpAls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    additional_request_headers_to_log: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.additionalRequestHeadersToLog),
    additional_response_headers_to_log: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.additionalResponseHeadersToLog),
    additional_response_trailers_to_log: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.additionalResponseTrailersToLog),
    filter_state_objects_to_log: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.filterStateObjectsToLog),
    log_name: cdktf.stringToTerraform(struct!.logName),
    port: cdktf.numberToTerraform(struct!.port),
    service: cdktf.stringToTerraform(struct!.service),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyHttpAlsToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyHttpAls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    additional_request_headers_to_log: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.additionalRequestHeadersToLog),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    additional_response_headers_to_log: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.additionalResponseHeadersToLog),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    additional_response_trailers_to_log: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.additionalResponseTrailersToLog),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    filter_state_objects_to_log: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.filterStateObjectsToLog),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    log_name: {
      value: cdktf.stringToHclTerraform(struct!.logName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    service: {
      value: cdktf.stringToHclTerraform(struct!.service),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyHttpAlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyHttpAls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._additionalRequestHeadersToLog !== undefined) {
      hasAnyValues = true;
      internalValueResult.additionalRequestHeadersToLog = this._additionalRequestHeadersToLog;
    }
    if (this._additionalResponseHeadersToLog !== undefined) {
      hasAnyValues = true;
      internalValueResult.additionalResponseHeadersToLog = this._additionalResponseHeadersToLog;
    }
    if (this._additionalResponseTrailersToLog !== undefined) {
      hasAnyValues = true;
      internalValueResult.additionalResponseTrailersToLog = this._additionalResponseTrailersToLog;
    }
    if (this._filterStateObjectsToLog !== undefined) {
      hasAnyValues = true;
      internalValueResult.filterStateObjectsToLog = this._filterStateObjectsToLog;
    }
    if (this._logName !== undefined) {
      hasAnyValues = true;
      internalValueResult.logName = this._logName;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._service !== undefined) {
      hasAnyValues = true;
      internalValueResult.service = this._service;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyHttpAls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._additionalRequestHeadersToLog = undefined;
      this._additionalResponseHeadersToLog = undefined;
      this._additionalResponseTrailersToLog = undefined;
      this._filterStateObjectsToLog = undefined;
      this._logName = undefined;
      this._port = undefined;
      this._service = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._additionalRequestHeadersToLog = value.additionalRequestHeadersToLog;
      this._additionalResponseHeadersToLog = value.additionalResponseHeadersToLog;
      this._additionalResponseTrailersToLog = value.additionalResponseTrailersToLog;
      this._filterStateObjectsToLog = value.filterStateObjectsToLog;
      this._logName = value.logName;
      this._port = value.port;
      this._service = value.service;
    }
  }

  // additional_request_headers_to_log - computed: false, optional: true, required: false
  private _additionalRequestHeadersToLog?: string[]; 
  public get additionalRequestHeadersToLog() {
    return this.getListAttribute('additional_request_headers_to_log');
  }
  public set additionalRequestHeadersToLog(value: string[]) {
    this._additionalRequestHeadersToLog = value;
  }
  public resetAdditionalRequestHeadersToLog() {
    this._additionalRequestHeadersToLog = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get additionalRequestHeadersToLogInput() {
    return this._additionalRequestHeadersToLog;
  }

  // additional_response_headers_to_log - computed: false, optional: true, required: false
  private _additionalResponseHeadersToLog?: string[]; 
  public get additionalResponseHeadersToLog() {
    return this.getListAttribute('additional_response_headers_to_log');
  }
  public set additionalResponseHeadersToLog(value: string[]) {
    this._additionalResponseHeadersToLog = value;
  }
  public resetAdditionalResponseHeadersToLog() {
    this._additionalResponseHeadersToLog = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get additionalResponseHeadersToLogInput() {
    return this._additionalResponseHeadersToLog;
  }

  // additional_response_trailers_to_log - computed: false, optional: true, required: false
  private _additionalResponseTrailersToLog?: string[]; 
  public get additionalResponseTrailersToLog() {
    return this.getListAttribute('additional_response_trailers_to_log');
  }
  public set additionalResponseTrailersToLog(value: string[]) {
    this._additionalResponseTrailersToLog = value;
  }
  public resetAdditionalResponseTrailersToLog() {
    this._additionalResponseTrailersToLog = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get additionalResponseTrailersToLogInput() {
    return this._additionalResponseTrailersToLog;
  }

  // filter_state_objects_to_log - computed: false, optional: true, required: false
  private _filterStateObjectsToLog?: string[]; 
  public get filterStateObjectsToLog() {
    return this.getListAttribute('filter_state_objects_to_log');
  }
  public set filterStateObjectsToLog(value: string[]) {
    this._filterStateObjectsToLog = value;
  }
  public resetFilterStateObjectsToLog() {
    this._filterStateObjectsToLog = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get filterStateObjectsToLogInput() {
    return this._filterStateObjectsToLog;
  }

  // log_name - computed: false, optional: true, required: false
  private _logName?: string; 
  public get logName() {
    return this.getStringAttribute('log_name');
  }
  public set logName(value: string) {
    this._logName = value;
  }
  public resetLogName() {
    this._logName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logNameInput() {
    return this._logName;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // service - computed: false, optional: true, required: false
  private _service?: string; 
  public get service() {
    return this.getStringAttribute('service');
  }
  public set service(value: string) {
    this._service = value;
  }
  public resetService() {
    this._service = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceInput() {
    return this._service;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyOtelAlsLogFormat {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#labels DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#labels}
  */
  readonly labels?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#text DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyOtelAlsLogFormatToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyOtelAlsLogFormat | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyOtelAlsLogFormatToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyOtelAlsLogFormat | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyOtelAlsLogFormatOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyOtelAlsLogFormat | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyOtelAlsLogFormat | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._labels = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._labels = value.labels;
      this._text = value.text;
    }
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyOtelAls {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#log_format DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#log_format}
  */
  readonly logFormat?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyOtelAlsLogFormat;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#log_name DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#log_name}
  */
  readonly logName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#port DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#port}
  */
  readonly port?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#service DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#service}
  */
  readonly service?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyOtelAlsToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyOtelAls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    log_format: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyOtelAlsLogFormatToTerraform(struct!.logFormat),
    log_name: cdktf.stringToTerraform(struct!.logName),
    port: cdktf.numberToTerraform(struct!.port),
    service: cdktf.stringToTerraform(struct!.service),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyOtelAlsToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyOtelAls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    log_format: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyOtelAlsLogFormatToHclTerraform(struct!.logFormat),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyOtelAlsLogFormat",
    },
    log_name: {
      value: cdktf.stringToHclTerraform(struct!.logName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    service: {
      value: cdktf.stringToHclTerraform(struct!.service),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyOtelAlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyOtelAls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._logFormat?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.logFormat = this._logFormat?.internalValue;
    }
    if (this._logName !== undefined) {
      hasAnyValues = true;
      internalValueResult.logName = this._logName;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._service !== undefined) {
      hasAnyValues = true;
      internalValueResult.service = this._service;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyOtelAls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._logFormat.internalValue = undefined;
      this._logName = undefined;
      this._port = undefined;
      this._service = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._logFormat.internalValue = value.logFormat;
      this._logName = value.logName;
      this._port = value.port;
      this._service = value.service;
    }
  }

  // log_format - computed: false, optional: true, required: false
  private _logFormat = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyOtelAlsLogFormatOutputReference(this, "log_format");
  public get logFormat() {
    return this._logFormat;
  }
  public putLogFormat(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyOtelAlsLogFormat) {
    this._logFormat.internalValue = value;
  }
  public resetLogFormat() {
    this._logFormat.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logFormatInput() {
    return this._logFormat.internalValue;
  }

  // log_name - computed: false, optional: true, required: false
  private _logName?: string; 
  public get logName() {
    return this.getStringAttribute('log_name');
  }
  public set logName(value: string) {
    this._logName = value;
  }
  public resetLogName() {
    this._logName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logNameInput() {
    return this._logName;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // service - computed: false, optional: true, required: false
  private _service?: string; 
  public get service() {
    return this.getStringAttribute('service');
  }
  public set service(value: string) {
    this._service = value;
  }
  public resetService() {
    this._service = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceInput() {
    return this._service;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyTcpAls {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#filter_state_objects_to_log DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#filter_state_objects_to_log}
  */
  readonly filterStateObjectsToLog?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#log_name DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#log_name}
  */
  readonly logName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#port DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#port}
  */
  readonly port?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#service DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#service}
  */
  readonly service?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyTcpAlsToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyTcpAls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    filter_state_objects_to_log: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.filterStateObjectsToLog),
    log_name: cdktf.stringToTerraform(struct!.logName),
    port: cdktf.numberToTerraform(struct!.port),
    service: cdktf.stringToTerraform(struct!.service),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyTcpAlsToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyTcpAls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    filter_state_objects_to_log: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.filterStateObjectsToLog),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    log_name: {
      value: cdktf.stringToHclTerraform(struct!.logName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    service: {
      value: cdktf.stringToHclTerraform(struct!.service),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyTcpAlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyTcpAls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._filterStateObjectsToLog !== undefined) {
      hasAnyValues = true;
      internalValueResult.filterStateObjectsToLog = this._filterStateObjectsToLog;
    }
    if (this._logName !== undefined) {
      hasAnyValues = true;
      internalValueResult.logName = this._logName;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._service !== undefined) {
      hasAnyValues = true;
      internalValueResult.service = this._service;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyTcpAls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._filterStateObjectsToLog = undefined;
      this._logName = undefined;
      this._port = undefined;
      this._service = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._filterStateObjectsToLog = value.filterStateObjectsToLog;
      this._logName = value.logName;
      this._port = value.port;
      this._service = value.service;
    }
  }

  // filter_state_objects_to_log - computed: false, optional: true, required: false
  private _filterStateObjectsToLog?: string[]; 
  public get filterStateObjectsToLog() {
    return this.getListAttribute('filter_state_objects_to_log');
  }
  public set filterStateObjectsToLog(value: string[]) {
    this._filterStateObjectsToLog = value;
  }
  public resetFilterStateObjectsToLog() {
    this._filterStateObjectsToLog = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get filterStateObjectsToLogInput() {
    return this._filterStateObjectsToLog;
  }

  // log_name - computed: false, optional: true, required: false
  private _logName?: string; 
  public get logName() {
    return this.getStringAttribute('log_name');
  }
  public set logName(value: string) {
    this._logName = value;
  }
  public resetLogName() {
    this._logName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logNameInput() {
    return this._logName;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // service - computed: false, optional: true, required: false
  private _service?: string; 
  public get service() {
    return this.getStringAttribute('service');
  }
  public set service(value: string) {
    this._service = value;
  }
  public resetService() {
    this._service = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceInput() {
    return this._service;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersLightstep {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#access_token DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#access_token}
  */
  readonly accessToken?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#max_tag_length DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#max_tag_length}
  */
  readonly maxTagLength?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#port DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#port}
  */
  readonly port?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#service DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#service}
  */
  readonly service?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersLightstepToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersLightstep | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_token: cdktf.stringToTerraform(struct!.accessToken),
    max_tag_length: cdktf.numberToTerraform(struct!.maxTagLength),
    port: cdktf.numberToTerraform(struct!.port),
    service: cdktf.stringToTerraform(struct!.service),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersLightstepToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersLightstep | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_token: {
      value: cdktf.stringToHclTerraform(struct!.accessToken),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_tag_length: {
      value: cdktf.numberToHclTerraform(struct!.maxTagLength),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    service: {
      value: cdktf.stringToHclTerraform(struct!.service),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersLightstepOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersLightstep | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessToken !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessToken = this._accessToken;
    }
    if (this._maxTagLength !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxTagLength = this._maxTagLength;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._service !== undefined) {
      hasAnyValues = true;
      internalValueResult.service = this._service;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersLightstep | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessToken = undefined;
      this._maxTagLength = undefined;
      this._port = undefined;
      this._service = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessToken = value.accessToken;
      this._maxTagLength = value.maxTagLength;
      this._port = value.port;
      this._service = value.service;
    }
  }

  // access_token - computed: false, optional: true, required: false
  private _accessToken?: string; 
  public get accessToken() {
    return this.getStringAttribute('access_token');
  }
  public set accessToken(value: string) {
    this._accessToken = value;
  }
  public resetAccessToken() {
    this._accessToken = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessTokenInput() {
    return this._accessToken;
  }

  // max_tag_length - computed: false, optional: true, required: false
  private _maxTagLength?: number; 
  public get maxTagLength() {
    return this.getNumberAttribute('max_tag_length');
  }
  public set maxTagLength(value: number) {
    this._maxTagLength = value;
  }
  public resetMaxTagLength() {
    this._maxTagLength = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxTagLengthInput() {
    return this._maxTagLength;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // service - computed: false, optional: true, required: false
  private _service?: string; 
  public get service() {
    return this.getStringAttribute('service');
  }
  public set service(value: string) {
    this._service = value;
  }
  public resetService() {
    this._service = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceInput() {
    return this._service;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersOpencensus {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#context DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#context}
  */
  readonly context?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#max_tag_length DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#max_tag_length}
  */
  readonly maxTagLength?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#port DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#port}
  */
  readonly port?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#service DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#service}
  */
  readonly service?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersOpencensusToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersOpencensus | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    context: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.context),
    max_tag_length: cdktf.numberToTerraform(struct!.maxTagLength),
    port: cdktf.numberToTerraform(struct!.port),
    service: cdktf.stringToTerraform(struct!.service),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersOpencensusToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersOpencensus | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    context: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.context),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    max_tag_length: {
      value: cdktf.numberToHclTerraform(struct!.maxTagLength),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    service: {
      value: cdktf.stringToHclTerraform(struct!.service),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersOpencensusOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersOpencensus | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._context !== undefined) {
      hasAnyValues = true;
      internalValueResult.context = this._context;
    }
    if (this._maxTagLength !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxTagLength = this._maxTagLength;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._service !== undefined) {
      hasAnyValues = true;
      internalValueResult.service = this._service;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersOpencensus | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._context = undefined;
      this._maxTagLength = undefined;
      this._port = undefined;
      this._service = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._context = value.context;
      this._maxTagLength = value.maxTagLength;
      this._port = value.port;
      this._service = value.service;
    }
  }

  // context - computed: false, optional: true, required: false
  private _context?: string[]; 
  public get context() {
    return this.getListAttribute('context');
  }
  public set context(value: string[]) {
    this._context = value;
  }
  public resetContext() {
    this._context = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contextInput() {
    return this._context;
  }

  // max_tag_length - computed: false, optional: true, required: false
  private _maxTagLength?: number; 
  public get maxTagLength() {
    return this.getNumberAttribute('max_tag_length');
  }
  public set maxTagLength(value: number) {
    this._maxTagLength = value;
  }
  public resetMaxTagLength() {
    this._maxTagLength = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxTagLengthInput() {
    return this._maxTagLength;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // service - computed: false, optional: true, required: false
  private _service?: string; 
  public get service() {
    return this.getStringAttribute('service');
  }
  public set service(value: string) {
    this._service = value;
  }
  public resetService() {
    this._service = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceInput() {
    return this._service;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersOpentelemetry {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#max_tag_length DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#max_tag_length}
  */
  readonly maxTagLength?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#port DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#port}
  */
  readonly port?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#service DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#service}
  */
  readonly service?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersOpentelemetryToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersOpentelemetry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    max_tag_length: cdktf.numberToTerraform(struct!.maxTagLength),
    port: cdktf.numberToTerraform(struct!.port),
    service: cdktf.stringToTerraform(struct!.service),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersOpentelemetryToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersOpentelemetry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    max_tag_length: {
      value: cdktf.numberToHclTerraform(struct!.maxTagLength),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    service: {
      value: cdktf.stringToHclTerraform(struct!.service),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersOpentelemetryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersOpentelemetry | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._maxTagLength !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxTagLength = this._maxTagLength;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._service !== undefined) {
      hasAnyValues = true;
      internalValueResult.service = this._service;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersOpentelemetry | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._maxTagLength = undefined;
      this._port = undefined;
      this._service = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._maxTagLength = value.maxTagLength;
      this._port = value.port;
      this._service = value.service;
    }
  }

  // max_tag_length - computed: false, optional: true, required: false
  private _maxTagLength?: number; 
  public get maxTagLength() {
    return this.getNumberAttribute('max_tag_length');
  }
  public set maxTagLength(value: number) {
    this._maxTagLength = value;
  }
  public resetMaxTagLength() {
    this._maxTagLength = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxTagLengthInput() {
    return this._maxTagLength;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // service - computed: false, optional: true, required: false
  private _service?: string; 
  public get service() {
    return this.getStringAttribute('service');
  }
  public set service(value: string) {
    this._service = value;
  }
  public resetService() {
    this._service = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceInput() {
    return this._service;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersSkywalking {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#access_token DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#access_token}
  */
  readonly accessToken?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#port DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#port}
  */
  readonly port?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#service DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#service}
  */
  readonly service?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersSkywalkingToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersSkywalking | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_token: cdktf.stringToTerraform(struct!.accessToken),
    port: cdktf.numberToTerraform(struct!.port),
    service: cdktf.stringToTerraform(struct!.service),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersSkywalkingToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersSkywalking | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_token: {
      value: cdktf.stringToHclTerraform(struct!.accessToken),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    service: {
      value: cdktf.stringToHclTerraform(struct!.service),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersSkywalkingOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersSkywalking | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessToken !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessToken = this._accessToken;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._service !== undefined) {
      hasAnyValues = true;
      internalValueResult.service = this._service;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersSkywalking | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessToken = undefined;
      this._port = undefined;
      this._service = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessToken = value.accessToken;
      this._port = value.port;
      this._service = value.service;
    }
  }

  // access_token - computed: false, optional: true, required: false
  private _accessToken?: string; 
  public get accessToken() {
    return this.getStringAttribute('access_token');
  }
  public set accessToken(value: string) {
    this._accessToken = value;
  }
  public resetAccessToken() {
    this._accessToken = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessTokenInput() {
    return this._accessToken;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // service - computed: false, optional: true, required: false
  private _service?: string; 
  public get service() {
    return this.getStringAttribute('service');
  }
  public set service(value: string) {
    this._service = value;
  }
  public resetService() {
    this._service = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceInput() {
    return this._service;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersStackdriverLogging {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#labels DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#labels}
  */
  readonly labels?: { [key: string]: string };
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersStackdriverLoggingToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersStackdriverLogging | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersStackdriverLoggingToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersStackdriverLogging | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersStackdriverLoggingOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersStackdriverLogging | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersStackdriverLogging | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._labels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._labels = value.labels;
    }
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersStackdriver {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#debug DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#debug}
  */
  readonly debug?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#logging DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#logging}
  */
  readonly logging?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersStackdriverLogging;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#max_number_of_annotations DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#max_number_of_annotations}
  */
  readonly maxNumberOfAnnotations?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#max_number_of_attributes DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#max_number_of_attributes}
  */
  readonly maxNumberOfAttributes?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#max_number_of_message_events DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#max_number_of_message_events}
  */
  readonly maxNumberOfMessageEvents?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#max_tag_length DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#max_tag_length}
  */
  readonly maxTagLength?: number;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersStackdriverToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersStackdriver | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    debug: cdktf.booleanToTerraform(struct!.debug),
    logging: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersStackdriverLoggingToTerraform(struct!.logging),
    max_number_of_annotations: cdktf.numberToTerraform(struct!.maxNumberOfAnnotations),
    max_number_of_attributes: cdktf.numberToTerraform(struct!.maxNumberOfAttributes),
    max_number_of_message_events: cdktf.numberToTerraform(struct!.maxNumberOfMessageEvents),
    max_tag_length: cdktf.numberToTerraform(struct!.maxTagLength),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersStackdriverToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersStackdriver | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    debug: {
      value: cdktf.booleanToHclTerraform(struct!.debug),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    logging: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersStackdriverLoggingToHclTerraform(struct!.logging),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersStackdriverLogging",
    },
    max_number_of_annotations: {
      value: cdktf.numberToHclTerraform(struct!.maxNumberOfAnnotations),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_number_of_attributes: {
      value: cdktf.numberToHclTerraform(struct!.maxNumberOfAttributes),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_number_of_message_events: {
      value: cdktf.numberToHclTerraform(struct!.maxNumberOfMessageEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_tag_length: {
      value: cdktf.numberToHclTerraform(struct!.maxTagLength),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersStackdriverOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersStackdriver | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._debug !== undefined) {
      hasAnyValues = true;
      internalValueResult.debug = this._debug;
    }
    if (this._logging?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.logging = this._logging?.internalValue;
    }
    if (this._maxNumberOfAnnotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxNumberOfAnnotations = this._maxNumberOfAnnotations;
    }
    if (this._maxNumberOfAttributes !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxNumberOfAttributes = this._maxNumberOfAttributes;
    }
    if (this._maxNumberOfMessageEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxNumberOfMessageEvents = this._maxNumberOfMessageEvents;
    }
    if (this._maxTagLength !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxTagLength = this._maxTagLength;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersStackdriver | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._debug = undefined;
      this._logging.internalValue = undefined;
      this._maxNumberOfAnnotations = undefined;
      this._maxNumberOfAttributes = undefined;
      this._maxNumberOfMessageEvents = undefined;
      this._maxTagLength = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._debug = value.debug;
      this._logging.internalValue = value.logging;
      this._maxNumberOfAnnotations = value.maxNumberOfAnnotations;
      this._maxNumberOfAttributes = value.maxNumberOfAttributes;
      this._maxNumberOfMessageEvents = value.maxNumberOfMessageEvents;
      this._maxTagLength = value.maxTagLength;
    }
  }

  // debug - computed: false, optional: true, required: false
  private _debug?: boolean | cdktf.IResolvable; 
  public get debug() {
    return this.getBooleanAttribute('debug');
  }
  public set debug(value: boolean | cdktf.IResolvable) {
    this._debug = value;
  }
  public resetDebug() {
    this._debug = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get debugInput() {
    return this._debug;
  }

  // logging - computed: false, optional: true, required: false
  private _logging = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersStackdriverLoggingOutputReference(this, "logging");
  public get logging() {
    return this._logging;
  }
  public putLogging(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersStackdriverLogging) {
    this._logging.internalValue = value;
  }
  public resetLogging() {
    this._logging.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loggingInput() {
    return this._logging.internalValue;
  }

  // max_number_of_annotations - computed: false, optional: true, required: false
  private _maxNumberOfAnnotations?: number; 
  public get maxNumberOfAnnotations() {
    return this.getNumberAttribute('max_number_of_annotations');
  }
  public set maxNumberOfAnnotations(value: number) {
    this._maxNumberOfAnnotations = value;
  }
  public resetMaxNumberOfAnnotations() {
    this._maxNumberOfAnnotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxNumberOfAnnotationsInput() {
    return this._maxNumberOfAnnotations;
  }

  // max_number_of_attributes - computed: false, optional: true, required: false
  private _maxNumberOfAttributes?: number; 
  public get maxNumberOfAttributes() {
    return this.getNumberAttribute('max_number_of_attributes');
  }
  public set maxNumberOfAttributes(value: number) {
    this._maxNumberOfAttributes = value;
  }
  public resetMaxNumberOfAttributes() {
    this._maxNumberOfAttributes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxNumberOfAttributesInput() {
    return this._maxNumberOfAttributes;
  }

  // max_number_of_message_events - computed: false, optional: true, required: false
  private _maxNumberOfMessageEvents?: number; 
  public get maxNumberOfMessageEvents() {
    return this.getNumberAttribute('max_number_of_message_events');
  }
  public set maxNumberOfMessageEvents(value: number) {
    this._maxNumberOfMessageEvents = value;
  }
  public resetMaxNumberOfMessageEvents() {
    this._maxNumberOfMessageEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxNumberOfMessageEventsInput() {
    return this._maxNumberOfMessageEvents;
  }

  // max_tag_length - computed: false, optional: true, required: false
  private _maxTagLength?: number; 
  public get maxTagLength() {
    return this.getNumberAttribute('max_tag_length');
  }
  public set maxTagLength(value: number) {
    this._maxTagLength = value;
  }
  public resetMaxTagLength() {
    this._maxTagLength = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxTagLengthInput() {
    return this._maxTagLength;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersZipkin {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#max_tag_length DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#max_tag_length}
  */
  readonly maxTagLength?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#port DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#port}
  */
  readonly port?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#service DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#service}
  */
  readonly service?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersZipkinToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersZipkin | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    max_tag_length: cdktf.numberToTerraform(struct!.maxTagLength),
    port: cdktf.numberToTerraform(struct!.port),
    service: cdktf.stringToTerraform(struct!.service),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersZipkinToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersZipkin | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    max_tag_length: {
      value: cdktf.numberToHclTerraform(struct!.maxTagLength),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    service: {
      value: cdktf.stringToHclTerraform(struct!.service),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersZipkinOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersZipkin | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._maxTagLength !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxTagLength = this._maxTagLength;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._service !== undefined) {
      hasAnyValues = true;
      internalValueResult.service = this._service;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersZipkin | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._maxTagLength = undefined;
      this._port = undefined;
      this._service = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._maxTagLength = value.maxTagLength;
      this._port = value.port;
      this._service = value.service;
    }
  }

  // max_tag_length - computed: false, optional: true, required: false
  private _maxTagLength?: number; 
  public get maxTagLength() {
    return this.getNumberAttribute('max_tag_length');
  }
  public set maxTagLength(value: number) {
    this._maxTagLength = value;
  }
  public resetMaxTagLength() {
    this._maxTagLength = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxTagLengthInput() {
    return this._maxTagLength;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // service - computed: false, optional: true, required: false
  private _service?: string; 
  public get service() {
    return this.getStringAttribute('service');
  }
  public set service(value: string) {
    this._service = value;
  }
  public resetService() {
    this._service = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceInput() {
    return this._service;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProviders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#datadog DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#datadog}
  */
  readonly datadog?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersDatadog;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#envoy_ext_authz_grpc DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#envoy_ext_authz_grpc}
  */
  readonly envoyExtAuthzGrpc?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyExtAuthzGrpc;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#envoy_ext_authz_http DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#envoy_ext_authz_http}
  */
  readonly envoyExtAuthzHttp?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyExtAuthzHttp;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#envoy_file_access_log DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#envoy_file_access_log}
  */
  readonly envoyFileAccessLog?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyFileAccessLog;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#envoy_http_als DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#envoy_http_als}
  */
  readonly envoyHttpAls?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyHttpAls;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#envoy_otel_als DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#envoy_otel_als}
  */
  readonly envoyOtelAls?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyOtelAls;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#envoy_tcp_als DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#envoy_tcp_als}
  */
  readonly envoyTcpAls?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyTcpAls;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#lightstep DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#lightstep}
  */
  readonly lightstep?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersLightstep;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#name DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#opencensus DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#opencensus}
  */
  readonly opencensus?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersOpencensus;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#opentelemetry DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#opentelemetry}
  */
  readonly opentelemetry?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersOpentelemetry;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#prometheus DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#prometheus}
  */
  readonly prometheus?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#skywalking DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#skywalking}
  */
  readonly skywalking?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersSkywalking;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#stackdriver DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#stackdriver}
  */
  readonly stackdriver?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersStackdriver;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#zipkin DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#zipkin}
  */
  readonly zipkin?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersZipkin;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProviders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    datadog: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersDatadogToTerraform(struct!.datadog),
    envoy_ext_authz_grpc: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyExtAuthzGrpcToTerraform(struct!.envoyExtAuthzGrpc),
    envoy_ext_authz_http: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyExtAuthzHttpToTerraform(struct!.envoyExtAuthzHttp),
    envoy_file_access_log: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyFileAccessLogToTerraform(struct!.envoyFileAccessLog),
    envoy_http_als: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyHttpAlsToTerraform(struct!.envoyHttpAls),
    envoy_otel_als: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyOtelAlsToTerraform(struct!.envoyOtelAls),
    envoy_tcp_als: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyTcpAlsToTerraform(struct!.envoyTcpAls),
    lightstep: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersLightstepToTerraform(struct!.lightstep),
    name: cdktf.stringToTerraform(struct!.name),
    opencensus: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersOpencensusToTerraform(struct!.opencensus),
    opentelemetry: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersOpentelemetryToTerraform(struct!.opentelemetry),
    prometheus: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.prometheus),
    skywalking: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersSkywalkingToTerraform(struct!.skywalking),
    stackdriver: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersStackdriverToTerraform(struct!.stackdriver),
    zipkin: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersZipkinToTerraform(struct!.zipkin),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProviders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    datadog: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersDatadogToHclTerraform(struct!.datadog),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersDatadog",
    },
    envoy_ext_authz_grpc: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyExtAuthzGrpcToHclTerraform(struct!.envoyExtAuthzGrpc),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyExtAuthzGrpc",
    },
    envoy_ext_authz_http: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyExtAuthzHttpToHclTerraform(struct!.envoyExtAuthzHttp),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyExtAuthzHttp",
    },
    envoy_file_access_log: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyFileAccessLogToHclTerraform(struct!.envoyFileAccessLog),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyFileAccessLog",
    },
    envoy_http_als: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyHttpAlsToHclTerraform(struct!.envoyHttpAls),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyHttpAls",
    },
    envoy_otel_als: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyOtelAlsToHclTerraform(struct!.envoyOtelAls),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyOtelAls",
    },
    envoy_tcp_als: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyTcpAlsToHclTerraform(struct!.envoyTcpAls),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyTcpAls",
    },
    lightstep: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersLightstepToHclTerraform(struct!.lightstep),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersLightstep",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    opencensus: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersOpencensusToHclTerraform(struct!.opencensus),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersOpencensus",
    },
    opentelemetry: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersOpentelemetryToHclTerraform(struct!.opentelemetry),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersOpentelemetry",
    },
    prometheus: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.prometheus),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    skywalking: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersSkywalkingToHclTerraform(struct!.skywalking),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersSkywalking",
    },
    stackdriver: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersStackdriverToHclTerraform(struct!.stackdriver),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersStackdriver",
    },
    zipkin: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersZipkinToHclTerraform(struct!.zipkin),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersZipkin",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProviders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._datadog?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.datadog = this._datadog?.internalValue;
    }
    if (this._envoyExtAuthzGrpc?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.envoyExtAuthzGrpc = this._envoyExtAuthzGrpc?.internalValue;
    }
    if (this._envoyExtAuthzHttp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.envoyExtAuthzHttp = this._envoyExtAuthzHttp?.internalValue;
    }
    if (this._envoyFileAccessLog?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.envoyFileAccessLog = this._envoyFileAccessLog?.internalValue;
    }
    if (this._envoyHttpAls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.envoyHttpAls = this._envoyHttpAls?.internalValue;
    }
    if (this._envoyOtelAls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.envoyOtelAls = this._envoyOtelAls?.internalValue;
    }
    if (this._envoyTcpAls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.envoyTcpAls = this._envoyTcpAls?.internalValue;
    }
    if (this._lightstep?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.lightstep = this._lightstep?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._opencensus?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.opencensus = this._opencensus?.internalValue;
    }
    if (this._opentelemetry?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.opentelemetry = this._opentelemetry?.internalValue;
    }
    if (this._prometheus !== undefined) {
      hasAnyValues = true;
      internalValueResult.prometheus = this._prometheus;
    }
    if (this._skywalking?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.skywalking = this._skywalking?.internalValue;
    }
    if (this._stackdriver?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.stackdriver = this._stackdriver?.internalValue;
    }
    if (this._zipkin?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.zipkin = this._zipkin?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProviders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._datadog.internalValue = undefined;
      this._envoyExtAuthzGrpc.internalValue = undefined;
      this._envoyExtAuthzHttp.internalValue = undefined;
      this._envoyFileAccessLog.internalValue = undefined;
      this._envoyHttpAls.internalValue = undefined;
      this._envoyOtelAls.internalValue = undefined;
      this._envoyTcpAls.internalValue = undefined;
      this._lightstep.internalValue = undefined;
      this._name = undefined;
      this._opencensus.internalValue = undefined;
      this._opentelemetry.internalValue = undefined;
      this._prometheus = undefined;
      this._skywalking.internalValue = undefined;
      this._stackdriver.internalValue = undefined;
      this._zipkin.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._datadog.internalValue = value.datadog;
      this._envoyExtAuthzGrpc.internalValue = value.envoyExtAuthzGrpc;
      this._envoyExtAuthzHttp.internalValue = value.envoyExtAuthzHttp;
      this._envoyFileAccessLog.internalValue = value.envoyFileAccessLog;
      this._envoyHttpAls.internalValue = value.envoyHttpAls;
      this._envoyOtelAls.internalValue = value.envoyOtelAls;
      this._envoyTcpAls.internalValue = value.envoyTcpAls;
      this._lightstep.internalValue = value.lightstep;
      this._name = value.name;
      this._opencensus.internalValue = value.opencensus;
      this._opentelemetry.internalValue = value.opentelemetry;
      this._prometheus = value.prometheus;
      this._skywalking.internalValue = value.skywalking;
      this._stackdriver.internalValue = value.stackdriver;
      this._zipkin.internalValue = value.zipkin;
    }
  }

  // datadog - computed: false, optional: true, required: false
  private _datadog = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersDatadogOutputReference(this, "datadog");
  public get datadog() {
    return this._datadog;
  }
  public putDatadog(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersDatadog) {
    this._datadog.internalValue = value;
  }
  public resetDatadog() {
    this._datadog.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get datadogInput() {
    return this._datadog.internalValue;
  }

  // envoy_ext_authz_grpc - computed: false, optional: true, required: false
  private _envoyExtAuthzGrpc = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyExtAuthzGrpcOutputReference(this, "envoy_ext_authz_grpc");
  public get envoyExtAuthzGrpc() {
    return this._envoyExtAuthzGrpc;
  }
  public putEnvoyExtAuthzGrpc(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyExtAuthzGrpc) {
    this._envoyExtAuthzGrpc.internalValue = value;
  }
  public resetEnvoyExtAuthzGrpc() {
    this._envoyExtAuthzGrpc.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get envoyExtAuthzGrpcInput() {
    return this._envoyExtAuthzGrpc.internalValue;
  }

  // envoy_ext_authz_http - computed: false, optional: true, required: false
  private _envoyExtAuthzHttp = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyExtAuthzHttpOutputReference(this, "envoy_ext_authz_http");
  public get envoyExtAuthzHttp() {
    return this._envoyExtAuthzHttp;
  }
  public putEnvoyExtAuthzHttp(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyExtAuthzHttp) {
    this._envoyExtAuthzHttp.internalValue = value;
  }
  public resetEnvoyExtAuthzHttp() {
    this._envoyExtAuthzHttp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get envoyExtAuthzHttpInput() {
    return this._envoyExtAuthzHttp.internalValue;
  }

  // envoy_file_access_log - computed: false, optional: true, required: false
  private _envoyFileAccessLog = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyFileAccessLogOutputReference(this, "envoy_file_access_log");
  public get envoyFileAccessLog() {
    return this._envoyFileAccessLog;
  }
  public putEnvoyFileAccessLog(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyFileAccessLog) {
    this._envoyFileAccessLog.internalValue = value;
  }
  public resetEnvoyFileAccessLog() {
    this._envoyFileAccessLog.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get envoyFileAccessLogInput() {
    return this._envoyFileAccessLog.internalValue;
  }

  // envoy_http_als - computed: false, optional: true, required: false
  private _envoyHttpAls = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyHttpAlsOutputReference(this, "envoy_http_als");
  public get envoyHttpAls() {
    return this._envoyHttpAls;
  }
  public putEnvoyHttpAls(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyHttpAls) {
    this._envoyHttpAls.internalValue = value;
  }
  public resetEnvoyHttpAls() {
    this._envoyHttpAls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get envoyHttpAlsInput() {
    return this._envoyHttpAls.internalValue;
  }

  // envoy_otel_als - computed: false, optional: true, required: false
  private _envoyOtelAls = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyOtelAlsOutputReference(this, "envoy_otel_als");
  public get envoyOtelAls() {
    return this._envoyOtelAls;
  }
  public putEnvoyOtelAls(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyOtelAls) {
    this._envoyOtelAls.internalValue = value;
  }
  public resetEnvoyOtelAls() {
    this._envoyOtelAls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get envoyOtelAlsInput() {
    return this._envoyOtelAls.internalValue;
  }

  // envoy_tcp_als - computed: false, optional: true, required: false
  private _envoyTcpAls = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyTcpAlsOutputReference(this, "envoy_tcp_als");
  public get envoyTcpAls() {
    return this._envoyTcpAls;
  }
  public putEnvoyTcpAls(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersEnvoyTcpAls) {
    this._envoyTcpAls.internalValue = value;
  }
  public resetEnvoyTcpAls() {
    this._envoyTcpAls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get envoyTcpAlsInput() {
    return this._envoyTcpAls.internalValue;
  }

  // lightstep - computed: false, optional: true, required: false
  private _lightstep = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersLightstepOutputReference(this, "lightstep");
  public get lightstep() {
    return this._lightstep;
  }
  public putLightstep(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersLightstep) {
    this._lightstep.internalValue = value;
  }
  public resetLightstep() {
    this._lightstep.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lightstepInput() {
    return this._lightstep.internalValue;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // opencensus - computed: false, optional: true, required: false
  private _opencensus = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersOpencensusOutputReference(this, "opencensus");
  public get opencensus() {
    return this._opencensus;
  }
  public putOpencensus(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersOpencensus) {
    this._opencensus.internalValue = value;
  }
  public resetOpencensus() {
    this._opencensus.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get opencensusInput() {
    return this._opencensus.internalValue;
  }

  // opentelemetry - computed: false, optional: true, required: false
  private _opentelemetry = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersOpentelemetryOutputReference(this, "opentelemetry");
  public get opentelemetry() {
    return this._opentelemetry;
  }
  public putOpentelemetry(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersOpentelemetry) {
    this._opentelemetry.internalValue = value;
  }
  public resetOpentelemetry() {
    this._opentelemetry.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get opentelemetryInput() {
    return this._opentelemetry.internalValue;
  }

  // prometheus - computed: false, optional: true, required: false
  private _prometheus?: { [key: string]: string }; 
  public get prometheus() {
    return this.getStringMapAttribute('prometheus');
  }
  public set prometheus(value: { [key: string]: string }) {
    this._prometheus = value;
  }
  public resetPrometheus() {
    this._prometheus = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prometheusInput() {
    return this._prometheus;
  }

  // skywalking - computed: false, optional: true, required: false
  private _skywalking = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersSkywalkingOutputReference(this, "skywalking");
  public get skywalking() {
    return this._skywalking;
  }
  public putSkywalking(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersSkywalking) {
    this._skywalking.internalValue = value;
  }
  public resetSkywalking() {
    this._skywalking.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get skywalkingInput() {
    return this._skywalking.internalValue;
  }

  // stackdriver - computed: false, optional: true, required: false
  private _stackdriver = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersStackdriverOutputReference(this, "stackdriver");
  public get stackdriver() {
    return this._stackdriver;
  }
  public putStackdriver(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersStackdriver) {
    this._stackdriver.internalValue = value;
  }
  public resetStackdriver() {
    this._stackdriver.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stackdriverInput() {
    return this._stackdriver.internalValue;
  }

  // zipkin - computed: false, optional: true, required: false
  private _zipkin = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersZipkinOutputReference(this, "zipkin");
  public get zipkin() {
    return this._zipkin;
  }
  public putZipkin(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersZipkin) {
    this._zipkin.internalValue = value;
  }
  public resetZipkin() {
    this._zipkin.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get zipkinInput() {
    return this._zipkin.internalValue;
  }
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersList extends cdktf.ComplexList {
  public internalValue? : DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProviders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersOutputReference {
    return new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigLocalityLbSettingDistribute {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#from DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#from}
  */
  readonly from?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#to DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#to}
  */
  readonly to?: { [key: string]: string };
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigLocalityLbSettingDistributeToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigLocalityLbSettingDistribute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    from: cdktf.stringToTerraform(struct!.from),
    to: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.to),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigLocalityLbSettingDistributeToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigLocalityLbSettingDistribute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    from: {
      value: cdktf.stringToHclTerraform(struct!.from),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    to: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.to),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigLocalityLbSettingDistributeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigLocalityLbSettingDistribute | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._from !== undefined) {
      hasAnyValues = true;
      internalValueResult.from = this._from;
    }
    if (this._to !== undefined) {
      hasAnyValues = true;
      internalValueResult.to = this._to;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigLocalityLbSettingDistribute | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._from = undefined;
      this._to = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._from = value.from;
      this._to = value.to;
    }
  }

  // from - computed: false, optional: true, required: false
  private _from?: string; 
  public get from() {
    return this.getStringAttribute('from');
  }
  public set from(value: string) {
    this._from = value;
  }
  public resetFrom() {
    this._from = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fromInput() {
    return this._from;
  }

  // to - computed: false, optional: true, required: false
  private _to?: { [key: string]: string }; 
  public get to() {
    return this.getStringMapAttribute('to');
  }
  public set to(value: { [key: string]: string }) {
    this._to = value;
  }
  public resetTo() {
    this._to = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get toInput() {
    return this._to;
  }
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigLocalityLbSettingDistributeList extends cdktf.ComplexList {
  public internalValue? : DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigLocalityLbSettingDistribute[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigLocalityLbSettingDistributeOutputReference {
    return new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigLocalityLbSettingDistributeOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigLocalityLbSettingFailover {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#from DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#from}
  */
  readonly from?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#to DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#to}
  */
  readonly to?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigLocalityLbSettingFailoverToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigLocalityLbSettingFailover | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    from: cdktf.stringToTerraform(struct!.from),
    to: cdktf.stringToTerraform(struct!.to),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigLocalityLbSettingFailoverToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigLocalityLbSettingFailover | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    from: {
      value: cdktf.stringToHclTerraform(struct!.from),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    to: {
      value: cdktf.stringToHclTerraform(struct!.to),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigLocalityLbSettingFailoverOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigLocalityLbSettingFailover | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._from !== undefined) {
      hasAnyValues = true;
      internalValueResult.from = this._from;
    }
    if (this._to !== undefined) {
      hasAnyValues = true;
      internalValueResult.to = this._to;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigLocalityLbSettingFailover | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._from = undefined;
      this._to = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._from = value.from;
      this._to = value.to;
    }
  }

  // from - computed: false, optional: true, required: false
  private _from?: string; 
  public get from() {
    return this.getStringAttribute('from');
  }
  public set from(value: string) {
    this._from = value;
  }
  public resetFrom() {
    this._from = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fromInput() {
    return this._from;
  }

  // to - computed: false, optional: true, required: false
  private _to?: string; 
  public get to() {
    return this.getStringAttribute('to');
  }
  public set to(value: string) {
    this._to = value;
  }
  public resetTo() {
    this._to = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get toInput() {
    return this._to;
  }
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigLocalityLbSettingFailoverList extends cdktf.ComplexList {
  public internalValue? : DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigLocalityLbSettingFailover[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigLocalityLbSettingFailoverOutputReference {
    return new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigLocalityLbSettingFailoverOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigLocalityLbSetting {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#distribute DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#distribute}
  */
  readonly distribute?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigLocalityLbSettingDistribute[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#enabled DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#failover DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#failover}
  */
  readonly failover?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigLocalityLbSettingFailover[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#failover_priority DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#failover_priority}
  */
  readonly failoverPriority?: string[];
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigLocalityLbSettingToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigLocalityLbSetting | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    distribute: cdktf.listMapper(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigLocalityLbSettingDistributeToTerraform, false)(struct!.distribute),
    enabled: cdktf.booleanToTerraform(struct!.enabled),
    failover: cdktf.listMapper(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigLocalityLbSettingFailoverToTerraform, false)(struct!.failover),
    failover_priority: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.failoverPriority),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigLocalityLbSettingToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigLocalityLbSetting | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    distribute: {
      value: cdktf.listMapperHcl(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigLocalityLbSettingDistributeToHclTerraform, false)(struct!.distribute),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigLocalityLbSettingDistributeList",
    },
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    failover: {
      value: cdktf.listMapperHcl(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigLocalityLbSettingFailoverToHclTerraform, false)(struct!.failover),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigLocalityLbSettingFailoverList",
    },
    failover_priority: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.failoverPriority),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigLocalityLbSettingOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigLocalityLbSetting | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._distribute?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.distribute = this._distribute?.internalValue;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._failover?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.failover = this._failover?.internalValue;
    }
    if (this._failoverPriority !== undefined) {
      hasAnyValues = true;
      internalValueResult.failoverPriority = this._failoverPriority;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigLocalityLbSetting | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._distribute.internalValue = undefined;
      this._enabled = undefined;
      this._failover.internalValue = undefined;
      this._failoverPriority = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._distribute.internalValue = value.distribute;
      this._enabled = value.enabled;
      this._failover.internalValue = value.failover;
      this._failoverPriority = value.failoverPriority;
    }
  }

  // distribute - computed: false, optional: true, required: false
  private _distribute = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigLocalityLbSettingDistributeList(this, "distribute", false);
  public get distribute() {
    return this._distribute;
  }
  public putDistribute(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigLocalityLbSettingDistribute[] | cdktf.IResolvable) {
    this._distribute.internalValue = value;
  }
  public resetDistribute() {
    this._distribute.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get distributeInput() {
    return this._distribute.internalValue;
  }

  // enabled - computed: false, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // failover - computed: false, optional: true, required: false
  private _failover = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigLocalityLbSettingFailoverList(this, "failover", false);
  public get failover() {
    return this._failover;
  }
  public putFailover(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigLocalityLbSettingFailover[] | cdktf.IResolvable) {
    this._failover.internalValue = value;
  }
  public resetFailover() {
    this._failover.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failoverInput() {
    return this._failover.internalValue;
  }

  // failover_priority - computed: false, optional: true, required: false
  private _failoverPriority?: string[]; 
  public get failoverPriority() {
    return this.getListAttribute('failover_priority');
  }
  public set failoverPriority(value: string[]) {
    this._failoverPriority = value;
  }
  public resetFailoverPriority() {
    this._failoverPriority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failoverPriorityInput() {
    return this._failoverPriority;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigMeshMtls {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#min_protocol_version DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#min_protocol_version}
  */
  readonly minProtocolVersion?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigMeshMtlsToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigMeshMtls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    min_protocol_version: cdktf.stringToTerraform(struct!.minProtocolVersion),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigMeshMtlsToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigMeshMtls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    min_protocol_version: {
      value: cdktf.stringToHclTerraform(struct!.minProtocolVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigMeshMtlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigMeshMtls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._minProtocolVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minProtocolVersion = this._minProtocolVersion;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigMeshMtls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._minProtocolVersion = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._minProtocolVersion = value.minProtocolVersion;
    }
  }

  // min_protocol_version - computed: false, optional: true, required: false
  private _minProtocolVersion?: string; 
  public get minProtocolVersion() {
    return this.getStringAttribute('min_protocol_version');
  }
  public set minProtocolVersion(value: string) {
    this._minProtocolVersion = value;
  }
  public resetMinProtocolVersion() {
    this._minProtocolVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minProtocolVersionInput() {
    return this._minProtocolVersion;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigOutboundTrafficPolicy {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#mode DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#mode}
  */
  readonly mode?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigOutboundTrafficPolicyToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigOutboundTrafficPolicy | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mode: cdktf.stringToTerraform(struct!.mode),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigOutboundTrafficPolicyToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigOutboundTrafficPolicy | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigOutboundTrafficPolicyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigOutboundTrafficPolicy | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigOutboundTrafficPolicy | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._mode = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._mode = value.mode;
    }
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigPathNormalization {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#normalization DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#normalization}
  */
  readonly normalization?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigPathNormalizationToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigPathNormalization | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    normalization: cdktf.stringToTerraform(struct!.normalization),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigPathNormalizationToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigPathNormalization | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    normalization: {
      value: cdktf.stringToHclTerraform(struct!.normalization),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigPathNormalizationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigPathNormalization | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._normalization !== undefined) {
      hasAnyValues = true;
      internalValueResult.normalization = this._normalization;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigPathNormalization | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._normalization = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._normalization = value.normalization;
    }
  }

  // normalization - computed: false, optional: true, required: false
  private _normalization?: string; 
  public get normalization() {
    return this.getStringAttribute('normalization');
  }
  public set normalization(value: string) {
    this._normalization = value;
  }
  public resetNormalization() {
    this._normalization = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get normalizationInput() {
    return this._normalization;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigServiceSettingsSettings {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#cluster_local DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#cluster_local}
  */
  readonly clusterLocal?: boolean | cdktf.IResolvable;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigServiceSettingsSettingsToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigServiceSettingsSettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cluster_local: cdktf.booleanToTerraform(struct!.clusterLocal),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigServiceSettingsSettingsToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigServiceSettingsSettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cluster_local: {
      value: cdktf.booleanToHclTerraform(struct!.clusterLocal),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigServiceSettingsSettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigServiceSettingsSettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clusterLocal !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterLocal = this._clusterLocal;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigServiceSettingsSettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clusterLocal = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clusterLocal = value.clusterLocal;
    }
  }

  // cluster_local - computed: false, optional: true, required: false
  private _clusterLocal?: boolean | cdktf.IResolvable; 
  public get clusterLocal() {
    return this.getBooleanAttribute('cluster_local');
  }
  public set clusterLocal(value: boolean | cdktf.IResolvable) {
    this._clusterLocal = value;
  }
  public resetClusterLocal() {
    this._clusterLocal = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterLocalInput() {
    return this._clusterLocal;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigServiceSettings {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#hosts DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#hosts}
  */
  readonly hosts?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#settings DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#settings}
  */
  readonly settings?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigServiceSettingsSettings;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigServiceSettingsToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigServiceSettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    hosts: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.hosts),
    settings: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigServiceSettingsSettingsToTerraform(struct!.settings),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigServiceSettingsToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigServiceSettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    hosts: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.hosts),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    settings: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigServiceSettingsSettingsToHclTerraform(struct!.settings),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigServiceSettingsSettings",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigServiceSettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigServiceSettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._hosts !== undefined) {
      hasAnyValues = true;
      internalValueResult.hosts = this._hosts;
    }
    if (this._settings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.settings = this._settings?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigServiceSettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._hosts = undefined;
      this._settings.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._hosts = value.hosts;
      this._settings.internalValue = value.settings;
    }
  }

  // hosts - computed: false, optional: true, required: false
  private _hosts?: string[]; 
  public get hosts() {
    return this.getListAttribute('hosts');
  }
  public set hosts(value: string[]) {
    this._hosts = value;
  }
  public resetHosts() {
    this._hosts = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostsInput() {
    return this._hosts;
  }

  // settings - computed: false, optional: true, required: false
  private _settings = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigServiceSettingsSettingsOutputReference(this, "settings");
  public get settings() {
    return this._settings;
  }
  public putSettings(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigServiceSettingsSettings) {
    this._settings.internalValue = value;
  }
  public resetSettings() {
    this._settings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get settingsInput() {
    return this._settings.internalValue;
  }
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigServiceSettingsList extends cdktf.ComplexList {
  public internalValue? : DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigServiceSettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigServiceSettingsOutputReference {
    return new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigServiceSettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigTcpKeepalive {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#interval DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#interval}
  */
  readonly interval?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#probes DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#probes}
  */
  readonly probes?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#time DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#time}
  */
  readonly time?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigTcpKeepaliveToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigTcpKeepalive | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    interval: cdktf.stringToTerraform(struct!.interval),
    probes: cdktf.numberToTerraform(struct!.probes),
    time: cdktf.stringToTerraform(struct!.time),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigTcpKeepaliveToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigTcpKeepalive | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    interval: {
      value: cdktf.stringToHclTerraform(struct!.interval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    probes: {
      value: cdktf.numberToHclTerraform(struct!.probes),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    time: {
      value: cdktf.stringToHclTerraform(struct!.time),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigTcpKeepaliveOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigTcpKeepalive | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._interval !== undefined) {
      hasAnyValues = true;
      internalValueResult.interval = this._interval;
    }
    if (this._probes !== undefined) {
      hasAnyValues = true;
      internalValueResult.probes = this._probes;
    }
    if (this._time !== undefined) {
      hasAnyValues = true;
      internalValueResult.time = this._time;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigTcpKeepalive | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._interval = undefined;
      this._probes = undefined;
      this._time = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._interval = value.interval;
      this._probes = value.probes;
      this._time = value.time;
    }
  }

  // interval - computed: false, optional: true, required: false
  private _interval?: string; 
  public get interval() {
    return this.getStringAttribute('interval');
  }
  public set interval(value: string) {
    this._interval = value;
  }
  public resetInterval() {
    this._interval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get intervalInput() {
    return this._interval;
  }

  // probes - computed: false, optional: true, required: false
  private _probes?: number; 
  public get probes() {
    return this.getNumberAttribute('probes');
  }
  public set probes(value: number) {
    this._probes = value;
  }
  public resetProbes() {
    this._probes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get probesInput() {
    return this._probes;
  }

  // time - computed: false, optional: true, required: false
  private _time?: string; 
  public get time() {
    return this.getStringAttribute('time');
  }
  public set time(value: string) {
    this._time = value;
  }
  public resetTime() {
    this._time = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeInput() {
    return this._time;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#access_log_encoding DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#access_log_encoding}
  */
  readonly accessLogEncoding?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#access_log_file DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#access_log_file}
  */
  readonly accessLogFile?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#access_log_format DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#access_log_format}
  */
  readonly accessLogFormat?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#ca DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#ca}
  */
  readonly ca?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCa;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#ca_certificates DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#ca_certificates}
  */
  readonly caCertificates?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCaCertificates[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#certificates DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#certificates}
  */
  readonly certificates?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCertificates[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#config_sources DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#config_sources}
  */
  readonly configSources?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigConfigSources[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#connect_timeout DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#connect_timeout}
  */
  readonly connectTimeout?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#default_config DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#default_config}
  */
  readonly defaultConfig?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfig;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#default_destination_rule_export_to DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#default_destination_rule_export_to}
  */
  readonly defaultDestinationRuleExportTo?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#default_http_retry_policy DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#default_http_retry_policy}
  */
  readonly defaultHttpRetryPolicy?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultHttpRetryPolicy;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#default_providers DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#default_providers}
  */
  readonly defaultProviders?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultProviders;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#default_service_export_to DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#default_service_export_to}
  */
  readonly defaultServiceExportTo?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#default_virtual_service_export_to DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#default_virtual_service_export_to}
  */
  readonly defaultVirtualServiceExportTo?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#disable_envoy_listener_log DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#disable_envoy_listener_log}
  */
  readonly disableEnvoyListenerLog?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#discovery_selectors DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#discovery_selectors}
  */
  readonly discoverySelectors?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDiscoverySelectors[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#dns_refresh_rate DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#dns_refresh_rate}
  */
  readonly dnsRefreshRate?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#enable_auto_mtls DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#enable_auto_mtls}
  */
  readonly enableAutoMtls?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#enable_envoy_access_log_service DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#enable_envoy_access_log_service}
  */
  readonly enableEnvoyAccessLogService?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#enable_prometheus_merge DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#enable_prometheus_merge}
  */
  readonly enablePrometheusMerge?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#enable_tracing DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#enable_tracing}
  */
  readonly enableTracing?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#extension_providers DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#extension_providers}
  */
  readonly extensionProviders?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProviders[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#h2_upgrade_policy DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#h2_upgrade_policy}
  */
  readonly h2UpgradePolicy?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#inbound_cluster_stat_name DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#inbound_cluster_stat_name}
  */
  readonly inboundClusterStatName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#ingress_class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#ingress_class}
  */
  readonly ingressClass?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#ingress_controller_mode DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#ingress_controller_mode}
  */
  readonly ingressControllerMode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#ingress_selector DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#ingress_selector}
  */
  readonly ingressSelector?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#ingress_service DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#ingress_service}
  */
  readonly ingressService?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#locality_lb_setting DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#locality_lb_setting}
  */
  readonly localityLbSetting?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigLocalityLbSetting;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#mesh_mtls DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#mesh_mtls}
  */
  readonly meshMtls?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigMeshMtls;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#outbound_cluster_stat_name DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#outbound_cluster_stat_name}
  */
  readonly outboundClusterStatName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#outbound_traffic_policy DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#outbound_traffic_policy}
  */
  readonly outboundTrafficPolicy?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigOutboundTrafficPolicy;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#path_normalization DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#path_normalization}
  */
  readonly pathNormalization?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigPathNormalization;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#protocol_detection_timeout DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#protocol_detection_timeout}
  */
  readonly protocolDetectionTimeout?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#proxy_http_port DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#proxy_http_port}
  */
  readonly proxyHttpPort?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#proxy_listen_port DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#proxy_listen_port}
  */
  readonly proxyListenPort?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#root_namespace DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#root_namespace}
  */
  readonly rootNamespace?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#service_settings DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#service_settings}
  */
  readonly serviceSettings?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigServiceSettings[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#tcp_keepalive DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#tcp_keepalive}
  */
  readonly tcpKeepalive?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigTcpKeepalive;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#trust_domain DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#trust_domain}
  */
  readonly trustDomain?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#trust_domain_aliases DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#trust_domain_aliases}
  */
  readonly trustDomainAliases?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#verify_certificate_at_client DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#verify_certificate_at_client}
  */
  readonly verifyCertificateAtClient?: boolean | cdktf.IResolvable;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_log_encoding: cdktf.stringToTerraform(struct!.accessLogEncoding),
    access_log_file: cdktf.stringToTerraform(struct!.accessLogFile),
    access_log_format: cdktf.stringToTerraform(struct!.accessLogFormat),
    ca: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCaToTerraform(struct!.ca),
    ca_certificates: cdktf.listMapper(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCaCertificatesToTerraform, false)(struct!.caCertificates),
    certificates: cdktf.listMapper(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCertificatesToTerraform, false)(struct!.certificates),
    config_sources: cdktf.listMapper(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigConfigSourcesToTerraform, false)(struct!.configSources),
    connect_timeout: cdktf.stringToTerraform(struct!.connectTimeout),
    default_config: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigToTerraform(struct!.defaultConfig),
    default_destination_rule_export_to: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.defaultDestinationRuleExportTo),
    default_http_retry_policy: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultHttpRetryPolicyToTerraform(struct!.defaultHttpRetryPolicy),
    default_providers: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultProvidersToTerraform(struct!.defaultProviders),
    default_service_export_to: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.defaultServiceExportTo),
    default_virtual_service_export_to: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.defaultVirtualServiceExportTo),
    disable_envoy_listener_log: cdktf.booleanToTerraform(struct!.disableEnvoyListenerLog),
    discovery_selectors: cdktf.listMapper(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDiscoverySelectorsToTerraform, false)(struct!.discoverySelectors),
    dns_refresh_rate: cdktf.stringToTerraform(struct!.dnsRefreshRate),
    enable_auto_mtls: cdktf.booleanToTerraform(struct!.enableAutoMtls),
    enable_envoy_access_log_service: cdktf.booleanToTerraform(struct!.enableEnvoyAccessLogService),
    enable_prometheus_merge: cdktf.booleanToTerraform(struct!.enablePrometheusMerge),
    enable_tracing: cdktf.booleanToTerraform(struct!.enableTracing),
    extension_providers: cdktf.listMapper(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersToTerraform, false)(struct!.extensionProviders),
    h2_upgrade_policy: cdktf.stringToTerraform(struct!.h2UpgradePolicy),
    inbound_cluster_stat_name: cdktf.stringToTerraform(struct!.inboundClusterStatName),
    ingress_class: cdktf.stringToTerraform(struct!.ingressClass),
    ingress_controller_mode: cdktf.stringToTerraform(struct!.ingressControllerMode),
    ingress_selector: cdktf.stringToTerraform(struct!.ingressSelector),
    ingress_service: cdktf.stringToTerraform(struct!.ingressService),
    locality_lb_setting: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigLocalityLbSettingToTerraform(struct!.localityLbSetting),
    mesh_mtls: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigMeshMtlsToTerraform(struct!.meshMtls),
    outbound_cluster_stat_name: cdktf.stringToTerraform(struct!.outboundClusterStatName),
    outbound_traffic_policy: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigOutboundTrafficPolicyToTerraform(struct!.outboundTrafficPolicy),
    path_normalization: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigPathNormalizationToTerraform(struct!.pathNormalization),
    protocol_detection_timeout: cdktf.stringToTerraform(struct!.protocolDetectionTimeout),
    proxy_http_port: cdktf.numberToTerraform(struct!.proxyHttpPort),
    proxy_listen_port: cdktf.numberToTerraform(struct!.proxyListenPort),
    root_namespace: cdktf.stringToTerraform(struct!.rootNamespace),
    service_settings: cdktf.listMapper(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigServiceSettingsToTerraform, false)(struct!.serviceSettings),
    tcp_keepalive: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigTcpKeepaliveToTerraform(struct!.tcpKeepalive),
    trust_domain: cdktf.stringToTerraform(struct!.trustDomain),
    trust_domain_aliases: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.trustDomainAliases),
    verify_certificate_at_client: cdktf.booleanToTerraform(struct!.verifyCertificateAtClient),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_log_encoding: {
      value: cdktf.stringToHclTerraform(struct!.accessLogEncoding),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    access_log_file: {
      value: cdktf.stringToHclTerraform(struct!.accessLogFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    access_log_format: {
      value: cdktf.stringToHclTerraform(struct!.accessLogFormat),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ca: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCaToHclTerraform(struct!.ca),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCa",
    },
    ca_certificates: {
      value: cdktf.listMapperHcl(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCaCertificatesToHclTerraform, false)(struct!.caCertificates),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCaCertificatesList",
    },
    certificates: {
      value: cdktf.listMapperHcl(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCertificatesToHclTerraform, false)(struct!.certificates),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCertificatesList",
    },
    config_sources: {
      value: cdktf.listMapperHcl(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigConfigSourcesToHclTerraform, false)(struct!.configSources),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigConfigSourcesList",
    },
    connect_timeout: {
      value: cdktf.stringToHclTerraform(struct!.connectTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    default_config: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigToHclTerraform(struct!.defaultConfig),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfig",
    },
    default_destination_rule_export_to: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.defaultDestinationRuleExportTo),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    default_http_retry_policy: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultHttpRetryPolicyToHclTerraform(struct!.defaultHttpRetryPolicy),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultHttpRetryPolicy",
    },
    default_providers: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultProvidersToHclTerraform(struct!.defaultProviders),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultProviders",
    },
    default_service_export_to: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.defaultServiceExportTo),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    default_virtual_service_export_to: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.defaultVirtualServiceExportTo),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    disable_envoy_listener_log: {
      value: cdktf.booleanToHclTerraform(struct!.disableEnvoyListenerLog),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    discovery_selectors: {
      value: cdktf.listMapperHcl(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDiscoverySelectorsToHclTerraform, false)(struct!.discoverySelectors),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDiscoverySelectorsList",
    },
    dns_refresh_rate: {
      value: cdktf.stringToHclTerraform(struct!.dnsRefreshRate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enable_auto_mtls: {
      value: cdktf.booleanToHclTerraform(struct!.enableAutoMtls),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_envoy_access_log_service: {
      value: cdktf.booleanToHclTerraform(struct!.enableEnvoyAccessLogService),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_prometheus_merge: {
      value: cdktf.booleanToHclTerraform(struct!.enablePrometheusMerge),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_tracing: {
      value: cdktf.booleanToHclTerraform(struct!.enableTracing),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    extension_providers: {
      value: cdktf.listMapperHcl(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersToHclTerraform, false)(struct!.extensionProviders),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersList",
    },
    h2_upgrade_policy: {
      value: cdktf.stringToHclTerraform(struct!.h2UpgradePolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    inbound_cluster_stat_name: {
      value: cdktf.stringToHclTerraform(struct!.inboundClusterStatName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ingress_class: {
      value: cdktf.stringToHclTerraform(struct!.ingressClass),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ingress_controller_mode: {
      value: cdktf.stringToHclTerraform(struct!.ingressControllerMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ingress_selector: {
      value: cdktf.stringToHclTerraform(struct!.ingressSelector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ingress_service: {
      value: cdktf.stringToHclTerraform(struct!.ingressService),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    locality_lb_setting: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigLocalityLbSettingToHclTerraform(struct!.localityLbSetting),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigLocalityLbSetting",
    },
    mesh_mtls: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigMeshMtlsToHclTerraform(struct!.meshMtls),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigMeshMtls",
    },
    outbound_cluster_stat_name: {
      value: cdktf.stringToHclTerraform(struct!.outboundClusterStatName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    outbound_traffic_policy: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigOutboundTrafficPolicyToHclTerraform(struct!.outboundTrafficPolicy),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigOutboundTrafficPolicy",
    },
    path_normalization: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigPathNormalizationToHclTerraform(struct!.pathNormalization),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigPathNormalization",
    },
    protocol_detection_timeout: {
      value: cdktf.stringToHclTerraform(struct!.protocolDetectionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    proxy_http_port: {
      value: cdktf.numberToHclTerraform(struct!.proxyHttpPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_listen_port: {
      value: cdktf.numberToHclTerraform(struct!.proxyListenPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    root_namespace: {
      value: cdktf.stringToHclTerraform(struct!.rootNamespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    service_settings: {
      value: cdktf.listMapperHcl(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigServiceSettingsToHclTerraform, false)(struct!.serviceSettings),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigServiceSettingsList",
    },
    tcp_keepalive: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigTcpKeepaliveToHclTerraform(struct!.tcpKeepalive),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigTcpKeepalive",
    },
    trust_domain: {
      value: cdktf.stringToHclTerraform(struct!.trustDomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    trust_domain_aliases: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.trustDomainAliases),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    verify_certificate_at_client: {
      value: cdktf.booleanToHclTerraform(struct!.verifyCertificateAtClient),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessLogEncoding !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessLogEncoding = this._accessLogEncoding;
    }
    if (this._accessLogFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessLogFile = this._accessLogFile;
    }
    if (this._accessLogFormat !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessLogFormat = this._accessLogFormat;
    }
    if (this._ca?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ca = this._ca?.internalValue;
    }
    if (this._caCertificates?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.caCertificates = this._caCertificates?.internalValue;
    }
    if (this._certificates?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificates = this._certificates?.internalValue;
    }
    if (this._configSources?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.configSources = this._configSources?.internalValue;
    }
    if (this._connectTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectTimeout = this._connectTimeout;
    }
    if (this._defaultConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultConfig = this._defaultConfig?.internalValue;
    }
    if (this._defaultDestinationRuleExportTo !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultDestinationRuleExportTo = this._defaultDestinationRuleExportTo;
    }
    if (this._defaultHttpRetryPolicy?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultHttpRetryPolicy = this._defaultHttpRetryPolicy?.internalValue;
    }
    if (this._defaultProviders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultProviders = this._defaultProviders?.internalValue;
    }
    if (this._defaultServiceExportTo !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultServiceExportTo = this._defaultServiceExportTo;
    }
    if (this._defaultVirtualServiceExportTo !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultVirtualServiceExportTo = this._defaultVirtualServiceExportTo;
    }
    if (this._disableEnvoyListenerLog !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableEnvoyListenerLog = this._disableEnvoyListenerLog;
    }
    if (this._discoverySelectors?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.discoverySelectors = this._discoverySelectors?.internalValue;
    }
    if (this._dnsRefreshRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsRefreshRate = this._dnsRefreshRate;
    }
    if (this._enableAutoMtls !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableAutoMtls = this._enableAutoMtls;
    }
    if (this._enableEnvoyAccessLogService !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableEnvoyAccessLogService = this._enableEnvoyAccessLogService;
    }
    if (this._enablePrometheusMerge !== undefined) {
      hasAnyValues = true;
      internalValueResult.enablePrometheusMerge = this._enablePrometheusMerge;
    }
    if (this._enableTracing !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableTracing = this._enableTracing;
    }
    if (this._extensionProviders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extensionProviders = this._extensionProviders?.internalValue;
    }
    if (this._h2UpgradePolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.h2UpgradePolicy = this._h2UpgradePolicy;
    }
    if (this._inboundClusterStatName !== undefined) {
      hasAnyValues = true;
      internalValueResult.inboundClusterStatName = this._inboundClusterStatName;
    }
    if (this._ingressClass !== undefined) {
      hasAnyValues = true;
      internalValueResult.ingressClass = this._ingressClass;
    }
    if (this._ingressControllerMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.ingressControllerMode = this._ingressControllerMode;
    }
    if (this._ingressSelector !== undefined) {
      hasAnyValues = true;
      internalValueResult.ingressSelector = this._ingressSelector;
    }
    if (this._ingressService !== undefined) {
      hasAnyValues = true;
      internalValueResult.ingressService = this._ingressService;
    }
    if (this._localityLbSetting?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.localityLbSetting = this._localityLbSetting?.internalValue;
    }
    if (this._meshMtls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.meshMtls = this._meshMtls?.internalValue;
    }
    if (this._outboundClusterStatName !== undefined) {
      hasAnyValues = true;
      internalValueResult.outboundClusterStatName = this._outboundClusterStatName;
    }
    if (this._outboundTrafficPolicy?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.outboundTrafficPolicy = this._outboundTrafficPolicy?.internalValue;
    }
    if (this._pathNormalization?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pathNormalization = this._pathNormalization?.internalValue;
    }
    if (this._protocolDetectionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocolDetectionTimeout = this._protocolDetectionTimeout;
    }
    if (this._proxyHttpPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyHttpPort = this._proxyHttpPort;
    }
    if (this._proxyListenPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyListenPort = this._proxyListenPort;
    }
    if (this._rootNamespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.rootNamespace = this._rootNamespace;
    }
    if (this._serviceSettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceSettings = this._serviceSettings?.internalValue;
    }
    if (this._tcpKeepalive?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tcpKeepalive = this._tcpKeepalive?.internalValue;
    }
    if (this._trustDomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.trustDomain = this._trustDomain;
    }
    if (this._trustDomainAliases !== undefined) {
      hasAnyValues = true;
      internalValueResult.trustDomainAliases = this._trustDomainAliases;
    }
    if (this._verifyCertificateAtClient !== undefined) {
      hasAnyValues = true;
      internalValueResult.verifyCertificateAtClient = this._verifyCertificateAtClient;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessLogEncoding = undefined;
      this._accessLogFile = undefined;
      this._accessLogFormat = undefined;
      this._ca.internalValue = undefined;
      this._caCertificates.internalValue = undefined;
      this._certificates.internalValue = undefined;
      this._configSources.internalValue = undefined;
      this._connectTimeout = undefined;
      this._defaultConfig.internalValue = undefined;
      this._defaultDestinationRuleExportTo = undefined;
      this._defaultHttpRetryPolicy.internalValue = undefined;
      this._defaultProviders.internalValue = undefined;
      this._defaultServiceExportTo = undefined;
      this._defaultVirtualServiceExportTo = undefined;
      this._disableEnvoyListenerLog = undefined;
      this._discoverySelectors.internalValue = undefined;
      this._dnsRefreshRate = undefined;
      this._enableAutoMtls = undefined;
      this._enableEnvoyAccessLogService = undefined;
      this._enablePrometheusMerge = undefined;
      this._enableTracing = undefined;
      this._extensionProviders.internalValue = undefined;
      this._h2UpgradePolicy = undefined;
      this._inboundClusterStatName = undefined;
      this._ingressClass = undefined;
      this._ingressControllerMode = undefined;
      this._ingressSelector = undefined;
      this._ingressService = undefined;
      this._localityLbSetting.internalValue = undefined;
      this._meshMtls.internalValue = undefined;
      this._outboundClusterStatName = undefined;
      this._outboundTrafficPolicy.internalValue = undefined;
      this._pathNormalization.internalValue = undefined;
      this._protocolDetectionTimeout = undefined;
      this._proxyHttpPort = undefined;
      this._proxyListenPort = undefined;
      this._rootNamespace = undefined;
      this._serviceSettings.internalValue = undefined;
      this._tcpKeepalive.internalValue = undefined;
      this._trustDomain = undefined;
      this._trustDomainAliases = undefined;
      this._verifyCertificateAtClient = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessLogEncoding = value.accessLogEncoding;
      this._accessLogFile = value.accessLogFile;
      this._accessLogFormat = value.accessLogFormat;
      this._ca.internalValue = value.ca;
      this._caCertificates.internalValue = value.caCertificates;
      this._certificates.internalValue = value.certificates;
      this._configSources.internalValue = value.configSources;
      this._connectTimeout = value.connectTimeout;
      this._defaultConfig.internalValue = value.defaultConfig;
      this._defaultDestinationRuleExportTo = value.defaultDestinationRuleExportTo;
      this._defaultHttpRetryPolicy.internalValue = value.defaultHttpRetryPolicy;
      this._defaultProviders.internalValue = value.defaultProviders;
      this._defaultServiceExportTo = value.defaultServiceExportTo;
      this._defaultVirtualServiceExportTo = value.defaultVirtualServiceExportTo;
      this._disableEnvoyListenerLog = value.disableEnvoyListenerLog;
      this._discoverySelectors.internalValue = value.discoverySelectors;
      this._dnsRefreshRate = value.dnsRefreshRate;
      this._enableAutoMtls = value.enableAutoMtls;
      this._enableEnvoyAccessLogService = value.enableEnvoyAccessLogService;
      this._enablePrometheusMerge = value.enablePrometheusMerge;
      this._enableTracing = value.enableTracing;
      this._extensionProviders.internalValue = value.extensionProviders;
      this._h2UpgradePolicy = value.h2UpgradePolicy;
      this._inboundClusterStatName = value.inboundClusterStatName;
      this._ingressClass = value.ingressClass;
      this._ingressControllerMode = value.ingressControllerMode;
      this._ingressSelector = value.ingressSelector;
      this._ingressService = value.ingressService;
      this._localityLbSetting.internalValue = value.localityLbSetting;
      this._meshMtls.internalValue = value.meshMtls;
      this._outboundClusterStatName = value.outboundClusterStatName;
      this._outboundTrafficPolicy.internalValue = value.outboundTrafficPolicy;
      this._pathNormalization.internalValue = value.pathNormalization;
      this._protocolDetectionTimeout = value.protocolDetectionTimeout;
      this._proxyHttpPort = value.proxyHttpPort;
      this._proxyListenPort = value.proxyListenPort;
      this._rootNamespace = value.rootNamespace;
      this._serviceSettings.internalValue = value.serviceSettings;
      this._tcpKeepalive.internalValue = value.tcpKeepalive;
      this._trustDomain = value.trustDomain;
      this._trustDomainAliases = value.trustDomainAliases;
      this._verifyCertificateAtClient = value.verifyCertificateAtClient;
    }
  }

  // access_log_encoding - computed: false, optional: true, required: false
  private _accessLogEncoding?: string; 
  public get accessLogEncoding() {
    return this.getStringAttribute('access_log_encoding');
  }
  public set accessLogEncoding(value: string) {
    this._accessLogEncoding = value;
  }
  public resetAccessLogEncoding() {
    this._accessLogEncoding = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessLogEncodingInput() {
    return this._accessLogEncoding;
  }

  // access_log_file - computed: false, optional: true, required: false
  private _accessLogFile?: string; 
  public get accessLogFile() {
    return this.getStringAttribute('access_log_file');
  }
  public set accessLogFile(value: string) {
    this._accessLogFile = value;
  }
  public resetAccessLogFile() {
    this._accessLogFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessLogFileInput() {
    return this._accessLogFile;
  }

  // access_log_format - computed: false, optional: true, required: false
  private _accessLogFormat?: string; 
  public get accessLogFormat() {
    return this.getStringAttribute('access_log_format');
  }
  public set accessLogFormat(value: string) {
    this._accessLogFormat = value;
  }
  public resetAccessLogFormat() {
    this._accessLogFormat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessLogFormatInput() {
    return this._accessLogFormat;
  }

  // ca - computed: false, optional: true, required: false
  private _ca = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCaOutputReference(this, "ca");
  public get ca() {
    return this._ca;
  }
  public putCa(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCa) {
    this._ca.internalValue = value;
  }
  public resetCa() {
    this._ca.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caInput() {
    return this._ca.internalValue;
  }

  // ca_certificates - computed: false, optional: true, required: false
  private _caCertificates = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCaCertificatesList(this, "ca_certificates", false);
  public get caCertificates() {
    return this._caCertificates;
  }
  public putCaCertificates(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCaCertificates[] | cdktf.IResolvable) {
    this._caCertificates.internalValue = value;
  }
  public resetCaCertificates() {
    this._caCertificates.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caCertificatesInput() {
    return this._caCertificates.internalValue;
  }

  // certificates - computed: false, optional: true, required: false
  private _certificates = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCertificatesList(this, "certificates", false);
  public get certificates() {
    return this._certificates;
  }
  public putCertificates(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigCertificates[] | cdktf.IResolvable) {
    this._certificates.internalValue = value;
  }
  public resetCertificates() {
    this._certificates.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificatesInput() {
    return this._certificates.internalValue;
  }

  // config_sources - computed: false, optional: true, required: false
  private _configSources = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigConfigSourcesList(this, "config_sources", false);
  public get configSources() {
    return this._configSources;
  }
  public putConfigSources(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigConfigSources[] | cdktf.IResolvable) {
    this._configSources.internalValue = value;
  }
  public resetConfigSources() {
    this._configSources.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configSourcesInput() {
    return this._configSources.internalValue;
  }

  // connect_timeout - computed: false, optional: true, required: false
  private _connectTimeout?: string; 
  public get connectTimeout() {
    return this.getStringAttribute('connect_timeout');
  }
  public set connectTimeout(value: string) {
    this._connectTimeout = value;
  }
  public resetConnectTimeout() {
    this._connectTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectTimeoutInput() {
    return this._connectTimeout;
  }

  // default_config - computed: false, optional: true, required: false
  private _defaultConfig = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfigOutputReference(this, "default_config");
  public get defaultConfig() {
    return this._defaultConfig;
  }
  public putDefaultConfig(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultConfig) {
    this._defaultConfig.internalValue = value;
  }
  public resetDefaultConfig() {
    this._defaultConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultConfigInput() {
    return this._defaultConfig.internalValue;
  }

  // default_destination_rule_export_to - computed: false, optional: true, required: false
  private _defaultDestinationRuleExportTo?: string[]; 
  public get defaultDestinationRuleExportTo() {
    return this.getListAttribute('default_destination_rule_export_to');
  }
  public set defaultDestinationRuleExportTo(value: string[]) {
    this._defaultDestinationRuleExportTo = value;
  }
  public resetDefaultDestinationRuleExportTo() {
    this._defaultDestinationRuleExportTo = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultDestinationRuleExportToInput() {
    return this._defaultDestinationRuleExportTo;
  }

  // default_http_retry_policy - computed: false, optional: true, required: false
  private _defaultHttpRetryPolicy = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultHttpRetryPolicyOutputReference(this, "default_http_retry_policy");
  public get defaultHttpRetryPolicy() {
    return this._defaultHttpRetryPolicy;
  }
  public putDefaultHttpRetryPolicy(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultHttpRetryPolicy) {
    this._defaultHttpRetryPolicy.internalValue = value;
  }
  public resetDefaultHttpRetryPolicy() {
    this._defaultHttpRetryPolicy.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultHttpRetryPolicyInput() {
    return this._defaultHttpRetryPolicy.internalValue;
  }

  // default_providers - computed: false, optional: true, required: false
  private _defaultProviders = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultProvidersOutputReference(this, "default_providers");
  public get defaultProviders() {
    return this._defaultProviders;
  }
  public putDefaultProviders(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDefaultProviders) {
    this._defaultProviders.internalValue = value;
  }
  public resetDefaultProviders() {
    this._defaultProviders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultProvidersInput() {
    return this._defaultProviders.internalValue;
  }

  // default_service_export_to - computed: false, optional: true, required: false
  private _defaultServiceExportTo?: string[]; 
  public get defaultServiceExportTo() {
    return this.getListAttribute('default_service_export_to');
  }
  public set defaultServiceExportTo(value: string[]) {
    this._defaultServiceExportTo = value;
  }
  public resetDefaultServiceExportTo() {
    this._defaultServiceExportTo = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultServiceExportToInput() {
    return this._defaultServiceExportTo;
  }

  // default_virtual_service_export_to - computed: false, optional: true, required: false
  private _defaultVirtualServiceExportTo?: string[]; 
  public get defaultVirtualServiceExportTo() {
    return this.getListAttribute('default_virtual_service_export_to');
  }
  public set defaultVirtualServiceExportTo(value: string[]) {
    this._defaultVirtualServiceExportTo = value;
  }
  public resetDefaultVirtualServiceExportTo() {
    this._defaultVirtualServiceExportTo = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultVirtualServiceExportToInput() {
    return this._defaultVirtualServiceExportTo;
  }

  // disable_envoy_listener_log - computed: false, optional: true, required: false
  private _disableEnvoyListenerLog?: boolean | cdktf.IResolvable; 
  public get disableEnvoyListenerLog() {
    return this.getBooleanAttribute('disable_envoy_listener_log');
  }
  public set disableEnvoyListenerLog(value: boolean | cdktf.IResolvable) {
    this._disableEnvoyListenerLog = value;
  }
  public resetDisableEnvoyListenerLog() {
    this._disableEnvoyListenerLog = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableEnvoyListenerLogInput() {
    return this._disableEnvoyListenerLog;
  }

  // discovery_selectors - computed: false, optional: true, required: false
  private _discoverySelectors = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDiscoverySelectorsList(this, "discovery_selectors", false);
  public get discoverySelectors() {
    return this._discoverySelectors;
  }
  public putDiscoverySelectors(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigDiscoverySelectors[] | cdktf.IResolvable) {
    this._discoverySelectors.internalValue = value;
  }
  public resetDiscoverySelectors() {
    this._discoverySelectors.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get discoverySelectorsInput() {
    return this._discoverySelectors.internalValue;
  }

  // dns_refresh_rate - computed: false, optional: true, required: false
  private _dnsRefreshRate?: string; 
  public get dnsRefreshRate() {
    return this.getStringAttribute('dns_refresh_rate');
  }
  public set dnsRefreshRate(value: string) {
    this._dnsRefreshRate = value;
  }
  public resetDnsRefreshRate() {
    this._dnsRefreshRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsRefreshRateInput() {
    return this._dnsRefreshRate;
  }

  // enable_auto_mtls - computed: false, optional: true, required: false
  private _enableAutoMtls?: boolean | cdktf.IResolvable; 
  public get enableAutoMtls() {
    return this.getBooleanAttribute('enable_auto_mtls');
  }
  public set enableAutoMtls(value: boolean | cdktf.IResolvable) {
    this._enableAutoMtls = value;
  }
  public resetEnableAutoMtls() {
    this._enableAutoMtls = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableAutoMtlsInput() {
    return this._enableAutoMtls;
  }

  // enable_envoy_access_log_service - computed: false, optional: true, required: false
  private _enableEnvoyAccessLogService?: boolean | cdktf.IResolvable; 
  public get enableEnvoyAccessLogService() {
    return this.getBooleanAttribute('enable_envoy_access_log_service');
  }
  public set enableEnvoyAccessLogService(value: boolean | cdktf.IResolvable) {
    this._enableEnvoyAccessLogService = value;
  }
  public resetEnableEnvoyAccessLogService() {
    this._enableEnvoyAccessLogService = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableEnvoyAccessLogServiceInput() {
    return this._enableEnvoyAccessLogService;
  }

  // enable_prometheus_merge - computed: false, optional: true, required: false
  private _enablePrometheusMerge?: boolean | cdktf.IResolvable; 
  public get enablePrometheusMerge() {
    return this.getBooleanAttribute('enable_prometheus_merge');
  }
  public set enablePrometheusMerge(value: boolean | cdktf.IResolvable) {
    this._enablePrometheusMerge = value;
  }
  public resetEnablePrometheusMerge() {
    this._enablePrometheusMerge = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enablePrometheusMergeInput() {
    return this._enablePrometheusMerge;
  }

  // enable_tracing - computed: false, optional: true, required: false
  private _enableTracing?: boolean | cdktf.IResolvable; 
  public get enableTracing() {
    return this.getBooleanAttribute('enable_tracing');
  }
  public set enableTracing(value: boolean | cdktf.IResolvable) {
    this._enableTracing = value;
  }
  public resetEnableTracing() {
    this._enableTracing = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableTracingInput() {
    return this._enableTracing;
  }

  // extension_providers - computed: false, optional: true, required: false
  private _extensionProviders = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProvidersList(this, "extension_providers", false);
  public get extensionProviders() {
    return this._extensionProviders;
  }
  public putExtensionProviders(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigExtensionProviders[] | cdktf.IResolvable) {
    this._extensionProviders.internalValue = value;
  }
  public resetExtensionProviders() {
    this._extensionProviders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extensionProvidersInput() {
    return this._extensionProviders.internalValue;
  }

  // h2_upgrade_policy - computed: false, optional: true, required: false
  private _h2UpgradePolicy?: string; 
  public get h2UpgradePolicy() {
    return this.getStringAttribute('h2_upgrade_policy');
  }
  public set h2UpgradePolicy(value: string) {
    this._h2UpgradePolicy = value;
  }
  public resetH2UpgradePolicy() {
    this._h2UpgradePolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get h2UpgradePolicyInput() {
    return this._h2UpgradePolicy;
  }

  // inbound_cluster_stat_name - computed: false, optional: true, required: false
  private _inboundClusterStatName?: string; 
  public get inboundClusterStatName() {
    return this.getStringAttribute('inbound_cluster_stat_name');
  }
  public set inboundClusterStatName(value: string) {
    this._inboundClusterStatName = value;
  }
  public resetInboundClusterStatName() {
    this._inboundClusterStatName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inboundClusterStatNameInput() {
    return this._inboundClusterStatName;
  }

  // ingress_class - computed: false, optional: true, required: false
  private _ingressClass?: string; 
  public get ingressClass() {
    return this.getStringAttribute('ingress_class');
  }
  public set ingressClass(value: string) {
    this._ingressClass = value;
  }
  public resetIngressClass() {
    this._ingressClass = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ingressClassInput() {
    return this._ingressClass;
  }

  // ingress_controller_mode - computed: false, optional: true, required: false
  private _ingressControllerMode?: string; 
  public get ingressControllerMode() {
    return this.getStringAttribute('ingress_controller_mode');
  }
  public set ingressControllerMode(value: string) {
    this._ingressControllerMode = value;
  }
  public resetIngressControllerMode() {
    this._ingressControllerMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ingressControllerModeInput() {
    return this._ingressControllerMode;
  }

  // ingress_selector - computed: false, optional: true, required: false
  private _ingressSelector?: string; 
  public get ingressSelector() {
    return this.getStringAttribute('ingress_selector');
  }
  public set ingressSelector(value: string) {
    this._ingressSelector = value;
  }
  public resetIngressSelector() {
    this._ingressSelector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ingressSelectorInput() {
    return this._ingressSelector;
  }

  // ingress_service - computed: false, optional: true, required: false
  private _ingressService?: string; 
  public get ingressService() {
    return this.getStringAttribute('ingress_service');
  }
  public set ingressService(value: string) {
    this._ingressService = value;
  }
  public resetIngressService() {
    this._ingressService = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ingressServiceInput() {
    return this._ingressService;
  }

  // locality_lb_setting - computed: false, optional: true, required: false
  private _localityLbSetting = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigLocalityLbSettingOutputReference(this, "locality_lb_setting");
  public get localityLbSetting() {
    return this._localityLbSetting;
  }
  public putLocalityLbSetting(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigLocalityLbSetting) {
    this._localityLbSetting.internalValue = value;
  }
  public resetLocalityLbSetting() {
    this._localityLbSetting.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localityLbSettingInput() {
    return this._localityLbSetting.internalValue;
  }

  // mesh_mtls - computed: false, optional: true, required: false
  private _meshMtls = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigMeshMtlsOutputReference(this, "mesh_mtls");
  public get meshMtls() {
    return this._meshMtls;
  }
  public putMeshMtls(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigMeshMtls) {
    this._meshMtls.internalValue = value;
  }
  public resetMeshMtls() {
    this._meshMtls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get meshMtlsInput() {
    return this._meshMtls.internalValue;
  }

  // outbound_cluster_stat_name - computed: false, optional: true, required: false
  private _outboundClusterStatName?: string; 
  public get outboundClusterStatName() {
    return this.getStringAttribute('outbound_cluster_stat_name');
  }
  public set outboundClusterStatName(value: string) {
    this._outboundClusterStatName = value;
  }
  public resetOutboundClusterStatName() {
    this._outboundClusterStatName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get outboundClusterStatNameInput() {
    return this._outboundClusterStatName;
  }

  // outbound_traffic_policy - computed: false, optional: true, required: false
  private _outboundTrafficPolicy = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigOutboundTrafficPolicyOutputReference(this, "outbound_traffic_policy");
  public get outboundTrafficPolicy() {
    return this._outboundTrafficPolicy;
  }
  public putOutboundTrafficPolicy(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigOutboundTrafficPolicy) {
    this._outboundTrafficPolicy.internalValue = value;
  }
  public resetOutboundTrafficPolicy() {
    this._outboundTrafficPolicy.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get outboundTrafficPolicyInput() {
    return this._outboundTrafficPolicy.internalValue;
  }

  // path_normalization - computed: false, optional: true, required: false
  private _pathNormalization = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigPathNormalizationOutputReference(this, "path_normalization");
  public get pathNormalization() {
    return this._pathNormalization;
  }
  public putPathNormalization(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigPathNormalization) {
    this._pathNormalization.internalValue = value;
  }
  public resetPathNormalization() {
    this._pathNormalization.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathNormalizationInput() {
    return this._pathNormalization.internalValue;
  }

  // protocol_detection_timeout - computed: false, optional: true, required: false
  private _protocolDetectionTimeout?: string; 
  public get protocolDetectionTimeout() {
    return this.getStringAttribute('protocol_detection_timeout');
  }
  public set protocolDetectionTimeout(value: string) {
    this._protocolDetectionTimeout = value;
  }
  public resetProtocolDetectionTimeout() {
    this._protocolDetectionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolDetectionTimeoutInput() {
    return this._protocolDetectionTimeout;
  }

  // proxy_http_port - computed: false, optional: true, required: false
  private _proxyHttpPort?: number; 
  public get proxyHttpPort() {
    return this.getNumberAttribute('proxy_http_port');
  }
  public set proxyHttpPort(value: number) {
    this._proxyHttpPort = value;
  }
  public resetProxyHttpPort() {
    this._proxyHttpPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyHttpPortInput() {
    return this._proxyHttpPort;
  }

  // proxy_listen_port - computed: false, optional: true, required: false
  private _proxyListenPort?: number; 
  public get proxyListenPort() {
    return this.getNumberAttribute('proxy_listen_port');
  }
  public set proxyListenPort(value: number) {
    this._proxyListenPort = value;
  }
  public resetProxyListenPort() {
    this._proxyListenPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyListenPortInput() {
    return this._proxyListenPort;
  }

  // root_namespace - computed: false, optional: true, required: false
  private _rootNamespace?: string; 
  public get rootNamespace() {
    return this.getStringAttribute('root_namespace');
  }
  public set rootNamespace(value: string) {
    this._rootNamespace = value;
  }
  public resetRootNamespace() {
    this._rootNamespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rootNamespaceInput() {
    return this._rootNamespace;
  }

  // service_settings - computed: false, optional: true, required: false
  private _serviceSettings = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigServiceSettingsList(this, "service_settings", false);
  public get serviceSettings() {
    return this._serviceSettings;
  }
  public putServiceSettings(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigServiceSettings[] | cdktf.IResolvable) {
    this._serviceSettings.internalValue = value;
  }
  public resetServiceSettings() {
    this._serviceSettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceSettingsInput() {
    return this._serviceSettings.internalValue;
  }

  // tcp_keepalive - computed: false, optional: true, required: false
  private _tcpKeepalive = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigTcpKeepaliveOutputReference(this, "tcp_keepalive");
  public get tcpKeepalive() {
    return this._tcpKeepalive;
  }
  public putTcpKeepalive(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshConfigTcpKeepalive) {
    this._tcpKeepalive.internalValue = value;
  }
  public resetTcpKeepalive() {
    this._tcpKeepalive.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tcpKeepaliveInput() {
    return this._tcpKeepalive.internalValue;
  }

  // trust_domain - computed: false, optional: true, required: false
  private _trustDomain?: string; 
  public get trustDomain() {
    return this.getStringAttribute('trust_domain');
  }
  public set trustDomain(value: string) {
    this._trustDomain = value;
  }
  public resetTrustDomain() {
    this._trustDomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get trustDomainInput() {
    return this._trustDomain;
  }

  // trust_domain_aliases - computed: false, optional: true, required: false
  private _trustDomainAliases?: string[]; 
  public get trustDomainAliases() {
    return this.getListAttribute('trust_domain_aliases');
  }
  public set trustDomainAliases(value: string[]) {
    this._trustDomainAliases = value;
  }
  public resetTrustDomainAliases() {
    this._trustDomainAliases = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get trustDomainAliasesInput() {
    return this._trustDomainAliases;
  }

  // verify_certificate_at_client - computed: false, optional: true, required: false
  private _verifyCertificateAtClient?: boolean | cdktf.IResolvable; 
  public get verifyCertificateAtClient() {
    return this.getBooleanAttribute('verify_certificate_at_client');
  }
  public set verifyCertificateAtClient(value: boolean | cdktf.IResolvable) {
    this._verifyCertificateAtClient = value;
  }
  public resetVerifyCertificateAtClient() {
    this._verifyCertificateAtClient = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verifyCertificateAtClientInput() {
    return this._verifyCertificateAtClient;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionClusterServices {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#expose DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#expose}
  */
  readonly expose?: boolean | cdktf.IResolvable;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionClusterServicesToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionClusterServices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    expose: cdktf.booleanToTerraform(struct!.expose),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionClusterServicesToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionClusterServices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    expose: {
      value: cdktf.booleanToHclTerraform(struct!.expose),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionClusterServicesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionClusterServices | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._expose !== undefined) {
      hasAnyValues = true;
      internalValueResult.expose = this._expose;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionClusterServices | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._expose = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._expose = value.expose;
    }
  }

  // expose - computed: false, optional: true, required: false
  private _expose?: boolean | cdktf.IResolvable; 
  public get expose() {
    return this.getBooleanAttribute('expose');
  }
  public set expose(value: boolean | cdktf.IResolvable) {
    this._expose = value;
  }
  public resetExpose() {
    this._expose = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exposeInput() {
    return this._expose;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#key DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#operator DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#operator}
  */
  readonly operator?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#values DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutputReference {
    return new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#key DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#operator DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#operator}
  */
  readonly operator?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#values DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsList extends cdktf.ComplexList {
  public internalValue? : DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutputReference {
    return new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#match_expressions DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#match_fields DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#match_fields}
  */
  readonly matchFields?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[] | cdktf.IResolvable;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_fields: cdktf.listMapper(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsToTerraform, false)(struct!.matchFields),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsList",
    },
    match_fields: {
      value: cdktf.listMapperHcl(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsToHclTerraform, false)(struct!.matchFields),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchFields?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchFields = this._matchFields?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchFields.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchFields.internalValue = value.matchFields;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_fields - computed: false, optional: true, required: false
  private _matchFields = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsList(this, "match_fields", false);
  public get matchFields() {
    return this._matchFields;
  }
  public putMatchFields(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[] | cdktf.IResolvable) {
    this._matchFields.internalValue = value;
  }
  public resetMatchFields() {
    this._matchFields.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchFieldsInput() {
    return this._matchFields.internalValue;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#preference DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#preference}
  */
  readonly preference?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#weight DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#weight}
  */
  readonly weight?: number;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    preference: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceToTerraform(struct!.preference),
    weight: cdktf.numberToTerraform(struct!.weight),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    preference: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceToHclTerraform(struct!.preference),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference",
    },
    weight: {
      value: cdktf.numberToHclTerraform(struct!.weight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._preference?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.preference = this._preference?.internalValue;
    }
    if (this._weight !== undefined) {
      hasAnyValues = true;
      internalValueResult.weight = this._weight;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._preference.internalValue = undefined;
      this._weight = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._preference.internalValue = value.preference;
      this._weight = value.weight;
    }
  }

  // preference - computed: false, optional: true, required: false
  private _preference = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutputReference(this, "preference");
  public get preference() {
    return this._preference;
  }
  public putPreference(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference) {
    this._preference.internalValue = value;
  }
  public resetPreference() {
    this._preference.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preferenceInput() {
    return this._preference.internalValue;
  }

  // weight - computed: false, optional: true, required: false
  private _weight?: number; 
  public get weight() {
    return this.getNumberAttribute('weight');
  }
  public set weight(value: number) {
    this._weight = value;
  }
  public resetWeight() {
    this._weight = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get weightInput() {
    return this._weight;
  }
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionList extends cdktf.ComplexList {
  public internalValue? : DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference {
    return new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#key DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#operator DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#operator}
  */
  readonly operator?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#values DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutputReference {
    return new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#key DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#operator DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#operator}
  */
  readonly operator?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#values DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsList extends cdktf.ComplexList {
  public internalValue? : DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutputReference {
    return new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#match_expressions DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#match_fields DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#match_fields}
  */
  readonly matchFields?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[] | cdktf.IResolvable;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_fields: cdktf.listMapper(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsToTerraform, false)(struct!.matchFields),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsList",
    },
    match_fields: {
      value: cdktf.listMapperHcl(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsToHclTerraform, false)(struct!.matchFields),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchFields?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchFields = this._matchFields?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchFields.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchFields.internalValue = value.matchFields;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_fields - computed: false, optional: true, required: false
  private _matchFields = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsList(this, "match_fields", false);
  public get matchFields() {
    return this._matchFields;
  }
  public putMatchFields(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[] | cdktf.IResolvable) {
    this._matchFields.internalValue = value;
  }
  public resetMatchFields() {
    this._matchFields.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchFieldsInput() {
    return this._matchFields.internalValue;
  }
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsList extends cdktf.ComplexList {
  public internalValue? : DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutputReference {
    return new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#node_selector_terms DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#node_selector_terms}
  */
  readonly nodeSelectorTerms?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[] | cdktf.IResolvable;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    node_selector_terms: cdktf.listMapper(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsToTerraform, false)(struct!.nodeSelectorTerms),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    node_selector_terms: {
      value: cdktf.listMapperHcl(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsToHclTerraform, false)(struct!.nodeSelectorTerms),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._nodeSelectorTerms?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeSelectorTerms = this._nodeSelectorTerms?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._nodeSelectorTerms.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._nodeSelectorTerms.internalValue = value.nodeSelectorTerms;
    }
  }

  // node_selector_terms - computed: false, optional: true, required: false
  private _nodeSelectorTerms = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsList(this, "node_selector_terms", false);
  public get nodeSelectorTerms() {
    return this._nodeSelectorTerms;
  }
  public putNodeSelectorTerms(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[] | cdktf.IResolvable) {
    this._nodeSelectorTerms.internalValue = value;
  }
  public resetNodeSelectorTerms() {
    this._nodeSelectorTerms.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeSelectorTermsInput() {
    return this._nodeSelectorTerms.internalValue;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinity {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#preferred_during_scheduling_ignored_during_execution DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#preferred_during_scheduling_ignored_during_execution}
  */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#required_during_scheduling_ignored_during_execution DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#required_during_scheduling_ignored_during_execution}
  */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    preferred_during_scheduling_ignored_during_execution: cdktf.listMapper(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionToTerraform, false)(struct!.preferredDuringSchedulingIgnoredDuringExecution),
    required_during_scheduling_ignored_during_execution: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionToTerraform(struct!.requiredDuringSchedulingIgnoredDuringExecution),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    preferred_during_scheduling_ignored_during_execution: {
      value: cdktf.listMapperHcl(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionToHclTerraform, false)(struct!.preferredDuringSchedulingIgnoredDuringExecution),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionList",
    },
    required_during_scheduling_ignored_during_execution: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionToHclTerraform(struct!.requiredDuringSchedulingIgnoredDuringExecution),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._preferredDuringSchedulingIgnoredDuringExecution?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.preferredDuringSchedulingIgnoredDuringExecution = this._preferredDuringSchedulingIgnoredDuringExecution?.internalValue;
    }
    if (this._requiredDuringSchedulingIgnoredDuringExecution?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.requiredDuringSchedulingIgnoredDuringExecution = this._requiredDuringSchedulingIgnoredDuringExecution?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
      this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = value.preferredDuringSchedulingIgnoredDuringExecution;
      this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = value.requiredDuringSchedulingIgnoredDuringExecution;
    }
  }

  // preferred_during_scheduling_ignored_during_execution - computed: false, optional: true, required: false
  private _preferredDuringSchedulingIgnoredDuringExecution = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionList(this, "preferred_during_scheduling_ignored_during_execution", false);
  public get preferredDuringSchedulingIgnoredDuringExecution() {
    return this._preferredDuringSchedulingIgnoredDuringExecution;
  }
  public putPreferredDuringSchedulingIgnoredDuringExecution(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable) {
    this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = value;
  }
  public resetPreferredDuringSchedulingIgnoredDuringExecution() {
    this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preferredDuringSchedulingIgnoredDuringExecutionInput() {
    return this._preferredDuringSchedulingIgnoredDuringExecution.internalValue;
  }

  // required_during_scheduling_ignored_during_execution - computed: false, optional: true, required: false
  private _requiredDuringSchedulingIgnoredDuringExecution = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference(this, "required_during_scheduling_ignored_during_execution");
  public get requiredDuringSchedulingIgnoredDuringExecution() {
    return this._requiredDuringSchedulingIgnoredDuringExecution;
  }
  public putRequiredDuringSchedulingIgnoredDuringExecution(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution) {
    this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = value;
  }
  public resetRequiredDuringSchedulingIgnoredDuringExecution() {
    this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requiredDuringSchedulingIgnoredDuringExecutionInput() {
    return this._requiredDuringSchedulingIgnoredDuringExecution.internalValue;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#key DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#operator DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#operator}
  */
  readonly operator?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#values DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference {
    return new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#match_expressions DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#match_labels DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#key DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#operator DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#operator}
  */
  readonly operator?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#values DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputReference {
    return new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#match_expressions DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#match_labels DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#label_selector DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#label_selector}
  */
  readonly labelSelector?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#namespace_selector DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#namespace_selector}
  */
  readonly namespaceSelector?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#namespaces DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#namespaces}
  */
  readonly namespaces?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#topology_key DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#topology_key}
  */
  readonly topologyKey?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label_selector: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToTerraform(struct!.labelSelector),
    namespace_selector: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToTerraform(struct!.namespaceSelector),
    namespaces: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.namespaces),
    topology_key: cdktf.stringToTerraform(struct!.topologyKey),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label_selector: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToHclTerraform(struct!.labelSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    },
    namespace_selector: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToHclTerraform(struct!.namespaceSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector",
    },
    namespaces: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.namespaces),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    topology_key: {
      value: cdktf.stringToHclTerraform(struct!.topologyKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._labelSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSelector = this._labelSelector?.internalValue;
    }
    if (this._namespaceSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaceSelector = this._namespaceSelector?.internalValue;
    }
    if (this._namespaces !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaces = this._namespaces;
    }
    if (this._topologyKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.topologyKey = this._topologyKey;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = undefined;
      this._namespaceSelector.internalValue = undefined;
      this._namespaces = undefined;
      this._topologyKey = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = value.labelSelector;
      this._namespaceSelector.internalValue = value.namespaceSelector;
      this._namespaces = value.namespaces;
      this._topologyKey = value.topologyKey;
    }
  }

  // label_selector - computed: false, optional: true, required: false
  private _labelSelector = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputReference(this, "label_selector");
  public get labelSelector() {
    return this._labelSelector;
  }
  public putLabelSelector(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) {
    this._labelSelector.internalValue = value;
  }
  public resetLabelSelector() {
    this._labelSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSelectorInput() {
    return this._labelSelector.internalValue;
  }

  // namespace_selector - computed: false, optional: true, required: false
  private _namespaceSelector = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputReference(this, "namespace_selector");
  public get namespaceSelector() {
    return this._namespaceSelector;
  }
  public putNamespaceSelector(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) {
    this._namespaceSelector.internalValue = value;
  }
  public resetNamespaceSelector() {
    this._namespaceSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceSelectorInput() {
    return this._namespaceSelector.internalValue;
  }

  // namespaces - computed: false, optional: true, required: false
  private _namespaces?: string[]; 
  public get namespaces() {
    return this.getListAttribute('namespaces');
  }
  public set namespaces(value: string[]) {
    this._namespaces = value;
  }
  public resetNamespaces() {
    this._namespaces = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespacesInput() {
    return this._namespaces;
  }

  // topology_key - computed: false, optional: true, required: false
  private _topologyKey?: string; 
  public get topologyKey() {
    return this.getStringAttribute('topology_key');
  }
  public set topologyKey(value: string) {
    this._topologyKey = value;
  }
  public resetTopologyKey() {
    this._topologyKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get topologyKeyInput() {
    return this._topologyKey;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#pod_affinity_term DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#pod_affinity_term}
  */
  readonly podAffinityTerm?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#weight DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#weight}
  */
  readonly weight?: number;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    pod_affinity_term: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToTerraform(struct!.podAffinityTerm),
    weight: cdktf.numberToTerraform(struct!.weight),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    pod_affinity_term: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToHclTerraform(struct!.podAffinityTerm),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    },
    weight: {
      value: cdktf.numberToHclTerraform(struct!.weight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._podAffinityTerm?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.podAffinityTerm = this._podAffinityTerm?.internalValue;
    }
    if (this._weight !== undefined) {
      hasAnyValues = true;
      internalValueResult.weight = this._weight;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._podAffinityTerm.internalValue = undefined;
      this._weight = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._podAffinityTerm.internalValue = value.podAffinityTerm;
      this._weight = value.weight;
    }
  }

  // pod_affinity_term - computed: false, optional: true, required: false
  private _podAffinityTerm = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputReference(this, "pod_affinity_term");
  public get podAffinityTerm() {
    return this._podAffinityTerm;
  }
  public putPodAffinityTerm(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) {
    this._podAffinityTerm.internalValue = value;
  }
  public resetPodAffinityTerm() {
    this._podAffinityTerm.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podAffinityTermInput() {
    return this._podAffinityTerm.internalValue;
  }

  // weight - computed: false, optional: true, required: false
  private _weight?: number; 
  public get weight() {
    return this.getNumberAttribute('weight');
  }
  public set weight(value: number) {
    this._weight = value;
  }
  public resetWeight() {
    this._weight = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get weightInput() {
    return this._weight;
  }
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionList extends cdktf.ComplexList {
  public internalValue? : DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference {
    return new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#key DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#operator DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#operator}
  */
  readonly operator?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#values DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference {
    return new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#match_expressions DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#match_labels DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#key DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#operator DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#operator}
  */
  readonly operator?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#values DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputReference {
    return new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#match_expressions DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#match_labels DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#label_selector DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#label_selector}
  */
  readonly labelSelector?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#namespace_selector DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#namespace_selector}
  */
  readonly namespaceSelector?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#namespaces DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#namespaces}
  */
  readonly namespaces?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#topology_key DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#topology_key}
  */
  readonly topologyKey?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label_selector: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToTerraform(struct!.labelSelector),
    namespace_selector: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToTerraform(struct!.namespaceSelector),
    namespaces: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.namespaces),
    topology_key: cdktf.stringToTerraform(struct!.topologyKey),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label_selector: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToHclTerraform(struct!.labelSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    },
    namespace_selector: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToHclTerraform(struct!.namespaceSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector",
    },
    namespaces: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.namespaces),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    topology_key: {
      value: cdktf.stringToHclTerraform(struct!.topologyKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._labelSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSelector = this._labelSelector?.internalValue;
    }
    if (this._namespaceSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaceSelector = this._namespaceSelector?.internalValue;
    }
    if (this._namespaces !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaces = this._namespaces;
    }
    if (this._topologyKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.topologyKey = this._topologyKey;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = undefined;
      this._namespaceSelector.internalValue = undefined;
      this._namespaces = undefined;
      this._topologyKey = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = value.labelSelector;
      this._namespaceSelector.internalValue = value.namespaceSelector;
      this._namespaces = value.namespaces;
      this._topologyKey = value.topologyKey;
    }
  }

  // label_selector - computed: false, optional: true, required: false
  private _labelSelector = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputReference(this, "label_selector");
  public get labelSelector() {
    return this._labelSelector;
  }
  public putLabelSelector(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) {
    this._labelSelector.internalValue = value;
  }
  public resetLabelSelector() {
    this._labelSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSelectorInput() {
    return this._labelSelector.internalValue;
  }

  // namespace_selector - computed: false, optional: true, required: false
  private _namespaceSelector = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputReference(this, "namespace_selector");
  public get namespaceSelector() {
    return this._namespaceSelector;
  }
  public putNamespaceSelector(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) {
    this._namespaceSelector.internalValue = value;
  }
  public resetNamespaceSelector() {
    this._namespaceSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceSelectorInput() {
    return this._namespaceSelector.internalValue;
  }

  // namespaces - computed: false, optional: true, required: false
  private _namespaces?: string[]; 
  public get namespaces() {
    return this.getListAttribute('namespaces');
  }
  public set namespaces(value: string[]) {
    this._namespaces = value;
  }
  public resetNamespaces() {
    this._namespaces = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespacesInput() {
    return this._namespaces;
  }

  // topology_key - computed: false, optional: true, required: false
  private _topologyKey?: string; 
  public get topologyKey() {
    return this.getStringAttribute('topology_key');
  }
  public set topologyKey(value: string) {
    this._topologyKey = value;
  }
  public resetTopologyKey() {
    this._topologyKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get topologyKeyInput() {
    return this._topologyKey;
  }
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionList extends cdktf.ComplexList {
  public internalValue? : DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference {
    return new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinity {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#preferred_during_scheduling_ignored_during_execution DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#preferred_during_scheduling_ignored_during_execution}
  */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#required_during_scheduling_ignored_during_execution DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#required_during_scheduling_ignored_during_execution}
  */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    preferred_during_scheduling_ignored_during_execution: cdktf.listMapper(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionToTerraform, false)(struct!.preferredDuringSchedulingIgnoredDuringExecution),
    required_during_scheduling_ignored_during_execution: cdktf.listMapper(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionToTerraform, false)(struct!.requiredDuringSchedulingIgnoredDuringExecution),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    preferred_during_scheduling_ignored_during_execution: {
      value: cdktf.listMapperHcl(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionToHclTerraform, false)(struct!.preferredDuringSchedulingIgnoredDuringExecution),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionList",
    },
    required_during_scheduling_ignored_during_execution: {
      value: cdktf.listMapperHcl(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionToHclTerraform, false)(struct!.requiredDuringSchedulingIgnoredDuringExecution),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._preferredDuringSchedulingIgnoredDuringExecution?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.preferredDuringSchedulingIgnoredDuringExecution = this._preferredDuringSchedulingIgnoredDuringExecution?.internalValue;
    }
    if (this._requiredDuringSchedulingIgnoredDuringExecution?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.requiredDuringSchedulingIgnoredDuringExecution = this._requiredDuringSchedulingIgnoredDuringExecution?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
      this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = value.preferredDuringSchedulingIgnoredDuringExecution;
      this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = value.requiredDuringSchedulingIgnoredDuringExecution;
    }
  }

  // preferred_during_scheduling_ignored_during_execution - computed: false, optional: true, required: false
  private _preferredDuringSchedulingIgnoredDuringExecution = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionList(this, "preferred_during_scheduling_ignored_during_execution", false);
  public get preferredDuringSchedulingIgnoredDuringExecution() {
    return this._preferredDuringSchedulingIgnoredDuringExecution;
  }
  public putPreferredDuringSchedulingIgnoredDuringExecution(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable) {
    this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = value;
  }
  public resetPreferredDuringSchedulingIgnoredDuringExecution() {
    this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preferredDuringSchedulingIgnoredDuringExecutionInput() {
    return this._preferredDuringSchedulingIgnoredDuringExecution.internalValue;
  }

  // required_during_scheduling_ignored_during_execution - computed: false, optional: true, required: false
  private _requiredDuringSchedulingIgnoredDuringExecution = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionList(this, "required_during_scheduling_ignored_during_execution", false);
  public get requiredDuringSchedulingIgnoredDuringExecution() {
    return this._requiredDuringSchedulingIgnoredDuringExecution;
  }
  public putRequiredDuringSchedulingIgnoredDuringExecution(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable) {
    this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = value;
  }
  public resetRequiredDuringSchedulingIgnoredDuringExecution() {
    this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requiredDuringSchedulingIgnoredDuringExecutionInput() {
    return this._requiredDuringSchedulingIgnoredDuringExecution.internalValue;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#key DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#operator DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#operator}
  */
  readonly operator?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#values DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference {
    return new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#match_expressions DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#match_labels DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#key DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#operator DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#operator}
  */
  readonly operator?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#values DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputReference {
    return new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#match_expressions DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#match_labels DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#label_selector DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#label_selector}
  */
  readonly labelSelector?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#namespace_selector DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#namespace_selector}
  */
  readonly namespaceSelector?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#namespaces DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#namespaces}
  */
  readonly namespaces?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#topology_key DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#topology_key}
  */
  readonly topologyKey?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label_selector: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToTerraform(struct!.labelSelector),
    namespace_selector: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToTerraform(struct!.namespaceSelector),
    namespaces: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.namespaces),
    topology_key: cdktf.stringToTerraform(struct!.topologyKey),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label_selector: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToHclTerraform(struct!.labelSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    },
    namespace_selector: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToHclTerraform(struct!.namespaceSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector",
    },
    namespaces: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.namespaces),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    topology_key: {
      value: cdktf.stringToHclTerraform(struct!.topologyKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._labelSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSelector = this._labelSelector?.internalValue;
    }
    if (this._namespaceSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaceSelector = this._namespaceSelector?.internalValue;
    }
    if (this._namespaces !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaces = this._namespaces;
    }
    if (this._topologyKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.topologyKey = this._topologyKey;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = undefined;
      this._namespaceSelector.internalValue = undefined;
      this._namespaces = undefined;
      this._topologyKey = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = value.labelSelector;
      this._namespaceSelector.internalValue = value.namespaceSelector;
      this._namespaces = value.namespaces;
      this._topologyKey = value.topologyKey;
    }
  }

  // label_selector - computed: false, optional: true, required: false
  private _labelSelector = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputReference(this, "label_selector");
  public get labelSelector() {
    return this._labelSelector;
  }
  public putLabelSelector(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) {
    this._labelSelector.internalValue = value;
  }
  public resetLabelSelector() {
    this._labelSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSelectorInput() {
    return this._labelSelector.internalValue;
  }

  // namespace_selector - computed: false, optional: true, required: false
  private _namespaceSelector = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputReference(this, "namespace_selector");
  public get namespaceSelector() {
    return this._namespaceSelector;
  }
  public putNamespaceSelector(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) {
    this._namespaceSelector.internalValue = value;
  }
  public resetNamespaceSelector() {
    this._namespaceSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceSelectorInput() {
    return this._namespaceSelector.internalValue;
  }

  // namespaces - computed: false, optional: true, required: false
  private _namespaces?: string[]; 
  public get namespaces() {
    return this.getListAttribute('namespaces');
  }
  public set namespaces(value: string[]) {
    this._namespaces = value;
  }
  public resetNamespaces() {
    this._namespaces = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespacesInput() {
    return this._namespaces;
  }

  // topology_key - computed: false, optional: true, required: false
  private _topologyKey?: string; 
  public get topologyKey() {
    return this.getStringAttribute('topology_key');
  }
  public set topologyKey(value: string) {
    this._topologyKey = value;
  }
  public resetTopologyKey() {
    this._topologyKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get topologyKeyInput() {
    return this._topologyKey;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#pod_affinity_term DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#pod_affinity_term}
  */
  readonly podAffinityTerm?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#weight DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#weight}
  */
  readonly weight?: number;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    pod_affinity_term: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToTerraform(struct!.podAffinityTerm),
    weight: cdktf.numberToTerraform(struct!.weight),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    pod_affinity_term: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToHclTerraform(struct!.podAffinityTerm),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    },
    weight: {
      value: cdktf.numberToHclTerraform(struct!.weight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._podAffinityTerm?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.podAffinityTerm = this._podAffinityTerm?.internalValue;
    }
    if (this._weight !== undefined) {
      hasAnyValues = true;
      internalValueResult.weight = this._weight;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._podAffinityTerm.internalValue = undefined;
      this._weight = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._podAffinityTerm.internalValue = value.podAffinityTerm;
      this._weight = value.weight;
    }
  }

  // pod_affinity_term - computed: false, optional: true, required: false
  private _podAffinityTerm = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputReference(this, "pod_affinity_term");
  public get podAffinityTerm() {
    return this._podAffinityTerm;
  }
  public putPodAffinityTerm(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) {
    this._podAffinityTerm.internalValue = value;
  }
  public resetPodAffinityTerm() {
    this._podAffinityTerm.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podAffinityTermInput() {
    return this._podAffinityTerm.internalValue;
  }

  // weight - computed: false, optional: true, required: false
  private _weight?: number; 
  public get weight() {
    return this.getNumberAttribute('weight');
  }
  public set weight(value: number) {
    this._weight = value;
  }
  public resetWeight() {
    this._weight = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get weightInput() {
    return this._weight;
  }
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionList extends cdktf.ComplexList {
  public internalValue? : DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference {
    return new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#key DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#operator DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#operator}
  */
  readonly operator?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#values DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference {
    return new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#match_expressions DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#match_labels DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#key DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#operator DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#operator}
  */
  readonly operator?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#values DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputReference {
    return new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#match_expressions DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#match_labels DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#label_selector DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#label_selector}
  */
  readonly labelSelector?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#namespace_selector DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#namespace_selector}
  */
  readonly namespaceSelector?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#namespaces DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#namespaces}
  */
  readonly namespaces?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#topology_key DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#topology_key}
  */
  readonly topologyKey?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label_selector: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToTerraform(struct!.labelSelector),
    namespace_selector: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToTerraform(struct!.namespaceSelector),
    namespaces: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.namespaces),
    topology_key: cdktf.stringToTerraform(struct!.topologyKey),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label_selector: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToHclTerraform(struct!.labelSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    },
    namespace_selector: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToHclTerraform(struct!.namespaceSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector",
    },
    namespaces: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.namespaces),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    topology_key: {
      value: cdktf.stringToHclTerraform(struct!.topologyKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._labelSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSelector = this._labelSelector?.internalValue;
    }
    if (this._namespaceSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaceSelector = this._namespaceSelector?.internalValue;
    }
    if (this._namespaces !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaces = this._namespaces;
    }
    if (this._topologyKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.topologyKey = this._topologyKey;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = undefined;
      this._namespaceSelector.internalValue = undefined;
      this._namespaces = undefined;
      this._topologyKey = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = value.labelSelector;
      this._namespaceSelector.internalValue = value.namespaceSelector;
      this._namespaces = value.namespaces;
      this._topologyKey = value.topologyKey;
    }
  }

  // label_selector - computed: false, optional: true, required: false
  private _labelSelector = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputReference(this, "label_selector");
  public get labelSelector() {
    return this._labelSelector;
  }
  public putLabelSelector(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) {
    this._labelSelector.internalValue = value;
  }
  public resetLabelSelector() {
    this._labelSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSelectorInput() {
    return this._labelSelector.internalValue;
  }

  // namespace_selector - computed: false, optional: true, required: false
  private _namespaceSelector = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputReference(this, "namespace_selector");
  public get namespaceSelector() {
    return this._namespaceSelector;
  }
  public putNamespaceSelector(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) {
    this._namespaceSelector.internalValue = value;
  }
  public resetNamespaceSelector() {
    this._namespaceSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceSelectorInput() {
    return this._namespaceSelector.internalValue;
  }

  // namespaces - computed: false, optional: true, required: false
  private _namespaces?: string[]; 
  public get namespaces() {
    return this.getListAttribute('namespaces');
  }
  public set namespaces(value: string[]) {
    this._namespaces = value;
  }
  public resetNamespaces() {
    this._namespaces = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespacesInput() {
    return this._namespaces;
  }

  // topology_key - computed: false, optional: true, required: false
  private _topologyKey?: string; 
  public get topologyKey() {
    return this.getStringAttribute('topology_key');
  }
  public set topologyKey(value: string) {
    this._topologyKey = value;
  }
  public resetTopologyKey() {
    this._topologyKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get topologyKeyInput() {
    return this._topologyKey;
  }
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionList extends cdktf.ComplexList {
  public internalValue? : DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference {
    return new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinity {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#preferred_during_scheduling_ignored_during_execution DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#preferred_during_scheduling_ignored_during_execution}
  */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#required_during_scheduling_ignored_during_execution DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#required_during_scheduling_ignored_during_execution}
  */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    preferred_during_scheduling_ignored_during_execution: cdktf.listMapper(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionToTerraform, false)(struct!.preferredDuringSchedulingIgnoredDuringExecution),
    required_during_scheduling_ignored_during_execution: cdktf.listMapper(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionToTerraform, false)(struct!.requiredDuringSchedulingIgnoredDuringExecution),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    preferred_during_scheduling_ignored_during_execution: {
      value: cdktf.listMapperHcl(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionToHclTerraform, false)(struct!.preferredDuringSchedulingIgnoredDuringExecution),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionList",
    },
    required_during_scheduling_ignored_during_execution: {
      value: cdktf.listMapperHcl(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionToHclTerraform, false)(struct!.requiredDuringSchedulingIgnoredDuringExecution),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._preferredDuringSchedulingIgnoredDuringExecution?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.preferredDuringSchedulingIgnoredDuringExecution = this._preferredDuringSchedulingIgnoredDuringExecution?.internalValue;
    }
    if (this._requiredDuringSchedulingIgnoredDuringExecution?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.requiredDuringSchedulingIgnoredDuringExecution = this._requiredDuringSchedulingIgnoredDuringExecution?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
      this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = value.preferredDuringSchedulingIgnoredDuringExecution;
      this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = value.requiredDuringSchedulingIgnoredDuringExecution;
    }
  }

  // preferred_during_scheduling_ignored_during_execution - computed: false, optional: true, required: false
  private _preferredDuringSchedulingIgnoredDuringExecution = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionList(this, "preferred_during_scheduling_ignored_during_execution", false);
  public get preferredDuringSchedulingIgnoredDuringExecution() {
    return this._preferredDuringSchedulingIgnoredDuringExecution;
  }
  public putPreferredDuringSchedulingIgnoredDuringExecution(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable) {
    this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = value;
  }
  public resetPreferredDuringSchedulingIgnoredDuringExecution() {
    this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preferredDuringSchedulingIgnoredDuringExecutionInput() {
    return this._preferredDuringSchedulingIgnoredDuringExecution.internalValue;
  }

  // required_during_scheduling_ignored_during_execution - computed: false, optional: true, required: false
  private _requiredDuringSchedulingIgnoredDuringExecution = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionList(this, "required_during_scheduling_ignored_during_execution", false);
  public get requiredDuringSchedulingIgnoredDuringExecution() {
    return this._requiredDuringSchedulingIgnoredDuringExecution;
  }
  public putRequiredDuringSchedulingIgnoredDuringExecution(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable) {
    this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = value;
  }
  public resetRequiredDuringSchedulingIgnoredDuringExecution() {
    this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requiredDuringSchedulingIgnoredDuringExecutionInput() {
    return this._requiredDuringSchedulingIgnoredDuringExecution.internalValue;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinity {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#node_affinity DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#node_affinity}
  */
  readonly nodeAffinity?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinity;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#pod_affinity DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#pod_affinity}
  */
  readonly podAffinity?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinity;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#pod_anti_affinity DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#pod_anti_affinity}
  */
  readonly podAntiAffinity?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinity;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    node_affinity: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityToTerraform(struct!.nodeAffinity),
    pod_affinity: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityToTerraform(struct!.podAffinity),
    pod_anti_affinity: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityToTerraform(struct!.podAntiAffinity),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    node_affinity: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityToHclTerraform(struct!.nodeAffinity),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinity",
    },
    pod_affinity: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityToHclTerraform(struct!.podAffinity),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinity",
    },
    pod_anti_affinity: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityToHclTerraform(struct!.podAntiAffinity),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinity",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._nodeAffinity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeAffinity = this._nodeAffinity?.internalValue;
    }
    if (this._podAffinity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.podAffinity = this._podAffinity?.internalValue;
    }
    if (this._podAntiAffinity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.podAntiAffinity = this._podAntiAffinity?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._nodeAffinity.internalValue = undefined;
      this._podAffinity.internalValue = undefined;
      this._podAntiAffinity.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._nodeAffinity.internalValue = value.nodeAffinity;
      this._podAffinity.internalValue = value.podAffinity;
      this._podAntiAffinity.internalValue = value.podAntiAffinity;
    }
  }

  // node_affinity - computed: false, optional: true, required: false
  private _nodeAffinity = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinityOutputReference(this, "node_affinity");
  public get nodeAffinity() {
    return this._nodeAffinity;
  }
  public putNodeAffinity(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityNodeAffinity) {
    this._nodeAffinity.internalValue = value;
  }
  public resetNodeAffinity() {
    this._nodeAffinity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeAffinityInput() {
    return this._nodeAffinity.internalValue;
  }

  // pod_affinity - computed: false, optional: true, required: false
  private _podAffinity = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinityOutputReference(this, "pod_affinity");
  public get podAffinity() {
    return this._podAffinity;
  }
  public putPodAffinity(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAffinity) {
    this._podAffinity.internalValue = value;
  }
  public resetPodAffinity() {
    this._podAffinity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podAffinityInput() {
    return this._podAffinity.internalValue;
  }

  // pod_anti_affinity - computed: false, optional: true, required: false
  private _podAntiAffinity = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinityOutputReference(this, "pod_anti_affinity");
  public get podAntiAffinity() {
    return this._podAntiAffinity;
  }
  public putPodAntiAffinity(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentAffinityPodAntiAffinity) {
    this._podAntiAffinity.internalValue = value;
  }
  public resetPodAntiAffinity() {
    this._podAntiAffinity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podAntiAffinityInput() {
    return this._podAntiAffinity.internalValue;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentDeploymentStrategyRollingUpdate {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#max_surge DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#max_surge}
  */
  readonly maxSurge?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#max_unavailable DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#max_unavailable}
  */
  readonly maxUnavailable?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentDeploymentStrategyRollingUpdateToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentDeploymentStrategyRollingUpdate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    max_surge: cdktf.stringToTerraform(struct!.maxSurge),
    max_unavailable: cdktf.stringToTerraform(struct!.maxUnavailable),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentDeploymentStrategyRollingUpdateToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentDeploymentStrategyRollingUpdate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    max_surge: {
      value: cdktf.stringToHclTerraform(struct!.maxSurge),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_unavailable: {
      value: cdktf.stringToHclTerraform(struct!.maxUnavailable),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentDeploymentStrategyRollingUpdateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentDeploymentStrategyRollingUpdate | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._maxSurge !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSurge = this._maxSurge;
    }
    if (this._maxUnavailable !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxUnavailable = this._maxUnavailable;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentDeploymentStrategyRollingUpdate | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._maxSurge = undefined;
      this._maxUnavailable = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._maxSurge = value.maxSurge;
      this._maxUnavailable = value.maxUnavailable;
    }
  }

  // max_surge - computed: false, optional: true, required: false
  private _maxSurge?: string; 
  public get maxSurge() {
    return this.getStringAttribute('max_surge');
  }
  public set maxSurge(value: string) {
    this._maxSurge = value;
  }
  public resetMaxSurge() {
    this._maxSurge = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSurgeInput() {
    return this._maxSurge;
  }

  // max_unavailable - computed: false, optional: true, required: false
  private _maxUnavailable?: string; 
  public get maxUnavailable() {
    return this.getStringAttribute('max_unavailable');
  }
  public set maxUnavailable(value: string) {
    this._maxUnavailable = value;
  }
  public resetMaxUnavailable() {
    this._maxUnavailable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxUnavailableInput() {
    return this._maxUnavailable;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentDeploymentStrategy {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#rolling_update DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#rolling_update}
  */
  readonly rollingUpdate?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentDeploymentStrategyRollingUpdate;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#type DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#type}
  */
  readonly type?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentDeploymentStrategyToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentDeploymentStrategy | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    rolling_update: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentDeploymentStrategyRollingUpdateToTerraform(struct!.rollingUpdate),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentDeploymentStrategyToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentDeploymentStrategy | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    rolling_update: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentDeploymentStrategyRollingUpdateToHclTerraform(struct!.rollingUpdate),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentDeploymentStrategyRollingUpdate",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentDeploymentStrategyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentDeploymentStrategy | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._rollingUpdate?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rollingUpdate = this._rollingUpdate?.internalValue;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentDeploymentStrategy | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._rollingUpdate.internalValue = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._rollingUpdate.internalValue = value.rollingUpdate;
      this._type = value.type;
    }
  }

  // rolling_update - computed: false, optional: true, required: false
  private _rollingUpdate = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentDeploymentStrategyRollingUpdateOutputReference(this, "rolling_update");
  public get rollingUpdate() {
    return this._rollingUpdate;
  }
  public putRollingUpdate(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentDeploymentStrategyRollingUpdate) {
    this._rollingUpdate.internalValue = value;
  }
  public resetRollingUpdate() {
    this._rollingUpdate.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rollingUpdateInput() {
    return this._rollingUpdate.internalValue;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromConfigMapKeyRefLocalObjectReference {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#name DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#name}
  */
  readonly name?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromConfigMapKeyRefLocalObjectReferenceToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromConfigMapKeyRefLocalObjectReference | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromConfigMapKeyRefLocalObjectReferenceToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromConfigMapKeyRefLocalObjectReference | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromConfigMapKeyRefLocalObjectReferenceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromConfigMapKeyRefLocalObjectReference | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromConfigMapKeyRefLocalObjectReference | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromConfigMapKeyRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#key DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#local_object_reference DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#local_object_reference}
  */
  readonly localObjectReference?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromConfigMapKeyRefLocalObjectReference;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#optional DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromConfigMapKeyRefToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromConfigMapKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    local_object_reference: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromConfigMapKeyRefLocalObjectReferenceToTerraform(struct!.localObjectReference),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromConfigMapKeyRefToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromConfigMapKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    local_object_reference: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromConfigMapKeyRefLocalObjectReferenceToHclTerraform(struct!.localObjectReference),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromConfigMapKeyRefLocalObjectReference",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromConfigMapKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromConfigMapKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._localObjectReference?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.localObjectReference = this._localObjectReference?.internalValue;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromConfigMapKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._localObjectReference.internalValue = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._localObjectReference.internalValue = value.localObjectReference;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // local_object_reference - computed: false, optional: true, required: false
  private _localObjectReference = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromConfigMapKeyRefLocalObjectReferenceOutputReference(this, "local_object_reference");
  public get localObjectReference() {
    return this._localObjectReference;
  }
  public putLocalObjectReference(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromConfigMapKeyRefLocalObjectReference) {
    this._localObjectReference.internalValue = value;
  }
  public resetLocalObjectReference() {
    this._localObjectReference.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localObjectReferenceInput() {
    return this._localObjectReference.internalValue;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromFieldRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#api_version DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#api_version}
  */
  readonly apiVersion?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#field_path DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#field_path}
  */
  readonly fieldPath?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromFieldRefToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    field_path: cdktf.stringToTerraform(struct!.fieldPath),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromFieldRefToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    field_path: {
      value: cdktf.stringToHclTerraform(struct!.fieldPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromFieldRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromFieldRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._fieldPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.fieldPath = this._fieldPath;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromFieldRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiVersion = undefined;
      this._fieldPath = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiVersion = value.apiVersion;
      this._fieldPath = value.fieldPath;
    }
  }

  // api_version - computed: false, optional: true, required: false
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  public resetApiVersion() {
    this._apiVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // field_path - computed: false, optional: true, required: false
  private _fieldPath?: string; 
  public get fieldPath() {
    return this.getStringAttribute('field_path');
  }
  public set fieldPath(value: string) {
    this._fieldPath = value;
  }
  public resetFieldPath() {
    this._fieldPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldPathInput() {
    return this._fieldPath;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromResourceFieldRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#container_name DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#container_name}
  */
  readonly containerName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#divisor DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#divisor}
  */
  readonly divisor?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#resource DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#resource}
  */
  readonly resource?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromResourceFieldRefToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromResourceFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    container_name: cdktf.stringToTerraform(struct!.containerName),
    divisor: cdktf.stringToTerraform(struct!.divisor),
    resource: cdktf.stringToTerraform(struct!.resource),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromResourceFieldRefToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromResourceFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    container_name: {
      value: cdktf.stringToHclTerraform(struct!.containerName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    divisor: {
      value: cdktf.stringToHclTerraform(struct!.divisor),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    resource: {
      value: cdktf.stringToHclTerraform(struct!.resource),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromResourceFieldRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromResourceFieldRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._containerName !== undefined) {
      hasAnyValues = true;
      internalValueResult.containerName = this._containerName;
    }
    if (this._divisor !== undefined) {
      hasAnyValues = true;
      internalValueResult.divisor = this._divisor;
    }
    if (this._resource !== undefined) {
      hasAnyValues = true;
      internalValueResult.resource = this._resource;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromResourceFieldRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._containerName = undefined;
      this._divisor = undefined;
      this._resource = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._containerName = value.containerName;
      this._divisor = value.divisor;
      this._resource = value.resource;
    }
  }

  // container_name - computed: false, optional: true, required: false
  private _containerName?: string; 
  public get containerName() {
    return this.getStringAttribute('container_name');
  }
  public set containerName(value: string) {
    this._containerName = value;
  }
  public resetContainerName() {
    this._containerName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get containerNameInput() {
    return this._containerName;
  }

  // divisor - computed: false, optional: true, required: false
  private _divisor?: string; 
  public get divisor() {
    return this.getStringAttribute('divisor');
  }
  public set divisor(value: string) {
    this._divisor = value;
  }
  public resetDivisor() {
    this._divisor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get divisorInput() {
    return this._divisor;
  }

  // resource - computed: false, optional: true, required: false
  private _resource?: string; 
  public get resource() {
    return this.getStringAttribute('resource');
  }
  public set resource(value: string) {
    this._resource = value;
  }
  public resetResource() {
    this._resource = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceInput() {
    return this._resource;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromSecretKeyRefLocalObjectReference {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#name DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#name}
  */
  readonly name?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromSecretKeyRefLocalObjectReferenceToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromSecretKeyRefLocalObjectReference | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromSecretKeyRefLocalObjectReferenceToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromSecretKeyRefLocalObjectReference | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromSecretKeyRefLocalObjectReferenceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromSecretKeyRefLocalObjectReference | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromSecretKeyRefLocalObjectReference | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromSecretKeyRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#key DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#local_object_reference DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#local_object_reference}
  */
  readonly localObjectReference?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromSecretKeyRefLocalObjectReference;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#optional DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromSecretKeyRefToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    local_object_reference: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromSecretKeyRefLocalObjectReferenceToTerraform(struct!.localObjectReference),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromSecretKeyRefToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    local_object_reference: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromSecretKeyRefLocalObjectReferenceToHclTerraform(struct!.localObjectReference),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromSecretKeyRefLocalObjectReference",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._localObjectReference?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.localObjectReference = this._localObjectReference?.internalValue;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._localObjectReference.internalValue = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._localObjectReference.internalValue = value.localObjectReference;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // local_object_reference - computed: false, optional: true, required: false
  private _localObjectReference = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromSecretKeyRefLocalObjectReferenceOutputReference(this, "local_object_reference");
  public get localObjectReference() {
    return this._localObjectReference;
  }
  public putLocalObjectReference(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromSecretKeyRefLocalObjectReference) {
    this._localObjectReference.internalValue = value;
  }
  public resetLocalObjectReference() {
    this._localObjectReference.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localObjectReferenceInput() {
    return this._localObjectReference.internalValue;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFrom {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#config_map_key_ref DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#config_map_key_ref}
  */
  readonly configMapKeyRef?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromConfigMapKeyRef;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#field_ref DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#field_ref}
  */
  readonly fieldRef?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromFieldRef;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#resource_field_ref DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#resource_field_ref}
  */
  readonly resourceFieldRef?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromResourceFieldRef;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#secret_key_ref DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromSecretKeyRef;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    config_map_key_ref: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromConfigMapKeyRefToTerraform(struct!.configMapKeyRef),
    field_ref: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromFieldRefToTerraform(struct!.fieldRef),
    resource_field_ref: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromResourceFieldRefToTerraform(struct!.resourceFieldRef),
    secret_key_ref: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    config_map_key_ref: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromConfigMapKeyRefToHclTerraform(struct!.configMapKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromConfigMapKeyRef",
    },
    field_ref: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromFieldRefToHclTerraform(struct!.fieldRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromFieldRef",
    },
    resource_field_ref: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromResourceFieldRefToHclTerraform(struct!.resourceFieldRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromResourceFieldRef",
    },
    secret_key_ref: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._configMapKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.configMapKeyRef = this._configMapKeyRef?.internalValue;
    }
    if (this._fieldRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.fieldRef = this._fieldRef?.internalValue;
    }
    if (this._resourceFieldRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resourceFieldRef = this._resourceFieldRef?.internalValue;
    }
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._configMapKeyRef.internalValue = undefined;
      this._fieldRef.internalValue = undefined;
      this._resourceFieldRef.internalValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._configMapKeyRef.internalValue = value.configMapKeyRef;
      this._fieldRef.internalValue = value.fieldRef;
      this._resourceFieldRef.internalValue = value.resourceFieldRef;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // config_map_key_ref - computed: false, optional: true, required: false
  private _configMapKeyRef = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromConfigMapKeyRefOutputReference(this, "config_map_key_ref");
  public get configMapKeyRef() {
    return this._configMapKeyRef;
  }
  public putConfigMapKeyRef(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromConfigMapKeyRef) {
    this._configMapKeyRef.internalValue = value;
  }
  public resetConfigMapKeyRef() {
    this._configMapKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configMapKeyRefInput() {
    return this._configMapKeyRef.internalValue;
  }

  // field_ref - computed: false, optional: true, required: false
  private _fieldRef = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromFieldRefOutputReference(this, "field_ref");
  public get fieldRef() {
    return this._fieldRef;
  }
  public putFieldRef(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromFieldRef) {
    this._fieldRef.internalValue = value;
  }
  public resetFieldRef() {
    this._fieldRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldRefInput() {
    return this._fieldRef.internalValue;
  }

  // resource_field_ref - computed: false, optional: true, required: false
  private _resourceFieldRef = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromResourceFieldRefOutputReference(this, "resource_field_ref");
  public get resourceFieldRef() {
    return this._resourceFieldRef;
  }
  public putResourceFieldRef(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromResourceFieldRef) {
    this._resourceFieldRef.internalValue = value;
  }
  public resetResourceFieldRef() {
    this._resourceFieldRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceFieldRefInput() {
    return this._resourceFieldRef.internalValue;
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnv {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#name DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#value DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#value}
  */
  readonly value?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#value_from DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#value_from}
  */
  readonly valueFrom?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFrom;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
    value_from: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value_from: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnv | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnv | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvList extends cdktf.ComplexList {
  public internalValue? : DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnv[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvOutputReference {
    return new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentEnvOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentImagePullSecrets {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#name DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#name}
  */
  readonly name?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentImagePullSecretsToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentImagePullSecrets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentImagePullSecretsToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentImagePullSecrets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentImagePullSecretsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentImagePullSecrets | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentImagePullSecrets | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentImagePullSecretsList extends cdktf.ComplexList {
  public internalValue? : DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentImagePullSecrets[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentImagePullSecretsOutputReference {
    return new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentImagePullSecretsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeExec {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#command DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#command}
  */
  readonly command?: string[];
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeExecToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeExec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    command: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.command),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeExecToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeExec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    command: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.command),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeExecOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeExec | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._command !== undefined) {
      hasAnyValues = true;
      internalValueResult.command = this._command;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeExec | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._command = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._command = value.command;
    }
  }

  // command - computed: false, optional: true, required: false
  private _command?: string[]; 
  public get command() {
    return this.getListAttribute('command');
  }
  public set command(value: string[]) {
    this._command = value;
  }
  public resetCommand() {
    this._command = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commandInput() {
    return this._command;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeGrpc {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#port DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#port}
  */
  readonly port?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#service DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#service}
  */
  readonly service?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeGrpcToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeGrpc | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    port: cdktf.numberToTerraform(struct!.port),
    service: cdktf.stringToTerraform(struct!.service),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeGrpcToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeGrpc | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    service: {
      value: cdktf.stringToHclTerraform(struct!.service),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeGrpcOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeGrpc | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._service !== undefined) {
      hasAnyValues = true;
      internalValueResult.service = this._service;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeGrpc | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._port = undefined;
      this._service = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._port = value.port;
      this._service = value.service;
    }
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // service - computed: false, optional: true, required: false
  private _service?: string; 
  public get service() {
    return this.getStringAttribute('service');
  }
  public set service(value: string) {
    this._service = value;
  }
  public resetService() {
    this._service = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceInput() {
    return this._service;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeHttpGetHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#name DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#value DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeHttpGetHttpHeadersToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeHttpGetHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeHttpGetHttpHeadersToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeHttpGetHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeHttpGetHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeHttpGetHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeHttpGetHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeHttpGetHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeHttpGetHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeHttpGetHttpHeadersOutputReference {
    return new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeHttpGetHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeHttpGet {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#host DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#host}
  */
  readonly host?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#http_headers DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#http_headers}
  */
  readonly httpHeaders?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeHttpGetHttpHeaders[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#path DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#path}
  */
  readonly path?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#port DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#port}
  */
  readonly port?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#scheme DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#scheme}
  */
  readonly scheme?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeHttpGetToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeHttpGet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    host: cdktf.stringToTerraform(struct!.host),
    http_headers: cdktf.listMapper(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeHttpGetHttpHeadersToTerraform, false)(struct!.httpHeaders),
    path: cdktf.stringToTerraform(struct!.path),
    port: cdktf.stringToTerraform(struct!.port),
    scheme: cdktf.stringToTerraform(struct!.scheme),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeHttpGetToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeHttpGet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    http_headers: {
      value: cdktf.listMapperHcl(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeHttpGetHttpHeadersToHclTerraform, false)(struct!.httpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeHttpGetHttpHeadersList",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.stringToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    scheme: {
      value: cdktf.stringToHclTerraform(struct!.scheme),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeHttpGetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeHttpGet | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._httpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpHeaders = this._httpHeaders?.internalValue;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._scheme !== undefined) {
      hasAnyValues = true;
      internalValueResult.scheme = this._scheme;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeHttpGet | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._host = undefined;
      this._httpHeaders.internalValue = undefined;
      this._path = undefined;
      this._port = undefined;
      this._scheme = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._host = value.host;
      this._httpHeaders.internalValue = value.httpHeaders;
      this._path = value.path;
      this._port = value.port;
      this._scheme = value.scheme;
    }
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // http_headers - computed: false, optional: true, required: false
  private _httpHeaders = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeHttpGetHttpHeadersList(this, "http_headers", false);
  public get httpHeaders() {
    return this._httpHeaders;
  }
  public putHttpHeaders(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeHttpGetHttpHeaders[] | cdktf.IResolvable) {
    this._httpHeaders.internalValue = value;
  }
  public resetHttpHeaders() {
    this._httpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpHeadersInput() {
    return this._httpHeaders.internalValue;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // port - computed: false, optional: true, required: false
  private _port?: string; 
  public get port() {
    return this.getStringAttribute('port');
  }
  public set port(value: string) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // scheme - computed: false, optional: true, required: false
  private _scheme?: string; 
  public get scheme() {
    return this.getStringAttribute('scheme');
  }
  public set scheme(value: string) {
    this._scheme = value;
  }
  public resetScheme() {
    this._scheme = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get schemeInput() {
    return this._scheme;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeTcpSocket {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#host DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#host}
  */
  readonly host?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#port DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#port}
  */
  readonly port?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeTcpSocketToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeTcpSocket | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    host: cdktf.stringToTerraform(struct!.host),
    port: cdktf.stringToTerraform(struct!.port),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeTcpSocketToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeTcpSocket | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.stringToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeTcpSocketOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeTcpSocket | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeTcpSocket | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._host = undefined;
      this._port = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._host = value.host;
      this._port = value.port;
    }
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // port - computed: false, optional: true, required: false
  private _port?: string; 
  public get port() {
    return this.getStringAttribute('port');
  }
  public set port(value: string) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbe {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#exec DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#exec}
  */
  readonly exec?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeExec;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#failure_threshold DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#failure_threshold}
  */
  readonly failureThreshold?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#grpc DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#grpc}
  */
  readonly grpc?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeGrpc;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#http_get DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#http_get}
  */
  readonly httpGet?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeHttpGet;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#initial_delay_seconds DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#initial_delay_seconds}
  */
  readonly initialDelaySeconds?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#period_seconds DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#period_seconds}
  */
  readonly periodSeconds?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#success_threshold DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#success_threshold}
  */
  readonly successThreshold?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#tcp_socket DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#tcp_socket}
  */
  readonly tcpSocket?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeTcpSocket;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#termination_grace_period_seconds DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#termination_grace_period_seconds}
  */
  readonly terminationGracePeriodSeconds?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#timeout_seconds DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#timeout_seconds}
  */
  readonly timeoutSeconds?: number;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbe | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    exec: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeExecToTerraform(struct!.exec),
    failure_threshold: cdktf.numberToTerraform(struct!.failureThreshold),
    grpc: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeGrpcToTerraform(struct!.grpc),
    http_get: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeHttpGetToTerraform(struct!.httpGet),
    initial_delay_seconds: cdktf.numberToTerraform(struct!.initialDelaySeconds),
    period_seconds: cdktf.numberToTerraform(struct!.periodSeconds),
    success_threshold: cdktf.numberToTerraform(struct!.successThreshold),
    tcp_socket: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeTcpSocketToTerraform(struct!.tcpSocket),
    termination_grace_period_seconds: cdktf.numberToTerraform(struct!.terminationGracePeriodSeconds),
    timeout_seconds: cdktf.numberToTerraform(struct!.timeoutSeconds),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbe | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    exec: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeExecToHclTerraform(struct!.exec),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeExec",
    },
    failure_threshold: {
      value: cdktf.numberToHclTerraform(struct!.failureThreshold),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    grpc: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeGrpcToHclTerraform(struct!.grpc),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeGrpc",
    },
    http_get: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeHttpGetToHclTerraform(struct!.httpGet),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeHttpGet",
    },
    initial_delay_seconds: {
      value: cdktf.numberToHclTerraform(struct!.initialDelaySeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    period_seconds: {
      value: cdktf.numberToHclTerraform(struct!.periodSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    success_threshold: {
      value: cdktf.numberToHclTerraform(struct!.successThreshold),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    tcp_socket: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeTcpSocketToHclTerraform(struct!.tcpSocket),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeTcpSocket",
    },
    termination_grace_period_seconds: {
      value: cdktf.numberToHclTerraform(struct!.terminationGracePeriodSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_seconds: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbe | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._exec?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.exec = this._exec?.internalValue;
    }
    if (this._failureThreshold !== undefined) {
      hasAnyValues = true;
      internalValueResult.failureThreshold = this._failureThreshold;
    }
    if (this._grpc?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.grpc = this._grpc?.internalValue;
    }
    if (this._httpGet?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpGet = this._httpGet?.internalValue;
    }
    if (this._initialDelaySeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialDelaySeconds = this._initialDelaySeconds;
    }
    if (this._periodSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.periodSeconds = this._periodSeconds;
    }
    if (this._successThreshold !== undefined) {
      hasAnyValues = true;
      internalValueResult.successThreshold = this._successThreshold;
    }
    if (this._tcpSocket?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tcpSocket = this._tcpSocket?.internalValue;
    }
    if (this._terminationGracePeriodSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.terminationGracePeriodSeconds = this._terminationGracePeriodSeconds;
    }
    if (this._timeoutSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSeconds = this._timeoutSeconds;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbe | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._exec.internalValue = undefined;
      this._failureThreshold = undefined;
      this._grpc.internalValue = undefined;
      this._httpGet.internalValue = undefined;
      this._initialDelaySeconds = undefined;
      this._periodSeconds = undefined;
      this._successThreshold = undefined;
      this._tcpSocket.internalValue = undefined;
      this._terminationGracePeriodSeconds = undefined;
      this._timeoutSeconds = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._exec.internalValue = value.exec;
      this._failureThreshold = value.failureThreshold;
      this._grpc.internalValue = value.grpc;
      this._httpGet.internalValue = value.httpGet;
      this._initialDelaySeconds = value.initialDelaySeconds;
      this._periodSeconds = value.periodSeconds;
      this._successThreshold = value.successThreshold;
      this._tcpSocket.internalValue = value.tcpSocket;
      this._terminationGracePeriodSeconds = value.terminationGracePeriodSeconds;
      this._timeoutSeconds = value.timeoutSeconds;
    }
  }

  // exec - computed: false, optional: true, required: false
  private _exec = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeExecOutputReference(this, "exec");
  public get exec() {
    return this._exec;
  }
  public putExec(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeExec) {
    this._exec.internalValue = value;
  }
  public resetExec() {
    this._exec.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get execInput() {
    return this._exec.internalValue;
  }

  // failure_threshold - computed: false, optional: true, required: false
  private _failureThreshold?: number; 
  public get failureThreshold() {
    return this.getNumberAttribute('failure_threshold');
  }
  public set failureThreshold(value: number) {
    this._failureThreshold = value;
  }
  public resetFailureThreshold() {
    this._failureThreshold = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failureThresholdInput() {
    return this._failureThreshold;
  }

  // grpc - computed: false, optional: true, required: false
  private _grpc = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeGrpcOutputReference(this, "grpc");
  public get grpc() {
    return this._grpc;
  }
  public putGrpc(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeGrpc) {
    this._grpc.internalValue = value;
  }
  public resetGrpc() {
    this._grpc.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get grpcInput() {
    return this._grpc.internalValue;
  }

  // http_get - computed: false, optional: true, required: false
  private _httpGet = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeHttpGetOutputReference(this, "http_get");
  public get httpGet() {
    return this._httpGet;
  }
  public putHttpGet(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeHttpGet) {
    this._httpGet.internalValue = value;
  }
  public resetHttpGet() {
    this._httpGet.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpGetInput() {
    return this._httpGet.internalValue;
  }

  // initial_delay_seconds - computed: false, optional: true, required: false
  private _initialDelaySeconds?: number; 
  public get initialDelaySeconds() {
    return this.getNumberAttribute('initial_delay_seconds');
  }
  public set initialDelaySeconds(value: number) {
    this._initialDelaySeconds = value;
  }
  public resetInitialDelaySeconds() {
    this._initialDelaySeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialDelaySecondsInput() {
    return this._initialDelaySeconds;
  }

  // period_seconds - computed: false, optional: true, required: false
  private _periodSeconds?: number; 
  public get periodSeconds() {
    return this.getNumberAttribute('period_seconds');
  }
  public set periodSeconds(value: number) {
    this._periodSeconds = value;
  }
  public resetPeriodSeconds() {
    this._periodSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get periodSecondsInput() {
    return this._periodSeconds;
  }

  // success_threshold - computed: false, optional: true, required: false
  private _successThreshold?: number; 
  public get successThreshold() {
    return this.getNumberAttribute('success_threshold');
  }
  public set successThreshold(value: number) {
    this._successThreshold = value;
  }
  public resetSuccessThreshold() {
    this._successThreshold = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get successThresholdInput() {
    return this._successThreshold;
  }

  // tcp_socket - computed: false, optional: true, required: false
  private _tcpSocket = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeTcpSocketOutputReference(this, "tcp_socket");
  public get tcpSocket() {
    return this._tcpSocket;
  }
  public putTcpSocket(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentLivenessProbeTcpSocket) {
    this._tcpSocket.internalValue = value;
  }
  public resetTcpSocket() {
    this._tcpSocket.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tcpSocketInput() {
    return this._tcpSocket.internalValue;
  }

  // termination_grace_period_seconds - computed: false, optional: true, required: false
  private _terminationGracePeriodSeconds?: number; 
  public get terminationGracePeriodSeconds() {
    return this.getNumberAttribute('termination_grace_period_seconds');
  }
  public set terminationGracePeriodSeconds(value: number) {
    this._terminationGracePeriodSeconds = value;
  }
  public resetTerminationGracePeriodSeconds() {
    this._terminationGracePeriodSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get terminationGracePeriodSecondsInput() {
    return this._terminationGracePeriodSeconds;
  }

  // timeout_seconds - computed: false, optional: true, required: false
  private _timeoutSeconds?: number; 
  public get timeoutSeconds() {
    return this.getNumberAttribute('timeout_seconds');
  }
  public set timeoutSeconds(value: number) {
    this._timeoutSeconds = value;
  }
  public resetTimeoutSeconds() {
    this._timeoutSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecondsInput() {
    return this._timeoutSeconds;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#annotations DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#labels DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#labels}
  */
  readonly labels?: { [key: string]: string };
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentMetadataToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentMetadataToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotations = undefined;
      this._labels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotations = value.annotations;
      this._labels = value.labels;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodDisruptionBudget {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#max_unavailable DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#max_unavailable}
  */
  readonly maxUnavailable?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#min_available DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#min_available}
  */
  readonly minAvailable?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodDisruptionBudgetToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodDisruptionBudget | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    max_unavailable: cdktf.stringToTerraform(struct!.maxUnavailable),
    min_available: cdktf.stringToTerraform(struct!.minAvailable),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodDisruptionBudgetToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodDisruptionBudget | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    max_unavailable: {
      value: cdktf.stringToHclTerraform(struct!.maxUnavailable),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_available: {
      value: cdktf.stringToHclTerraform(struct!.minAvailable),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodDisruptionBudgetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodDisruptionBudget | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._maxUnavailable !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxUnavailable = this._maxUnavailable;
    }
    if (this._minAvailable !== undefined) {
      hasAnyValues = true;
      internalValueResult.minAvailable = this._minAvailable;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodDisruptionBudget | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._maxUnavailable = undefined;
      this._minAvailable = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._maxUnavailable = value.maxUnavailable;
      this._minAvailable = value.minAvailable;
    }
  }

  // max_unavailable - computed: false, optional: true, required: false
  private _maxUnavailable?: string; 
  public get maxUnavailable() {
    return this.getStringAttribute('max_unavailable');
  }
  public set maxUnavailable(value: string) {
    this._maxUnavailable = value;
  }
  public resetMaxUnavailable() {
    this._maxUnavailable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxUnavailableInput() {
    return this._maxUnavailable;
  }

  // min_available - computed: false, optional: true, required: false
  private _minAvailable?: string; 
  public get minAvailable() {
    return this.getStringAttribute('min_available');
  }
  public set minAvailable(value: string) {
    this._minAvailable = value;
  }
  public resetMinAvailable() {
    this._minAvailable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minAvailableInput() {
    return this._minAvailable;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#annotations DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#labels DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#labels}
  */
  readonly labels?: { [key: string]: string };
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodMetadataToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodMetadataToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotations = undefined;
      this._labels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotations = value.annotations;
      this._labels = value.labels;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextSeLinuxOptions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#level DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#level}
  */
  readonly level?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#role DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#role}
  */
  readonly role?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#type DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#type}
  */
  readonly type?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#user DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#user}
  */
  readonly user?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextSeLinuxOptionsToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextSeLinuxOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    level: cdktf.stringToTerraform(struct!.level),
    role: cdktf.stringToTerraform(struct!.role),
    type: cdktf.stringToTerraform(struct!.type),
    user: cdktf.stringToTerraform(struct!.user),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextSeLinuxOptionsToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextSeLinuxOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    level: {
      value: cdktf.stringToHclTerraform(struct!.level),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role: {
      value: cdktf.stringToHclTerraform(struct!.role),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    user: {
      value: cdktf.stringToHclTerraform(struct!.user),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextSeLinuxOptionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextSeLinuxOptions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._level !== undefined) {
      hasAnyValues = true;
      internalValueResult.level = this._level;
    }
    if (this._role !== undefined) {
      hasAnyValues = true;
      internalValueResult.role = this._role;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._user !== undefined) {
      hasAnyValues = true;
      internalValueResult.user = this._user;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextSeLinuxOptions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._level = undefined;
      this._role = undefined;
      this._type = undefined;
      this._user = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._level = value.level;
      this._role = value.role;
      this._type = value.type;
      this._user = value.user;
    }
  }

  // level - computed: false, optional: true, required: false
  private _level?: string; 
  public get level() {
    return this.getStringAttribute('level');
  }
  public set level(value: string) {
    this._level = value;
  }
  public resetLevel() {
    this._level = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get levelInput() {
    return this._level;
  }

  // role - computed: false, optional: true, required: false
  private _role?: string; 
  public get role() {
    return this.getStringAttribute('role');
  }
  public set role(value: string) {
    this._role = value;
  }
  public resetRole() {
    this._role = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleInput() {
    return this._role;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // user - computed: false, optional: true, required: false
  private _user?: string; 
  public get user() {
    return this.getStringAttribute('user');
  }
  public set user(value: string) {
    this._user = value;
  }
  public resetUser() {
    this._user = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get userInput() {
    return this._user;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextSeccompProfile {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#localhost_profile DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#localhost_profile}
  */
  readonly localhostProfile?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#type DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#type}
  */
  readonly type?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextSeccompProfileToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextSeccompProfile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    localhost_profile: cdktf.stringToTerraform(struct!.localhostProfile),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextSeccompProfileToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextSeccompProfile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    localhost_profile: {
      value: cdktf.stringToHclTerraform(struct!.localhostProfile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextSeccompProfileOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextSeccompProfile | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._localhostProfile !== undefined) {
      hasAnyValues = true;
      internalValueResult.localhostProfile = this._localhostProfile;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextSeccompProfile | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._localhostProfile = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._localhostProfile = value.localhostProfile;
      this._type = value.type;
    }
  }

  // localhost_profile - computed: false, optional: true, required: false
  private _localhostProfile?: string; 
  public get localhostProfile() {
    return this.getStringAttribute('localhost_profile');
  }
  public set localhostProfile(value: string) {
    this._localhostProfile = value;
  }
  public resetLocalhostProfile() {
    this._localhostProfile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localhostProfileInput() {
    return this._localhostProfile;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextSysctls {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#name DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#value DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextSysctlsToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextSysctls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextSysctlsToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextSysctls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextSysctlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextSysctls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextSysctls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextSysctlsList extends cdktf.ComplexList {
  public internalValue? : DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextSysctls[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextSysctlsOutputReference {
    return new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextSysctlsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextWindowsOptions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#gmsa_credential_spec DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#gmsa_credential_spec}
  */
  readonly gmsaCredentialSpec?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#gmsa_credential_spec_name DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#gmsa_credential_spec_name}
  */
  readonly gmsaCredentialSpecName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#host_process DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#host_process}
  */
  readonly hostProcess?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#run_as_user_name DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#run_as_user_name}
  */
  readonly runAsUserName?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextWindowsOptionsToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextWindowsOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    gmsa_credential_spec: cdktf.stringToTerraform(struct!.gmsaCredentialSpec),
    gmsa_credential_spec_name: cdktf.stringToTerraform(struct!.gmsaCredentialSpecName),
    host_process: cdktf.booleanToTerraform(struct!.hostProcess),
    run_as_user_name: cdktf.stringToTerraform(struct!.runAsUserName),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextWindowsOptionsToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextWindowsOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    gmsa_credential_spec: {
      value: cdktf.stringToHclTerraform(struct!.gmsaCredentialSpec),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    gmsa_credential_spec_name: {
      value: cdktf.stringToHclTerraform(struct!.gmsaCredentialSpecName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host_process: {
      value: cdktf.booleanToHclTerraform(struct!.hostProcess),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    run_as_user_name: {
      value: cdktf.stringToHclTerraform(struct!.runAsUserName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextWindowsOptionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextWindowsOptions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._gmsaCredentialSpec !== undefined) {
      hasAnyValues = true;
      internalValueResult.gmsaCredentialSpec = this._gmsaCredentialSpec;
    }
    if (this._gmsaCredentialSpecName !== undefined) {
      hasAnyValues = true;
      internalValueResult.gmsaCredentialSpecName = this._gmsaCredentialSpecName;
    }
    if (this._hostProcess !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostProcess = this._hostProcess;
    }
    if (this._runAsUserName !== undefined) {
      hasAnyValues = true;
      internalValueResult.runAsUserName = this._runAsUserName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextWindowsOptions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._gmsaCredentialSpec = undefined;
      this._gmsaCredentialSpecName = undefined;
      this._hostProcess = undefined;
      this._runAsUserName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._gmsaCredentialSpec = value.gmsaCredentialSpec;
      this._gmsaCredentialSpecName = value.gmsaCredentialSpecName;
      this._hostProcess = value.hostProcess;
      this._runAsUserName = value.runAsUserName;
    }
  }

  // gmsa_credential_spec - computed: false, optional: true, required: false
  private _gmsaCredentialSpec?: string; 
  public get gmsaCredentialSpec() {
    return this.getStringAttribute('gmsa_credential_spec');
  }
  public set gmsaCredentialSpec(value: string) {
    this._gmsaCredentialSpec = value;
  }
  public resetGmsaCredentialSpec() {
    this._gmsaCredentialSpec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gmsaCredentialSpecInput() {
    return this._gmsaCredentialSpec;
  }

  // gmsa_credential_spec_name - computed: false, optional: true, required: false
  private _gmsaCredentialSpecName?: string; 
  public get gmsaCredentialSpecName() {
    return this.getStringAttribute('gmsa_credential_spec_name');
  }
  public set gmsaCredentialSpecName(value: string) {
    this._gmsaCredentialSpecName = value;
  }
  public resetGmsaCredentialSpecName() {
    this._gmsaCredentialSpecName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gmsaCredentialSpecNameInput() {
    return this._gmsaCredentialSpecName;
  }

  // host_process - computed: false, optional: true, required: false
  private _hostProcess?: boolean | cdktf.IResolvable; 
  public get hostProcess() {
    return this.getBooleanAttribute('host_process');
  }
  public set hostProcess(value: boolean | cdktf.IResolvable) {
    this._hostProcess = value;
  }
  public resetHostProcess() {
    this._hostProcess = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostProcessInput() {
    return this._hostProcess;
  }

  // run_as_user_name - computed: false, optional: true, required: false
  private _runAsUserName?: string; 
  public get runAsUserName() {
    return this.getStringAttribute('run_as_user_name');
  }
  public set runAsUserName(value: string) {
    this._runAsUserName = value;
  }
  public resetRunAsUserName() {
    this._runAsUserName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get runAsUserNameInput() {
    return this._runAsUserName;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContext {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#fs_group DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#fs_group}
  */
  readonly fsGroup?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#fs_group_change_policy DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#fs_group_change_policy}
  */
  readonly fsGroupChangePolicy?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#run_as_group DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#run_as_group}
  */
  readonly runAsGroup?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#run_as_non_root DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#run_as_non_root}
  */
  readonly runAsNonRoot?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#run_as_user DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#run_as_user}
  */
  readonly runAsUser?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#se_linux_options DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#se_linux_options}
  */
  readonly seLinuxOptions?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextSeLinuxOptions;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#seccomp_profile DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#seccomp_profile}
  */
  readonly seccompProfile?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextSeccompProfile;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#supplemental_groups DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#supplemental_groups}
  */
  readonly supplementalGroups?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#sysctls DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#sysctls}
  */
  readonly sysctls?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextSysctls[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#windows_options DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#windows_options}
  */
  readonly windowsOptions?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextWindowsOptions;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContext | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    fs_group: cdktf.numberToTerraform(struct!.fsGroup),
    fs_group_change_policy: cdktf.stringToTerraform(struct!.fsGroupChangePolicy),
    run_as_group: cdktf.numberToTerraform(struct!.runAsGroup),
    run_as_non_root: cdktf.booleanToTerraform(struct!.runAsNonRoot),
    run_as_user: cdktf.numberToTerraform(struct!.runAsUser),
    se_linux_options: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextSeLinuxOptionsToTerraform(struct!.seLinuxOptions),
    seccomp_profile: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextSeccompProfileToTerraform(struct!.seccompProfile),
    supplemental_groups: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.supplementalGroups),
    sysctls: cdktf.listMapper(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextSysctlsToTerraform, false)(struct!.sysctls),
    windows_options: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextWindowsOptionsToTerraform(struct!.windowsOptions),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContext | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    fs_group: {
      value: cdktf.numberToHclTerraform(struct!.fsGroup),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    fs_group_change_policy: {
      value: cdktf.stringToHclTerraform(struct!.fsGroupChangePolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    run_as_group: {
      value: cdktf.numberToHclTerraform(struct!.runAsGroup),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    run_as_non_root: {
      value: cdktf.booleanToHclTerraform(struct!.runAsNonRoot),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    run_as_user: {
      value: cdktf.numberToHclTerraform(struct!.runAsUser),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    se_linux_options: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextSeLinuxOptionsToHclTerraform(struct!.seLinuxOptions),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextSeLinuxOptions",
    },
    seccomp_profile: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextSeccompProfileToHclTerraform(struct!.seccompProfile),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextSeccompProfile",
    },
    supplemental_groups: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.supplementalGroups),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    sysctls: {
      value: cdktf.listMapperHcl(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextSysctlsToHclTerraform, false)(struct!.sysctls),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextSysctlsList",
    },
    windows_options: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextWindowsOptionsToHclTerraform(struct!.windowsOptions),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextWindowsOptions",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContext | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fsGroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.fsGroup = this._fsGroup;
    }
    if (this._fsGroupChangePolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.fsGroupChangePolicy = this._fsGroupChangePolicy;
    }
    if (this._runAsGroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.runAsGroup = this._runAsGroup;
    }
    if (this._runAsNonRoot !== undefined) {
      hasAnyValues = true;
      internalValueResult.runAsNonRoot = this._runAsNonRoot;
    }
    if (this._runAsUser !== undefined) {
      hasAnyValues = true;
      internalValueResult.runAsUser = this._runAsUser;
    }
    if (this._seLinuxOptions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.seLinuxOptions = this._seLinuxOptions?.internalValue;
    }
    if (this._seccompProfile?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.seccompProfile = this._seccompProfile?.internalValue;
    }
    if (this._supplementalGroups !== undefined) {
      hasAnyValues = true;
      internalValueResult.supplementalGroups = this._supplementalGroups;
    }
    if (this._sysctls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sysctls = this._sysctls?.internalValue;
    }
    if (this._windowsOptions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.windowsOptions = this._windowsOptions?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContext | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fsGroup = undefined;
      this._fsGroupChangePolicy = undefined;
      this._runAsGroup = undefined;
      this._runAsNonRoot = undefined;
      this._runAsUser = undefined;
      this._seLinuxOptions.internalValue = undefined;
      this._seccompProfile.internalValue = undefined;
      this._supplementalGroups = undefined;
      this._sysctls.internalValue = undefined;
      this._windowsOptions.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fsGroup = value.fsGroup;
      this._fsGroupChangePolicy = value.fsGroupChangePolicy;
      this._runAsGroup = value.runAsGroup;
      this._runAsNonRoot = value.runAsNonRoot;
      this._runAsUser = value.runAsUser;
      this._seLinuxOptions.internalValue = value.seLinuxOptions;
      this._seccompProfile.internalValue = value.seccompProfile;
      this._supplementalGroups = value.supplementalGroups;
      this._sysctls.internalValue = value.sysctls;
      this._windowsOptions.internalValue = value.windowsOptions;
    }
  }

  // fs_group - computed: false, optional: true, required: false
  private _fsGroup?: number; 
  public get fsGroup() {
    return this.getNumberAttribute('fs_group');
  }
  public set fsGroup(value: number) {
    this._fsGroup = value;
  }
  public resetFsGroup() {
    this._fsGroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fsGroupInput() {
    return this._fsGroup;
  }

  // fs_group_change_policy - computed: false, optional: true, required: false
  private _fsGroupChangePolicy?: string; 
  public get fsGroupChangePolicy() {
    return this.getStringAttribute('fs_group_change_policy');
  }
  public set fsGroupChangePolicy(value: string) {
    this._fsGroupChangePolicy = value;
  }
  public resetFsGroupChangePolicy() {
    this._fsGroupChangePolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fsGroupChangePolicyInput() {
    return this._fsGroupChangePolicy;
  }

  // run_as_group - computed: false, optional: true, required: false
  private _runAsGroup?: number; 
  public get runAsGroup() {
    return this.getNumberAttribute('run_as_group');
  }
  public set runAsGroup(value: number) {
    this._runAsGroup = value;
  }
  public resetRunAsGroup() {
    this._runAsGroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get runAsGroupInput() {
    return this._runAsGroup;
  }

  // run_as_non_root - computed: false, optional: true, required: false
  private _runAsNonRoot?: boolean | cdktf.IResolvable; 
  public get runAsNonRoot() {
    return this.getBooleanAttribute('run_as_non_root');
  }
  public set runAsNonRoot(value: boolean | cdktf.IResolvable) {
    this._runAsNonRoot = value;
  }
  public resetRunAsNonRoot() {
    this._runAsNonRoot = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get runAsNonRootInput() {
    return this._runAsNonRoot;
  }

  // run_as_user - computed: false, optional: true, required: false
  private _runAsUser?: number; 
  public get runAsUser() {
    return this.getNumberAttribute('run_as_user');
  }
  public set runAsUser(value: number) {
    this._runAsUser = value;
  }
  public resetRunAsUser() {
    this._runAsUser = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get runAsUserInput() {
    return this._runAsUser;
  }

  // se_linux_options - computed: false, optional: true, required: false
  private _seLinuxOptions = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextSeLinuxOptionsOutputReference(this, "se_linux_options");
  public get seLinuxOptions() {
    return this._seLinuxOptions;
  }
  public putSeLinuxOptions(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextSeLinuxOptions) {
    this._seLinuxOptions.internalValue = value;
  }
  public resetSeLinuxOptions() {
    this._seLinuxOptions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get seLinuxOptionsInput() {
    return this._seLinuxOptions.internalValue;
  }

  // seccomp_profile - computed: false, optional: true, required: false
  private _seccompProfile = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextSeccompProfileOutputReference(this, "seccomp_profile");
  public get seccompProfile() {
    return this._seccompProfile;
  }
  public putSeccompProfile(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextSeccompProfile) {
    this._seccompProfile.internalValue = value;
  }
  public resetSeccompProfile() {
    this._seccompProfile.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get seccompProfileInput() {
    return this._seccompProfile.internalValue;
  }

  // supplemental_groups - computed: false, optional: true, required: false
  private _supplementalGroups?: string[]; 
  public get supplementalGroups() {
    return this.getListAttribute('supplemental_groups');
  }
  public set supplementalGroups(value: string[]) {
    this._supplementalGroups = value;
  }
  public resetSupplementalGroups() {
    this._supplementalGroups = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get supplementalGroupsInput() {
    return this._supplementalGroups;
  }

  // sysctls - computed: false, optional: true, required: false
  private _sysctls = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextSysctlsList(this, "sysctls", false);
  public get sysctls() {
    return this._sysctls;
  }
  public putSysctls(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextSysctls[] | cdktf.IResolvable) {
    this._sysctls.internalValue = value;
  }
  public resetSysctls() {
    this._sysctls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sysctlsInput() {
    return this._sysctls.internalValue;
  }

  // windows_options - computed: false, optional: true, required: false
  private _windowsOptions = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextWindowsOptionsOutputReference(this, "windows_options");
  public get windowsOptions() {
    return this._windowsOptions;
  }
  public putWindowsOptions(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentPodSecurityContextWindowsOptions) {
    this._windowsOptions.internalValue = value;
  }
  public resetWindowsOptions() {
    this._windowsOptions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get windowsOptionsInput() {
    return this._windowsOptions.internalValue;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeExec {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#command DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#command}
  */
  readonly command?: string[];
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeExecToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeExec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    command: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.command),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeExecToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeExec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    command: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.command),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeExecOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeExec | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._command !== undefined) {
      hasAnyValues = true;
      internalValueResult.command = this._command;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeExec | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._command = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._command = value.command;
    }
  }

  // command - computed: false, optional: true, required: false
  private _command?: string[]; 
  public get command() {
    return this.getListAttribute('command');
  }
  public set command(value: string[]) {
    this._command = value;
  }
  public resetCommand() {
    this._command = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commandInput() {
    return this._command;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeGrpc {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#port DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#port}
  */
  readonly port?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#service DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#service}
  */
  readonly service?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeGrpcToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeGrpc | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    port: cdktf.numberToTerraform(struct!.port),
    service: cdktf.stringToTerraform(struct!.service),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeGrpcToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeGrpc | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    service: {
      value: cdktf.stringToHclTerraform(struct!.service),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeGrpcOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeGrpc | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._service !== undefined) {
      hasAnyValues = true;
      internalValueResult.service = this._service;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeGrpc | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._port = undefined;
      this._service = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._port = value.port;
      this._service = value.service;
    }
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // service - computed: false, optional: true, required: false
  private _service?: string; 
  public get service() {
    return this.getStringAttribute('service');
  }
  public set service(value: string) {
    this._service = value;
  }
  public resetService() {
    this._service = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceInput() {
    return this._service;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeHttpGetHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#name DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#value DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeHttpGetHttpHeadersToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeHttpGetHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeHttpGetHttpHeadersToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeHttpGetHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeHttpGetHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeHttpGetHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeHttpGetHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeHttpGetHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeHttpGetHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeHttpGetHttpHeadersOutputReference {
    return new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeHttpGetHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeHttpGet {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#host DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#host}
  */
  readonly host?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#http_headers DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#http_headers}
  */
  readonly httpHeaders?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeHttpGetHttpHeaders[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#path DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#path}
  */
  readonly path?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#port DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#port}
  */
  readonly port?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#scheme DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#scheme}
  */
  readonly scheme?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeHttpGetToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeHttpGet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    host: cdktf.stringToTerraform(struct!.host),
    http_headers: cdktf.listMapper(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeHttpGetHttpHeadersToTerraform, false)(struct!.httpHeaders),
    path: cdktf.stringToTerraform(struct!.path),
    port: cdktf.stringToTerraform(struct!.port),
    scheme: cdktf.stringToTerraform(struct!.scheme),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeHttpGetToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeHttpGet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    http_headers: {
      value: cdktf.listMapperHcl(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeHttpGetHttpHeadersToHclTerraform, false)(struct!.httpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeHttpGetHttpHeadersList",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.stringToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    scheme: {
      value: cdktf.stringToHclTerraform(struct!.scheme),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeHttpGetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeHttpGet | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._httpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpHeaders = this._httpHeaders?.internalValue;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._scheme !== undefined) {
      hasAnyValues = true;
      internalValueResult.scheme = this._scheme;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeHttpGet | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._host = undefined;
      this._httpHeaders.internalValue = undefined;
      this._path = undefined;
      this._port = undefined;
      this._scheme = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._host = value.host;
      this._httpHeaders.internalValue = value.httpHeaders;
      this._path = value.path;
      this._port = value.port;
      this._scheme = value.scheme;
    }
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // http_headers - computed: false, optional: true, required: false
  private _httpHeaders = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeHttpGetHttpHeadersList(this, "http_headers", false);
  public get httpHeaders() {
    return this._httpHeaders;
  }
  public putHttpHeaders(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeHttpGetHttpHeaders[] | cdktf.IResolvable) {
    this._httpHeaders.internalValue = value;
  }
  public resetHttpHeaders() {
    this._httpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpHeadersInput() {
    return this._httpHeaders.internalValue;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // port - computed: false, optional: true, required: false
  private _port?: string; 
  public get port() {
    return this.getStringAttribute('port');
  }
  public set port(value: string) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // scheme - computed: false, optional: true, required: false
  private _scheme?: string; 
  public get scheme() {
    return this.getStringAttribute('scheme');
  }
  public set scheme(value: string) {
    this._scheme = value;
  }
  public resetScheme() {
    this._scheme = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get schemeInput() {
    return this._scheme;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeTcpSocket {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#host DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#host}
  */
  readonly host?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#port DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#port}
  */
  readonly port?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeTcpSocketToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeTcpSocket | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    host: cdktf.stringToTerraform(struct!.host),
    port: cdktf.stringToTerraform(struct!.port),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeTcpSocketToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeTcpSocket | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.stringToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeTcpSocketOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeTcpSocket | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeTcpSocket | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._host = undefined;
      this._port = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._host = value.host;
      this._port = value.port;
    }
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // port - computed: false, optional: true, required: false
  private _port?: string; 
  public get port() {
    return this.getStringAttribute('port');
  }
  public set port(value: string) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbe {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#exec DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#exec}
  */
  readonly exec?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeExec;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#failure_threshold DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#failure_threshold}
  */
  readonly failureThreshold?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#grpc DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#grpc}
  */
  readonly grpc?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeGrpc;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#http_get DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#http_get}
  */
  readonly httpGet?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeHttpGet;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#initial_delay_seconds DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#initial_delay_seconds}
  */
  readonly initialDelaySeconds?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#period_seconds DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#period_seconds}
  */
  readonly periodSeconds?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#success_threshold DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#success_threshold}
  */
  readonly successThreshold?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#tcp_socket DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#tcp_socket}
  */
  readonly tcpSocket?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeTcpSocket;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#termination_grace_period_seconds DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#termination_grace_period_seconds}
  */
  readonly terminationGracePeriodSeconds?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#timeout_seconds DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#timeout_seconds}
  */
  readonly timeoutSeconds?: number;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbe | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    exec: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeExecToTerraform(struct!.exec),
    failure_threshold: cdktf.numberToTerraform(struct!.failureThreshold),
    grpc: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeGrpcToTerraform(struct!.grpc),
    http_get: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeHttpGetToTerraform(struct!.httpGet),
    initial_delay_seconds: cdktf.numberToTerraform(struct!.initialDelaySeconds),
    period_seconds: cdktf.numberToTerraform(struct!.periodSeconds),
    success_threshold: cdktf.numberToTerraform(struct!.successThreshold),
    tcp_socket: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeTcpSocketToTerraform(struct!.tcpSocket),
    termination_grace_period_seconds: cdktf.numberToTerraform(struct!.terminationGracePeriodSeconds),
    timeout_seconds: cdktf.numberToTerraform(struct!.timeoutSeconds),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbe | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    exec: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeExecToHclTerraform(struct!.exec),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeExec",
    },
    failure_threshold: {
      value: cdktf.numberToHclTerraform(struct!.failureThreshold),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    grpc: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeGrpcToHclTerraform(struct!.grpc),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeGrpc",
    },
    http_get: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeHttpGetToHclTerraform(struct!.httpGet),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeHttpGet",
    },
    initial_delay_seconds: {
      value: cdktf.numberToHclTerraform(struct!.initialDelaySeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    period_seconds: {
      value: cdktf.numberToHclTerraform(struct!.periodSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    success_threshold: {
      value: cdktf.numberToHclTerraform(struct!.successThreshold),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    tcp_socket: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeTcpSocketToHclTerraform(struct!.tcpSocket),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeTcpSocket",
    },
    termination_grace_period_seconds: {
      value: cdktf.numberToHclTerraform(struct!.terminationGracePeriodSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_seconds: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbe | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._exec?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.exec = this._exec?.internalValue;
    }
    if (this._failureThreshold !== undefined) {
      hasAnyValues = true;
      internalValueResult.failureThreshold = this._failureThreshold;
    }
    if (this._grpc?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.grpc = this._grpc?.internalValue;
    }
    if (this._httpGet?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpGet = this._httpGet?.internalValue;
    }
    if (this._initialDelaySeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialDelaySeconds = this._initialDelaySeconds;
    }
    if (this._periodSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.periodSeconds = this._periodSeconds;
    }
    if (this._successThreshold !== undefined) {
      hasAnyValues = true;
      internalValueResult.successThreshold = this._successThreshold;
    }
    if (this._tcpSocket?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tcpSocket = this._tcpSocket?.internalValue;
    }
    if (this._terminationGracePeriodSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.terminationGracePeriodSeconds = this._terminationGracePeriodSeconds;
    }
    if (this._timeoutSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSeconds = this._timeoutSeconds;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbe | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._exec.internalValue = undefined;
      this._failureThreshold = undefined;
      this._grpc.internalValue = undefined;
      this._httpGet.internalValue = undefined;
      this._initialDelaySeconds = undefined;
      this._periodSeconds = undefined;
      this._successThreshold = undefined;
      this._tcpSocket.internalValue = undefined;
      this._terminationGracePeriodSeconds = undefined;
      this._timeoutSeconds = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._exec.internalValue = value.exec;
      this._failureThreshold = value.failureThreshold;
      this._grpc.internalValue = value.grpc;
      this._httpGet.internalValue = value.httpGet;
      this._initialDelaySeconds = value.initialDelaySeconds;
      this._periodSeconds = value.periodSeconds;
      this._successThreshold = value.successThreshold;
      this._tcpSocket.internalValue = value.tcpSocket;
      this._terminationGracePeriodSeconds = value.terminationGracePeriodSeconds;
      this._timeoutSeconds = value.timeoutSeconds;
    }
  }

  // exec - computed: false, optional: true, required: false
  private _exec = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeExecOutputReference(this, "exec");
  public get exec() {
    return this._exec;
  }
  public putExec(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeExec) {
    this._exec.internalValue = value;
  }
  public resetExec() {
    this._exec.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get execInput() {
    return this._exec.internalValue;
  }

  // failure_threshold - computed: false, optional: true, required: false
  private _failureThreshold?: number; 
  public get failureThreshold() {
    return this.getNumberAttribute('failure_threshold');
  }
  public set failureThreshold(value: number) {
    this._failureThreshold = value;
  }
  public resetFailureThreshold() {
    this._failureThreshold = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failureThresholdInput() {
    return this._failureThreshold;
  }

  // grpc - computed: false, optional: true, required: false
  private _grpc = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeGrpcOutputReference(this, "grpc");
  public get grpc() {
    return this._grpc;
  }
  public putGrpc(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeGrpc) {
    this._grpc.internalValue = value;
  }
  public resetGrpc() {
    this._grpc.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get grpcInput() {
    return this._grpc.internalValue;
  }

  // http_get - computed: false, optional: true, required: false
  private _httpGet = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeHttpGetOutputReference(this, "http_get");
  public get httpGet() {
    return this._httpGet;
  }
  public putHttpGet(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeHttpGet) {
    this._httpGet.internalValue = value;
  }
  public resetHttpGet() {
    this._httpGet.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpGetInput() {
    return this._httpGet.internalValue;
  }

  // initial_delay_seconds - computed: false, optional: true, required: false
  private _initialDelaySeconds?: number; 
  public get initialDelaySeconds() {
    return this.getNumberAttribute('initial_delay_seconds');
  }
  public set initialDelaySeconds(value: number) {
    this._initialDelaySeconds = value;
  }
  public resetInitialDelaySeconds() {
    this._initialDelaySeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialDelaySecondsInput() {
    return this._initialDelaySeconds;
  }

  // period_seconds - computed: false, optional: true, required: false
  private _periodSeconds?: number; 
  public get periodSeconds() {
    return this.getNumberAttribute('period_seconds');
  }
  public set periodSeconds(value: number) {
    this._periodSeconds = value;
  }
  public resetPeriodSeconds() {
    this._periodSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get periodSecondsInput() {
    return this._periodSeconds;
  }

  // success_threshold - computed: false, optional: true, required: false
  private _successThreshold?: number; 
  public get successThreshold() {
    return this.getNumberAttribute('success_threshold');
  }
  public set successThreshold(value: number) {
    this._successThreshold = value;
  }
  public resetSuccessThreshold() {
    this._successThreshold = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get successThresholdInput() {
    return this._successThreshold;
  }

  // tcp_socket - computed: false, optional: true, required: false
  private _tcpSocket = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeTcpSocketOutputReference(this, "tcp_socket");
  public get tcpSocket() {
    return this._tcpSocket;
  }
  public putTcpSocket(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReadinessProbeTcpSocket) {
    this._tcpSocket.internalValue = value;
  }
  public resetTcpSocket() {
    this._tcpSocket.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tcpSocketInput() {
    return this._tcpSocket.internalValue;
  }

  // termination_grace_period_seconds - computed: false, optional: true, required: false
  private _terminationGracePeriodSeconds?: number; 
  public get terminationGracePeriodSeconds() {
    return this.getNumberAttribute('termination_grace_period_seconds');
  }
  public set terminationGracePeriodSeconds(value: number) {
    this._terminationGracePeriodSeconds = value;
  }
  public resetTerminationGracePeriodSeconds() {
    this._terminationGracePeriodSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get terminationGracePeriodSecondsInput() {
    return this._terminationGracePeriodSeconds;
  }

  // timeout_seconds - computed: false, optional: true, required: false
  private _timeoutSeconds?: number; 
  public get timeoutSeconds() {
    return this.getNumberAttribute('timeout_seconds');
  }
  public set timeoutSeconds(value: number) {
    this._timeoutSeconds = value;
  }
  public resetTimeoutSeconds() {
    this._timeoutSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecondsInput() {
    return this._timeoutSeconds;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReplicas {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#count DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#count}
  */
  readonly count?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#max DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#max}
  */
  readonly max?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#min DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#min}
  */
  readonly min?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#target_cpu_utilization_percentage DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#target_cpu_utilization_percentage}
  */
  readonly targetCpuUtilizationPercentage?: number;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReplicasToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReplicas | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    count: cdktf.numberToTerraform(struct!.count),
    max: cdktf.numberToTerraform(struct!.max),
    min: cdktf.numberToTerraform(struct!.min),
    target_cpu_utilization_percentage: cdktf.numberToTerraform(struct!.targetCpuUtilizationPercentage),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReplicasToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReplicas | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    count: {
      value: cdktf.numberToHclTerraform(struct!.count),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max: {
      value: cdktf.numberToHclTerraform(struct!.max),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    min: {
      value: cdktf.numberToHclTerraform(struct!.min),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    target_cpu_utilization_percentage: {
      value: cdktf.numberToHclTerraform(struct!.targetCpuUtilizationPercentage),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReplicasOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReplicas | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._count !== undefined) {
      hasAnyValues = true;
      internalValueResult.count = this._count;
    }
    if (this._max !== undefined) {
      hasAnyValues = true;
      internalValueResult.max = this._max;
    }
    if (this._min !== undefined) {
      hasAnyValues = true;
      internalValueResult.min = this._min;
    }
    if (this._targetCpuUtilizationPercentage !== undefined) {
      hasAnyValues = true;
      internalValueResult.targetCpuUtilizationPercentage = this._targetCpuUtilizationPercentage;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentReplicas | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._count = undefined;
      this._max = undefined;
      this._min = undefined;
      this._targetCpuUtilizationPercentage = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._count = value.count;
      this._max = value.max;
      this._min = value.min;
      this._targetCpuUtilizationPercentage = value.targetCpuUtilizationPercentage;
    }
  }

  // count - computed: false, optional: true, required: false
  private _count?: number; 
  public get count() {
    return this.getNumberAttribute('count');
  }
  public set count(value: number) {
    this._count = value;
  }
  public resetCount() {
    this._count = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get countInput() {
    return this._count;
  }

  // max - computed: false, optional: true, required: false
  private _max?: number; 
  public get max() {
    return this.getNumberAttribute('max');
  }
  public set max(value: number) {
    this._max = value;
  }
  public resetMax() {
    this._max = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxInput() {
    return this._max;
  }

  // min - computed: false, optional: true, required: false
  private _min?: number; 
  public get min() {
    return this.getNumberAttribute('min');
  }
  public set min(value: number) {
    this._min = value;
  }
  public resetMin() {
    this._min = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minInput() {
    return this._min;
  }

  // target_cpu_utilization_percentage - computed: false, optional: true, required: false
  private _targetCpuUtilizationPercentage?: number; 
  public get targetCpuUtilizationPercentage() {
    return this.getNumberAttribute('target_cpu_utilization_percentage');
  }
  public set targetCpuUtilizationPercentage(value: number) {
    this._targetCpuUtilizationPercentage = value;
  }
  public resetTargetCpuUtilizationPercentage() {
    this._targetCpuUtilizationPercentage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetCpuUtilizationPercentageInput() {
    return this._targetCpuUtilizationPercentage;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentResources {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#limits DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#limits}
  */
  readonly limits?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#requests DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#requests}
  */
  readonly requests?: { [key: string]: string };
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentResourcesToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentResources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    limits: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.limits),
    requests: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.requests),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentResourcesToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentResources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    limits: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.limits),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    requests: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.requests),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentResourcesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentResources | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._limits !== undefined) {
      hasAnyValues = true;
      internalValueResult.limits = this._limits;
    }
    if (this._requests !== undefined) {
      hasAnyValues = true;
      internalValueResult.requests = this._requests;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentResources | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._limits = undefined;
      this._requests = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._limits = value.limits;
      this._requests = value.requests;
    }
  }

  // limits - computed: false, optional: true, required: false
  private _limits?: { [key: string]: string }; 
  public get limits() {
    return this.getStringMapAttribute('limits');
  }
  public set limits(value: { [key: string]: string }) {
    this._limits = value;
  }
  public resetLimits() {
    this._limits = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get limitsInput() {
    return this._limits;
  }

  // requests - computed: false, optional: true, required: false
  private _requests?: { [key: string]: string }; 
  public get requests() {
    return this.getStringMapAttribute('requests');
  }
  public set requests(value: { [key: string]: string }) {
    this._requests = value;
  }
  public resetRequests() {
    this._requests = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestsInput() {
    return this._requests;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextCapabilities {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#add DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#add}
  */
  readonly add?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#drop DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#drop}
  */
  readonly drop?: string[];
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextCapabilitiesToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextCapabilities | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    add: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.add),
    drop: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.drop),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextCapabilitiesToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextCapabilities | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    add: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.add),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    drop: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.drop),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextCapabilitiesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextCapabilities | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._add !== undefined) {
      hasAnyValues = true;
      internalValueResult.add = this._add;
    }
    if (this._drop !== undefined) {
      hasAnyValues = true;
      internalValueResult.drop = this._drop;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextCapabilities | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._add = undefined;
      this._drop = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._add = value.add;
      this._drop = value.drop;
    }
  }

  // add - computed: false, optional: true, required: false
  private _add?: string[]; 
  public get add() {
    return this.getListAttribute('add');
  }
  public set add(value: string[]) {
    this._add = value;
  }
  public resetAdd() {
    this._add = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addInput() {
    return this._add;
  }

  // drop - computed: false, optional: true, required: false
  private _drop?: string[]; 
  public get drop() {
    return this.getListAttribute('drop');
  }
  public set drop(value: string[]) {
    this._drop = value;
  }
  public resetDrop() {
    this._drop = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dropInput() {
    return this._drop;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextSeLinuxOptions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#level DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#level}
  */
  readonly level?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#role DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#role}
  */
  readonly role?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#type DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#type}
  */
  readonly type?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#user DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#user}
  */
  readonly user?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextSeLinuxOptionsToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextSeLinuxOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    level: cdktf.stringToTerraform(struct!.level),
    role: cdktf.stringToTerraform(struct!.role),
    type: cdktf.stringToTerraform(struct!.type),
    user: cdktf.stringToTerraform(struct!.user),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextSeLinuxOptionsToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextSeLinuxOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    level: {
      value: cdktf.stringToHclTerraform(struct!.level),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role: {
      value: cdktf.stringToHclTerraform(struct!.role),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    user: {
      value: cdktf.stringToHclTerraform(struct!.user),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextSeLinuxOptionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextSeLinuxOptions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._level !== undefined) {
      hasAnyValues = true;
      internalValueResult.level = this._level;
    }
    if (this._role !== undefined) {
      hasAnyValues = true;
      internalValueResult.role = this._role;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._user !== undefined) {
      hasAnyValues = true;
      internalValueResult.user = this._user;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextSeLinuxOptions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._level = undefined;
      this._role = undefined;
      this._type = undefined;
      this._user = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._level = value.level;
      this._role = value.role;
      this._type = value.type;
      this._user = value.user;
    }
  }

  // level - computed: false, optional: true, required: false
  private _level?: string; 
  public get level() {
    return this.getStringAttribute('level');
  }
  public set level(value: string) {
    this._level = value;
  }
  public resetLevel() {
    this._level = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get levelInput() {
    return this._level;
  }

  // role - computed: false, optional: true, required: false
  private _role?: string; 
  public get role() {
    return this.getStringAttribute('role');
  }
  public set role(value: string) {
    this._role = value;
  }
  public resetRole() {
    this._role = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleInput() {
    return this._role;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // user - computed: false, optional: true, required: false
  private _user?: string; 
  public get user() {
    return this.getStringAttribute('user');
  }
  public set user(value: string) {
    this._user = value;
  }
  public resetUser() {
    this._user = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get userInput() {
    return this._user;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextSeccompProfile {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#localhost_profile DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#localhost_profile}
  */
  readonly localhostProfile?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#type DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#type}
  */
  readonly type?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextSeccompProfileToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextSeccompProfile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    localhost_profile: cdktf.stringToTerraform(struct!.localhostProfile),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextSeccompProfileToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextSeccompProfile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    localhost_profile: {
      value: cdktf.stringToHclTerraform(struct!.localhostProfile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextSeccompProfileOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextSeccompProfile | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._localhostProfile !== undefined) {
      hasAnyValues = true;
      internalValueResult.localhostProfile = this._localhostProfile;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextSeccompProfile | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._localhostProfile = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._localhostProfile = value.localhostProfile;
      this._type = value.type;
    }
  }

  // localhost_profile - computed: false, optional: true, required: false
  private _localhostProfile?: string; 
  public get localhostProfile() {
    return this.getStringAttribute('localhost_profile');
  }
  public set localhostProfile(value: string) {
    this._localhostProfile = value;
  }
  public resetLocalhostProfile() {
    this._localhostProfile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localhostProfileInput() {
    return this._localhostProfile;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextWindowsOptions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#gmsa_credential_spec DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#gmsa_credential_spec}
  */
  readonly gmsaCredentialSpec?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#gmsa_credential_spec_name DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#gmsa_credential_spec_name}
  */
  readonly gmsaCredentialSpecName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#host_process DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#host_process}
  */
  readonly hostProcess?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#run_as_user_name DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#run_as_user_name}
  */
  readonly runAsUserName?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextWindowsOptionsToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextWindowsOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    gmsa_credential_spec: cdktf.stringToTerraform(struct!.gmsaCredentialSpec),
    gmsa_credential_spec_name: cdktf.stringToTerraform(struct!.gmsaCredentialSpecName),
    host_process: cdktf.booleanToTerraform(struct!.hostProcess),
    run_as_user_name: cdktf.stringToTerraform(struct!.runAsUserName),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextWindowsOptionsToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextWindowsOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    gmsa_credential_spec: {
      value: cdktf.stringToHclTerraform(struct!.gmsaCredentialSpec),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    gmsa_credential_spec_name: {
      value: cdktf.stringToHclTerraform(struct!.gmsaCredentialSpecName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host_process: {
      value: cdktf.booleanToHclTerraform(struct!.hostProcess),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    run_as_user_name: {
      value: cdktf.stringToHclTerraform(struct!.runAsUserName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextWindowsOptionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextWindowsOptions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._gmsaCredentialSpec !== undefined) {
      hasAnyValues = true;
      internalValueResult.gmsaCredentialSpec = this._gmsaCredentialSpec;
    }
    if (this._gmsaCredentialSpecName !== undefined) {
      hasAnyValues = true;
      internalValueResult.gmsaCredentialSpecName = this._gmsaCredentialSpecName;
    }
    if (this._hostProcess !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostProcess = this._hostProcess;
    }
    if (this._runAsUserName !== undefined) {
      hasAnyValues = true;
      internalValueResult.runAsUserName = this._runAsUserName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextWindowsOptions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._gmsaCredentialSpec = undefined;
      this._gmsaCredentialSpecName = undefined;
      this._hostProcess = undefined;
      this._runAsUserName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._gmsaCredentialSpec = value.gmsaCredentialSpec;
      this._gmsaCredentialSpecName = value.gmsaCredentialSpecName;
      this._hostProcess = value.hostProcess;
      this._runAsUserName = value.runAsUserName;
    }
  }

  // gmsa_credential_spec - computed: false, optional: true, required: false
  private _gmsaCredentialSpec?: string; 
  public get gmsaCredentialSpec() {
    return this.getStringAttribute('gmsa_credential_spec');
  }
  public set gmsaCredentialSpec(value: string) {
    this._gmsaCredentialSpec = value;
  }
  public resetGmsaCredentialSpec() {
    this._gmsaCredentialSpec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gmsaCredentialSpecInput() {
    return this._gmsaCredentialSpec;
  }

  // gmsa_credential_spec_name - computed: false, optional: true, required: false
  private _gmsaCredentialSpecName?: string; 
  public get gmsaCredentialSpecName() {
    return this.getStringAttribute('gmsa_credential_spec_name');
  }
  public set gmsaCredentialSpecName(value: string) {
    this._gmsaCredentialSpecName = value;
  }
  public resetGmsaCredentialSpecName() {
    this._gmsaCredentialSpecName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gmsaCredentialSpecNameInput() {
    return this._gmsaCredentialSpecName;
  }

  // host_process - computed: false, optional: true, required: false
  private _hostProcess?: boolean | cdktf.IResolvable; 
  public get hostProcess() {
    return this.getBooleanAttribute('host_process');
  }
  public set hostProcess(value: boolean | cdktf.IResolvable) {
    this._hostProcess = value;
  }
  public resetHostProcess() {
    this._hostProcess = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostProcessInput() {
    return this._hostProcess;
  }

  // run_as_user_name - computed: false, optional: true, required: false
  private _runAsUserName?: string; 
  public get runAsUserName() {
    return this.getStringAttribute('run_as_user_name');
  }
  public set runAsUserName(value: string) {
    this._runAsUserName = value;
  }
  public resetRunAsUserName() {
    this._runAsUserName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get runAsUserNameInput() {
    return this._runAsUserName;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContext {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#allow_privilege_escalation DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#allow_privilege_escalation}
  */
  readonly allowPrivilegeEscalation?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#capabilities DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#capabilities}
  */
  readonly capabilities?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextCapabilities;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#privileged DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#privileged}
  */
  readonly privileged?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#proc_mount DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#proc_mount}
  */
  readonly procMount?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#read_only_root_filesystem DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#read_only_root_filesystem}
  */
  readonly readOnlyRootFilesystem?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#run_as_group DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#run_as_group}
  */
  readonly runAsGroup?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#run_as_non_root DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#run_as_non_root}
  */
  readonly runAsNonRoot?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#run_as_user DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#run_as_user}
  */
  readonly runAsUser?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#se_linux_options DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#se_linux_options}
  */
  readonly seLinuxOptions?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextSeLinuxOptions;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#seccomp_profile DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#seccomp_profile}
  */
  readonly seccompProfile?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextSeccompProfile;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#windows_options DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#windows_options}
  */
  readonly windowsOptions?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextWindowsOptions;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContext | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_privilege_escalation: cdktf.booleanToTerraform(struct!.allowPrivilegeEscalation),
    capabilities: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextCapabilitiesToTerraform(struct!.capabilities),
    privileged: cdktf.booleanToTerraform(struct!.privileged),
    proc_mount: cdktf.stringToTerraform(struct!.procMount),
    read_only_root_filesystem: cdktf.booleanToTerraform(struct!.readOnlyRootFilesystem),
    run_as_group: cdktf.numberToTerraform(struct!.runAsGroup),
    run_as_non_root: cdktf.booleanToTerraform(struct!.runAsNonRoot),
    run_as_user: cdktf.numberToTerraform(struct!.runAsUser),
    se_linux_options: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextSeLinuxOptionsToTerraform(struct!.seLinuxOptions),
    seccomp_profile: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextSeccompProfileToTerraform(struct!.seccompProfile),
    windows_options: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextWindowsOptionsToTerraform(struct!.windowsOptions),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContext | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_privilege_escalation: {
      value: cdktf.booleanToHclTerraform(struct!.allowPrivilegeEscalation),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    capabilities: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextCapabilitiesToHclTerraform(struct!.capabilities),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextCapabilities",
    },
    privileged: {
      value: cdktf.booleanToHclTerraform(struct!.privileged),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    proc_mount: {
      value: cdktf.stringToHclTerraform(struct!.procMount),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    read_only_root_filesystem: {
      value: cdktf.booleanToHclTerraform(struct!.readOnlyRootFilesystem),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    run_as_group: {
      value: cdktf.numberToHclTerraform(struct!.runAsGroup),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    run_as_non_root: {
      value: cdktf.booleanToHclTerraform(struct!.runAsNonRoot),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    run_as_user: {
      value: cdktf.numberToHclTerraform(struct!.runAsUser),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    se_linux_options: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextSeLinuxOptionsToHclTerraform(struct!.seLinuxOptions),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextSeLinuxOptions",
    },
    seccomp_profile: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextSeccompProfileToHclTerraform(struct!.seccompProfile),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextSeccompProfile",
    },
    windows_options: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextWindowsOptionsToHclTerraform(struct!.windowsOptions),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextWindowsOptions",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContext | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowPrivilegeEscalation !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowPrivilegeEscalation = this._allowPrivilegeEscalation;
    }
    if (this._capabilities?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.capabilities = this._capabilities?.internalValue;
    }
    if (this._privileged !== undefined) {
      hasAnyValues = true;
      internalValueResult.privileged = this._privileged;
    }
    if (this._procMount !== undefined) {
      hasAnyValues = true;
      internalValueResult.procMount = this._procMount;
    }
    if (this._readOnlyRootFilesystem !== undefined) {
      hasAnyValues = true;
      internalValueResult.readOnlyRootFilesystem = this._readOnlyRootFilesystem;
    }
    if (this._runAsGroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.runAsGroup = this._runAsGroup;
    }
    if (this._runAsNonRoot !== undefined) {
      hasAnyValues = true;
      internalValueResult.runAsNonRoot = this._runAsNonRoot;
    }
    if (this._runAsUser !== undefined) {
      hasAnyValues = true;
      internalValueResult.runAsUser = this._runAsUser;
    }
    if (this._seLinuxOptions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.seLinuxOptions = this._seLinuxOptions?.internalValue;
    }
    if (this._seccompProfile?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.seccompProfile = this._seccompProfile?.internalValue;
    }
    if (this._windowsOptions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.windowsOptions = this._windowsOptions?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContext | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allowPrivilegeEscalation = undefined;
      this._capabilities.internalValue = undefined;
      this._privileged = undefined;
      this._procMount = undefined;
      this._readOnlyRootFilesystem = undefined;
      this._runAsGroup = undefined;
      this._runAsNonRoot = undefined;
      this._runAsUser = undefined;
      this._seLinuxOptions.internalValue = undefined;
      this._seccompProfile.internalValue = undefined;
      this._windowsOptions.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allowPrivilegeEscalation = value.allowPrivilegeEscalation;
      this._capabilities.internalValue = value.capabilities;
      this._privileged = value.privileged;
      this._procMount = value.procMount;
      this._readOnlyRootFilesystem = value.readOnlyRootFilesystem;
      this._runAsGroup = value.runAsGroup;
      this._runAsNonRoot = value.runAsNonRoot;
      this._runAsUser = value.runAsUser;
      this._seLinuxOptions.internalValue = value.seLinuxOptions;
      this._seccompProfile.internalValue = value.seccompProfile;
      this._windowsOptions.internalValue = value.windowsOptions;
    }
  }

  // allow_privilege_escalation - computed: false, optional: true, required: false
  private _allowPrivilegeEscalation?: boolean | cdktf.IResolvable; 
  public get allowPrivilegeEscalation() {
    return this.getBooleanAttribute('allow_privilege_escalation');
  }
  public set allowPrivilegeEscalation(value: boolean | cdktf.IResolvable) {
    this._allowPrivilegeEscalation = value;
  }
  public resetAllowPrivilegeEscalation() {
    this._allowPrivilegeEscalation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowPrivilegeEscalationInput() {
    return this._allowPrivilegeEscalation;
  }

  // capabilities - computed: false, optional: true, required: false
  private _capabilities = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextCapabilitiesOutputReference(this, "capabilities");
  public get capabilities() {
    return this._capabilities;
  }
  public putCapabilities(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextCapabilities) {
    this._capabilities.internalValue = value;
  }
  public resetCapabilities() {
    this._capabilities.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get capabilitiesInput() {
    return this._capabilities.internalValue;
  }

  // privileged - computed: false, optional: true, required: false
  private _privileged?: boolean | cdktf.IResolvable; 
  public get privileged() {
    return this.getBooleanAttribute('privileged');
  }
  public set privileged(value: boolean | cdktf.IResolvable) {
    this._privileged = value;
  }
  public resetPrivileged() {
    this._privileged = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privilegedInput() {
    return this._privileged;
  }

  // proc_mount - computed: false, optional: true, required: false
  private _procMount?: string; 
  public get procMount() {
    return this.getStringAttribute('proc_mount');
  }
  public set procMount(value: string) {
    this._procMount = value;
  }
  public resetProcMount() {
    this._procMount = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get procMountInput() {
    return this._procMount;
  }

  // read_only_root_filesystem - computed: false, optional: true, required: false
  private _readOnlyRootFilesystem?: boolean | cdktf.IResolvable; 
  public get readOnlyRootFilesystem() {
    return this.getBooleanAttribute('read_only_root_filesystem');
  }
  public set readOnlyRootFilesystem(value: boolean | cdktf.IResolvable) {
    this._readOnlyRootFilesystem = value;
  }
  public resetReadOnlyRootFilesystem() {
    this._readOnlyRootFilesystem = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get readOnlyRootFilesystemInput() {
    return this._readOnlyRootFilesystem;
  }

  // run_as_group - computed: false, optional: true, required: false
  private _runAsGroup?: number; 
  public get runAsGroup() {
    return this.getNumberAttribute('run_as_group');
  }
  public set runAsGroup(value: number) {
    this._runAsGroup = value;
  }
  public resetRunAsGroup() {
    this._runAsGroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get runAsGroupInput() {
    return this._runAsGroup;
  }

  // run_as_non_root - computed: false, optional: true, required: false
  private _runAsNonRoot?: boolean | cdktf.IResolvable; 
  public get runAsNonRoot() {
    return this.getBooleanAttribute('run_as_non_root');
  }
  public set runAsNonRoot(value: boolean | cdktf.IResolvable) {
    this._runAsNonRoot = value;
  }
  public resetRunAsNonRoot() {
    this._runAsNonRoot = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get runAsNonRootInput() {
    return this._runAsNonRoot;
  }

  // run_as_user - computed: false, optional: true, required: false
  private _runAsUser?: number; 
  public get runAsUser() {
    return this.getNumberAttribute('run_as_user');
  }
  public set runAsUser(value: number) {
    this._runAsUser = value;
  }
  public resetRunAsUser() {
    this._runAsUser = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get runAsUserInput() {
    return this._runAsUser;
  }

  // se_linux_options - computed: false, optional: true, required: false
  private _seLinuxOptions = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextSeLinuxOptionsOutputReference(this, "se_linux_options");
  public get seLinuxOptions() {
    return this._seLinuxOptions;
  }
  public putSeLinuxOptions(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextSeLinuxOptions) {
    this._seLinuxOptions.internalValue = value;
  }
  public resetSeLinuxOptions() {
    this._seLinuxOptions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get seLinuxOptionsInput() {
    return this._seLinuxOptions.internalValue;
  }

  // seccomp_profile - computed: false, optional: true, required: false
  private _seccompProfile = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextSeccompProfileOutputReference(this, "seccomp_profile");
  public get seccompProfile() {
    return this._seccompProfile;
  }
  public putSeccompProfile(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextSeccompProfile) {
    this._seccompProfile.internalValue = value;
  }
  public resetSeccompProfile() {
    this._seccompProfile.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get seccompProfileInput() {
    return this._seccompProfile.internalValue;
  }

  // windows_options - computed: false, optional: true, required: false
  private _windowsOptions = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextWindowsOptionsOutputReference(this, "windows_options");
  public get windowsOptions() {
    return this._windowsOptions;
  }
  public putWindowsOptions(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentSecurityContextWindowsOptions) {
    this._windowsOptions.internalValue = value;
  }
  public resetWindowsOptions() {
    this._windowsOptions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get windowsOptionsInput() {
    return this._windowsOptions.internalValue;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentTolerations {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#effect DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#effect}
  */
  readonly effect?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#key DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#operator DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#operator}
  */
  readonly operator?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#toleration_seconds DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#toleration_seconds}
  */
  readonly tolerationSeconds?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#value DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentTolerationsToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentTolerations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    effect: cdktf.stringToTerraform(struct!.effect),
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    toleration_seconds: cdktf.numberToTerraform(struct!.tolerationSeconds),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentTolerationsToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentTolerations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    effect: {
      value: cdktf.stringToHclTerraform(struct!.effect),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    toleration_seconds: {
      value: cdktf.numberToHclTerraform(struct!.tolerationSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentTolerationsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentTolerations | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._effect !== undefined) {
      hasAnyValues = true;
      internalValueResult.effect = this._effect;
    }
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._tolerationSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.tolerationSeconds = this._tolerationSeconds;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentTolerations | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._effect = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._tolerationSeconds = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._effect = value.effect;
      this._key = value.key;
      this._operator = value.operator;
      this._tolerationSeconds = value.tolerationSeconds;
      this._value = value.value;
    }
  }

  // effect - computed: false, optional: true, required: false
  private _effect?: string; 
  public get effect() {
    return this.getStringAttribute('effect');
  }
  public set effect(value: string) {
    this._effect = value;
  }
  public resetEffect() {
    this._effect = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get effectInput() {
    return this._effect;
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // toleration_seconds - computed: false, optional: true, required: false
  private _tolerationSeconds?: number; 
  public get tolerationSeconds() {
    return this.getNumberAttribute('toleration_seconds');
  }
  public set tolerationSeconds(value: number) {
    this._tolerationSeconds = value;
  }
  public resetTolerationSeconds() {
    this._tolerationSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tolerationSecondsInput() {
    return this._tolerationSeconds;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentTolerationsList extends cdktf.ComplexList {
  public internalValue? : DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentTolerations[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentTolerationsOutputReference {
    return new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentTolerationsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentTopologySpreadConstraintsLabelSelectorMatchExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#key DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#operator DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#operator}
  */
  readonly operator?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#values DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentTopologySpreadConstraintsLabelSelectorMatchExpressionsToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentTopologySpreadConstraintsLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentTopologySpreadConstraintsLabelSelectorMatchExpressionsToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentTopologySpreadConstraintsLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentTopologySpreadConstraintsLabelSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentTopologySpreadConstraintsLabelSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentTopologySpreadConstraintsLabelSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentTopologySpreadConstraintsLabelSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentTopologySpreadConstraintsLabelSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentTopologySpreadConstraintsLabelSelectorMatchExpressionsOutputReference {
    return new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentTopologySpreadConstraintsLabelSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentTopologySpreadConstraintsLabelSelector {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#match_expressions DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentTopologySpreadConstraintsLabelSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#match_labels DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentTopologySpreadConstraintsLabelSelectorToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentTopologySpreadConstraintsLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentTopologySpreadConstraintsLabelSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentTopologySpreadConstraintsLabelSelectorToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentTopologySpreadConstraintsLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentTopologySpreadConstraintsLabelSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentTopologySpreadConstraintsLabelSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentTopologySpreadConstraintsLabelSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentTopologySpreadConstraintsLabelSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentTopologySpreadConstraintsLabelSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentTopologySpreadConstraintsLabelSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentTopologySpreadConstraintsLabelSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentTopologySpreadConstraints {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#label_selector DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#label_selector}
  */
  readonly labelSelector?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentTopologySpreadConstraintsLabelSelector;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#max_skew DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#max_skew}
  */
  readonly maxSkew?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#topology_key DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#topology_key}
  */
  readonly topologyKey?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#when_unsatisfiable DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#when_unsatisfiable}
  */
  readonly whenUnsatisfiable?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentTopologySpreadConstraintsToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentTopologySpreadConstraints | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label_selector: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentTopologySpreadConstraintsLabelSelectorToTerraform(struct!.labelSelector),
    max_skew: cdktf.numberToTerraform(struct!.maxSkew),
    topology_key: cdktf.stringToTerraform(struct!.topologyKey),
    when_unsatisfiable: cdktf.stringToTerraform(struct!.whenUnsatisfiable),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentTopologySpreadConstraintsToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentTopologySpreadConstraints | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label_selector: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentTopologySpreadConstraintsLabelSelectorToHclTerraform(struct!.labelSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentTopologySpreadConstraintsLabelSelector",
    },
    max_skew: {
      value: cdktf.numberToHclTerraform(struct!.maxSkew),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    topology_key: {
      value: cdktf.stringToHclTerraform(struct!.topologyKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    when_unsatisfiable: {
      value: cdktf.stringToHclTerraform(struct!.whenUnsatisfiable),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentTopologySpreadConstraintsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentTopologySpreadConstraints | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._labelSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSelector = this._labelSelector?.internalValue;
    }
    if (this._maxSkew !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSkew = this._maxSkew;
    }
    if (this._topologyKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.topologyKey = this._topologyKey;
    }
    if (this._whenUnsatisfiable !== undefined) {
      hasAnyValues = true;
      internalValueResult.whenUnsatisfiable = this._whenUnsatisfiable;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentTopologySpreadConstraints | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = undefined;
      this._maxSkew = undefined;
      this._topologyKey = undefined;
      this._whenUnsatisfiable = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = value.labelSelector;
      this._maxSkew = value.maxSkew;
      this._topologyKey = value.topologyKey;
      this._whenUnsatisfiable = value.whenUnsatisfiable;
    }
  }

  // label_selector - computed: false, optional: true, required: false
  private _labelSelector = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentTopologySpreadConstraintsLabelSelectorOutputReference(this, "label_selector");
  public get labelSelector() {
    return this._labelSelector;
  }
  public putLabelSelector(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentTopologySpreadConstraintsLabelSelector) {
    this._labelSelector.internalValue = value;
  }
  public resetLabelSelector() {
    this._labelSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSelectorInput() {
    return this._labelSelector.internalValue;
  }

  // max_skew - computed: false, optional: true, required: false
  private _maxSkew?: number; 
  public get maxSkew() {
    return this.getNumberAttribute('max_skew');
  }
  public set maxSkew(value: number) {
    this._maxSkew = value;
  }
  public resetMaxSkew() {
    this._maxSkew = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSkewInput() {
    return this._maxSkew;
  }

  // topology_key - computed: false, optional: true, required: false
  private _topologyKey?: string; 
  public get topologyKey() {
    return this.getStringAttribute('topology_key');
  }
  public set topologyKey(value: string) {
    this._topologyKey = value;
  }
  public resetTopologyKey() {
    this._topologyKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get topologyKeyInput() {
    return this._topologyKey;
  }

  // when_unsatisfiable - computed: false, optional: true, required: false
  private _whenUnsatisfiable?: string; 
  public get whenUnsatisfiable() {
    return this.getStringAttribute('when_unsatisfiable');
  }
  public set whenUnsatisfiable(value: string) {
    this._whenUnsatisfiable = value;
  }
  public resetWhenUnsatisfiable() {
    this._whenUnsatisfiable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get whenUnsatisfiableInput() {
    return this._whenUnsatisfiable;
  }
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentTopologySpreadConstraintsList extends cdktf.ComplexList {
  public internalValue? : DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentTopologySpreadConstraints[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentTopologySpreadConstraintsOutputReference {
    return new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentTopologySpreadConstraintsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumeMounts {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#mount_path DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#mount_path}
  */
  readonly mountPath?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#mount_propagation DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#mount_propagation}
  */
  readonly mountPropagation?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#name DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#read_only DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#read_only}
  */
  readonly readOnly?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#sub_path DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#sub_path}
  */
  readonly subPath?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#sub_path_expr DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#sub_path_expr}
  */
  readonly subPathExpr?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumeMountsToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumeMounts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mount_path: cdktf.stringToTerraform(struct!.mountPath),
    mount_propagation: cdktf.stringToTerraform(struct!.mountPropagation),
    name: cdktf.stringToTerraform(struct!.name),
    read_only: cdktf.booleanToTerraform(struct!.readOnly),
    sub_path: cdktf.stringToTerraform(struct!.subPath),
    sub_path_expr: cdktf.stringToTerraform(struct!.subPathExpr),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumeMountsToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumeMounts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mount_path: {
      value: cdktf.stringToHclTerraform(struct!.mountPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mount_propagation: {
      value: cdktf.stringToHclTerraform(struct!.mountPropagation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    read_only: {
      value: cdktf.booleanToHclTerraform(struct!.readOnly),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    sub_path: {
      value: cdktf.stringToHclTerraform(struct!.subPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sub_path_expr: {
      value: cdktf.stringToHclTerraform(struct!.subPathExpr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumeMountsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumeMounts | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mountPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.mountPath = this._mountPath;
    }
    if (this._mountPropagation !== undefined) {
      hasAnyValues = true;
      internalValueResult.mountPropagation = this._mountPropagation;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._readOnly !== undefined) {
      hasAnyValues = true;
      internalValueResult.readOnly = this._readOnly;
    }
    if (this._subPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.subPath = this._subPath;
    }
    if (this._subPathExpr !== undefined) {
      hasAnyValues = true;
      internalValueResult.subPathExpr = this._subPathExpr;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumeMounts | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._mountPath = undefined;
      this._mountPropagation = undefined;
      this._name = undefined;
      this._readOnly = undefined;
      this._subPath = undefined;
      this._subPathExpr = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._mountPath = value.mountPath;
      this._mountPropagation = value.mountPropagation;
      this._name = value.name;
      this._readOnly = value.readOnly;
      this._subPath = value.subPath;
      this._subPathExpr = value.subPathExpr;
    }
  }

  // mount_path - computed: false, optional: true, required: false
  private _mountPath?: string; 
  public get mountPath() {
    return this.getStringAttribute('mount_path');
  }
  public set mountPath(value: string) {
    this._mountPath = value;
  }
  public resetMountPath() {
    this._mountPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mountPathInput() {
    return this._mountPath;
  }

  // mount_propagation - computed: false, optional: true, required: false
  private _mountPropagation?: string; 
  public get mountPropagation() {
    return this.getStringAttribute('mount_propagation');
  }
  public set mountPropagation(value: string) {
    this._mountPropagation = value;
  }
  public resetMountPropagation() {
    this._mountPropagation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mountPropagationInput() {
    return this._mountPropagation;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // read_only - computed: false, optional: true, required: false
  private _readOnly?: boolean | cdktf.IResolvable; 
  public get readOnly() {
    return this.getBooleanAttribute('read_only');
  }
  public set readOnly(value: boolean | cdktf.IResolvable) {
    this._readOnly = value;
  }
  public resetReadOnly() {
    this._readOnly = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get readOnlyInput() {
    return this._readOnly;
  }

  // sub_path - computed: false, optional: true, required: false
  private _subPath?: string; 
  public get subPath() {
    return this.getStringAttribute('sub_path');
  }
  public set subPath(value: string) {
    this._subPath = value;
  }
  public resetSubPath() {
    this._subPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subPathInput() {
    return this._subPath;
  }

  // sub_path_expr - computed: false, optional: true, required: false
  private _subPathExpr?: string; 
  public get subPathExpr() {
    return this.getStringAttribute('sub_path_expr');
  }
  public set subPathExpr(value: string) {
    this._subPathExpr = value;
  }
  public resetSubPathExpr() {
    this._subPathExpr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subPathExprInput() {
    return this._subPathExpr;
  }
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumeMountsList extends cdktf.ComplexList {
  public internalValue? : DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumeMounts[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumeMountsOutputReference {
    return new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumeMountsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceAwsElasticBlockStore {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#fs_type DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#fs_type}
  */
  readonly fsType?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#partition DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#partition}
  */
  readonly partition?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#read_only DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#read_only}
  */
  readonly readOnly?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#volume_id DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#volume_id}
  */
  readonly volumeId?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceAwsElasticBlockStoreToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceAwsElasticBlockStore | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    fs_type: cdktf.stringToTerraform(struct!.fsType),
    partition: cdktf.numberToTerraform(struct!.partition),
    read_only: cdktf.booleanToTerraform(struct!.readOnly),
    volume_id: cdktf.stringToTerraform(struct!.volumeId),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceAwsElasticBlockStoreToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceAwsElasticBlockStore | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    fs_type: {
      value: cdktf.stringToHclTerraform(struct!.fsType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    partition: {
      value: cdktf.numberToHclTerraform(struct!.partition),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    read_only: {
      value: cdktf.booleanToHclTerraform(struct!.readOnly),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    volume_id: {
      value: cdktf.stringToHclTerraform(struct!.volumeId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceAwsElasticBlockStoreOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceAwsElasticBlockStore | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fsType !== undefined) {
      hasAnyValues = true;
      internalValueResult.fsType = this._fsType;
    }
    if (this._partition !== undefined) {
      hasAnyValues = true;
      internalValueResult.partition = this._partition;
    }
    if (this._readOnly !== undefined) {
      hasAnyValues = true;
      internalValueResult.readOnly = this._readOnly;
    }
    if (this._volumeId !== undefined) {
      hasAnyValues = true;
      internalValueResult.volumeId = this._volumeId;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceAwsElasticBlockStore | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fsType = undefined;
      this._partition = undefined;
      this._readOnly = undefined;
      this._volumeId = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fsType = value.fsType;
      this._partition = value.partition;
      this._readOnly = value.readOnly;
      this._volumeId = value.volumeId;
    }
  }

  // fs_type - computed: false, optional: true, required: false
  private _fsType?: string; 
  public get fsType() {
    return this.getStringAttribute('fs_type');
  }
  public set fsType(value: string) {
    this._fsType = value;
  }
  public resetFsType() {
    this._fsType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fsTypeInput() {
    return this._fsType;
  }

  // partition - computed: false, optional: true, required: false
  private _partition?: number; 
  public get partition() {
    return this.getNumberAttribute('partition');
  }
  public set partition(value: number) {
    this._partition = value;
  }
  public resetPartition() {
    this._partition = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get partitionInput() {
    return this._partition;
  }

  // read_only - computed: false, optional: true, required: false
  private _readOnly?: boolean | cdktf.IResolvable; 
  public get readOnly() {
    return this.getBooleanAttribute('read_only');
  }
  public set readOnly(value: boolean | cdktf.IResolvable) {
    this._readOnly = value;
  }
  public resetReadOnly() {
    this._readOnly = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get readOnlyInput() {
    return this._readOnly;
  }

  // volume_id - computed: false, optional: true, required: false
  private _volumeId?: string; 
  public get volumeId() {
    return this.getStringAttribute('volume_id');
  }
  public set volumeId(value: string) {
    this._volumeId = value;
  }
  public resetVolumeId() {
    this._volumeId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get volumeIdInput() {
    return this._volumeId;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceAzureDisk {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#caching_mode DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#caching_mode}
  */
  readonly cachingMode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#disk_name DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#disk_name}
  */
  readonly diskName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#disk_uri DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#disk_uri}
  */
  readonly diskUri?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#fs_type DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#fs_type}
  */
  readonly fsType?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#kind DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#kind}
  */
  readonly kind?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#read_only DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#read_only}
  */
  readonly readOnly?: boolean | cdktf.IResolvable;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceAzureDiskToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceAzureDisk | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    caching_mode: cdktf.stringToTerraform(struct!.cachingMode),
    disk_name: cdktf.stringToTerraform(struct!.diskName),
    disk_uri: cdktf.stringToTerraform(struct!.diskUri),
    fs_type: cdktf.stringToTerraform(struct!.fsType),
    kind: cdktf.stringToTerraform(struct!.kind),
    read_only: cdktf.booleanToTerraform(struct!.readOnly),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceAzureDiskToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceAzureDisk | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    caching_mode: {
      value: cdktf.stringToHclTerraform(struct!.cachingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disk_name: {
      value: cdktf.stringToHclTerraform(struct!.diskName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disk_uri: {
      value: cdktf.stringToHclTerraform(struct!.diskUri),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    fs_type: {
      value: cdktf.stringToHclTerraform(struct!.fsType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kind: {
      value: cdktf.stringToHclTerraform(struct!.kind),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    read_only: {
      value: cdktf.booleanToHclTerraform(struct!.readOnly),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceAzureDiskOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceAzureDisk | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cachingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.cachingMode = this._cachingMode;
    }
    if (this._diskName !== undefined) {
      hasAnyValues = true;
      internalValueResult.diskName = this._diskName;
    }
    if (this._diskUri !== undefined) {
      hasAnyValues = true;
      internalValueResult.diskUri = this._diskUri;
    }
    if (this._fsType !== undefined) {
      hasAnyValues = true;
      internalValueResult.fsType = this._fsType;
    }
    if (this._kind !== undefined) {
      hasAnyValues = true;
      internalValueResult.kind = this._kind;
    }
    if (this._readOnly !== undefined) {
      hasAnyValues = true;
      internalValueResult.readOnly = this._readOnly;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceAzureDisk | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cachingMode = undefined;
      this._diskName = undefined;
      this._diskUri = undefined;
      this._fsType = undefined;
      this._kind = undefined;
      this._readOnly = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cachingMode = value.cachingMode;
      this._diskName = value.diskName;
      this._diskUri = value.diskUri;
      this._fsType = value.fsType;
      this._kind = value.kind;
      this._readOnly = value.readOnly;
    }
  }

  // caching_mode - computed: false, optional: true, required: false
  private _cachingMode?: string; 
  public get cachingMode() {
    return this.getStringAttribute('caching_mode');
  }
  public set cachingMode(value: string) {
    this._cachingMode = value;
  }
  public resetCachingMode() {
    this._cachingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cachingModeInput() {
    return this._cachingMode;
  }

  // disk_name - computed: false, optional: true, required: false
  private _diskName?: string; 
  public get diskName() {
    return this.getStringAttribute('disk_name');
  }
  public set diskName(value: string) {
    this._diskName = value;
  }
  public resetDiskName() {
    this._diskName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get diskNameInput() {
    return this._diskName;
  }

  // disk_uri - computed: false, optional: true, required: false
  private _diskUri?: string; 
  public get diskUri() {
    return this.getStringAttribute('disk_uri');
  }
  public set diskUri(value: string) {
    this._diskUri = value;
  }
  public resetDiskUri() {
    this._diskUri = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get diskUriInput() {
    return this._diskUri;
  }

  // fs_type - computed: false, optional: true, required: false
  private _fsType?: string; 
  public get fsType() {
    return this.getStringAttribute('fs_type');
  }
  public set fsType(value: string) {
    this._fsType = value;
  }
  public resetFsType() {
    this._fsType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fsTypeInput() {
    return this._fsType;
  }

  // kind - computed: false, optional: true, required: false
  private _kind?: string; 
  public get kind() {
    return this.getStringAttribute('kind');
  }
  public set kind(value: string) {
    this._kind = value;
  }
  public resetKind() {
    this._kind = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kindInput() {
    return this._kind;
  }

  // read_only - computed: false, optional: true, required: false
  private _readOnly?: boolean | cdktf.IResolvable; 
  public get readOnly() {
    return this.getBooleanAttribute('read_only');
  }
  public set readOnly(value: boolean | cdktf.IResolvable) {
    this._readOnly = value;
  }
  public resetReadOnly() {
    this._readOnly = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get readOnlyInput() {
    return this._readOnly;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceAzureFile {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#read_only DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#read_only}
  */
  readonly readOnly?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#secret_name DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#secret_name}
  */
  readonly secretName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#share_name DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#share_name}
  */
  readonly shareName?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceAzureFileToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceAzureFile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    read_only: cdktf.booleanToTerraform(struct!.readOnly),
    secret_name: cdktf.stringToTerraform(struct!.secretName),
    share_name: cdktf.stringToTerraform(struct!.shareName),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceAzureFileToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceAzureFile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    read_only: {
      value: cdktf.booleanToHclTerraform(struct!.readOnly),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    secret_name: {
      value: cdktf.stringToHclTerraform(struct!.secretName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    share_name: {
      value: cdktf.stringToHclTerraform(struct!.shareName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceAzureFileOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceAzureFile | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._readOnly !== undefined) {
      hasAnyValues = true;
      internalValueResult.readOnly = this._readOnly;
    }
    if (this._secretName !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretName = this._secretName;
    }
    if (this._shareName !== undefined) {
      hasAnyValues = true;
      internalValueResult.shareName = this._shareName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceAzureFile | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._readOnly = undefined;
      this._secretName = undefined;
      this._shareName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._readOnly = value.readOnly;
      this._secretName = value.secretName;
      this._shareName = value.shareName;
    }
  }

  // read_only - computed: false, optional: true, required: false
  private _readOnly?: boolean | cdktf.IResolvable; 
  public get readOnly() {
    return this.getBooleanAttribute('read_only');
  }
  public set readOnly(value: boolean | cdktf.IResolvable) {
    this._readOnly = value;
  }
  public resetReadOnly() {
    this._readOnly = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get readOnlyInput() {
    return this._readOnly;
  }

  // secret_name - computed: false, optional: true, required: false
  private _secretName?: string; 
  public get secretName() {
    return this.getStringAttribute('secret_name');
  }
  public set secretName(value: string) {
    this._secretName = value;
  }
  public resetSecretName() {
    this._secretName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretNameInput() {
    return this._secretName;
  }

  // share_name - computed: false, optional: true, required: false
  private _shareName?: string; 
  public get shareName() {
    return this.getStringAttribute('share_name');
  }
  public set shareName(value: string) {
    this._shareName = value;
  }
  public resetShareName() {
    this._shareName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get shareNameInput() {
    return this._shareName;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceCephfsSecretRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#name DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#name}
  */
  readonly name?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceCephfsSecretRefToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceCephfsSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceCephfsSecretRefToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceCephfsSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceCephfsSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceCephfsSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceCephfsSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceCephfs {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#monitors DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#monitors}
  */
  readonly monitors?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#path DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#path}
  */
  readonly path?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#read_only DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#read_only}
  */
  readonly readOnly?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#secret_file DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#secret_file}
  */
  readonly secretFile?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#secret_ref DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceCephfsSecretRef;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#user DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#user}
  */
  readonly user?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceCephfsToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceCephfs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    monitors: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.monitors),
    path: cdktf.stringToTerraform(struct!.path),
    read_only: cdktf.booleanToTerraform(struct!.readOnly),
    secret_file: cdktf.stringToTerraform(struct!.secretFile),
    secret_ref: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceCephfsSecretRefToTerraform(struct!.secretRef),
    user: cdktf.stringToTerraform(struct!.user),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceCephfsToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceCephfs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    monitors: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.monitors),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    read_only: {
      value: cdktf.booleanToHclTerraform(struct!.readOnly),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    secret_file: {
      value: cdktf.stringToHclTerraform(struct!.secretFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_ref: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceCephfsSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceCephfsSecretRef",
    },
    user: {
      value: cdktf.stringToHclTerraform(struct!.user),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceCephfsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceCephfs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._monitors !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitors = this._monitors;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._readOnly !== undefined) {
      hasAnyValues = true;
      internalValueResult.readOnly = this._readOnly;
    }
    if (this._secretFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretFile = this._secretFile;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    if (this._user !== undefined) {
      hasAnyValues = true;
      internalValueResult.user = this._user;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceCephfs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._monitors = undefined;
      this._path = undefined;
      this._readOnly = undefined;
      this._secretFile = undefined;
      this._secretRef.internalValue = undefined;
      this._user = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._monitors = value.monitors;
      this._path = value.path;
      this._readOnly = value.readOnly;
      this._secretFile = value.secretFile;
      this._secretRef.internalValue = value.secretRef;
      this._user = value.user;
    }
  }

  // monitors - computed: false, optional: true, required: false
  private _monitors?: string[]; 
  public get monitors() {
    return this.getListAttribute('monitors');
  }
  public set monitors(value: string[]) {
    this._monitors = value;
  }
  public resetMonitors() {
    this._monitors = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitorsInput() {
    return this._monitors;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // read_only - computed: false, optional: true, required: false
  private _readOnly?: boolean | cdktf.IResolvable; 
  public get readOnly() {
    return this.getBooleanAttribute('read_only');
  }
  public set readOnly(value: boolean | cdktf.IResolvable) {
    this._readOnly = value;
  }
  public resetReadOnly() {
    this._readOnly = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get readOnlyInput() {
    return this._readOnly;
  }

  // secret_file - computed: false, optional: true, required: false
  private _secretFile?: string; 
  public get secretFile() {
    return this.getStringAttribute('secret_file');
  }
  public set secretFile(value: string) {
    this._secretFile = value;
  }
  public resetSecretFile() {
    this._secretFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretFileInput() {
    return this._secretFile;
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceCephfsSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceCephfsSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }

  // user - computed: false, optional: true, required: false
  private _user?: string; 
  public get user() {
    return this.getStringAttribute('user');
  }
  public set user(value: string) {
    this._user = value;
  }
  public resetUser() {
    this._user = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get userInput() {
    return this._user;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceCinderSecretRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#name DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#name}
  */
  readonly name?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceCinderSecretRefToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceCinderSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceCinderSecretRefToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceCinderSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceCinderSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceCinderSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceCinderSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceCinder {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#fs_type DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#fs_type}
  */
  readonly fsType?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#read_only DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#read_only}
  */
  readonly readOnly?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#secret_ref DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceCinderSecretRef;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#volume_id DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#volume_id}
  */
  readonly volumeId?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceCinderToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceCinder | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    fs_type: cdktf.stringToTerraform(struct!.fsType),
    read_only: cdktf.booleanToTerraform(struct!.readOnly),
    secret_ref: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceCinderSecretRefToTerraform(struct!.secretRef),
    volume_id: cdktf.stringToTerraform(struct!.volumeId),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceCinderToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceCinder | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    fs_type: {
      value: cdktf.stringToHclTerraform(struct!.fsType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    read_only: {
      value: cdktf.booleanToHclTerraform(struct!.readOnly),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    secret_ref: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceCinderSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceCinderSecretRef",
    },
    volume_id: {
      value: cdktf.stringToHclTerraform(struct!.volumeId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceCinderOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceCinder | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fsType !== undefined) {
      hasAnyValues = true;
      internalValueResult.fsType = this._fsType;
    }
    if (this._readOnly !== undefined) {
      hasAnyValues = true;
      internalValueResult.readOnly = this._readOnly;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    if (this._volumeId !== undefined) {
      hasAnyValues = true;
      internalValueResult.volumeId = this._volumeId;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceCinder | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fsType = undefined;
      this._readOnly = undefined;
      this._secretRef.internalValue = undefined;
      this._volumeId = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fsType = value.fsType;
      this._readOnly = value.readOnly;
      this._secretRef.internalValue = value.secretRef;
      this._volumeId = value.volumeId;
    }
  }

  // fs_type - computed: false, optional: true, required: false
  private _fsType?: string; 
  public get fsType() {
    return this.getStringAttribute('fs_type');
  }
  public set fsType(value: string) {
    this._fsType = value;
  }
  public resetFsType() {
    this._fsType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fsTypeInput() {
    return this._fsType;
  }

  // read_only - computed: false, optional: true, required: false
  private _readOnly?: boolean | cdktf.IResolvable; 
  public get readOnly() {
    return this.getBooleanAttribute('read_only');
  }
  public set readOnly(value: boolean | cdktf.IResolvable) {
    this._readOnly = value;
  }
  public resetReadOnly() {
    this._readOnly = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get readOnlyInput() {
    return this._readOnly;
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceCinderSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceCinderSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }

  // volume_id - computed: false, optional: true, required: false
  private _volumeId?: string; 
  public get volumeId() {
    return this.getStringAttribute('volume_id');
  }
  public set volumeId(value: string) {
    this._volumeId = value;
  }
  public resetVolumeId() {
    this._volumeId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get volumeIdInput() {
    return this._volumeId;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceConfigMapItems {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#key DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#mode DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#mode}
  */
  readonly mode?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#path DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#path}
  */
  readonly path?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceConfigMapItemsToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceConfigMapItems | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    mode: cdktf.numberToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceConfigMapItemsToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceConfigMapItems | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.numberToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceConfigMapItemsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceConfigMapItems | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceConfigMapItems | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: number; 
  public get mode() {
    return this.getNumberAttribute('mode');
  }
  public set mode(value: number) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceConfigMapItemsList extends cdktf.ComplexList {
  public internalValue? : DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceConfigMapItems[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceConfigMapItemsOutputReference {
    return new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceConfigMapItemsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceConfigMapLocalObjectReference {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#name DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#name}
  */
  readonly name?: string;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceConfigMapLocalObjectReferenceToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceConfigMapLocalObjectReference | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceConfigMapLocalObjectReferenceToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceConfigMapLocalObjectReference | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceConfigMapLocalObjectReferenceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceConfigMapLocalObjectReference | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceConfigMapLocalObjectReference | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceConfigMap {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#default_mode DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#default_mode}
  */
  readonly defaultMode?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#items DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#items}
  */
  readonly items?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceConfigMapItems[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#local_object_reference DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#local_object_reference}
  */
  readonly localObjectReference?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceConfigMapLocalObjectReference;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/servicemesh_cisco_com_istio_control_plane_v1alpha1_manifest#optional DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceConfigMapToTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceConfigMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    default_mode: cdktf.numberToTerraform(struct!.defaultMode),
    items: cdktf.listMapper(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceConfigMapItemsToTerraform, false)(struct!.items),
    local_object_reference: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceConfigMapLocalObjectReferenceToTerraform(struct!.localObjectReference),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceConfigMapToHclTerraform(struct?: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceConfigMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    default_mode: {
      value: cdktf.numberToHclTerraform(struct!.defaultMode),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    items: {
      value: cdktf.listMapperHcl(dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceConfigMapItemsToHclTerraform, false)(struct!.items),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceConfigMapItemsList",
    },
    local_object_reference: {
      value: dataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceConfigMapLocalObjectReferenceToHclTerraform(struct!.localObjectReference),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceConfigMapLocalObjectReference",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceConfigMapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceConfigMap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._defaultMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultMode = this._defaultMode;
    }
    if (this._items?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.items = this._items?.internalValue;
    }
    if (this._localObjectReference?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.localObjectReference = this._localObjectReference?.internalValue;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceConfigMap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._defaultMode = undefined;
      this._items.internalValue = undefined;
      this._localObjectReference.internalValue = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._defaultMode = value.defaultMode;
      this._items.internalValue = value.items;
      this._localObjectReference.internalValue = value.localObjectReference;
      this._optional = value.optional;
    }
  }

  // default_mode - computed: false, optional: true, required: false
  private _defaultMode?: number; 
  public get defaultMode() {
    return this.getNumberAttribute('default_mode');
  }
  public set defaultMode(value: number) {
    this._defaultMode = value;
  }
  public resetDefaultMode() {
    this._defaultMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultModeInput() {
    return this._defaultMode;
  }

  // items - computed: false, optional: true, required: false
  private _items = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceConfigMapItemsList(this, "items", false);
  public get items() {
    return this._items;
  }
  public putItems(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceConfigMapItems[] | cdktf.IResolvable) {
    this._items.internalValue = value;
  }
  public resetItems() {
    this._items.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get itemsInput() {
    return this._items.internalValue;
  }

  // local_object_reference - computed: false, optional: true, required: false
  private _localObjectReference = new DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceConfigMapLocalObjectReferenceOutputReference(this, "local_object_reference");
  public get localObjectReference() {
    return this._localObjectReference;
  }
  public putLocalObjectReference(value: DataK8SServicemeshCiscoComIstioControlPlaneV1Alpha1ManifestSpecMeshExpansionGatewayDeploymentVolumesVolumeSourceConfigMapLocalObjectReference) {
    this._localObjectReference.internalValue = value;
  }
  public resetLocalObjectReference() {
    this._localObjectReference.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localObjectReferenceInput() {
    return this._localObjectReference.internalValue;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
