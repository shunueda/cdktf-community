// https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestConfig extends cdktf.TerraformMetaArguments {
  /**
  * Data that helps uniquely identify this object. See https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#metadata DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#metadata}
  */
  readonly metadata: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestMetadata;
  /**
  * ResourceImportSpec defines the desired state of ResourceImport.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#spec DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#spec}
  */
  readonly spec?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpec;
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestMetadata {
  /**
  * Keys and values that can be used by external tooling to store and retrieve arbitrary metadata about this object. See https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/ for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#annotations DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Keys and values that can be used to organize and categorize objects. See https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/ for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#labels DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#labels}
  */
  readonly labels?: { [key: string]: string };
  /**
  * Unique identifier for this object. See https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#name DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#name}
  */
  readonly name: string;
  /**
  * Namespaces provides a mechanism for isolating groups of resources within a single cluster. See https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/ for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#namespace DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#namespace}
  */
  readonly namespace: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestMetadataToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestMetadataToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotations = undefined;
      this._labels = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotations = value.annotations;
      this._labels = value.labels;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: false, required: true
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusterinfoGatewayInfos {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#gateway_ip DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#gateway_ip}
  */
  readonly gatewayIp?: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusterinfoGatewayInfosToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusterinfoGatewayInfos | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    gateway_ip: cdktf.stringToTerraform(struct!.gatewayIp),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusterinfoGatewayInfosToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusterinfoGatewayInfos | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    gateway_ip: {
      value: cdktf.stringToHclTerraform(struct!.gatewayIp),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusterinfoGatewayInfosOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusterinfoGatewayInfos | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._gatewayIp !== undefined) {
      hasAnyValues = true;
      internalValueResult.gatewayIp = this._gatewayIp;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusterinfoGatewayInfos | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._gatewayIp = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._gatewayIp = value.gatewayIp;
    }
  }

  // gateway_ip - computed: false, optional: true, required: false
  private _gatewayIp?: string; 
  public get gatewayIp() {
    return this.getStringAttribute('gateway_ip');
  }
  public set gatewayIp(value: string) {
    this._gatewayIp = value;
  }
  public resetGatewayIp() {
    this._gatewayIp = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gatewayIpInput() {
    return this._gatewayIp;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusterinfoGatewayInfosList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusterinfoGatewayInfos[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusterinfoGatewayInfosOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusterinfoGatewayInfosOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusterinfoWireGuard {
  /**
  * Public key of the WireGuard tunnel.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#public_key DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#public_key}
  */
  readonly publicKey?: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusterinfoWireGuardToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusterinfoWireGuard | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    public_key: cdktf.stringToTerraform(struct!.publicKey),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusterinfoWireGuardToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusterinfoWireGuard | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    public_key: {
      value: cdktf.stringToHclTerraform(struct!.publicKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusterinfoWireGuardOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusterinfoWireGuard | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._publicKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.publicKey = this._publicKey;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusterinfoWireGuard | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._publicKey = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._publicKey = value.publicKey;
    }
  }

  // public_key - computed: false, optional: true, required: false
  private _publicKey?: string; 
  public get publicKey() {
    return this.getStringAttribute('public_key');
  }
  public set publicKey(value: string) {
    this._publicKey = value;
  }
  public resetPublicKey() {
    this._publicKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get publicKeyInput() {
    return this._publicKey;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusterinfo {
  /**
  * ClusterID of the member cluster.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#cluster_id DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#cluster_id}
  */
  readonly clusterId?: string;
  /**
  * GatewayInfos has information of Gateways
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#gateway_infos DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#gateway_infos}
  */
  readonly gatewayInfos?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusterinfoGatewayInfos[] | cdktf.IResolvable;
  /**
  * PodCIDRs is the Pod IP address CIDRs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#pod_cidrs DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#pod_cidrs}
  */
  readonly podCidrs?: string[];
  /**
  * ServiceCIDR is the IP ranges used by Service ClusterIP.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#service_cidr DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#service_cidr}
  */
  readonly serviceCidr?: string;
  /**
  * WireGuardInfo includes information of a WireGuard tunnel.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#wire_guard DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#wire_guard}
  */
  readonly wireGuard?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusterinfoWireGuard;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusterinfoToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusterinfo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cluster_id: cdktf.stringToTerraform(struct!.clusterId),
    gateway_infos: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusterinfoGatewayInfosToTerraform, false)(struct!.gatewayInfos),
    pod_cidrs: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.podCidrs),
    service_cidr: cdktf.stringToTerraform(struct!.serviceCidr),
    wire_guard: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusterinfoWireGuardToTerraform(struct!.wireGuard),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusterinfoToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusterinfo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.clusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    gateway_infos: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusterinfoGatewayInfosToHclTerraform, false)(struct!.gatewayInfos),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusterinfoGatewayInfosList",
    },
    pod_cidrs: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.podCidrs),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    service_cidr: {
      value: cdktf.stringToHclTerraform(struct!.serviceCidr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    wire_guard: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusterinfoWireGuardToHclTerraform(struct!.wireGuard),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusterinfoWireGuard",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusterinfoOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusterinfo | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterId = this._clusterId;
    }
    if (this._gatewayInfos?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.gatewayInfos = this._gatewayInfos?.internalValue;
    }
    if (this._podCidrs !== undefined) {
      hasAnyValues = true;
      internalValueResult.podCidrs = this._podCidrs;
    }
    if (this._serviceCidr !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceCidr = this._serviceCidr;
    }
    if (this._wireGuard?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.wireGuard = this._wireGuard?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusterinfo | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clusterId = undefined;
      this._gatewayInfos.internalValue = undefined;
      this._podCidrs = undefined;
      this._serviceCidr = undefined;
      this._wireGuard.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clusterId = value.clusterId;
      this._gatewayInfos.internalValue = value.gatewayInfos;
      this._podCidrs = value.podCidrs;
      this._serviceCidr = value.serviceCidr;
      this._wireGuard.internalValue = value.wireGuard;
    }
  }

  // cluster_id - computed: false, optional: true, required: false
  private _clusterId?: string; 
  public get clusterId() {
    return this.getStringAttribute('cluster_id');
  }
  public set clusterId(value: string) {
    this._clusterId = value;
  }
  public resetClusterId() {
    this._clusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterIdInput() {
    return this._clusterId;
  }

  // gateway_infos - computed: false, optional: true, required: false
  private _gatewayInfos = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusterinfoGatewayInfosList(this, "gateway_infos", false);
  public get gatewayInfos() {
    return this._gatewayInfos;
  }
  public putGatewayInfos(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusterinfoGatewayInfos[] | cdktf.IResolvable) {
    this._gatewayInfos.internalValue = value;
  }
  public resetGatewayInfos() {
    this._gatewayInfos.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gatewayInfosInput() {
    return this._gatewayInfos.internalValue;
  }

  // pod_cidrs - computed: false, optional: true, required: false
  private _podCidrs?: string[]; 
  public get podCidrs() {
    return this.getListAttribute('pod_cidrs');
  }
  public set podCidrs(value: string[]) {
    this._podCidrs = value;
  }
  public resetPodCidrs() {
    this._podCidrs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podCidrsInput() {
    return this._podCidrs;
  }

  // service_cidr - computed: false, optional: true, required: false
  private _serviceCidr?: string; 
  public get serviceCidr() {
    return this.getStringAttribute('service_cidr');
  }
  public set serviceCidr(value: string) {
    this._serviceCidr = value;
  }
  public resetServiceCidr() {
    this._serviceCidr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceCidrInput() {
    return this._serviceCidr;
  }

  // wire_guard - computed: false, optional: true, required: false
  private _wireGuard = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusterinfoWireGuardOutputReference(this, "wire_guard");
  public get wireGuard() {
    return this._wireGuard;
  }
  public putWireGuard(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusterinfoWireGuard) {
    this._wireGuard.internalValue = value;
  }
  public resetWireGuard() {
    this._wireGuard.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get wireGuardInput() {
    return this._wireGuard.internalValue;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToExternalEntitySelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#key DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#operator DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#values DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToExternalEntitySelectorMatchExpressionsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToExternalEntitySelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToExternalEntitySelectorMatchExpressionsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToExternalEntitySelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToExternalEntitySelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToExternalEntitySelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToExternalEntitySelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToExternalEntitySelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToExternalEntitySelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToExternalEntitySelectorMatchExpressionsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToExternalEntitySelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToExternalEntitySelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match_expressions DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToExternalEntitySelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match_labels DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToExternalEntitySelectorToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToExternalEntitySelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToExternalEntitySelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToExternalEntitySelectorToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToExternalEntitySelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToExternalEntitySelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToExternalEntitySelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToExternalEntitySelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToExternalEntitySelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToExternalEntitySelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToExternalEntitySelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToExternalEntitySelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNamespaceSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#key DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#operator DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#values DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNamespaceSelectorMatchExpressionsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNamespaceSelectorMatchExpressionsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNamespaceSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNamespaceSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNamespaceSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNamespaceSelectorMatchExpressionsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNamespaceSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNamespaceSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match_expressions DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNamespaceSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match_labels DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNamespaceSelectorToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNamespaceSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNamespaceSelectorToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNamespaceSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNamespaceSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNamespaceSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNamespaceSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNamespaceSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNamespaceSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNamespaceSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNodeSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#key DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#operator DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#values DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNodeSelectorMatchExpressionsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNodeSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNodeSelectorMatchExpressionsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNodeSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNodeSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNodeSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNodeSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNodeSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNodeSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNodeSelectorMatchExpressionsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNodeSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNodeSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match_expressions DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNodeSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match_labels DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNodeSelectorToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNodeSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNodeSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNodeSelectorToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNodeSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNodeSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNodeSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNodeSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNodeSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNodeSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNodeSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNodeSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToPodSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#key DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#operator DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#values DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToPodSelectorMatchExpressionsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToPodSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToPodSelectorMatchExpressionsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToPodSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToPodSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToPodSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToPodSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToPodSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToPodSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToPodSelectorMatchExpressionsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToPodSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToPodSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match_expressions DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToPodSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match_labels DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToPodSelectorToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToPodSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToPodSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToPodSelectorToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToPodSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToPodSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToPodSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToPodSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToPodSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToPodSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToPodSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToPodSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToService {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#name DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#namespace DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToServiceToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToServiceToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToServiceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToService | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToService | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToServiceAccount {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#name DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#namespace DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToServiceAccountToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToServiceAccount | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToServiceAccountToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToServiceAccount | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToServiceAccountOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToServiceAccount | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToServiceAccount | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedTo {
  /**
  * Select ExternalEntities from NetworkPolicy's Namespace as workloads in AppliedTo fields. If set with NamespaceSelector, ExternalEntities are matched from Namespaces matched by the NamespaceSelector. Cannot be set with any other selector except NamespaceSelector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#external_entity_selector DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#external_entity_selector}
  */
  readonly externalEntitySelector?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToExternalEntitySelector;
  /**
  * Group is the name of the ClusterGroup which can be set as an AppliedTo in place of a stand-alone selector. A Group cannot be set with any other selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#group DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#group}
  */
  readonly group?: string;
  /**
  * Select all Pods from Namespaces matched by this selector, as workloads in AppliedTo fields. If set with PodSelector, Pods are matched from Namespaces matched by the NamespaceSelector. Cannot be set with any other selector except PodSelector or ExternalEntitySelector. Cannot be set with Namespaces.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#namespace_selector DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#namespace_selector}
  */
  readonly namespaceSelector?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNamespaceSelector;
  /**
  * Select Nodes in cluster as workloads in AppliedTo fields. Cannot be set with any other selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#node_selector DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#node_selector}
  */
  readonly nodeSelector?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNodeSelector;
  /**
  * Select Pods from NetworkPolicy's Namespace as workloads in AppliedTo fields. If set with NamespaceSelector, Pods are matched from Namespaces matched by the NamespaceSelector. Cannot be set with any other selector except NamespaceSelector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#pod_selector DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#pod_selector}
  */
  readonly podSelector?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToPodSelector;
  /**
  * Select a certain Service which matches the NamespacedName. A Service can only be set in either policy level AppliedTo field in a policy that only has ingress rules or rule level AppliedTo field in an ingress rule. Only a NodePort Service can be referred by this field. Cannot be set with any other selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#service DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#service}
  */
  readonly service?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToService;
  /**
  * Select all Pods with the ServiceAccount matched by this field, as workloads in AppliedTo fields. Cannot be set with any other selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#service_account DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#service_account}
  */
  readonly serviceAccount?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToServiceAccount;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedTo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    external_entity_selector: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToExternalEntitySelectorToTerraform(struct!.externalEntitySelector),
    group: cdktf.stringToTerraform(struct!.group),
    namespace_selector: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNamespaceSelectorToTerraform(struct!.namespaceSelector),
    node_selector: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNodeSelectorToTerraform(struct!.nodeSelector),
    pod_selector: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToPodSelectorToTerraform(struct!.podSelector),
    service: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToServiceToTerraform(struct!.service),
    service_account: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToServiceAccountToTerraform(struct!.serviceAccount),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedTo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    external_entity_selector: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToExternalEntitySelectorToHclTerraform(struct!.externalEntitySelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToExternalEntitySelector",
    },
    group: {
      value: cdktf.stringToHclTerraform(struct!.group),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace_selector: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNamespaceSelectorToHclTerraform(struct!.namespaceSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNamespaceSelector",
    },
    node_selector: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNodeSelectorToHclTerraform(struct!.nodeSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNodeSelector",
    },
    pod_selector: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToPodSelectorToHclTerraform(struct!.podSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToPodSelector",
    },
    service: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToServiceToHclTerraform(struct!.service),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToService",
    },
    service_account: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToServiceAccountToHclTerraform(struct!.serviceAccount),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToServiceAccount",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedTo | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._externalEntitySelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.externalEntitySelector = this._externalEntitySelector?.internalValue;
    }
    if (this._group !== undefined) {
      hasAnyValues = true;
      internalValueResult.group = this._group;
    }
    if (this._namespaceSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaceSelector = this._namespaceSelector?.internalValue;
    }
    if (this._nodeSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeSelector = this._nodeSelector?.internalValue;
    }
    if (this._podSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.podSelector = this._podSelector?.internalValue;
    }
    if (this._service?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.service = this._service?.internalValue;
    }
    if (this._serviceAccount?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccount = this._serviceAccount?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedTo | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._externalEntitySelector.internalValue = undefined;
      this._group = undefined;
      this._namespaceSelector.internalValue = undefined;
      this._nodeSelector.internalValue = undefined;
      this._podSelector.internalValue = undefined;
      this._service.internalValue = undefined;
      this._serviceAccount.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._externalEntitySelector.internalValue = value.externalEntitySelector;
      this._group = value.group;
      this._namespaceSelector.internalValue = value.namespaceSelector;
      this._nodeSelector.internalValue = value.nodeSelector;
      this._podSelector.internalValue = value.podSelector;
      this._service.internalValue = value.service;
      this._serviceAccount.internalValue = value.serviceAccount;
    }
  }

  // external_entity_selector - computed: false, optional: true, required: false
  private _externalEntitySelector = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToExternalEntitySelectorOutputReference(this, "external_entity_selector");
  public get externalEntitySelector() {
    return this._externalEntitySelector;
  }
  public putExternalEntitySelector(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToExternalEntitySelector) {
    this._externalEntitySelector.internalValue = value;
  }
  public resetExternalEntitySelector() {
    this._externalEntitySelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get externalEntitySelectorInput() {
    return this._externalEntitySelector.internalValue;
  }

  // group - computed: false, optional: true, required: false
  private _group?: string; 
  public get group() {
    return this.getStringAttribute('group');
  }
  public set group(value: string) {
    this._group = value;
  }
  public resetGroup() {
    this._group = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupInput() {
    return this._group;
  }

  // namespace_selector - computed: false, optional: true, required: false
  private _namespaceSelector = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNamespaceSelectorOutputReference(this, "namespace_selector");
  public get namespaceSelector() {
    return this._namespaceSelector;
  }
  public putNamespaceSelector(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNamespaceSelector) {
    this._namespaceSelector.internalValue = value;
  }
  public resetNamespaceSelector() {
    this._namespaceSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceSelectorInput() {
    return this._namespaceSelector.internalValue;
  }

  // node_selector - computed: false, optional: true, required: false
  private _nodeSelector = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNodeSelectorOutputReference(this, "node_selector");
  public get nodeSelector() {
    return this._nodeSelector;
  }
  public putNodeSelector(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToNodeSelector) {
    this._nodeSelector.internalValue = value;
  }
  public resetNodeSelector() {
    this._nodeSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeSelectorInput() {
    return this._nodeSelector.internalValue;
  }

  // pod_selector - computed: false, optional: true, required: false
  private _podSelector = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToPodSelectorOutputReference(this, "pod_selector");
  public get podSelector() {
    return this._podSelector;
  }
  public putPodSelector(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToPodSelector) {
    this._podSelector.internalValue = value;
  }
  public resetPodSelector() {
    this._podSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podSelectorInput() {
    return this._podSelector.internalValue;
  }

  // service - computed: false, optional: true, required: false
  private _service = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToServiceOutputReference(this, "service");
  public get service() {
    return this._service;
  }
  public putService(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToService) {
    this._service.internalValue = value;
  }
  public resetService() {
    this._service.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceInput() {
    return this._service.internalValue;
  }

  // service_account - computed: false, optional: true, required: false
  private _serviceAccount = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToServiceAccountOutputReference(this, "service_account");
  public get serviceAccount() {
    return this._serviceAccount;
  }
  public putServiceAccount(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToServiceAccount) {
    this._serviceAccount.internalValue = value;
  }
  public resetServiceAccount() {
    this._serviceAccount.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountInput() {
    return this._serviceAccount.internalValue;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedTo[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToExternalEntitySelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#key DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#operator DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#values DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToExternalEntitySelectorMatchExpressionsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToExternalEntitySelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToExternalEntitySelectorMatchExpressionsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToExternalEntitySelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToExternalEntitySelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToExternalEntitySelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToExternalEntitySelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToExternalEntitySelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToExternalEntitySelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToExternalEntitySelectorMatchExpressionsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToExternalEntitySelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToExternalEntitySelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match_expressions DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToExternalEntitySelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match_labels DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToExternalEntitySelectorToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToExternalEntitySelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToExternalEntitySelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToExternalEntitySelectorToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToExternalEntitySelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToExternalEntitySelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToExternalEntitySelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToExternalEntitySelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToExternalEntitySelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToExternalEntitySelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToExternalEntitySelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToExternalEntitySelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNamespaceSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#key DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#operator DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#values DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNamespaceSelectorMatchExpressionsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNamespaceSelectorMatchExpressionsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNamespaceSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNamespaceSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNamespaceSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNamespaceSelectorMatchExpressionsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNamespaceSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNamespaceSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match_expressions DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNamespaceSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match_labels DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNamespaceSelectorToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNamespaceSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNamespaceSelectorToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNamespaceSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNamespaceSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNamespaceSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNamespaceSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNamespaceSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNamespaceSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNamespaceSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNodeSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#key DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#operator DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#values DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNodeSelectorMatchExpressionsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNodeSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNodeSelectorMatchExpressionsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNodeSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNodeSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNodeSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNodeSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNodeSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNodeSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNodeSelectorMatchExpressionsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNodeSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNodeSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match_expressions DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNodeSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match_labels DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNodeSelectorToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNodeSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNodeSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNodeSelectorToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNodeSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNodeSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNodeSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNodeSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNodeSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNodeSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNodeSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNodeSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToPodSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#key DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#operator DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#values DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToPodSelectorMatchExpressionsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToPodSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToPodSelectorMatchExpressionsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToPodSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToPodSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToPodSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToPodSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToPodSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToPodSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToPodSelectorMatchExpressionsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToPodSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToPodSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match_expressions DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToPodSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match_labels DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToPodSelectorToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToPodSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToPodSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToPodSelectorToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToPodSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToPodSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToPodSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToPodSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToPodSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToPodSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToPodSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToPodSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToService {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#name DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#namespace DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToServiceToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToServiceToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToServiceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToService | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToService | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToServiceAccount {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#name DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#namespace DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToServiceAccountToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToServiceAccount | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToServiceAccountToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToServiceAccount | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToServiceAccountOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToServiceAccount | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToServiceAccount | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedTo {
  /**
  * Select ExternalEntities from NetworkPolicy's Namespace as workloads in AppliedTo fields. If set with NamespaceSelector, ExternalEntities are matched from Namespaces matched by the NamespaceSelector. Cannot be set with any other selector except NamespaceSelector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#external_entity_selector DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#external_entity_selector}
  */
  readonly externalEntitySelector?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToExternalEntitySelector;
  /**
  * Group is the name of the ClusterGroup which can be set as an AppliedTo in place of a stand-alone selector. A Group cannot be set with any other selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#group DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#group}
  */
  readonly group?: string;
  /**
  * Select all Pods from Namespaces matched by this selector, as workloads in AppliedTo fields. If set with PodSelector, Pods are matched from Namespaces matched by the NamespaceSelector. Cannot be set with any other selector except PodSelector or ExternalEntitySelector. Cannot be set with Namespaces.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#namespace_selector DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#namespace_selector}
  */
  readonly namespaceSelector?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNamespaceSelector;
  /**
  * Select Nodes in cluster as workloads in AppliedTo fields. Cannot be set with any other selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#node_selector DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#node_selector}
  */
  readonly nodeSelector?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNodeSelector;
  /**
  * Select Pods from NetworkPolicy's Namespace as workloads in AppliedTo fields. If set with NamespaceSelector, Pods are matched from Namespaces matched by the NamespaceSelector. Cannot be set with any other selector except NamespaceSelector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#pod_selector DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#pod_selector}
  */
  readonly podSelector?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToPodSelector;
  /**
  * Select a certain Service which matches the NamespacedName. A Service can only be set in either policy level AppliedTo field in a policy that only has ingress rules or rule level AppliedTo field in an ingress rule. Only a NodePort Service can be referred by this field. Cannot be set with any other selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#service DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#service}
  */
  readonly service?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToService;
  /**
  * Select all Pods with the ServiceAccount matched by this field, as workloads in AppliedTo fields. Cannot be set with any other selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#service_account DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#service_account}
  */
  readonly serviceAccount?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToServiceAccount;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedTo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    external_entity_selector: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToExternalEntitySelectorToTerraform(struct!.externalEntitySelector),
    group: cdktf.stringToTerraform(struct!.group),
    namespace_selector: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNamespaceSelectorToTerraform(struct!.namespaceSelector),
    node_selector: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNodeSelectorToTerraform(struct!.nodeSelector),
    pod_selector: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToPodSelectorToTerraform(struct!.podSelector),
    service: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToServiceToTerraform(struct!.service),
    service_account: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToServiceAccountToTerraform(struct!.serviceAccount),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedTo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    external_entity_selector: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToExternalEntitySelectorToHclTerraform(struct!.externalEntitySelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToExternalEntitySelector",
    },
    group: {
      value: cdktf.stringToHclTerraform(struct!.group),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace_selector: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNamespaceSelectorToHclTerraform(struct!.namespaceSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNamespaceSelector",
    },
    node_selector: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNodeSelectorToHclTerraform(struct!.nodeSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNodeSelector",
    },
    pod_selector: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToPodSelectorToHclTerraform(struct!.podSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToPodSelector",
    },
    service: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToServiceToHclTerraform(struct!.service),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToService",
    },
    service_account: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToServiceAccountToHclTerraform(struct!.serviceAccount),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToServiceAccount",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedTo | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._externalEntitySelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.externalEntitySelector = this._externalEntitySelector?.internalValue;
    }
    if (this._group !== undefined) {
      hasAnyValues = true;
      internalValueResult.group = this._group;
    }
    if (this._namespaceSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaceSelector = this._namespaceSelector?.internalValue;
    }
    if (this._nodeSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeSelector = this._nodeSelector?.internalValue;
    }
    if (this._podSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.podSelector = this._podSelector?.internalValue;
    }
    if (this._service?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.service = this._service?.internalValue;
    }
    if (this._serviceAccount?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccount = this._serviceAccount?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedTo | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._externalEntitySelector.internalValue = undefined;
      this._group = undefined;
      this._namespaceSelector.internalValue = undefined;
      this._nodeSelector.internalValue = undefined;
      this._podSelector.internalValue = undefined;
      this._service.internalValue = undefined;
      this._serviceAccount.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._externalEntitySelector.internalValue = value.externalEntitySelector;
      this._group = value.group;
      this._namespaceSelector.internalValue = value.namespaceSelector;
      this._nodeSelector.internalValue = value.nodeSelector;
      this._podSelector.internalValue = value.podSelector;
      this._service.internalValue = value.service;
      this._serviceAccount.internalValue = value.serviceAccount;
    }
  }

  // external_entity_selector - computed: false, optional: true, required: false
  private _externalEntitySelector = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToExternalEntitySelectorOutputReference(this, "external_entity_selector");
  public get externalEntitySelector() {
    return this._externalEntitySelector;
  }
  public putExternalEntitySelector(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToExternalEntitySelector) {
    this._externalEntitySelector.internalValue = value;
  }
  public resetExternalEntitySelector() {
    this._externalEntitySelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get externalEntitySelectorInput() {
    return this._externalEntitySelector.internalValue;
  }

  // group - computed: false, optional: true, required: false
  private _group?: string; 
  public get group() {
    return this.getStringAttribute('group');
  }
  public set group(value: string) {
    this._group = value;
  }
  public resetGroup() {
    this._group = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupInput() {
    return this._group;
  }

  // namespace_selector - computed: false, optional: true, required: false
  private _namespaceSelector = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNamespaceSelectorOutputReference(this, "namespace_selector");
  public get namespaceSelector() {
    return this._namespaceSelector;
  }
  public putNamespaceSelector(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNamespaceSelector) {
    this._namespaceSelector.internalValue = value;
  }
  public resetNamespaceSelector() {
    this._namespaceSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceSelectorInput() {
    return this._namespaceSelector.internalValue;
  }

  // node_selector - computed: false, optional: true, required: false
  private _nodeSelector = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNodeSelectorOutputReference(this, "node_selector");
  public get nodeSelector() {
    return this._nodeSelector;
  }
  public putNodeSelector(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToNodeSelector) {
    this._nodeSelector.internalValue = value;
  }
  public resetNodeSelector() {
    this._nodeSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeSelectorInput() {
    return this._nodeSelector.internalValue;
  }

  // pod_selector - computed: false, optional: true, required: false
  private _podSelector = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToPodSelectorOutputReference(this, "pod_selector");
  public get podSelector() {
    return this._podSelector;
  }
  public putPodSelector(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToPodSelector) {
    this._podSelector.internalValue = value;
  }
  public resetPodSelector() {
    this._podSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podSelectorInput() {
    return this._podSelector.internalValue;
  }

  // service - computed: false, optional: true, required: false
  private _service = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToServiceOutputReference(this, "service");
  public get service() {
    return this._service;
  }
  public putService(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToService) {
    this._service.internalValue = value;
  }
  public resetService() {
    this._service.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceInput() {
    return this._service.internalValue;
  }

  // service_account - computed: false, optional: true, required: false
  private _serviceAccount = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToServiceAccountOutputReference(this, "service_account");
  public get serviceAccount() {
    return this._serviceAccount;
  }
  public putServiceAccount(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToServiceAccount) {
    this._serviceAccount.internalValue = value;
  }
  public resetServiceAccount() {
    this._serviceAccount.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountInput() {
    return this._serviceAccount.internalValue;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedTo[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromExternalEntitySelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#key DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#operator DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#values DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromExternalEntitySelectorMatchExpressionsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromExternalEntitySelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromExternalEntitySelectorMatchExpressionsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromExternalEntitySelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromExternalEntitySelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromExternalEntitySelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromExternalEntitySelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromExternalEntitySelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromExternalEntitySelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromExternalEntitySelectorMatchExpressionsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromExternalEntitySelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromExternalEntitySelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match_expressions DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromExternalEntitySelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match_labels DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromExternalEntitySelectorToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromExternalEntitySelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromExternalEntitySelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromExternalEntitySelectorToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromExternalEntitySelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromExternalEntitySelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromExternalEntitySelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromExternalEntitySelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromExternalEntitySelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromExternalEntitySelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromExternalEntitySelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromExternalEntitySelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromIpBlock {
  /**
  * CIDR is a string representing the IP Block Valid examples are '192.168.1.0/24'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#cidr DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#cidr}
  */
  readonly cidr: string;
  /**
  * except is a slice of CIDRs that should not be included within an IPBlock Valid examples are '192.168.1.0/28' or '2001:db8::/64' Except values will be rejected if they are outside the cidr range
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#except DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#except}
  */
  readonly except?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromIpBlockToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromIpBlock | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cidr: cdktf.stringToTerraform(struct!.cidr),
    except: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.except),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromIpBlockToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromIpBlock | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cidr: {
      value: cdktf.stringToHclTerraform(struct!.cidr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    except: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.except),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromIpBlockOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromIpBlock | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cidr !== undefined) {
      hasAnyValues = true;
      internalValueResult.cidr = this._cidr;
    }
    if (this._except !== undefined) {
      hasAnyValues = true;
      internalValueResult.except = this._except;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromIpBlock | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cidr = undefined;
      this._except = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cidr = value.cidr;
      this._except = value.except;
    }
  }

  // cidr - computed: false, optional: false, required: true
  private _cidr?: string; 
  public get cidr() {
    return this.getStringAttribute('cidr');
  }
  public set cidr(value: string) {
    this._cidr = value;
  }
  // Temporarily expose input value. Use with caution.
  public get cidrInput() {
    return this._cidr;
  }

  // except - computed: false, optional: true, required: false
  private _except?: string[]; 
  public get except() {
    return this.getListAttribute('except');
  }
  public set except(value: string[]) {
    this._except = value;
  }
  public resetExcept() {
    this._except = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exceptInput() {
    return this._except;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNamespaceSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#key DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#operator DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#values DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNamespaceSelectorMatchExpressionsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNamespaceSelectorMatchExpressionsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNamespaceSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNamespaceSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNamespaceSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNamespaceSelectorMatchExpressionsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNamespaceSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNamespaceSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match_expressions DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNamespaceSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match_labels DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNamespaceSelectorToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNamespaceSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNamespaceSelectorToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNamespaceSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNamespaceSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNamespaceSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNamespaceSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNamespaceSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNamespaceSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNamespaceSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNamespaces {
  /**
  * Selects from the same Namespace of the appliedTo workloads.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match}
  */
  readonly match?: string;
  /**
  * Selects Namespaces that share the same values for the given set of label keys with the appliedTo Namespace. Namespaces must have all the label keys.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#same_labels DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#same_labels}
  */
  readonly sameLabels?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNamespacesToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNamespaces | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match: cdktf.stringToTerraform(struct!.match),
    same_labels: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.sameLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNamespacesToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNamespaces | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match: {
      value: cdktf.stringToHclTerraform(struct!.match),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    same_labels: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.sameLabels),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNamespacesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNamespaces | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._match !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match;
    }
    if (this._sameLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.sameLabels = this._sameLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNamespaces | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._match = undefined;
      this._sameLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._match = value.match;
      this._sameLabels = value.sameLabels;
    }
  }

  // match - computed: false, optional: true, required: false
  private _match?: string; 
  public get match() {
    return this.getStringAttribute('match');
  }
  public set match(value: string) {
    this._match = value;
  }
  public resetMatch() {
    this._match = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match;
  }

  // same_labels - computed: false, optional: true, required: false
  private _sameLabels?: string[]; 
  public get sameLabels() {
    return this.getListAttribute('same_labels');
  }
  public set sameLabels(value: string[]) {
    this._sameLabels = value;
  }
  public resetSameLabels() {
    this._sameLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sameLabelsInput() {
    return this._sameLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNodeSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#key DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#operator DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#values DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNodeSelectorMatchExpressionsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNodeSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNodeSelectorMatchExpressionsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNodeSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNodeSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNodeSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNodeSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNodeSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNodeSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNodeSelectorMatchExpressionsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNodeSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNodeSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match_expressions DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNodeSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match_labels DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNodeSelectorToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNodeSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNodeSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNodeSelectorToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNodeSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNodeSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNodeSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNodeSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNodeSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNodeSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNodeSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNodeSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromPodSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#key DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#operator DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#values DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromPodSelectorMatchExpressionsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromPodSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromPodSelectorMatchExpressionsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromPodSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromPodSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromPodSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromPodSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromPodSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromPodSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromPodSelectorMatchExpressionsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromPodSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromPodSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match_expressions DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromPodSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match_labels DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromPodSelectorToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromPodSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromPodSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromPodSelectorToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromPodSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromPodSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromPodSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromPodSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromPodSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromPodSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromPodSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromPodSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromServiceAccount {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#name DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#namespace DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromServiceAccountToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromServiceAccount | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromServiceAccountToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromServiceAccount | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromServiceAccountOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromServiceAccount | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromServiceAccount | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFrom {
  /**
  * Select ExternalEntities from NetworkPolicy's Namespace as workloads in To/From fields. If set with NamespaceSelector, ExternalEntities are matched from Namespaces matched by the NamespaceSelector. Cannot be set with any other selector except NamespaceSelector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#external_entity_selector DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#external_entity_selector}
  */
  readonly externalEntitySelector?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromExternalEntitySelector;
  /**
  * Restrict egress access to the Fully Qualified Domain Names prescribed by name or by wildcard match patterns. This field can only be set for NetworkPolicyPeer of egress rules. Supported formats are: Exact FQDNs such as 'google.com'. Wildcard expressions such as '*wayfair.com'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#fqdn DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#fqdn}
  */
  readonly fqdn?: string;
  /**
  * Group is the name of the ClusterGroup which can be set within an Ingress or Egress rule in place of a stand-alone selector. A Group cannot be set with any other selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#group DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#group}
  */
  readonly group?: string;
  /**
  * IPBlock describes the IPAddresses/IPBlocks that is matched in to/from. IPBlock cannot be set as part of the AppliedTo field. Cannot be set with any other selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#ip_block DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#ip_block}
  */
  readonly ipBlock?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromIpBlock;
  /**
  * Select all Pods from Namespaces matched by this selector, as workloads in To/From fields. If set with PodSelector, Pods are matched from Namespaces matched by the NamespaceSelector. Cannot be set with any other selector except PodSelector or ExternalEntitySelector. Cannot be set with Namespaces.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#namespace_selector DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#namespace_selector}
  */
  readonly namespaceSelector?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNamespaceSelector;
  /**
  * Select Pod/ExternalEntity from Namespaces matched by specific criteria. Current supported criteria is match: Self, which selects from the same Namespace of the appliedTo workloads. Cannot be set with any other selector except PodSelector or ExternalEntitySelector. This field can only be set when NetworkPolicyPeer is created for ClusterNetworkPolicy ingress/egress rules. Cannot be set with NamespaceSelector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#namespaces DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#namespaces}
  */
  readonly namespaces?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNamespaces;
  /**
  * Select certain Nodes which match the label selector. A NodeSelector cannot be set with any other selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#node_selector DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#node_selector}
  */
  readonly nodeSelector?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNodeSelector;
  /**
  * Select Pods from NetworkPolicy's Namespace as workloads in To/From fields. If set with NamespaceSelector, Pods are matched from Namespaces matched by the NamespaceSelector. Cannot be set with any other selector except NamespaceSelector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#pod_selector DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#pod_selector}
  */
  readonly podSelector?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromPodSelector;
  /**
  * Define scope of the Pod/NamespaceSelector(s) of this peer. Can only be used in ingress NetworkPolicyPeers. Defaults to 'Cluster'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#scope DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#scope}
  */
  readonly scope?: string;
  /**
  * Select all Pods with the ServiceAccount matched by this field, as workloads in To/From fields. Cannot be set with any other selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#service_account DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#service_account}
  */
  readonly serviceAccount?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromServiceAccount;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    external_entity_selector: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromExternalEntitySelectorToTerraform(struct!.externalEntitySelector),
    fqdn: cdktf.stringToTerraform(struct!.fqdn),
    group: cdktf.stringToTerraform(struct!.group),
    ip_block: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromIpBlockToTerraform(struct!.ipBlock),
    namespace_selector: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNamespaceSelectorToTerraform(struct!.namespaceSelector),
    namespaces: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNamespacesToTerraform(struct!.namespaces),
    node_selector: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNodeSelectorToTerraform(struct!.nodeSelector),
    pod_selector: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromPodSelectorToTerraform(struct!.podSelector),
    scope: cdktf.stringToTerraform(struct!.scope),
    service_account: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromServiceAccountToTerraform(struct!.serviceAccount),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    external_entity_selector: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromExternalEntitySelectorToHclTerraform(struct!.externalEntitySelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromExternalEntitySelector",
    },
    fqdn: {
      value: cdktf.stringToHclTerraform(struct!.fqdn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    group: {
      value: cdktf.stringToHclTerraform(struct!.group),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_block: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromIpBlockToHclTerraform(struct!.ipBlock),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromIpBlock",
    },
    namespace_selector: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNamespaceSelectorToHclTerraform(struct!.namespaceSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNamespaceSelector",
    },
    namespaces: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNamespacesToHclTerraform(struct!.namespaces),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNamespaces",
    },
    node_selector: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNodeSelectorToHclTerraform(struct!.nodeSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNodeSelector",
    },
    pod_selector: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromPodSelectorToHclTerraform(struct!.podSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromPodSelector",
    },
    scope: {
      value: cdktf.stringToHclTerraform(struct!.scope),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    service_account: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromServiceAccountToHclTerraform(struct!.serviceAccount),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromServiceAccount",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._externalEntitySelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.externalEntitySelector = this._externalEntitySelector?.internalValue;
    }
    if (this._fqdn !== undefined) {
      hasAnyValues = true;
      internalValueResult.fqdn = this._fqdn;
    }
    if (this._group !== undefined) {
      hasAnyValues = true;
      internalValueResult.group = this._group;
    }
    if (this._ipBlock?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipBlock = this._ipBlock?.internalValue;
    }
    if (this._namespaceSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaceSelector = this._namespaceSelector?.internalValue;
    }
    if (this._namespaces?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaces = this._namespaces?.internalValue;
    }
    if (this._nodeSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeSelector = this._nodeSelector?.internalValue;
    }
    if (this._podSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.podSelector = this._podSelector?.internalValue;
    }
    if (this._scope !== undefined) {
      hasAnyValues = true;
      internalValueResult.scope = this._scope;
    }
    if (this._serviceAccount?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccount = this._serviceAccount?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._externalEntitySelector.internalValue = undefined;
      this._fqdn = undefined;
      this._group = undefined;
      this._ipBlock.internalValue = undefined;
      this._namespaceSelector.internalValue = undefined;
      this._namespaces.internalValue = undefined;
      this._nodeSelector.internalValue = undefined;
      this._podSelector.internalValue = undefined;
      this._scope = undefined;
      this._serviceAccount.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._externalEntitySelector.internalValue = value.externalEntitySelector;
      this._fqdn = value.fqdn;
      this._group = value.group;
      this._ipBlock.internalValue = value.ipBlock;
      this._namespaceSelector.internalValue = value.namespaceSelector;
      this._namespaces.internalValue = value.namespaces;
      this._nodeSelector.internalValue = value.nodeSelector;
      this._podSelector.internalValue = value.podSelector;
      this._scope = value.scope;
      this._serviceAccount.internalValue = value.serviceAccount;
    }
  }

  // external_entity_selector - computed: false, optional: true, required: false
  private _externalEntitySelector = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromExternalEntitySelectorOutputReference(this, "external_entity_selector");
  public get externalEntitySelector() {
    return this._externalEntitySelector;
  }
  public putExternalEntitySelector(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromExternalEntitySelector) {
    this._externalEntitySelector.internalValue = value;
  }
  public resetExternalEntitySelector() {
    this._externalEntitySelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get externalEntitySelectorInput() {
    return this._externalEntitySelector.internalValue;
  }

  // fqdn - computed: false, optional: true, required: false
  private _fqdn?: string; 
  public get fqdn() {
    return this.getStringAttribute('fqdn');
  }
  public set fqdn(value: string) {
    this._fqdn = value;
  }
  public resetFqdn() {
    this._fqdn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fqdnInput() {
    return this._fqdn;
  }

  // group - computed: false, optional: true, required: false
  private _group?: string; 
  public get group() {
    return this.getStringAttribute('group');
  }
  public set group(value: string) {
    this._group = value;
  }
  public resetGroup() {
    this._group = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupInput() {
    return this._group;
  }

  // ip_block - computed: false, optional: true, required: false
  private _ipBlock = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromIpBlockOutputReference(this, "ip_block");
  public get ipBlock() {
    return this._ipBlock;
  }
  public putIpBlock(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromIpBlock) {
    this._ipBlock.internalValue = value;
  }
  public resetIpBlock() {
    this._ipBlock.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipBlockInput() {
    return this._ipBlock.internalValue;
  }

  // namespace_selector - computed: false, optional: true, required: false
  private _namespaceSelector = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNamespaceSelectorOutputReference(this, "namespace_selector");
  public get namespaceSelector() {
    return this._namespaceSelector;
  }
  public putNamespaceSelector(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNamespaceSelector) {
    this._namespaceSelector.internalValue = value;
  }
  public resetNamespaceSelector() {
    this._namespaceSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceSelectorInput() {
    return this._namespaceSelector.internalValue;
  }

  // namespaces - computed: false, optional: true, required: false
  private _namespaces = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNamespacesOutputReference(this, "namespaces");
  public get namespaces() {
    return this._namespaces;
  }
  public putNamespaces(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNamespaces) {
    this._namespaces.internalValue = value;
  }
  public resetNamespaces() {
    this._namespaces.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespacesInput() {
    return this._namespaces.internalValue;
  }

  // node_selector - computed: false, optional: true, required: false
  private _nodeSelector = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNodeSelectorOutputReference(this, "node_selector");
  public get nodeSelector() {
    return this._nodeSelector;
  }
  public putNodeSelector(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromNodeSelector) {
    this._nodeSelector.internalValue = value;
  }
  public resetNodeSelector() {
    this._nodeSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeSelectorInput() {
    return this._nodeSelector.internalValue;
  }

  // pod_selector - computed: false, optional: true, required: false
  private _podSelector = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromPodSelectorOutputReference(this, "pod_selector");
  public get podSelector() {
    return this._podSelector;
  }
  public putPodSelector(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromPodSelector) {
    this._podSelector.internalValue = value;
  }
  public resetPodSelector() {
    this._podSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podSelectorInput() {
    return this._podSelector.internalValue;
  }

  // scope - computed: false, optional: true, required: false
  private _scope?: string; 
  public get scope() {
    return this.getStringAttribute('scope');
  }
  public set scope(value: string) {
    this._scope = value;
  }
  public resetScope() {
    this._scope = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scopeInput() {
    return this._scope;
  }

  // service_account - computed: false, optional: true, required: false
  private _serviceAccount = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromServiceAccountOutputReference(this, "service_account");
  public get serviceAccount() {
    return this._serviceAccount;
  }
  public putServiceAccount(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromServiceAccount) {
    this._serviceAccount.internalValue = value;
  }
  public resetServiceAccount() {
    this._serviceAccount.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountInput() {
    return this._serviceAccount.internalValue;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFrom[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressL7ProtocolsHttp {
  /**
  * Host represents the hostname present in the URI or the HTTP Host header to match. It does not contain the port associated with the host.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#host DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#host}
  */
  readonly host?: string;
  /**
  * Method represents the HTTP method to match. It could be GET, POST, PUT, HEAD, DELETE, TRACE, OPTIONS, CONNECT and PATCH.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#method DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#method}
  */
  readonly method?: string;
  /**
  * Path represents the URI path to match (Ex. '/index.html', '/admin').
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#path DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#path}
  */
  readonly path?: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressL7ProtocolsHttpToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressL7ProtocolsHttp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    host: cdktf.stringToTerraform(struct!.host),
    method: cdktf.stringToTerraform(struct!.method),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressL7ProtocolsHttpToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressL7ProtocolsHttp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    method: {
      value: cdktf.stringToHclTerraform(struct!.method),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressL7ProtocolsHttpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressL7ProtocolsHttp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._method !== undefined) {
      hasAnyValues = true;
      internalValueResult.method = this._method;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressL7ProtocolsHttp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._host = undefined;
      this._method = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._host = value.host;
      this._method = value.method;
      this._path = value.path;
    }
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // method - computed: false, optional: true, required: false
  private _method?: string; 
  public get method() {
    return this.getStringAttribute('method');
  }
  public set method(value: string) {
    this._method = value;
  }
  public resetMethod() {
    this._method = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get methodInput() {
    return this._method;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressL7ProtocolsTls {
  /**
  * SNI (Server Name Indication) indicates the server domain name in the TLS/SSL hello message.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#sni DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#sni}
  */
  readonly sni?: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressL7ProtocolsTlsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressL7ProtocolsTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    sni: cdktf.stringToTerraform(struct!.sni),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressL7ProtocolsTlsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressL7ProtocolsTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    sni: {
      value: cdktf.stringToHclTerraform(struct!.sni),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressL7ProtocolsTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressL7ProtocolsTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._sni !== undefined) {
      hasAnyValues = true;
      internalValueResult.sni = this._sni;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressL7ProtocolsTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._sni = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._sni = value.sni;
    }
  }

  // sni - computed: false, optional: true, required: false
  private _sni?: string; 
  public get sni() {
    return this.getStringAttribute('sni');
  }
  public set sni(value: string) {
    this._sni = value;
  }
  public resetSni() {
    this._sni = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sniInput() {
    return this._sni;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressL7Protocols {
  /**
  * HTTPProtocol matches HTTP requests with specific host, method, and path. All fields could be used alone or together. If all fields are not provided, it matches all HTTP requests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#http DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#http}
  */
  readonly http?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressL7ProtocolsHttp;
  /**
  * TLSProtocol matches TLS handshake packets with specific SNI. If the field is not provided, this matches all TLS handshake packets.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#tls DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#tls}
  */
  readonly tls?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressL7ProtocolsTls;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressL7ProtocolsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressL7Protocols | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    http: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressL7ProtocolsHttpToTerraform(struct!.http),
    tls: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressL7ProtocolsTlsToTerraform(struct!.tls),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressL7ProtocolsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressL7Protocols | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    http: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressL7ProtocolsHttpToHclTerraform(struct!.http),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressL7ProtocolsHttp",
    },
    tls: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressL7ProtocolsTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressL7ProtocolsTls",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressL7ProtocolsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressL7Protocols | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._http?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.http = this._http?.internalValue;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressL7Protocols | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._http.internalValue = undefined;
      this._tls.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._http.internalValue = value.http;
      this._tls.internalValue = value.tls;
    }
  }

  // http - computed: false, optional: true, required: false
  private _http = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressL7ProtocolsHttpOutputReference(this, "http");
  public get http() {
    return this._http;
  }
  public putHttp(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressL7ProtocolsHttp) {
    this._http.internalValue = value;
  }
  public resetHttp() {
    this._http.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpInput() {
    return this._http.internalValue;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressL7ProtocolsTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressL7ProtocolsTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressL7ProtocolsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressL7Protocols[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressL7ProtocolsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressL7ProtocolsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressPorts {
  /**
  * EndPort defines the end of the port range, inclusive. It can only be specified when a numerical 'port' is specified.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#end_port DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#end_port}
  */
  readonly endPort?: number;
  /**
  * The port on the given protocol. This can be either a numerical or named port on a Pod. If this field is not provided, this matches all port names and numbers.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#port DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#port}
  */
  readonly port?: string;
  /**
  * The protocol (TCP, UDP, or SCTP) which traffic must match. If not specified, this field defaults to TCP.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#protocol DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#protocol}
  */
  readonly protocol?: string;
  /**
  * SourceEndPort defines the end of the source port range, inclusive. It can only be specified when 'sourcePort' is specified.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#source_end_port DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#source_end_port}
  */
  readonly sourceEndPort?: number;
  /**
  * The source port on the given protocol. This can only be a numerical port. If this field is not provided, rule matches all source ports.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#source_port DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#source_port}
  */
  readonly sourcePort?: number;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressPortsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressPorts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    end_port: cdktf.numberToTerraform(struct!.endPort),
    port: cdktf.stringToTerraform(struct!.port),
    protocol: cdktf.stringToTerraform(struct!.protocol),
    source_end_port: cdktf.numberToTerraform(struct!.sourceEndPort),
    source_port: cdktf.numberToTerraform(struct!.sourcePort),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressPortsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressPorts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    end_port: {
      value: cdktf.numberToHclTerraform(struct!.endPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port: {
      value: cdktf.stringToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    protocol: {
      value: cdktf.stringToHclTerraform(struct!.protocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    source_end_port: {
      value: cdktf.numberToHclTerraform(struct!.sourceEndPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    source_port: {
      value: cdktf.numberToHclTerraform(struct!.sourcePort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressPortsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressPorts | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._endPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.endPort = this._endPort;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._protocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocol = this._protocol;
    }
    if (this._sourceEndPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceEndPort = this._sourceEndPort;
    }
    if (this._sourcePort !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourcePort = this._sourcePort;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressPorts | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._endPort = undefined;
      this._port = undefined;
      this._protocol = undefined;
      this._sourceEndPort = undefined;
      this._sourcePort = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._endPort = value.endPort;
      this._port = value.port;
      this._protocol = value.protocol;
      this._sourceEndPort = value.sourceEndPort;
      this._sourcePort = value.sourcePort;
    }
  }

  // end_port - computed: false, optional: true, required: false
  private _endPort?: number; 
  public get endPort() {
    return this.getNumberAttribute('end_port');
  }
  public set endPort(value: number) {
    this._endPort = value;
  }
  public resetEndPort() {
    this._endPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endPortInput() {
    return this._endPort;
  }

  // port - computed: false, optional: true, required: false
  private _port?: string; 
  public get port() {
    return this.getStringAttribute('port');
  }
  public set port(value: string) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // protocol - computed: false, optional: true, required: false
  private _protocol?: string; 
  public get protocol() {
    return this.getStringAttribute('protocol');
  }
  public set protocol(value: string) {
    this._protocol = value;
  }
  public resetProtocol() {
    this._protocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolInput() {
    return this._protocol;
  }

  // source_end_port - computed: false, optional: true, required: false
  private _sourceEndPort?: number; 
  public get sourceEndPort() {
    return this.getNumberAttribute('source_end_port');
  }
  public set sourceEndPort(value: number) {
    this._sourceEndPort = value;
  }
  public resetSourceEndPort() {
    this._sourceEndPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceEndPortInput() {
    return this._sourceEndPort;
  }

  // source_port - computed: false, optional: true, required: false
  private _sourcePort?: number; 
  public get sourcePort() {
    return this.getNumberAttribute('source_port');
  }
  public set sourcePort(value: number) {
    this._sourcePort = value;
  }
  public resetSourcePort() {
    this._sourcePort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourcePortInput() {
    return this._sourcePort;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressPortsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressPorts[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressPortsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressPortsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressProtocolsIcmp {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#icmp_code DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#icmp_code}
  */
  readonly icmpCode?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#icmp_type DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#icmp_type}
  */
  readonly icmpType?: number;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressProtocolsIcmpToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressProtocolsIcmp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    icmp_code: cdktf.numberToTerraform(struct!.icmpCode),
    icmp_type: cdktf.numberToTerraform(struct!.icmpType),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressProtocolsIcmpToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressProtocolsIcmp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    icmp_code: {
      value: cdktf.numberToHclTerraform(struct!.icmpCode),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    icmp_type: {
      value: cdktf.numberToHclTerraform(struct!.icmpType),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressProtocolsIcmpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressProtocolsIcmp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._icmpCode !== undefined) {
      hasAnyValues = true;
      internalValueResult.icmpCode = this._icmpCode;
    }
    if (this._icmpType !== undefined) {
      hasAnyValues = true;
      internalValueResult.icmpType = this._icmpType;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressProtocolsIcmp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._icmpCode = undefined;
      this._icmpType = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._icmpCode = value.icmpCode;
      this._icmpType = value.icmpType;
    }
  }

  // icmp_code - computed: false, optional: true, required: false
  private _icmpCode?: number; 
  public get icmpCode() {
    return this.getNumberAttribute('icmp_code');
  }
  public set icmpCode(value: number) {
    this._icmpCode = value;
  }
  public resetIcmpCode() {
    this._icmpCode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get icmpCodeInput() {
    return this._icmpCode;
  }

  // icmp_type - computed: false, optional: true, required: false
  private _icmpType?: number; 
  public get icmpType() {
    return this.getNumberAttribute('icmp_type');
  }
  public set icmpType(value: number) {
    this._icmpType = value;
  }
  public resetIcmpType() {
    this._icmpType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get icmpTypeInput() {
    return this._icmpType;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressProtocolsIgmp {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#group_address DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#group_address}
  */
  readonly groupAddress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#igmp_type DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#igmp_type}
  */
  readonly igmpType?: number;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressProtocolsIgmpToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressProtocolsIgmp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    group_address: cdktf.stringToTerraform(struct!.groupAddress),
    igmp_type: cdktf.numberToTerraform(struct!.igmpType),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressProtocolsIgmpToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressProtocolsIgmp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    group_address: {
      value: cdktf.stringToHclTerraform(struct!.groupAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    igmp_type: {
      value: cdktf.numberToHclTerraform(struct!.igmpType),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressProtocolsIgmpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressProtocolsIgmp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._groupAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupAddress = this._groupAddress;
    }
    if (this._igmpType !== undefined) {
      hasAnyValues = true;
      internalValueResult.igmpType = this._igmpType;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressProtocolsIgmp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._groupAddress = undefined;
      this._igmpType = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._groupAddress = value.groupAddress;
      this._igmpType = value.igmpType;
    }
  }

  // group_address - computed: false, optional: true, required: false
  private _groupAddress?: string; 
  public get groupAddress() {
    return this.getStringAttribute('group_address');
  }
  public set groupAddress(value: string) {
    this._groupAddress = value;
  }
  public resetGroupAddress() {
    this._groupAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupAddressInput() {
    return this._groupAddress;
  }

  // igmp_type - computed: false, optional: true, required: false
  private _igmpType?: number; 
  public get igmpType() {
    return this.getNumberAttribute('igmp_type');
  }
  public set igmpType(value: number) {
    this._igmpType = value;
  }
  public resetIgmpType() {
    this._igmpType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get igmpTypeInput() {
    return this._igmpType;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressProtocols {
  /**
  * ICMPProtocol matches ICMP traffic with specific ICMPType and/or ICMPCode. All fields could be used alone or together. If all fields are not provided, this matches all ICMP traffic.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#icmp DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#icmp}
  */
  readonly icmp?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressProtocolsIcmp;
  /**
  * IGMPProtocol matches IGMP traffic with IGMPType and GroupAddress. IGMPType must be filled with: IGMPQuery int32 = 0x11 IGMPReportV1 int32 = 0x12 IGMPReportV2 int32 = 0x16 IGMPReportV3 int32 = 0x22 If groupAddress is empty, all groupAddresses will be matched.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#igmp DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#igmp}
  */
  readonly igmp?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressProtocolsIgmp;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressProtocolsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressProtocols | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    icmp: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressProtocolsIcmpToTerraform(struct!.icmp),
    igmp: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressProtocolsIgmpToTerraform(struct!.igmp),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressProtocolsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressProtocols | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    icmp: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressProtocolsIcmpToHclTerraform(struct!.icmp),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressProtocolsIcmp",
    },
    igmp: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressProtocolsIgmpToHclTerraform(struct!.igmp),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressProtocolsIgmp",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressProtocolsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressProtocols | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._icmp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.icmp = this._icmp?.internalValue;
    }
    if (this._igmp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.igmp = this._igmp?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressProtocols | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._icmp.internalValue = undefined;
      this._igmp.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._icmp.internalValue = value.icmp;
      this._igmp.internalValue = value.igmp;
    }
  }

  // icmp - computed: false, optional: true, required: false
  private _icmp = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressProtocolsIcmpOutputReference(this, "icmp");
  public get icmp() {
    return this._icmp;
  }
  public putIcmp(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressProtocolsIcmp) {
    this._icmp.internalValue = value;
  }
  public resetIcmp() {
    this._icmp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get icmpInput() {
    return this._icmp.internalValue;
  }

  // igmp - computed: false, optional: true, required: false
  private _igmp = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressProtocolsIgmpOutputReference(this, "igmp");
  public get igmp() {
    return this._igmp;
  }
  public putIgmp(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressProtocolsIgmp) {
    this._igmp.internalValue = value;
  }
  public resetIgmp() {
    this._igmp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get igmpInput() {
    return this._igmp.internalValue;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressProtocolsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressProtocols[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressProtocolsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressProtocolsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToExternalEntitySelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#key DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#operator DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#values DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToExternalEntitySelectorMatchExpressionsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToExternalEntitySelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToExternalEntitySelectorMatchExpressionsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToExternalEntitySelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToExternalEntitySelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToExternalEntitySelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToExternalEntitySelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToExternalEntitySelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToExternalEntitySelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToExternalEntitySelectorMatchExpressionsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToExternalEntitySelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToExternalEntitySelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match_expressions DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToExternalEntitySelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match_labels DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToExternalEntitySelectorToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToExternalEntitySelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToExternalEntitySelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToExternalEntitySelectorToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToExternalEntitySelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToExternalEntitySelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToExternalEntitySelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToExternalEntitySelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToExternalEntitySelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToExternalEntitySelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToExternalEntitySelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToExternalEntitySelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToIpBlock {
  /**
  * CIDR is a string representing the IP Block Valid examples are '192.168.1.0/24'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#cidr DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#cidr}
  */
  readonly cidr: string;
  /**
  * except is a slice of CIDRs that should not be included within an IPBlock Valid examples are '192.168.1.0/28' or '2001:db8::/64' Except values will be rejected if they are outside the cidr range
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#except DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#except}
  */
  readonly except?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToIpBlockToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToIpBlock | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cidr: cdktf.stringToTerraform(struct!.cidr),
    except: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.except),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToIpBlockToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToIpBlock | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cidr: {
      value: cdktf.stringToHclTerraform(struct!.cidr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    except: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.except),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToIpBlockOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToIpBlock | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cidr !== undefined) {
      hasAnyValues = true;
      internalValueResult.cidr = this._cidr;
    }
    if (this._except !== undefined) {
      hasAnyValues = true;
      internalValueResult.except = this._except;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToIpBlock | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cidr = undefined;
      this._except = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cidr = value.cidr;
      this._except = value.except;
    }
  }

  // cidr - computed: false, optional: false, required: true
  private _cidr?: string; 
  public get cidr() {
    return this.getStringAttribute('cidr');
  }
  public set cidr(value: string) {
    this._cidr = value;
  }
  // Temporarily expose input value. Use with caution.
  public get cidrInput() {
    return this._cidr;
  }

  // except - computed: false, optional: true, required: false
  private _except?: string[]; 
  public get except() {
    return this.getListAttribute('except');
  }
  public set except(value: string[]) {
    this._except = value;
  }
  public resetExcept() {
    this._except = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exceptInput() {
    return this._except;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNamespaceSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#key DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#operator DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#values DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNamespaceSelectorMatchExpressionsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNamespaceSelectorMatchExpressionsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNamespaceSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNamespaceSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNamespaceSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNamespaceSelectorMatchExpressionsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNamespaceSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNamespaceSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match_expressions DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNamespaceSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match_labels DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNamespaceSelectorToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNamespaceSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNamespaceSelectorToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNamespaceSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNamespaceSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNamespaceSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNamespaceSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNamespaceSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNamespaceSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNamespaceSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNamespaces {
  /**
  * Selects from the same Namespace of the appliedTo workloads.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match}
  */
  readonly match?: string;
  /**
  * Selects Namespaces that share the same values for the given set of label keys with the appliedTo Namespace. Namespaces must have all the label keys.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#same_labels DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#same_labels}
  */
  readonly sameLabels?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNamespacesToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNamespaces | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match: cdktf.stringToTerraform(struct!.match),
    same_labels: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.sameLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNamespacesToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNamespaces | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match: {
      value: cdktf.stringToHclTerraform(struct!.match),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    same_labels: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.sameLabels),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNamespacesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNamespaces | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._match !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match;
    }
    if (this._sameLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.sameLabels = this._sameLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNamespaces | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._match = undefined;
      this._sameLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._match = value.match;
      this._sameLabels = value.sameLabels;
    }
  }

  // match - computed: false, optional: true, required: false
  private _match?: string; 
  public get match() {
    return this.getStringAttribute('match');
  }
  public set match(value: string) {
    this._match = value;
  }
  public resetMatch() {
    this._match = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match;
  }

  // same_labels - computed: false, optional: true, required: false
  private _sameLabels?: string[]; 
  public get sameLabels() {
    return this.getListAttribute('same_labels');
  }
  public set sameLabels(value: string[]) {
    this._sameLabels = value;
  }
  public resetSameLabels() {
    this._sameLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sameLabelsInput() {
    return this._sameLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNodeSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#key DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#operator DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#values DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNodeSelectorMatchExpressionsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNodeSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNodeSelectorMatchExpressionsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNodeSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNodeSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNodeSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNodeSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNodeSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNodeSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNodeSelectorMatchExpressionsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNodeSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNodeSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match_expressions DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNodeSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match_labels DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNodeSelectorToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNodeSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNodeSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNodeSelectorToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNodeSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNodeSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNodeSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNodeSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNodeSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNodeSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNodeSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNodeSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToPodSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#key DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#operator DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#values DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToPodSelectorMatchExpressionsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToPodSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToPodSelectorMatchExpressionsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToPodSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToPodSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToPodSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToPodSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToPodSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToPodSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToPodSelectorMatchExpressionsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToPodSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToPodSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match_expressions DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToPodSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match_labels DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToPodSelectorToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToPodSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToPodSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToPodSelectorToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToPodSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToPodSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToPodSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToPodSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToPodSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToPodSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToPodSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToPodSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToServiceAccount {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#name DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#namespace DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToServiceAccountToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToServiceAccount | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToServiceAccountToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToServiceAccount | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToServiceAccountOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToServiceAccount | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToServiceAccount | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressTo {
  /**
  * Select ExternalEntities from NetworkPolicy's Namespace as workloads in To/From fields. If set with NamespaceSelector, ExternalEntities are matched from Namespaces matched by the NamespaceSelector. Cannot be set with any other selector except NamespaceSelector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#external_entity_selector DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#external_entity_selector}
  */
  readonly externalEntitySelector?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToExternalEntitySelector;
  /**
  * Restrict egress access to the Fully Qualified Domain Names prescribed by name or by wildcard match patterns. This field can only be set for NetworkPolicyPeer of egress rules. Supported formats are: Exact FQDNs such as 'google.com'. Wildcard expressions such as '*wayfair.com'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#fqdn DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#fqdn}
  */
  readonly fqdn?: string;
  /**
  * Group is the name of the ClusterGroup which can be set within an Ingress or Egress rule in place of a stand-alone selector. A Group cannot be set with any other selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#group DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#group}
  */
  readonly group?: string;
  /**
  * IPBlock describes the IPAddresses/IPBlocks that is matched in to/from. IPBlock cannot be set as part of the AppliedTo field. Cannot be set with any other selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#ip_block DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#ip_block}
  */
  readonly ipBlock?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToIpBlock;
  /**
  * Select all Pods from Namespaces matched by this selector, as workloads in To/From fields. If set with PodSelector, Pods are matched from Namespaces matched by the NamespaceSelector. Cannot be set with any other selector except PodSelector or ExternalEntitySelector. Cannot be set with Namespaces.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#namespace_selector DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#namespace_selector}
  */
  readonly namespaceSelector?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNamespaceSelector;
  /**
  * Select Pod/ExternalEntity from Namespaces matched by specific criteria. Current supported criteria is match: Self, which selects from the same Namespace of the appliedTo workloads. Cannot be set with any other selector except PodSelector or ExternalEntitySelector. This field can only be set when NetworkPolicyPeer is created for ClusterNetworkPolicy ingress/egress rules. Cannot be set with NamespaceSelector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#namespaces DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#namespaces}
  */
  readonly namespaces?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNamespaces;
  /**
  * Select certain Nodes which match the label selector. A NodeSelector cannot be set with any other selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#node_selector DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#node_selector}
  */
  readonly nodeSelector?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNodeSelector;
  /**
  * Select Pods from NetworkPolicy's Namespace as workloads in To/From fields. If set with NamespaceSelector, Pods are matched from Namespaces matched by the NamespaceSelector. Cannot be set with any other selector except NamespaceSelector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#pod_selector DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#pod_selector}
  */
  readonly podSelector?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToPodSelector;
  /**
  * Define scope of the Pod/NamespaceSelector(s) of this peer. Can only be used in ingress NetworkPolicyPeers. Defaults to 'Cluster'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#scope DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#scope}
  */
  readonly scope?: string;
  /**
  * Select all Pods with the ServiceAccount matched by this field, as workloads in To/From fields. Cannot be set with any other selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#service_account DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#service_account}
  */
  readonly serviceAccount?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToServiceAccount;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressTo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    external_entity_selector: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToExternalEntitySelectorToTerraform(struct!.externalEntitySelector),
    fqdn: cdktf.stringToTerraform(struct!.fqdn),
    group: cdktf.stringToTerraform(struct!.group),
    ip_block: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToIpBlockToTerraform(struct!.ipBlock),
    namespace_selector: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNamespaceSelectorToTerraform(struct!.namespaceSelector),
    namespaces: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNamespacesToTerraform(struct!.namespaces),
    node_selector: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNodeSelectorToTerraform(struct!.nodeSelector),
    pod_selector: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToPodSelectorToTerraform(struct!.podSelector),
    scope: cdktf.stringToTerraform(struct!.scope),
    service_account: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToServiceAccountToTerraform(struct!.serviceAccount),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressTo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    external_entity_selector: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToExternalEntitySelectorToHclTerraform(struct!.externalEntitySelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToExternalEntitySelector",
    },
    fqdn: {
      value: cdktf.stringToHclTerraform(struct!.fqdn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    group: {
      value: cdktf.stringToHclTerraform(struct!.group),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_block: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToIpBlockToHclTerraform(struct!.ipBlock),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToIpBlock",
    },
    namespace_selector: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNamespaceSelectorToHclTerraform(struct!.namespaceSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNamespaceSelector",
    },
    namespaces: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNamespacesToHclTerraform(struct!.namespaces),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNamespaces",
    },
    node_selector: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNodeSelectorToHclTerraform(struct!.nodeSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNodeSelector",
    },
    pod_selector: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToPodSelectorToHclTerraform(struct!.podSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToPodSelector",
    },
    scope: {
      value: cdktf.stringToHclTerraform(struct!.scope),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    service_account: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToServiceAccountToHclTerraform(struct!.serviceAccount),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToServiceAccount",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressTo | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._externalEntitySelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.externalEntitySelector = this._externalEntitySelector?.internalValue;
    }
    if (this._fqdn !== undefined) {
      hasAnyValues = true;
      internalValueResult.fqdn = this._fqdn;
    }
    if (this._group !== undefined) {
      hasAnyValues = true;
      internalValueResult.group = this._group;
    }
    if (this._ipBlock?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipBlock = this._ipBlock?.internalValue;
    }
    if (this._namespaceSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaceSelector = this._namespaceSelector?.internalValue;
    }
    if (this._namespaces?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaces = this._namespaces?.internalValue;
    }
    if (this._nodeSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeSelector = this._nodeSelector?.internalValue;
    }
    if (this._podSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.podSelector = this._podSelector?.internalValue;
    }
    if (this._scope !== undefined) {
      hasAnyValues = true;
      internalValueResult.scope = this._scope;
    }
    if (this._serviceAccount?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccount = this._serviceAccount?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressTo | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._externalEntitySelector.internalValue = undefined;
      this._fqdn = undefined;
      this._group = undefined;
      this._ipBlock.internalValue = undefined;
      this._namespaceSelector.internalValue = undefined;
      this._namespaces.internalValue = undefined;
      this._nodeSelector.internalValue = undefined;
      this._podSelector.internalValue = undefined;
      this._scope = undefined;
      this._serviceAccount.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._externalEntitySelector.internalValue = value.externalEntitySelector;
      this._fqdn = value.fqdn;
      this._group = value.group;
      this._ipBlock.internalValue = value.ipBlock;
      this._namespaceSelector.internalValue = value.namespaceSelector;
      this._namespaces.internalValue = value.namespaces;
      this._nodeSelector.internalValue = value.nodeSelector;
      this._podSelector.internalValue = value.podSelector;
      this._scope = value.scope;
      this._serviceAccount.internalValue = value.serviceAccount;
    }
  }

  // external_entity_selector - computed: false, optional: true, required: false
  private _externalEntitySelector = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToExternalEntitySelectorOutputReference(this, "external_entity_selector");
  public get externalEntitySelector() {
    return this._externalEntitySelector;
  }
  public putExternalEntitySelector(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToExternalEntitySelector) {
    this._externalEntitySelector.internalValue = value;
  }
  public resetExternalEntitySelector() {
    this._externalEntitySelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get externalEntitySelectorInput() {
    return this._externalEntitySelector.internalValue;
  }

  // fqdn - computed: false, optional: true, required: false
  private _fqdn?: string; 
  public get fqdn() {
    return this.getStringAttribute('fqdn');
  }
  public set fqdn(value: string) {
    this._fqdn = value;
  }
  public resetFqdn() {
    this._fqdn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fqdnInput() {
    return this._fqdn;
  }

  // group - computed: false, optional: true, required: false
  private _group?: string; 
  public get group() {
    return this.getStringAttribute('group');
  }
  public set group(value: string) {
    this._group = value;
  }
  public resetGroup() {
    this._group = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupInput() {
    return this._group;
  }

  // ip_block - computed: false, optional: true, required: false
  private _ipBlock = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToIpBlockOutputReference(this, "ip_block");
  public get ipBlock() {
    return this._ipBlock;
  }
  public putIpBlock(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToIpBlock) {
    this._ipBlock.internalValue = value;
  }
  public resetIpBlock() {
    this._ipBlock.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipBlockInput() {
    return this._ipBlock.internalValue;
  }

  // namespace_selector - computed: false, optional: true, required: false
  private _namespaceSelector = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNamespaceSelectorOutputReference(this, "namespace_selector");
  public get namespaceSelector() {
    return this._namespaceSelector;
  }
  public putNamespaceSelector(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNamespaceSelector) {
    this._namespaceSelector.internalValue = value;
  }
  public resetNamespaceSelector() {
    this._namespaceSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceSelectorInput() {
    return this._namespaceSelector.internalValue;
  }

  // namespaces - computed: false, optional: true, required: false
  private _namespaces = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNamespacesOutputReference(this, "namespaces");
  public get namespaces() {
    return this._namespaces;
  }
  public putNamespaces(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNamespaces) {
    this._namespaces.internalValue = value;
  }
  public resetNamespaces() {
    this._namespaces.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespacesInput() {
    return this._namespaces.internalValue;
  }

  // node_selector - computed: false, optional: true, required: false
  private _nodeSelector = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNodeSelectorOutputReference(this, "node_selector");
  public get nodeSelector() {
    return this._nodeSelector;
  }
  public putNodeSelector(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToNodeSelector) {
    this._nodeSelector.internalValue = value;
  }
  public resetNodeSelector() {
    this._nodeSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeSelectorInput() {
    return this._nodeSelector.internalValue;
  }

  // pod_selector - computed: false, optional: true, required: false
  private _podSelector = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToPodSelectorOutputReference(this, "pod_selector");
  public get podSelector() {
    return this._podSelector;
  }
  public putPodSelector(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToPodSelector) {
    this._podSelector.internalValue = value;
  }
  public resetPodSelector() {
    this._podSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podSelectorInput() {
    return this._podSelector.internalValue;
  }

  // scope - computed: false, optional: true, required: false
  private _scope?: string; 
  public get scope() {
    return this.getStringAttribute('scope');
  }
  public set scope(value: string) {
    this._scope = value;
  }
  public resetScope() {
    this._scope = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scopeInput() {
    return this._scope;
  }

  // service_account - computed: false, optional: true, required: false
  private _serviceAccount = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToServiceAccountOutputReference(this, "service_account");
  public get serviceAccount() {
    return this._serviceAccount;
  }
  public putServiceAccount(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToServiceAccount) {
    this._serviceAccount.internalValue = value;
  }
  public resetServiceAccount() {
    this._serviceAccount.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountInput() {
    return this._serviceAccount.internalValue;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressTo[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToServices {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#name DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#namespace DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#namespace}
  */
  readonly namespace?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#scope DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#scope}
  */
  readonly scope?: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToServicesToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToServices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    scope: cdktf.stringToTerraform(struct!.scope),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToServicesToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToServices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    scope: {
      value: cdktf.stringToHclTerraform(struct!.scope),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToServicesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToServices | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._scope !== undefined) {
      hasAnyValues = true;
      internalValueResult.scope = this._scope;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToServices | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
      this._scope = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
      this._scope = value.scope;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // scope - computed: false, optional: true, required: false
  private _scope?: string; 
  public get scope() {
    return this.getStringAttribute('scope');
  }
  public set scope(value: string) {
    this._scope = value;
  }
  public resetScope() {
    this._scope = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scopeInput() {
    return this._scope;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToServicesList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToServices[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToServicesOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToServicesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgress {
  /**
  * Action specifies the action to be applied on the rule.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#action DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#action}
  */
  readonly action: string;
  /**
  * Select workloads on which this rule will be applied to. Cannot be set in conjunction with NetworkPolicySpec/ClusterNetworkPolicySpec.AppliedTo.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#applied_to DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#applied_to}
  */
  readonly appliedTo?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedTo[] | cdktf.IResolvable;
  /**
  * EnableLogging is used to indicate if agent should generate logs when rules are matched. Should be default to false.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#enable_logging DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#enable_logging}
  */
  readonly enableLogging?: boolean | cdktf.IResolvable;
  /**
  * Rule is matched if traffic originates from workloads selected by this field. If this field is empty, this rule matches all sources.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#from DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#from}
  */
  readonly from?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFrom[] | cdktf.IResolvable;
  /**
  * Set of layer 7 protocols matched by the rule. If this field is set, action can only be Allow. When this field is used in a rule, any traffic matching the other layer 3/4 criteria of the rule (typically the 5-tuple) will be forwarded to an application-aware engine for protocol detection and rule enforcement, and the traffic will be allowed if the layer 7 criteria is also matched, otherwise it will be dropped. Therefore, any rules after a layer 7 rule will not be enforced for the traffic.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#l7_protocols DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#l7_protocols}
  */
  readonly l7Protocols?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressL7Protocols[] | cdktf.IResolvable;
  /**
  * LogLabel is a user-defined arbitrary string which will be printed in the NetworkPolicy logs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#log_label DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#log_label}
  */
  readonly logLabel?: string;
  /**
  * Name describes the intention of this rule. Name should be unique within the policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#name DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Set of ports and protocols matched by the rule. If this field and Protocols are unset or empty, this rule matches all ports.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#ports DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#ports}
  */
  readonly ports?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressPorts[] | cdktf.IResolvable;
  /**
  * Set of protocols matched by the rule. If this field and Ports are unset or empty, this rule matches all protocols supported.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#protocols DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#protocols}
  */
  readonly protocols?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressProtocols[] | cdktf.IResolvable;
  /**
  * Rule is matched if traffic is intended for workloads selected by this field. This field can't be used with ToServices. If this field and ToServices are both empty or missing this rule matches all destinations.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#to DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#to}
  */
  readonly to?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressTo[] | cdktf.IResolvable;
  /**
  * Rule is matched if traffic is intended for a Service listed in this field. Currently, only ClusterIP types Services are supported in this field. When scope is set to ClusterSet, it matches traffic intended for a multi-cluster Service listed in this field. Service name and Namespace provided should match the original exported Service. This field can only be used when AntreaProxy is enabled. This field can't be used with To or Ports. If this field and To are both empty or missing, this rule matches all destinations.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#to_services DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#to_services}
  */
  readonly toServices?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToServices[] | cdktf.IResolvable;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    applied_to: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToToTerraform, false)(struct!.appliedTo),
    enable_logging: cdktf.booleanToTerraform(struct!.enableLogging),
    from: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromToTerraform, false)(struct!.from),
    l7_protocols: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressL7ProtocolsToTerraform, false)(struct!.l7Protocols),
    log_label: cdktf.stringToTerraform(struct!.logLabel),
    name: cdktf.stringToTerraform(struct!.name),
    ports: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressPortsToTerraform, false)(struct!.ports),
    protocols: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressProtocolsToTerraform, false)(struct!.protocols),
    to: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToToTerraform, false)(struct!.to),
    to_services: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToServicesToTerraform, false)(struct!.toServices),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    applied_to: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToToHclTerraform, false)(struct!.appliedTo),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToList",
    },
    enable_logging: {
      value: cdktf.booleanToHclTerraform(struct!.enableLogging),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    from: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromToHclTerraform, false)(struct!.from),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromList",
    },
    l7_protocols: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressL7ProtocolsToHclTerraform, false)(struct!.l7Protocols),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressL7ProtocolsList",
    },
    log_label: {
      value: cdktf.stringToHclTerraform(struct!.logLabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ports: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressPortsToHclTerraform, false)(struct!.ports),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressPortsList",
    },
    protocols: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressProtocolsToHclTerraform, false)(struct!.protocols),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressProtocolsList",
    },
    to: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToToHclTerraform, false)(struct!.to),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToList",
    },
    to_services: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToServicesToHclTerraform, false)(struct!.toServices),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToServicesList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._appliedTo?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.appliedTo = this._appliedTo?.internalValue;
    }
    if (this._enableLogging !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableLogging = this._enableLogging;
    }
    if (this._from?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.from = this._from?.internalValue;
    }
    if (this._l7Protocols?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.l7Protocols = this._l7Protocols?.internalValue;
    }
    if (this._logLabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.logLabel = this._logLabel;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._ports?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ports = this._ports?.internalValue;
    }
    if (this._protocols?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocols = this._protocols?.internalValue;
    }
    if (this._to?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.to = this._to?.internalValue;
    }
    if (this._toServices?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.toServices = this._toServices?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._appliedTo.internalValue = undefined;
      this._enableLogging = undefined;
      this._from.internalValue = undefined;
      this._l7Protocols.internalValue = undefined;
      this._logLabel = undefined;
      this._name = undefined;
      this._ports.internalValue = undefined;
      this._protocols.internalValue = undefined;
      this._to.internalValue = undefined;
      this._toServices.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._appliedTo.internalValue = value.appliedTo;
      this._enableLogging = value.enableLogging;
      this._from.internalValue = value.from;
      this._l7Protocols.internalValue = value.l7Protocols;
      this._logLabel = value.logLabel;
      this._name = value.name;
      this._ports.internalValue = value.ports;
      this._protocols.internalValue = value.protocols;
      this._to.internalValue = value.to;
      this._toServices.internalValue = value.toServices;
    }
  }

  // action - computed: false, optional: false, required: true
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // applied_to - computed: false, optional: true, required: false
  private _appliedTo = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedToList(this, "applied_to", false);
  public get appliedTo() {
    return this._appliedTo;
  }
  public putAppliedTo(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressAppliedTo[] | cdktf.IResolvable) {
    this._appliedTo.internalValue = value;
  }
  public resetAppliedTo() {
    this._appliedTo.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appliedToInput() {
    return this._appliedTo.internalValue;
  }

  // enable_logging - computed: false, optional: true, required: false
  private _enableLogging?: boolean | cdktf.IResolvable; 
  public get enableLogging() {
    return this.getBooleanAttribute('enable_logging');
  }
  public set enableLogging(value: boolean | cdktf.IResolvable) {
    this._enableLogging = value;
  }
  public resetEnableLogging() {
    this._enableLogging = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableLoggingInput() {
    return this._enableLogging;
  }

  // from - computed: false, optional: true, required: false
  private _from = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFromList(this, "from", false);
  public get from() {
    return this._from;
  }
  public putFrom(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressFrom[] | cdktf.IResolvable) {
    this._from.internalValue = value;
  }
  public resetFrom() {
    this._from.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fromInput() {
    return this._from.internalValue;
  }

  // l7_protocols - computed: false, optional: true, required: false
  private _l7Protocols = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressL7ProtocolsList(this, "l7_protocols", false);
  public get l7Protocols() {
    return this._l7Protocols;
  }
  public putL7Protocols(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressL7Protocols[] | cdktf.IResolvable) {
    this._l7Protocols.internalValue = value;
  }
  public resetL7Protocols() {
    this._l7Protocols.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get l7ProtocolsInput() {
    return this._l7Protocols.internalValue;
  }

  // log_label - computed: false, optional: true, required: false
  private _logLabel?: string; 
  public get logLabel() {
    return this.getStringAttribute('log_label');
  }
  public set logLabel(value: string) {
    this._logLabel = value;
  }
  public resetLogLabel() {
    this._logLabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logLabelInput() {
    return this._logLabel;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // ports - computed: false, optional: true, required: false
  private _ports = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressPortsList(this, "ports", false);
  public get ports() {
    return this._ports;
  }
  public putPorts(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressPorts[] | cdktf.IResolvable) {
    this._ports.internalValue = value;
  }
  public resetPorts() {
    this._ports.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portsInput() {
    return this._ports.internalValue;
  }

  // protocols - computed: false, optional: true, required: false
  private _protocols = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressProtocolsList(this, "protocols", false);
  public get protocols() {
    return this._protocols;
  }
  public putProtocols(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressProtocols[] | cdktf.IResolvable) {
    this._protocols.internalValue = value;
  }
  public resetProtocols() {
    this._protocols.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolsInput() {
    return this._protocols.internalValue;
  }

  // to - computed: false, optional: true, required: false
  private _to = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToList(this, "to", false);
  public get to() {
    return this._to;
  }
  public putTo(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressTo[] | cdktf.IResolvable) {
    this._to.internalValue = value;
  }
  public resetTo() {
    this._to.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get toInput() {
    return this._to.internalValue;
  }

  // to_services - computed: false, optional: true, required: false
  private _toServices = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToServicesList(this, "to_services", false);
  public get toServices() {
    return this._toServices;
  }
  public putToServices(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToServices[] | cdktf.IResolvable) {
    this._toServices.internalValue = value;
  }
  public resetToServices() {
    this._toServices.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get toServicesInput() {
    return this._toServices.internalValue;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgress[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToExternalEntitySelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#key DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#operator DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#values DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToExternalEntitySelectorMatchExpressionsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToExternalEntitySelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToExternalEntitySelectorMatchExpressionsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToExternalEntitySelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToExternalEntitySelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToExternalEntitySelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToExternalEntitySelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToExternalEntitySelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToExternalEntitySelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToExternalEntitySelectorMatchExpressionsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToExternalEntitySelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToExternalEntitySelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match_expressions DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToExternalEntitySelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match_labels DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToExternalEntitySelectorToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToExternalEntitySelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToExternalEntitySelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToExternalEntitySelectorToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToExternalEntitySelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToExternalEntitySelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToExternalEntitySelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToExternalEntitySelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToExternalEntitySelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToExternalEntitySelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToExternalEntitySelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToExternalEntitySelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNamespaceSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#key DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#operator DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#values DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNamespaceSelectorMatchExpressionsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNamespaceSelectorMatchExpressionsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNamespaceSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNamespaceSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNamespaceSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNamespaceSelectorMatchExpressionsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNamespaceSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNamespaceSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match_expressions DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNamespaceSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match_labels DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNamespaceSelectorToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNamespaceSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNamespaceSelectorToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNamespaceSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNamespaceSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNamespaceSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNamespaceSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNamespaceSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNamespaceSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNamespaceSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNodeSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#key DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#operator DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#values DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNodeSelectorMatchExpressionsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNodeSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNodeSelectorMatchExpressionsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNodeSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNodeSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNodeSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNodeSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNodeSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNodeSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNodeSelectorMatchExpressionsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNodeSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNodeSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match_expressions DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNodeSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match_labels DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNodeSelectorToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNodeSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNodeSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNodeSelectorToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNodeSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNodeSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNodeSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNodeSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNodeSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNodeSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNodeSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNodeSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToPodSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#key DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#operator DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#values DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToPodSelectorMatchExpressionsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToPodSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToPodSelectorMatchExpressionsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToPodSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToPodSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToPodSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToPodSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToPodSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToPodSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToPodSelectorMatchExpressionsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToPodSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToPodSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match_expressions DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToPodSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match_labels DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToPodSelectorToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToPodSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToPodSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToPodSelectorToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToPodSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToPodSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToPodSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToPodSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToPodSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToPodSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToPodSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToPodSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToService {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#name DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#namespace DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToServiceToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToServiceToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToServiceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToService | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToService | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToServiceAccount {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#name DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#namespace DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToServiceAccountToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToServiceAccount | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToServiceAccountToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToServiceAccount | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToServiceAccountOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToServiceAccount | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToServiceAccount | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedTo {
  /**
  * Select ExternalEntities from NetworkPolicy's Namespace as workloads in AppliedTo fields. If set with NamespaceSelector, ExternalEntities are matched from Namespaces matched by the NamespaceSelector. Cannot be set with any other selector except NamespaceSelector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#external_entity_selector DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#external_entity_selector}
  */
  readonly externalEntitySelector?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToExternalEntitySelector;
  /**
  * Group is the name of the ClusterGroup which can be set as an AppliedTo in place of a stand-alone selector. A Group cannot be set with any other selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#group DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#group}
  */
  readonly group?: string;
  /**
  * Select all Pods from Namespaces matched by this selector, as workloads in AppliedTo fields. If set with PodSelector, Pods are matched from Namespaces matched by the NamespaceSelector. Cannot be set with any other selector except PodSelector or ExternalEntitySelector. Cannot be set with Namespaces.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#namespace_selector DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#namespace_selector}
  */
  readonly namespaceSelector?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNamespaceSelector;
  /**
  * Select Nodes in cluster as workloads in AppliedTo fields. Cannot be set with any other selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#node_selector DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#node_selector}
  */
  readonly nodeSelector?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNodeSelector;
  /**
  * Select Pods from NetworkPolicy's Namespace as workloads in AppliedTo fields. If set with NamespaceSelector, Pods are matched from Namespaces matched by the NamespaceSelector. Cannot be set with any other selector except NamespaceSelector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#pod_selector DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#pod_selector}
  */
  readonly podSelector?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToPodSelector;
  /**
  * Select a certain Service which matches the NamespacedName. A Service can only be set in either policy level AppliedTo field in a policy that only has ingress rules or rule level AppliedTo field in an ingress rule. Only a NodePort Service can be referred by this field. Cannot be set with any other selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#service DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#service}
  */
  readonly service?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToService;
  /**
  * Select all Pods with the ServiceAccount matched by this field, as workloads in AppliedTo fields. Cannot be set with any other selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#service_account DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#service_account}
  */
  readonly serviceAccount?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToServiceAccount;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedTo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    external_entity_selector: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToExternalEntitySelectorToTerraform(struct!.externalEntitySelector),
    group: cdktf.stringToTerraform(struct!.group),
    namespace_selector: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNamespaceSelectorToTerraform(struct!.namespaceSelector),
    node_selector: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNodeSelectorToTerraform(struct!.nodeSelector),
    pod_selector: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToPodSelectorToTerraform(struct!.podSelector),
    service: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToServiceToTerraform(struct!.service),
    service_account: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToServiceAccountToTerraform(struct!.serviceAccount),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedTo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    external_entity_selector: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToExternalEntitySelectorToHclTerraform(struct!.externalEntitySelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToExternalEntitySelector",
    },
    group: {
      value: cdktf.stringToHclTerraform(struct!.group),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace_selector: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNamespaceSelectorToHclTerraform(struct!.namespaceSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNamespaceSelector",
    },
    node_selector: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNodeSelectorToHclTerraform(struct!.nodeSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNodeSelector",
    },
    pod_selector: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToPodSelectorToHclTerraform(struct!.podSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToPodSelector",
    },
    service: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToServiceToHclTerraform(struct!.service),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToService",
    },
    service_account: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToServiceAccountToHclTerraform(struct!.serviceAccount),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToServiceAccount",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedTo | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._externalEntitySelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.externalEntitySelector = this._externalEntitySelector?.internalValue;
    }
    if (this._group !== undefined) {
      hasAnyValues = true;
      internalValueResult.group = this._group;
    }
    if (this._namespaceSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaceSelector = this._namespaceSelector?.internalValue;
    }
    if (this._nodeSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeSelector = this._nodeSelector?.internalValue;
    }
    if (this._podSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.podSelector = this._podSelector?.internalValue;
    }
    if (this._service?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.service = this._service?.internalValue;
    }
    if (this._serviceAccount?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccount = this._serviceAccount?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedTo | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._externalEntitySelector.internalValue = undefined;
      this._group = undefined;
      this._namespaceSelector.internalValue = undefined;
      this._nodeSelector.internalValue = undefined;
      this._podSelector.internalValue = undefined;
      this._service.internalValue = undefined;
      this._serviceAccount.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._externalEntitySelector.internalValue = value.externalEntitySelector;
      this._group = value.group;
      this._namespaceSelector.internalValue = value.namespaceSelector;
      this._nodeSelector.internalValue = value.nodeSelector;
      this._podSelector.internalValue = value.podSelector;
      this._service.internalValue = value.service;
      this._serviceAccount.internalValue = value.serviceAccount;
    }
  }

  // external_entity_selector - computed: false, optional: true, required: false
  private _externalEntitySelector = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToExternalEntitySelectorOutputReference(this, "external_entity_selector");
  public get externalEntitySelector() {
    return this._externalEntitySelector;
  }
  public putExternalEntitySelector(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToExternalEntitySelector) {
    this._externalEntitySelector.internalValue = value;
  }
  public resetExternalEntitySelector() {
    this._externalEntitySelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get externalEntitySelectorInput() {
    return this._externalEntitySelector.internalValue;
  }

  // group - computed: false, optional: true, required: false
  private _group?: string; 
  public get group() {
    return this.getStringAttribute('group');
  }
  public set group(value: string) {
    this._group = value;
  }
  public resetGroup() {
    this._group = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupInput() {
    return this._group;
  }

  // namespace_selector - computed: false, optional: true, required: false
  private _namespaceSelector = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNamespaceSelectorOutputReference(this, "namespace_selector");
  public get namespaceSelector() {
    return this._namespaceSelector;
  }
  public putNamespaceSelector(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNamespaceSelector) {
    this._namespaceSelector.internalValue = value;
  }
  public resetNamespaceSelector() {
    this._namespaceSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceSelectorInput() {
    return this._namespaceSelector.internalValue;
  }

  // node_selector - computed: false, optional: true, required: false
  private _nodeSelector = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNodeSelectorOutputReference(this, "node_selector");
  public get nodeSelector() {
    return this._nodeSelector;
  }
  public putNodeSelector(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToNodeSelector) {
    this._nodeSelector.internalValue = value;
  }
  public resetNodeSelector() {
    this._nodeSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeSelectorInput() {
    return this._nodeSelector.internalValue;
  }

  // pod_selector - computed: false, optional: true, required: false
  private _podSelector = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToPodSelectorOutputReference(this, "pod_selector");
  public get podSelector() {
    return this._podSelector;
  }
  public putPodSelector(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToPodSelector) {
    this._podSelector.internalValue = value;
  }
  public resetPodSelector() {
    this._podSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podSelectorInput() {
    return this._podSelector.internalValue;
  }

  // service - computed: false, optional: true, required: false
  private _service = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToServiceOutputReference(this, "service");
  public get service() {
    return this._service;
  }
  public putService(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToService) {
    this._service.internalValue = value;
  }
  public resetService() {
    this._service.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceInput() {
    return this._service.internalValue;
  }

  // service_account - computed: false, optional: true, required: false
  private _serviceAccount = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToServiceAccountOutputReference(this, "service_account");
  public get serviceAccount() {
    return this._serviceAccount;
  }
  public putServiceAccount(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToServiceAccount) {
    this._serviceAccount.internalValue = value;
  }
  public resetServiceAccount() {
    this._serviceAccount.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountInput() {
    return this._serviceAccount.internalValue;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedTo[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromExternalEntitySelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#key DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#operator DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#values DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromExternalEntitySelectorMatchExpressionsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromExternalEntitySelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromExternalEntitySelectorMatchExpressionsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromExternalEntitySelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromExternalEntitySelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromExternalEntitySelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromExternalEntitySelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromExternalEntitySelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromExternalEntitySelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromExternalEntitySelectorMatchExpressionsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromExternalEntitySelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromExternalEntitySelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match_expressions DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromExternalEntitySelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match_labels DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromExternalEntitySelectorToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromExternalEntitySelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromExternalEntitySelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromExternalEntitySelectorToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromExternalEntitySelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromExternalEntitySelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromExternalEntitySelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromExternalEntitySelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromExternalEntitySelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromExternalEntitySelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromExternalEntitySelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromExternalEntitySelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromIpBlock {
  /**
  * CIDR is a string representing the IP Block Valid examples are '192.168.1.0/24'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#cidr DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#cidr}
  */
  readonly cidr: string;
  /**
  * except is a slice of CIDRs that should not be included within an IPBlock Valid examples are '192.168.1.0/28' or '2001:db8::/64' Except values will be rejected if they are outside the cidr range
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#except DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#except}
  */
  readonly except?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromIpBlockToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromIpBlock | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cidr: cdktf.stringToTerraform(struct!.cidr),
    except: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.except),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromIpBlockToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromIpBlock | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cidr: {
      value: cdktf.stringToHclTerraform(struct!.cidr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    except: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.except),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromIpBlockOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromIpBlock | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cidr !== undefined) {
      hasAnyValues = true;
      internalValueResult.cidr = this._cidr;
    }
    if (this._except !== undefined) {
      hasAnyValues = true;
      internalValueResult.except = this._except;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromIpBlock | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cidr = undefined;
      this._except = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cidr = value.cidr;
      this._except = value.except;
    }
  }

  // cidr - computed: false, optional: false, required: true
  private _cidr?: string; 
  public get cidr() {
    return this.getStringAttribute('cidr');
  }
  public set cidr(value: string) {
    this._cidr = value;
  }
  // Temporarily expose input value. Use with caution.
  public get cidrInput() {
    return this._cidr;
  }

  // except - computed: false, optional: true, required: false
  private _except?: string[]; 
  public get except() {
    return this.getListAttribute('except');
  }
  public set except(value: string[]) {
    this._except = value;
  }
  public resetExcept() {
    this._except = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exceptInput() {
    return this._except;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNamespaceSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#key DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#operator DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#values DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNamespaceSelectorMatchExpressionsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNamespaceSelectorMatchExpressionsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNamespaceSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNamespaceSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNamespaceSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNamespaceSelectorMatchExpressionsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNamespaceSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNamespaceSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match_expressions DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNamespaceSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match_labels DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNamespaceSelectorToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNamespaceSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNamespaceSelectorToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNamespaceSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNamespaceSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNamespaceSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNamespaceSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNamespaceSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNamespaceSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNamespaceSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNamespaces {
  /**
  * Selects from the same Namespace of the appliedTo workloads.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match}
  */
  readonly match?: string;
  /**
  * Selects Namespaces that share the same values for the given set of label keys with the appliedTo Namespace. Namespaces must have all the label keys.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#same_labels DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#same_labels}
  */
  readonly sameLabels?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNamespacesToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNamespaces | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match: cdktf.stringToTerraform(struct!.match),
    same_labels: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.sameLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNamespacesToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNamespaces | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match: {
      value: cdktf.stringToHclTerraform(struct!.match),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    same_labels: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.sameLabels),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNamespacesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNamespaces | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._match !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match;
    }
    if (this._sameLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.sameLabels = this._sameLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNamespaces | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._match = undefined;
      this._sameLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._match = value.match;
      this._sameLabels = value.sameLabels;
    }
  }

  // match - computed: false, optional: true, required: false
  private _match?: string; 
  public get match() {
    return this.getStringAttribute('match');
  }
  public set match(value: string) {
    this._match = value;
  }
  public resetMatch() {
    this._match = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match;
  }

  // same_labels - computed: false, optional: true, required: false
  private _sameLabels?: string[]; 
  public get sameLabels() {
    return this.getListAttribute('same_labels');
  }
  public set sameLabels(value: string[]) {
    this._sameLabels = value;
  }
  public resetSameLabels() {
    this._sameLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sameLabelsInput() {
    return this._sameLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNodeSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#key DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#operator DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#values DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNodeSelectorMatchExpressionsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNodeSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNodeSelectorMatchExpressionsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNodeSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNodeSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNodeSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNodeSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNodeSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNodeSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNodeSelectorMatchExpressionsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNodeSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNodeSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match_expressions DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNodeSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match_labels DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNodeSelectorToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNodeSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNodeSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNodeSelectorToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNodeSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNodeSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNodeSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNodeSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNodeSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNodeSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNodeSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNodeSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromPodSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#key DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#operator DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#values DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromPodSelectorMatchExpressionsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromPodSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromPodSelectorMatchExpressionsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromPodSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromPodSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromPodSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromPodSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromPodSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromPodSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromPodSelectorMatchExpressionsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromPodSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromPodSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match_expressions DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromPodSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match_labels DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromPodSelectorToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromPodSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromPodSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromPodSelectorToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromPodSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromPodSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromPodSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromPodSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromPodSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromPodSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromPodSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromPodSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromServiceAccount {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#name DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#namespace DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromServiceAccountToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromServiceAccount | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromServiceAccountToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromServiceAccount | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromServiceAccountOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromServiceAccount | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromServiceAccount | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFrom {
  /**
  * Select ExternalEntities from NetworkPolicy's Namespace as workloads in To/From fields. If set with NamespaceSelector, ExternalEntities are matched from Namespaces matched by the NamespaceSelector. Cannot be set with any other selector except NamespaceSelector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#external_entity_selector DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#external_entity_selector}
  */
  readonly externalEntitySelector?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromExternalEntitySelector;
  /**
  * Restrict egress access to the Fully Qualified Domain Names prescribed by name or by wildcard match patterns. This field can only be set for NetworkPolicyPeer of egress rules. Supported formats are: Exact FQDNs such as 'google.com'. Wildcard expressions such as '*wayfair.com'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#fqdn DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#fqdn}
  */
  readonly fqdn?: string;
  /**
  * Group is the name of the ClusterGroup which can be set within an Ingress or Egress rule in place of a stand-alone selector. A Group cannot be set with any other selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#group DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#group}
  */
  readonly group?: string;
  /**
  * IPBlock describes the IPAddresses/IPBlocks that is matched in to/from. IPBlock cannot be set as part of the AppliedTo field. Cannot be set with any other selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#ip_block DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#ip_block}
  */
  readonly ipBlock?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromIpBlock;
  /**
  * Select all Pods from Namespaces matched by this selector, as workloads in To/From fields. If set with PodSelector, Pods are matched from Namespaces matched by the NamespaceSelector. Cannot be set with any other selector except PodSelector or ExternalEntitySelector. Cannot be set with Namespaces.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#namespace_selector DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#namespace_selector}
  */
  readonly namespaceSelector?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNamespaceSelector;
  /**
  * Select Pod/ExternalEntity from Namespaces matched by specific criteria. Current supported criteria is match: Self, which selects from the same Namespace of the appliedTo workloads. Cannot be set with any other selector except PodSelector or ExternalEntitySelector. This field can only be set when NetworkPolicyPeer is created for ClusterNetworkPolicy ingress/egress rules. Cannot be set with NamespaceSelector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#namespaces DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#namespaces}
  */
  readonly namespaces?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNamespaces;
  /**
  * Select certain Nodes which match the label selector. A NodeSelector cannot be set with any other selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#node_selector DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#node_selector}
  */
  readonly nodeSelector?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNodeSelector;
  /**
  * Select Pods from NetworkPolicy's Namespace as workloads in To/From fields. If set with NamespaceSelector, Pods are matched from Namespaces matched by the NamespaceSelector. Cannot be set with any other selector except NamespaceSelector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#pod_selector DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#pod_selector}
  */
  readonly podSelector?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromPodSelector;
  /**
  * Define scope of the Pod/NamespaceSelector(s) of this peer. Can only be used in ingress NetworkPolicyPeers. Defaults to 'Cluster'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#scope DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#scope}
  */
  readonly scope?: string;
  /**
  * Select all Pods with the ServiceAccount matched by this field, as workloads in To/From fields. Cannot be set with any other selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#service_account DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#service_account}
  */
  readonly serviceAccount?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromServiceAccount;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    external_entity_selector: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromExternalEntitySelectorToTerraform(struct!.externalEntitySelector),
    fqdn: cdktf.stringToTerraform(struct!.fqdn),
    group: cdktf.stringToTerraform(struct!.group),
    ip_block: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromIpBlockToTerraform(struct!.ipBlock),
    namespace_selector: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNamespaceSelectorToTerraform(struct!.namespaceSelector),
    namespaces: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNamespacesToTerraform(struct!.namespaces),
    node_selector: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNodeSelectorToTerraform(struct!.nodeSelector),
    pod_selector: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromPodSelectorToTerraform(struct!.podSelector),
    scope: cdktf.stringToTerraform(struct!.scope),
    service_account: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromServiceAccountToTerraform(struct!.serviceAccount),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    external_entity_selector: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromExternalEntitySelectorToHclTerraform(struct!.externalEntitySelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromExternalEntitySelector",
    },
    fqdn: {
      value: cdktf.stringToHclTerraform(struct!.fqdn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    group: {
      value: cdktf.stringToHclTerraform(struct!.group),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_block: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromIpBlockToHclTerraform(struct!.ipBlock),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromIpBlock",
    },
    namespace_selector: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNamespaceSelectorToHclTerraform(struct!.namespaceSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNamespaceSelector",
    },
    namespaces: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNamespacesToHclTerraform(struct!.namespaces),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNamespaces",
    },
    node_selector: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNodeSelectorToHclTerraform(struct!.nodeSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNodeSelector",
    },
    pod_selector: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromPodSelectorToHclTerraform(struct!.podSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromPodSelector",
    },
    scope: {
      value: cdktf.stringToHclTerraform(struct!.scope),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    service_account: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromServiceAccountToHclTerraform(struct!.serviceAccount),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromServiceAccount",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._externalEntitySelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.externalEntitySelector = this._externalEntitySelector?.internalValue;
    }
    if (this._fqdn !== undefined) {
      hasAnyValues = true;
      internalValueResult.fqdn = this._fqdn;
    }
    if (this._group !== undefined) {
      hasAnyValues = true;
      internalValueResult.group = this._group;
    }
    if (this._ipBlock?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipBlock = this._ipBlock?.internalValue;
    }
    if (this._namespaceSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaceSelector = this._namespaceSelector?.internalValue;
    }
    if (this._namespaces?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaces = this._namespaces?.internalValue;
    }
    if (this._nodeSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeSelector = this._nodeSelector?.internalValue;
    }
    if (this._podSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.podSelector = this._podSelector?.internalValue;
    }
    if (this._scope !== undefined) {
      hasAnyValues = true;
      internalValueResult.scope = this._scope;
    }
    if (this._serviceAccount?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccount = this._serviceAccount?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._externalEntitySelector.internalValue = undefined;
      this._fqdn = undefined;
      this._group = undefined;
      this._ipBlock.internalValue = undefined;
      this._namespaceSelector.internalValue = undefined;
      this._namespaces.internalValue = undefined;
      this._nodeSelector.internalValue = undefined;
      this._podSelector.internalValue = undefined;
      this._scope = undefined;
      this._serviceAccount.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._externalEntitySelector.internalValue = value.externalEntitySelector;
      this._fqdn = value.fqdn;
      this._group = value.group;
      this._ipBlock.internalValue = value.ipBlock;
      this._namespaceSelector.internalValue = value.namespaceSelector;
      this._namespaces.internalValue = value.namespaces;
      this._nodeSelector.internalValue = value.nodeSelector;
      this._podSelector.internalValue = value.podSelector;
      this._scope = value.scope;
      this._serviceAccount.internalValue = value.serviceAccount;
    }
  }

  // external_entity_selector - computed: false, optional: true, required: false
  private _externalEntitySelector = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromExternalEntitySelectorOutputReference(this, "external_entity_selector");
  public get externalEntitySelector() {
    return this._externalEntitySelector;
  }
  public putExternalEntitySelector(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromExternalEntitySelector) {
    this._externalEntitySelector.internalValue = value;
  }
  public resetExternalEntitySelector() {
    this._externalEntitySelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get externalEntitySelectorInput() {
    return this._externalEntitySelector.internalValue;
  }

  // fqdn - computed: false, optional: true, required: false
  private _fqdn?: string; 
  public get fqdn() {
    return this.getStringAttribute('fqdn');
  }
  public set fqdn(value: string) {
    this._fqdn = value;
  }
  public resetFqdn() {
    this._fqdn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fqdnInput() {
    return this._fqdn;
  }

  // group - computed: false, optional: true, required: false
  private _group?: string; 
  public get group() {
    return this.getStringAttribute('group');
  }
  public set group(value: string) {
    this._group = value;
  }
  public resetGroup() {
    this._group = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupInput() {
    return this._group;
  }

  // ip_block - computed: false, optional: true, required: false
  private _ipBlock = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromIpBlockOutputReference(this, "ip_block");
  public get ipBlock() {
    return this._ipBlock;
  }
  public putIpBlock(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromIpBlock) {
    this._ipBlock.internalValue = value;
  }
  public resetIpBlock() {
    this._ipBlock.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipBlockInput() {
    return this._ipBlock.internalValue;
  }

  // namespace_selector - computed: false, optional: true, required: false
  private _namespaceSelector = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNamespaceSelectorOutputReference(this, "namespace_selector");
  public get namespaceSelector() {
    return this._namespaceSelector;
  }
  public putNamespaceSelector(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNamespaceSelector) {
    this._namespaceSelector.internalValue = value;
  }
  public resetNamespaceSelector() {
    this._namespaceSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceSelectorInput() {
    return this._namespaceSelector.internalValue;
  }

  // namespaces - computed: false, optional: true, required: false
  private _namespaces = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNamespacesOutputReference(this, "namespaces");
  public get namespaces() {
    return this._namespaces;
  }
  public putNamespaces(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNamespaces) {
    this._namespaces.internalValue = value;
  }
  public resetNamespaces() {
    this._namespaces.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespacesInput() {
    return this._namespaces.internalValue;
  }

  // node_selector - computed: false, optional: true, required: false
  private _nodeSelector = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNodeSelectorOutputReference(this, "node_selector");
  public get nodeSelector() {
    return this._nodeSelector;
  }
  public putNodeSelector(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromNodeSelector) {
    this._nodeSelector.internalValue = value;
  }
  public resetNodeSelector() {
    this._nodeSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeSelectorInput() {
    return this._nodeSelector.internalValue;
  }

  // pod_selector - computed: false, optional: true, required: false
  private _podSelector = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromPodSelectorOutputReference(this, "pod_selector");
  public get podSelector() {
    return this._podSelector;
  }
  public putPodSelector(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromPodSelector) {
    this._podSelector.internalValue = value;
  }
  public resetPodSelector() {
    this._podSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podSelectorInput() {
    return this._podSelector.internalValue;
  }

  // scope - computed: false, optional: true, required: false
  private _scope?: string; 
  public get scope() {
    return this.getStringAttribute('scope');
  }
  public set scope(value: string) {
    this._scope = value;
  }
  public resetScope() {
    this._scope = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scopeInput() {
    return this._scope;
  }

  // service_account - computed: false, optional: true, required: false
  private _serviceAccount = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromServiceAccountOutputReference(this, "service_account");
  public get serviceAccount() {
    return this._serviceAccount;
  }
  public putServiceAccount(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromServiceAccount) {
    this._serviceAccount.internalValue = value;
  }
  public resetServiceAccount() {
    this._serviceAccount.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountInput() {
    return this._serviceAccount.internalValue;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFrom[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressL7ProtocolsHttp {
  /**
  * Host represents the hostname present in the URI or the HTTP Host header to match. It does not contain the port associated with the host.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#host DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#host}
  */
  readonly host?: string;
  /**
  * Method represents the HTTP method to match. It could be GET, POST, PUT, HEAD, DELETE, TRACE, OPTIONS, CONNECT and PATCH.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#method DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#method}
  */
  readonly method?: string;
  /**
  * Path represents the URI path to match (Ex. '/index.html', '/admin').
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#path DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#path}
  */
  readonly path?: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressL7ProtocolsHttpToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressL7ProtocolsHttp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    host: cdktf.stringToTerraform(struct!.host),
    method: cdktf.stringToTerraform(struct!.method),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressL7ProtocolsHttpToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressL7ProtocolsHttp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    method: {
      value: cdktf.stringToHclTerraform(struct!.method),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressL7ProtocolsHttpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressL7ProtocolsHttp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._method !== undefined) {
      hasAnyValues = true;
      internalValueResult.method = this._method;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressL7ProtocolsHttp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._host = undefined;
      this._method = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._host = value.host;
      this._method = value.method;
      this._path = value.path;
    }
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // method - computed: false, optional: true, required: false
  private _method?: string; 
  public get method() {
    return this.getStringAttribute('method');
  }
  public set method(value: string) {
    this._method = value;
  }
  public resetMethod() {
    this._method = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get methodInput() {
    return this._method;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressL7ProtocolsTls {
  /**
  * SNI (Server Name Indication) indicates the server domain name in the TLS/SSL hello message.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#sni DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#sni}
  */
  readonly sni?: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressL7ProtocolsTlsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressL7ProtocolsTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    sni: cdktf.stringToTerraform(struct!.sni),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressL7ProtocolsTlsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressL7ProtocolsTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    sni: {
      value: cdktf.stringToHclTerraform(struct!.sni),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressL7ProtocolsTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressL7ProtocolsTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._sni !== undefined) {
      hasAnyValues = true;
      internalValueResult.sni = this._sni;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressL7ProtocolsTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._sni = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._sni = value.sni;
    }
  }

  // sni - computed: false, optional: true, required: false
  private _sni?: string; 
  public get sni() {
    return this.getStringAttribute('sni');
  }
  public set sni(value: string) {
    this._sni = value;
  }
  public resetSni() {
    this._sni = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sniInput() {
    return this._sni;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressL7Protocols {
  /**
  * HTTPProtocol matches HTTP requests with specific host, method, and path. All fields could be used alone or together. If all fields are not provided, it matches all HTTP requests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#http DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#http}
  */
  readonly http?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressL7ProtocolsHttp;
  /**
  * TLSProtocol matches TLS handshake packets with specific SNI. If the field is not provided, this matches all TLS handshake packets.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#tls DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#tls}
  */
  readonly tls?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressL7ProtocolsTls;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressL7ProtocolsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressL7Protocols | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    http: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressL7ProtocolsHttpToTerraform(struct!.http),
    tls: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressL7ProtocolsTlsToTerraform(struct!.tls),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressL7ProtocolsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressL7Protocols | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    http: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressL7ProtocolsHttpToHclTerraform(struct!.http),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressL7ProtocolsHttp",
    },
    tls: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressL7ProtocolsTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressL7ProtocolsTls",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressL7ProtocolsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressL7Protocols | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._http?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.http = this._http?.internalValue;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressL7Protocols | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._http.internalValue = undefined;
      this._tls.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._http.internalValue = value.http;
      this._tls.internalValue = value.tls;
    }
  }

  // http - computed: false, optional: true, required: false
  private _http = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressL7ProtocolsHttpOutputReference(this, "http");
  public get http() {
    return this._http;
  }
  public putHttp(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressL7ProtocolsHttp) {
    this._http.internalValue = value;
  }
  public resetHttp() {
    this._http.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpInput() {
    return this._http.internalValue;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressL7ProtocolsTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressL7ProtocolsTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressL7ProtocolsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressL7Protocols[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressL7ProtocolsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressL7ProtocolsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressPorts {
  /**
  * EndPort defines the end of the port range, inclusive. It can only be specified when a numerical 'port' is specified.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#end_port DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#end_port}
  */
  readonly endPort?: number;
  /**
  * The port on the given protocol. This can be either a numerical or named port on a Pod. If this field is not provided, this matches all port names and numbers.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#port DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#port}
  */
  readonly port?: string;
  /**
  * The protocol (TCP, UDP, or SCTP) which traffic must match. If not specified, this field defaults to TCP.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#protocol DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#protocol}
  */
  readonly protocol?: string;
  /**
  * SourceEndPort defines the end of the source port range, inclusive. It can only be specified when 'sourcePort' is specified.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#source_end_port DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#source_end_port}
  */
  readonly sourceEndPort?: number;
  /**
  * The source port on the given protocol. This can only be a numerical port. If this field is not provided, rule matches all source ports.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#source_port DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#source_port}
  */
  readonly sourcePort?: number;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressPortsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressPorts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    end_port: cdktf.numberToTerraform(struct!.endPort),
    port: cdktf.stringToTerraform(struct!.port),
    protocol: cdktf.stringToTerraform(struct!.protocol),
    source_end_port: cdktf.numberToTerraform(struct!.sourceEndPort),
    source_port: cdktf.numberToTerraform(struct!.sourcePort),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressPortsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressPorts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    end_port: {
      value: cdktf.numberToHclTerraform(struct!.endPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port: {
      value: cdktf.stringToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    protocol: {
      value: cdktf.stringToHclTerraform(struct!.protocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    source_end_port: {
      value: cdktf.numberToHclTerraform(struct!.sourceEndPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    source_port: {
      value: cdktf.numberToHclTerraform(struct!.sourcePort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressPortsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressPorts | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._endPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.endPort = this._endPort;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._protocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocol = this._protocol;
    }
    if (this._sourceEndPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceEndPort = this._sourceEndPort;
    }
    if (this._sourcePort !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourcePort = this._sourcePort;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressPorts | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._endPort = undefined;
      this._port = undefined;
      this._protocol = undefined;
      this._sourceEndPort = undefined;
      this._sourcePort = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._endPort = value.endPort;
      this._port = value.port;
      this._protocol = value.protocol;
      this._sourceEndPort = value.sourceEndPort;
      this._sourcePort = value.sourcePort;
    }
  }

  // end_port - computed: false, optional: true, required: false
  private _endPort?: number; 
  public get endPort() {
    return this.getNumberAttribute('end_port');
  }
  public set endPort(value: number) {
    this._endPort = value;
  }
  public resetEndPort() {
    this._endPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endPortInput() {
    return this._endPort;
  }

  // port - computed: false, optional: true, required: false
  private _port?: string; 
  public get port() {
    return this.getStringAttribute('port');
  }
  public set port(value: string) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // protocol - computed: false, optional: true, required: false
  private _protocol?: string; 
  public get protocol() {
    return this.getStringAttribute('protocol');
  }
  public set protocol(value: string) {
    this._protocol = value;
  }
  public resetProtocol() {
    this._protocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolInput() {
    return this._protocol;
  }

  // source_end_port - computed: false, optional: true, required: false
  private _sourceEndPort?: number; 
  public get sourceEndPort() {
    return this.getNumberAttribute('source_end_port');
  }
  public set sourceEndPort(value: number) {
    this._sourceEndPort = value;
  }
  public resetSourceEndPort() {
    this._sourceEndPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceEndPortInput() {
    return this._sourceEndPort;
  }

  // source_port - computed: false, optional: true, required: false
  private _sourcePort?: number; 
  public get sourcePort() {
    return this.getNumberAttribute('source_port');
  }
  public set sourcePort(value: number) {
    this._sourcePort = value;
  }
  public resetSourcePort() {
    this._sourcePort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourcePortInput() {
    return this._sourcePort;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressPortsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressPorts[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressPortsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressPortsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressProtocolsIcmp {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#icmp_code DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#icmp_code}
  */
  readonly icmpCode?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#icmp_type DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#icmp_type}
  */
  readonly icmpType?: number;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressProtocolsIcmpToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressProtocolsIcmp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    icmp_code: cdktf.numberToTerraform(struct!.icmpCode),
    icmp_type: cdktf.numberToTerraform(struct!.icmpType),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressProtocolsIcmpToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressProtocolsIcmp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    icmp_code: {
      value: cdktf.numberToHclTerraform(struct!.icmpCode),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    icmp_type: {
      value: cdktf.numberToHclTerraform(struct!.icmpType),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressProtocolsIcmpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressProtocolsIcmp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._icmpCode !== undefined) {
      hasAnyValues = true;
      internalValueResult.icmpCode = this._icmpCode;
    }
    if (this._icmpType !== undefined) {
      hasAnyValues = true;
      internalValueResult.icmpType = this._icmpType;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressProtocolsIcmp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._icmpCode = undefined;
      this._icmpType = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._icmpCode = value.icmpCode;
      this._icmpType = value.icmpType;
    }
  }

  // icmp_code - computed: false, optional: true, required: false
  private _icmpCode?: number; 
  public get icmpCode() {
    return this.getNumberAttribute('icmp_code');
  }
  public set icmpCode(value: number) {
    this._icmpCode = value;
  }
  public resetIcmpCode() {
    this._icmpCode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get icmpCodeInput() {
    return this._icmpCode;
  }

  // icmp_type - computed: false, optional: true, required: false
  private _icmpType?: number; 
  public get icmpType() {
    return this.getNumberAttribute('icmp_type');
  }
  public set icmpType(value: number) {
    this._icmpType = value;
  }
  public resetIcmpType() {
    this._icmpType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get icmpTypeInput() {
    return this._icmpType;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressProtocolsIgmp {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#group_address DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#group_address}
  */
  readonly groupAddress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#igmp_type DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#igmp_type}
  */
  readonly igmpType?: number;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressProtocolsIgmpToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressProtocolsIgmp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    group_address: cdktf.stringToTerraform(struct!.groupAddress),
    igmp_type: cdktf.numberToTerraform(struct!.igmpType),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressProtocolsIgmpToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressProtocolsIgmp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    group_address: {
      value: cdktf.stringToHclTerraform(struct!.groupAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    igmp_type: {
      value: cdktf.numberToHclTerraform(struct!.igmpType),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressProtocolsIgmpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressProtocolsIgmp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._groupAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupAddress = this._groupAddress;
    }
    if (this._igmpType !== undefined) {
      hasAnyValues = true;
      internalValueResult.igmpType = this._igmpType;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressProtocolsIgmp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._groupAddress = undefined;
      this._igmpType = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._groupAddress = value.groupAddress;
      this._igmpType = value.igmpType;
    }
  }

  // group_address - computed: false, optional: true, required: false
  private _groupAddress?: string; 
  public get groupAddress() {
    return this.getStringAttribute('group_address');
  }
  public set groupAddress(value: string) {
    this._groupAddress = value;
  }
  public resetGroupAddress() {
    this._groupAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupAddressInput() {
    return this._groupAddress;
  }

  // igmp_type - computed: false, optional: true, required: false
  private _igmpType?: number; 
  public get igmpType() {
    return this.getNumberAttribute('igmp_type');
  }
  public set igmpType(value: number) {
    this._igmpType = value;
  }
  public resetIgmpType() {
    this._igmpType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get igmpTypeInput() {
    return this._igmpType;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressProtocols {
  /**
  * ICMPProtocol matches ICMP traffic with specific ICMPType and/or ICMPCode. All fields could be used alone or together. If all fields are not provided, this matches all ICMP traffic.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#icmp DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#icmp}
  */
  readonly icmp?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressProtocolsIcmp;
  /**
  * IGMPProtocol matches IGMP traffic with IGMPType and GroupAddress. IGMPType must be filled with: IGMPQuery int32 = 0x11 IGMPReportV1 int32 = 0x12 IGMPReportV2 int32 = 0x16 IGMPReportV3 int32 = 0x22 If groupAddress is empty, all groupAddresses will be matched.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#igmp DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#igmp}
  */
  readonly igmp?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressProtocolsIgmp;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressProtocolsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressProtocols | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    icmp: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressProtocolsIcmpToTerraform(struct!.icmp),
    igmp: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressProtocolsIgmpToTerraform(struct!.igmp),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressProtocolsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressProtocols | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    icmp: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressProtocolsIcmpToHclTerraform(struct!.icmp),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressProtocolsIcmp",
    },
    igmp: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressProtocolsIgmpToHclTerraform(struct!.igmp),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressProtocolsIgmp",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressProtocolsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressProtocols | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._icmp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.icmp = this._icmp?.internalValue;
    }
    if (this._igmp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.igmp = this._igmp?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressProtocols | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._icmp.internalValue = undefined;
      this._igmp.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._icmp.internalValue = value.icmp;
      this._igmp.internalValue = value.igmp;
    }
  }

  // icmp - computed: false, optional: true, required: false
  private _icmp = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressProtocolsIcmpOutputReference(this, "icmp");
  public get icmp() {
    return this._icmp;
  }
  public putIcmp(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressProtocolsIcmp) {
    this._icmp.internalValue = value;
  }
  public resetIcmp() {
    this._icmp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get icmpInput() {
    return this._icmp.internalValue;
  }

  // igmp - computed: false, optional: true, required: false
  private _igmp = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressProtocolsIgmpOutputReference(this, "igmp");
  public get igmp() {
    return this._igmp;
  }
  public putIgmp(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressProtocolsIgmp) {
    this._igmp.internalValue = value;
  }
  public resetIgmp() {
    this._igmp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get igmpInput() {
    return this._igmp.internalValue;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressProtocolsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressProtocols[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressProtocolsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressProtocolsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToExternalEntitySelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#key DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#operator DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#values DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToExternalEntitySelectorMatchExpressionsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToExternalEntitySelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToExternalEntitySelectorMatchExpressionsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToExternalEntitySelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToExternalEntitySelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToExternalEntitySelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToExternalEntitySelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToExternalEntitySelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToExternalEntitySelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToExternalEntitySelectorMatchExpressionsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToExternalEntitySelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToExternalEntitySelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match_expressions DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToExternalEntitySelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match_labels DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToExternalEntitySelectorToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToExternalEntitySelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToExternalEntitySelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToExternalEntitySelectorToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToExternalEntitySelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToExternalEntitySelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToExternalEntitySelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToExternalEntitySelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToExternalEntitySelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToExternalEntitySelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToExternalEntitySelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToExternalEntitySelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToIpBlock {
  /**
  * CIDR is a string representing the IP Block Valid examples are '192.168.1.0/24'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#cidr DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#cidr}
  */
  readonly cidr: string;
  /**
  * except is a slice of CIDRs that should not be included within an IPBlock Valid examples are '192.168.1.0/28' or '2001:db8::/64' Except values will be rejected if they are outside the cidr range
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#except DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#except}
  */
  readonly except?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToIpBlockToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToIpBlock | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cidr: cdktf.stringToTerraform(struct!.cidr),
    except: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.except),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToIpBlockToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToIpBlock | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cidr: {
      value: cdktf.stringToHclTerraform(struct!.cidr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    except: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.except),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToIpBlockOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToIpBlock | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cidr !== undefined) {
      hasAnyValues = true;
      internalValueResult.cidr = this._cidr;
    }
    if (this._except !== undefined) {
      hasAnyValues = true;
      internalValueResult.except = this._except;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToIpBlock | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cidr = undefined;
      this._except = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cidr = value.cidr;
      this._except = value.except;
    }
  }

  // cidr - computed: false, optional: false, required: true
  private _cidr?: string; 
  public get cidr() {
    return this.getStringAttribute('cidr');
  }
  public set cidr(value: string) {
    this._cidr = value;
  }
  // Temporarily expose input value. Use with caution.
  public get cidrInput() {
    return this._cidr;
  }

  // except - computed: false, optional: true, required: false
  private _except?: string[]; 
  public get except() {
    return this.getListAttribute('except');
  }
  public set except(value: string[]) {
    this._except = value;
  }
  public resetExcept() {
    this._except = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exceptInput() {
    return this._except;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNamespaceSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#key DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#operator DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#values DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNamespaceSelectorMatchExpressionsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNamespaceSelectorMatchExpressionsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNamespaceSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNamespaceSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNamespaceSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNamespaceSelectorMatchExpressionsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNamespaceSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNamespaceSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match_expressions DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNamespaceSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match_labels DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNamespaceSelectorToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNamespaceSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNamespaceSelectorToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNamespaceSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNamespaceSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNamespaceSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNamespaceSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNamespaceSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNamespaceSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNamespaceSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNamespaces {
  /**
  * Selects from the same Namespace of the appliedTo workloads.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match}
  */
  readonly match?: string;
  /**
  * Selects Namespaces that share the same values for the given set of label keys with the appliedTo Namespace. Namespaces must have all the label keys.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#same_labels DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#same_labels}
  */
  readonly sameLabels?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNamespacesToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNamespaces | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match: cdktf.stringToTerraform(struct!.match),
    same_labels: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.sameLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNamespacesToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNamespaces | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match: {
      value: cdktf.stringToHclTerraform(struct!.match),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    same_labels: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.sameLabels),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNamespacesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNamespaces | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._match !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match;
    }
    if (this._sameLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.sameLabels = this._sameLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNamespaces | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._match = undefined;
      this._sameLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._match = value.match;
      this._sameLabels = value.sameLabels;
    }
  }

  // match - computed: false, optional: true, required: false
  private _match?: string; 
  public get match() {
    return this.getStringAttribute('match');
  }
  public set match(value: string) {
    this._match = value;
  }
  public resetMatch() {
    this._match = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match;
  }

  // same_labels - computed: false, optional: true, required: false
  private _sameLabels?: string[]; 
  public get sameLabels() {
    return this.getListAttribute('same_labels');
  }
  public set sameLabels(value: string[]) {
    this._sameLabels = value;
  }
  public resetSameLabels() {
    this._sameLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sameLabelsInput() {
    return this._sameLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNodeSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#key DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#operator DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#values DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNodeSelectorMatchExpressionsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNodeSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNodeSelectorMatchExpressionsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNodeSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNodeSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNodeSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNodeSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNodeSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNodeSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNodeSelectorMatchExpressionsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNodeSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNodeSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match_expressions DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNodeSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match_labels DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNodeSelectorToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNodeSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNodeSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNodeSelectorToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNodeSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNodeSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNodeSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNodeSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNodeSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNodeSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNodeSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNodeSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToPodSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#key DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#operator DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#values DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToPodSelectorMatchExpressionsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToPodSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToPodSelectorMatchExpressionsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToPodSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToPodSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToPodSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToPodSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToPodSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToPodSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToPodSelectorMatchExpressionsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToPodSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToPodSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match_expressions DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToPodSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#match_labels DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToPodSelectorToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToPodSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToPodSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToPodSelectorToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToPodSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToPodSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToPodSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToPodSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToPodSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToPodSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToPodSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToPodSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToServiceAccount {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#name DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#namespace DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToServiceAccountToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToServiceAccount | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToServiceAccountToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToServiceAccount | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToServiceAccountOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToServiceAccount | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToServiceAccount | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressTo {
  /**
  * Select ExternalEntities from NetworkPolicy's Namespace as workloads in To/From fields. If set with NamespaceSelector, ExternalEntities are matched from Namespaces matched by the NamespaceSelector. Cannot be set with any other selector except NamespaceSelector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#external_entity_selector DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#external_entity_selector}
  */
  readonly externalEntitySelector?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToExternalEntitySelector;
  /**
  * Restrict egress access to the Fully Qualified Domain Names prescribed by name or by wildcard match patterns. This field can only be set for NetworkPolicyPeer of egress rules. Supported formats are: Exact FQDNs such as 'google.com'. Wildcard expressions such as '*wayfair.com'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#fqdn DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#fqdn}
  */
  readonly fqdn?: string;
  /**
  * Group is the name of the ClusterGroup which can be set within an Ingress or Egress rule in place of a stand-alone selector. A Group cannot be set with any other selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#group DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#group}
  */
  readonly group?: string;
  /**
  * IPBlock describes the IPAddresses/IPBlocks that is matched in to/from. IPBlock cannot be set as part of the AppliedTo field. Cannot be set with any other selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#ip_block DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#ip_block}
  */
  readonly ipBlock?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToIpBlock;
  /**
  * Select all Pods from Namespaces matched by this selector, as workloads in To/From fields. If set with PodSelector, Pods are matched from Namespaces matched by the NamespaceSelector. Cannot be set with any other selector except PodSelector or ExternalEntitySelector. Cannot be set with Namespaces.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#namespace_selector DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#namespace_selector}
  */
  readonly namespaceSelector?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNamespaceSelector;
  /**
  * Select Pod/ExternalEntity from Namespaces matched by specific criteria. Current supported criteria is match: Self, which selects from the same Namespace of the appliedTo workloads. Cannot be set with any other selector except PodSelector or ExternalEntitySelector. This field can only be set when NetworkPolicyPeer is created for ClusterNetworkPolicy ingress/egress rules. Cannot be set with NamespaceSelector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#namespaces DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#namespaces}
  */
  readonly namespaces?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNamespaces;
  /**
  * Select certain Nodes which match the label selector. A NodeSelector cannot be set with any other selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#node_selector DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#node_selector}
  */
  readonly nodeSelector?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNodeSelector;
  /**
  * Select Pods from NetworkPolicy's Namespace as workloads in To/From fields. If set with NamespaceSelector, Pods are matched from Namespaces matched by the NamespaceSelector. Cannot be set with any other selector except NamespaceSelector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#pod_selector DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#pod_selector}
  */
  readonly podSelector?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToPodSelector;
  /**
  * Define scope of the Pod/NamespaceSelector(s) of this peer. Can only be used in ingress NetworkPolicyPeers. Defaults to 'Cluster'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#scope DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#scope}
  */
  readonly scope?: string;
  /**
  * Select all Pods with the ServiceAccount matched by this field, as workloads in To/From fields. Cannot be set with any other selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#service_account DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#service_account}
  */
  readonly serviceAccount?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToServiceAccount;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressTo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    external_entity_selector: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToExternalEntitySelectorToTerraform(struct!.externalEntitySelector),
    fqdn: cdktf.stringToTerraform(struct!.fqdn),
    group: cdktf.stringToTerraform(struct!.group),
    ip_block: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToIpBlockToTerraform(struct!.ipBlock),
    namespace_selector: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNamespaceSelectorToTerraform(struct!.namespaceSelector),
    namespaces: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNamespacesToTerraform(struct!.namespaces),
    node_selector: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNodeSelectorToTerraform(struct!.nodeSelector),
    pod_selector: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToPodSelectorToTerraform(struct!.podSelector),
    scope: cdktf.stringToTerraform(struct!.scope),
    service_account: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToServiceAccountToTerraform(struct!.serviceAccount),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressTo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    external_entity_selector: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToExternalEntitySelectorToHclTerraform(struct!.externalEntitySelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToExternalEntitySelector",
    },
    fqdn: {
      value: cdktf.stringToHclTerraform(struct!.fqdn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    group: {
      value: cdktf.stringToHclTerraform(struct!.group),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_block: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToIpBlockToHclTerraform(struct!.ipBlock),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToIpBlock",
    },
    namespace_selector: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNamespaceSelectorToHclTerraform(struct!.namespaceSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNamespaceSelector",
    },
    namespaces: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNamespacesToHclTerraform(struct!.namespaces),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNamespaces",
    },
    node_selector: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNodeSelectorToHclTerraform(struct!.nodeSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNodeSelector",
    },
    pod_selector: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToPodSelectorToHclTerraform(struct!.podSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToPodSelector",
    },
    scope: {
      value: cdktf.stringToHclTerraform(struct!.scope),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    service_account: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToServiceAccountToHclTerraform(struct!.serviceAccount),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToServiceAccount",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressTo | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._externalEntitySelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.externalEntitySelector = this._externalEntitySelector?.internalValue;
    }
    if (this._fqdn !== undefined) {
      hasAnyValues = true;
      internalValueResult.fqdn = this._fqdn;
    }
    if (this._group !== undefined) {
      hasAnyValues = true;
      internalValueResult.group = this._group;
    }
    if (this._ipBlock?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipBlock = this._ipBlock?.internalValue;
    }
    if (this._namespaceSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaceSelector = this._namespaceSelector?.internalValue;
    }
    if (this._namespaces?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaces = this._namespaces?.internalValue;
    }
    if (this._nodeSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeSelector = this._nodeSelector?.internalValue;
    }
    if (this._podSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.podSelector = this._podSelector?.internalValue;
    }
    if (this._scope !== undefined) {
      hasAnyValues = true;
      internalValueResult.scope = this._scope;
    }
    if (this._serviceAccount?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccount = this._serviceAccount?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressTo | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._externalEntitySelector.internalValue = undefined;
      this._fqdn = undefined;
      this._group = undefined;
      this._ipBlock.internalValue = undefined;
      this._namespaceSelector.internalValue = undefined;
      this._namespaces.internalValue = undefined;
      this._nodeSelector.internalValue = undefined;
      this._podSelector.internalValue = undefined;
      this._scope = undefined;
      this._serviceAccount.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._externalEntitySelector.internalValue = value.externalEntitySelector;
      this._fqdn = value.fqdn;
      this._group = value.group;
      this._ipBlock.internalValue = value.ipBlock;
      this._namespaceSelector.internalValue = value.namespaceSelector;
      this._namespaces.internalValue = value.namespaces;
      this._nodeSelector.internalValue = value.nodeSelector;
      this._podSelector.internalValue = value.podSelector;
      this._scope = value.scope;
      this._serviceAccount.internalValue = value.serviceAccount;
    }
  }

  // external_entity_selector - computed: false, optional: true, required: false
  private _externalEntitySelector = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToExternalEntitySelectorOutputReference(this, "external_entity_selector");
  public get externalEntitySelector() {
    return this._externalEntitySelector;
  }
  public putExternalEntitySelector(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToExternalEntitySelector) {
    this._externalEntitySelector.internalValue = value;
  }
  public resetExternalEntitySelector() {
    this._externalEntitySelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get externalEntitySelectorInput() {
    return this._externalEntitySelector.internalValue;
  }

  // fqdn - computed: false, optional: true, required: false
  private _fqdn?: string; 
  public get fqdn() {
    return this.getStringAttribute('fqdn');
  }
  public set fqdn(value: string) {
    this._fqdn = value;
  }
  public resetFqdn() {
    this._fqdn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fqdnInput() {
    return this._fqdn;
  }

  // group - computed: false, optional: true, required: false
  private _group?: string; 
  public get group() {
    return this.getStringAttribute('group');
  }
  public set group(value: string) {
    this._group = value;
  }
  public resetGroup() {
    this._group = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupInput() {
    return this._group;
  }

  // ip_block - computed: false, optional: true, required: false
  private _ipBlock = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToIpBlockOutputReference(this, "ip_block");
  public get ipBlock() {
    return this._ipBlock;
  }
  public putIpBlock(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToIpBlock) {
    this._ipBlock.internalValue = value;
  }
  public resetIpBlock() {
    this._ipBlock.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipBlockInput() {
    return this._ipBlock.internalValue;
  }

  // namespace_selector - computed: false, optional: true, required: false
  private _namespaceSelector = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNamespaceSelectorOutputReference(this, "namespace_selector");
  public get namespaceSelector() {
    return this._namespaceSelector;
  }
  public putNamespaceSelector(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNamespaceSelector) {
    this._namespaceSelector.internalValue = value;
  }
  public resetNamespaceSelector() {
    this._namespaceSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceSelectorInput() {
    return this._namespaceSelector.internalValue;
  }

  // namespaces - computed: false, optional: true, required: false
  private _namespaces = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNamespacesOutputReference(this, "namespaces");
  public get namespaces() {
    return this._namespaces;
  }
  public putNamespaces(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNamespaces) {
    this._namespaces.internalValue = value;
  }
  public resetNamespaces() {
    this._namespaces.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespacesInput() {
    return this._namespaces.internalValue;
  }

  // node_selector - computed: false, optional: true, required: false
  private _nodeSelector = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNodeSelectorOutputReference(this, "node_selector");
  public get nodeSelector() {
    return this._nodeSelector;
  }
  public putNodeSelector(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToNodeSelector) {
    this._nodeSelector.internalValue = value;
  }
  public resetNodeSelector() {
    this._nodeSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeSelectorInput() {
    return this._nodeSelector.internalValue;
  }

  // pod_selector - computed: false, optional: true, required: false
  private _podSelector = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToPodSelectorOutputReference(this, "pod_selector");
  public get podSelector() {
    return this._podSelector;
  }
  public putPodSelector(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToPodSelector) {
    this._podSelector.internalValue = value;
  }
  public resetPodSelector() {
    this._podSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podSelectorInput() {
    return this._podSelector.internalValue;
  }

  // scope - computed: false, optional: true, required: false
  private _scope?: string; 
  public get scope() {
    return this.getStringAttribute('scope');
  }
  public set scope(value: string) {
    this._scope = value;
  }
  public resetScope() {
    this._scope = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scopeInput() {
    return this._scope;
  }

  // service_account - computed: false, optional: true, required: false
  private _serviceAccount = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToServiceAccountOutputReference(this, "service_account");
  public get serviceAccount() {
    return this._serviceAccount;
  }
  public putServiceAccount(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToServiceAccount) {
    this._serviceAccount.internalValue = value;
  }
  public resetServiceAccount() {
    this._serviceAccount.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountInput() {
    return this._serviceAccount.internalValue;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressTo[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToServices {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#name DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#namespace DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#namespace}
  */
  readonly namespace?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#scope DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#scope}
  */
  readonly scope?: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToServicesToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToServices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    scope: cdktf.stringToTerraform(struct!.scope),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToServicesToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToServices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    scope: {
      value: cdktf.stringToHclTerraform(struct!.scope),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToServicesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToServices | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._scope !== undefined) {
      hasAnyValues = true;
      internalValueResult.scope = this._scope;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToServices | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
      this._scope = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
      this._scope = value.scope;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // scope - computed: false, optional: true, required: false
  private _scope?: string; 
  public get scope() {
    return this.getStringAttribute('scope');
  }
  public set scope(value: string) {
    this._scope = value;
  }
  public resetScope() {
    this._scope = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scopeInput() {
    return this._scope;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToServicesList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToServices[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToServicesOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToServicesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngress {
  /**
  * Action specifies the action to be applied on the rule.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#action DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#action}
  */
  readonly action: string;
  /**
  * Select workloads on which this rule will be applied to. Cannot be set in conjunction with NetworkPolicySpec/ClusterNetworkPolicySpec.AppliedTo.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#applied_to DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#applied_to}
  */
  readonly appliedTo?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedTo[] | cdktf.IResolvable;
  /**
  * EnableLogging is used to indicate if agent should generate logs when rules are matched. Should be default to false.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#enable_logging DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#enable_logging}
  */
  readonly enableLogging?: boolean | cdktf.IResolvable;
  /**
  * Rule is matched if traffic originates from workloads selected by this field. If this field is empty, this rule matches all sources.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#from DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#from}
  */
  readonly from?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFrom[] | cdktf.IResolvable;
  /**
  * Set of layer 7 protocols matched by the rule. If this field is set, action can only be Allow. When this field is used in a rule, any traffic matching the other layer 3/4 criteria of the rule (typically the 5-tuple) will be forwarded to an application-aware engine for protocol detection and rule enforcement, and the traffic will be allowed if the layer 7 criteria is also matched, otherwise it will be dropped. Therefore, any rules after a layer 7 rule will not be enforced for the traffic.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#l7_protocols DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#l7_protocols}
  */
  readonly l7Protocols?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressL7Protocols[] | cdktf.IResolvable;
  /**
  * LogLabel is a user-defined arbitrary string which will be printed in the NetworkPolicy logs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#log_label DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#log_label}
  */
  readonly logLabel?: string;
  /**
  * Name describes the intention of this rule. Name should be unique within the policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#name DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Set of ports and protocols matched by the rule. If this field and Protocols are unset or empty, this rule matches all ports.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#ports DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#ports}
  */
  readonly ports?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressPorts[] | cdktf.IResolvable;
  /**
  * Set of protocols matched by the rule. If this field and Ports are unset or empty, this rule matches all protocols supported.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#protocols DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#protocols}
  */
  readonly protocols?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressProtocols[] | cdktf.IResolvable;
  /**
  * Rule is matched if traffic is intended for workloads selected by this field. This field can't be used with ToServices. If this field and ToServices are both empty or missing this rule matches all destinations.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#to DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#to}
  */
  readonly to?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressTo[] | cdktf.IResolvable;
  /**
  * Rule is matched if traffic is intended for a Service listed in this field. Currently, only ClusterIP types Services are supported in this field. When scope is set to ClusterSet, it matches traffic intended for a multi-cluster Service listed in this field. Service name and Namespace provided should match the original exported Service. This field can only be used when AntreaProxy is enabled. This field can't be used with To or Ports. If this field and To are both empty or missing, this rule matches all destinations.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#to_services DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#to_services}
  */
  readonly toServices?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToServices[] | cdktf.IResolvable;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    applied_to: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToToTerraform, false)(struct!.appliedTo),
    enable_logging: cdktf.booleanToTerraform(struct!.enableLogging),
    from: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromToTerraform, false)(struct!.from),
    l7_protocols: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressL7ProtocolsToTerraform, false)(struct!.l7Protocols),
    log_label: cdktf.stringToTerraform(struct!.logLabel),
    name: cdktf.stringToTerraform(struct!.name),
    ports: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressPortsToTerraform, false)(struct!.ports),
    protocols: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressProtocolsToTerraform, false)(struct!.protocols),
    to: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToToTerraform, false)(struct!.to),
    to_services: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToServicesToTerraform, false)(struct!.toServices),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    applied_to: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToToHclTerraform, false)(struct!.appliedTo),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToList",
    },
    enable_logging: {
      value: cdktf.booleanToHclTerraform(struct!.enableLogging),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    from: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromToHclTerraform, false)(struct!.from),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromList",
    },
    l7_protocols: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressL7ProtocolsToHclTerraform, false)(struct!.l7Protocols),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressL7ProtocolsList",
    },
    log_label: {
      value: cdktf.stringToHclTerraform(struct!.logLabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ports: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressPortsToHclTerraform, false)(struct!.ports),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressPortsList",
    },
    protocols: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressProtocolsToHclTerraform, false)(struct!.protocols),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressProtocolsList",
    },
    to: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToToHclTerraform, false)(struct!.to),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToList",
    },
    to_services: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToServicesToHclTerraform, false)(struct!.toServices),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToServicesList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._appliedTo?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.appliedTo = this._appliedTo?.internalValue;
    }
    if (this._enableLogging !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableLogging = this._enableLogging;
    }
    if (this._from?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.from = this._from?.internalValue;
    }
    if (this._l7Protocols?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.l7Protocols = this._l7Protocols?.internalValue;
    }
    if (this._logLabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.logLabel = this._logLabel;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._ports?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ports = this._ports?.internalValue;
    }
    if (this._protocols?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocols = this._protocols?.internalValue;
    }
    if (this._to?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.to = this._to?.internalValue;
    }
    if (this._toServices?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.toServices = this._toServices?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._appliedTo.internalValue = undefined;
      this._enableLogging = undefined;
      this._from.internalValue = undefined;
      this._l7Protocols.internalValue = undefined;
      this._logLabel = undefined;
      this._name = undefined;
      this._ports.internalValue = undefined;
      this._protocols.internalValue = undefined;
      this._to.internalValue = undefined;
      this._toServices.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._appliedTo.internalValue = value.appliedTo;
      this._enableLogging = value.enableLogging;
      this._from.internalValue = value.from;
      this._l7Protocols.internalValue = value.l7Protocols;
      this._logLabel = value.logLabel;
      this._name = value.name;
      this._ports.internalValue = value.ports;
      this._protocols.internalValue = value.protocols;
      this._to.internalValue = value.to;
      this._toServices.internalValue = value.toServices;
    }
  }

  // action - computed: false, optional: false, required: true
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // applied_to - computed: false, optional: true, required: false
  private _appliedTo = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedToList(this, "applied_to", false);
  public get appliedTo() {
    return this._appliedTo;
  }
  public putAppliedTo(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressAppliedTo[] | cdktf.IResolvable) {
    this._appliedTo.internalValue = value;
  }
  public resetAppliedTo() {
    this._appliedTo.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appliedToInput() {
    return this._appliedTo.internalValue;
  }

  // enable_logging - computed: false, optional: true, required: false
  private _enableLogging?: boolean | cdktf.IResolvable; 
  public get enableLogging() {
    return this.getBooleanAttribute('enable_logging');
  }
  public set enableLogging(value: boolean | cdktf.IResolvable) {
    this._enableLogging = value;
  }
  public resetEnableLogging() {
    this._enableLogging = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableLoggingInput() {
    return this._enableLogging;
  }

  // from - computed: false, optional: true, required: false
  private _from = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFromList(this, "from", false);
  public get from() {
    return this._from;
  }
  public putFrom(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressFrom[] | cdktf.IResolvable) {
    this._from.internalValue = value;
  }
  public resetFrom() {
    this._from.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fromInput() {
    return this._from.internalValue;
  }

  // l7_protocols - computed: false, optional: true, required: false
  private _l7Protocols = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressL7ProtocolsList(this, "l7_protocols", false);
  public get l7Protocols() {
    return this._l7Protocols;
  }
  public putL7Protocols(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressL7Protocols[] | cdktf.IResolvable) {
    this._l7Protocols.internalValue = value;
  }
  public resetL7Protocols() {
    this._l7Protocols.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get l7ProtocolsInput() {
    return this._l7Protocols.internalValue;
  }

  // log_label - computed: false, optional: true, required: false
  private _logLabel?: string; 
  public get logLabel() {
    return this.getStringAttribute('log_label');
  }
  public set logLabel(value: string) {
    this._logLabel = value;
  }
  public resetLogLabel() {
    this._logLabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logLabelInput() {
    return this._logLabel;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // ports - computed: false, optional: true, required: false
  private _ports = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressPortsList(this, "ports", false);
  public get ports() {
    return this._ports;
  }
  public putPorts(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressPorts[] | cdktf.IResolvable) {
    this._ports.internalValue = value;
  }
  public resetPorts() {
    this._ports.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portsInput() {
    return this._ports.internalValue;
  }

  // protocols - computed: false, optional: true, required: false
  private _protocols = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressProtocolsList(this, "protocols", false);
  public get protocols() {
    return this._protocols;
  }
  public putProtocols(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressProtocols[] | cdktf.IResolvable) {
    this._protocols.internalValue = value;
  }
  public resetProtocols() {
    this._protocols.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolsInput() {
    return this._protocols.internalValue;
  }

  // to - computed: false, optional: true, required: false
  private _to = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToList(this, "to", false);
  public get to() {
    return this._to;
  }
  public putTo(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressTo[] | cdktf.IResolvable) {
    this._to.internalValue = value;
  }
  public resetTo() {
    this._to.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get toInput() {
    return this._to.internalValue;
  }

  // to_services - computed: false, optional: true, required: false
  private _toServices = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToServicesList(this, "to_services", false);
  public get toServices() {
    return this._toServices;
  }
  public putToServices(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToServices[] | cdktf.IResolvable) {
    this._toServices.internalValue = value;
  }
  public resetToServices() {
    this._toServices.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get toServicesInput() {
    return this._toServices.internalValue;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngress[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicy {
  /**
  * Select workloads on which the rules will be applied to. Cannot be set in conjunction with AppliedTo in each rule.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#applied_to DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#applied_to}
  */
  readonly appliedTo?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedTo[] | cdktf.IResolvable;
  /**
  * Set of egress rules evaluated based on the order in which they are set. Currently Egress rule supports setting the 'To' field but not the 'From' field within a Rule.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#egress DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#egress}
  */
  readonly egress?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgress[] | cdktf.IResolvable;
  /**
  * Set of ingress rules evaluated based on the order in which they are set. Currently Ingress rule supports setting the 'From' field but not the 'To' field within a Rule.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#ingress DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#ingress}
  */
  readonly ingress?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngress[] | cdktf.IResolvable;
  /**
  * Priority specfies the order of the ClusterNetworkPolicy relative to other AntreaClusterNetworkPolicies.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#priority DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#priority}
  */
  readonly priority: number;
  /**
  * Tier specifies the tier to which this ClusterNetworkPolicy belongs to. The ClusterNetworkPolicy order will be determined based on the combination of the Tier's Priority and the ClusterNetworkPolicy's own Priority. If not specified, this policy will be created in the Application Tier right above the K8s NetworkPolicy which resides at the bottom.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#tier DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#tier}
  */
  readonly tier?: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicy | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    applied_to: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToToTerraform, false)(struct!.appliedTo),
    egress: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToTerraform, false)(struct!.egress),
    ingress: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToTerraform, false)(struct!.ingress),
    priority: cdktf.numberToTerraform(struct!.priority),
    tier: cdktf.stringToTerraform(struct!.tier),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicy | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    applied_to: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToToHclTerraform, false)(struct!.appliedTo),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToList",
    },
    egress: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressToHclTerraform, false)(struct!.egress),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressList",
    },
    ingress: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressToHclTerraform, false)(struct!.ingress),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressList",
    },
    priority: {
      value: cdktf.numberToHclTerraform(struct!.priority),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    tier: {
      value: cdktf.stringToHclTerraform(struct!.tier),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicy | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._appliedTo?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.appliedTo = this._appliedTo?.internalValue;
    }
    if (this._egress?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.egress = this._egress?.internalValue;
    }
    if (this._ingress?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ingress = this._ingress?.internalValue;
    }
    if (this._priority !== undefined) {
      hasAnyValues = true;
      internalValueResult.priority = this._priority;
    }
    if (this._tier !== undefined) {
      hasAnyValues = true;
      internalValueResult.tier = this._tier;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicy | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._appliedTo.internalValue = undefined;
      this._egress.internalValue = undefined;
      this._ingress.internalValue = undefined;
      this._priority = undefined;
      this._tier = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._appliedTo.internalValue = value.appliedTo;
      this._egress.internalValue = value.egress;
      this._ingress.internalValue = value.ingress;
      this._priority = value.priority;
      this._tier = value.tier;
    }
  }

  // applied_to - computed: false, optional: true, required: false
  private _appliedTo = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedToList(this, "applied_to", false);
  public get appliedTo() {
    return this._appliedTo;
  }
  public putAppliedTo(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyAppliedTo[] | cdktf.IResolvable) {
    this._appliedTo.internalValue = value;
  }
  public resetAppliedTo() {
    this._appliedTo.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appliedToInput() {
    return this._appliedTo.internalValue;
  }

  // egress - computed: false, optional: true, required: false
  private _egress = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgressList(this, "egress", false);
  public get egress() {
    return this._egress;
  }
  public putEgress(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyEgress[] | cdktf.IResolvable) {
    this._egress.internalValue = value;
  }
  public resetEgress() {
    this._egress.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressInput() {
    return this._egress.internalValue;
  }

  // ingress - computed: false, optional: true, required: false
  private _ingress = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngressList(this, "ingress", false);
  public get ingress() {
    return this._ingress;
  }
  public putIngress(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyIngress[] | cdktf.IResolvable) {
    this._ingress.internalValue = value;
  }
  public resetIngress() {
    this._ingress.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ingressInput() {
    return this._ingress.internalValue;
  }

  // priority - computed: false, optional: false, required: true
  private _priority?: number; 
  public get priority() {
    return this.getNumberAttribute('priority');
  }
  public set priority(value: number) {
    this._priority = value;
  }
  // Temporarily expose input value. Use with caution.
  public get priorityInput() {
    return this._priority;
  }

  // tier - computed: false, optional: true, required: false
  private _tier?: string; 
  public get tier() {
    return this.getStringAttribute('tier');
  }
  public set tier(value: string) {
    this._tier = value;
  }
  public resetTier() {
    this._tier = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tierInput() {
    return this._tier;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsAddressesTargetRef {
  /**
  * API version of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#api_version DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#api_version}
  */
  readonly apiVersion?: string;
  /**
  * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: 'spec.containers{name}' (where 'name' refers to the name of the container that triggered the event) or if no container name is specified 'spec.containers[2]' (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#field_path DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#field_path}
  */
  readonly fieldPath?: string;
  /**
  * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#kind DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#kind}
  */
  readonly kind?: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#name DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#namespace DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#namespace}
  */
  readonly namespace?: string;
  /**
  * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#resource_version DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#resource_version}
  */
  readonly resourceVersion?: string;
  /**
  * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#uid DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#uid}
  */
  readonly uid?: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsAddressesTargetRefToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsAddressesTargetRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    field_path: cdktf.stringToTerraform(struct!.fieldPath),
    kind: cdktf.stringToTerraform(struct!.kind),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    resource_version: cdktf.stringToTerraform(struct!.resourceVersion),
    uid: cdktf.stringToTerraform(struct!.uid),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsAddressesTargetRefToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsAddressesTargetRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    field_path: {
      value: cdktf.stringToHclTerraform(struct!.fieldPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kind: {
      value: cdktf.stringToHclTerraform(struct!.kind),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    resource_version: {
      value: cdktf.stringToHclTerraform(struct!.resourceVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    uid: {
      value: cdktf.stringToHclTerraform(struct!.uid),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsAddressesTargetRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsAddressesTargetRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._fieldPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.fieldPath = this._fieldPath;
    }
    if (this._kind !== undefined) {
      hasAnyValues = true;
      internalValueResult.kind = this._kind;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._resourceVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.resourceVersion = this._resourceVersion;
    }
    if (this._uid !== undefined) {
      hasAnyValues = true;
      internalValueResult.uid = this._uid;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsAddressesTargetRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiVersion = undefined;
      this._fieldPath = undefined;
      this._kind = undefined;
      this._name = undefined;
      this._namespace = undefined;
      this._resourceVersion = undefined;
      this._uid = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiVersion = value.apiVersion;
      this._fieldPath = value.fieldPath;
      this._kind = value.kind;
      this._name = value.name;
      this._namespace = value.namespace;
      this._resourceVersion = value.resourceVersion;
      this._uid = value.uid;
    }
  }

  // api_version - computed: false, optional: true, required: false
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  public resetApiVersion() {
    this._apiVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // field_path - computed: false, optional: true, required: false
  private _fieldPath?: string; 
  public get fieldPath() {
    return this.getStringAttribute('field_path');
  }
  public set fieldPath(value: string) {
    this._fieldPath = value;
  }
  public resetFieldPath() {
    this._fieldPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldPathInput() {
    return this._fieldPath;
  }

  // kind - computed: false, optional: true, required: false
  private _kind?: string; 
  public get kind() {
    return this.getStringAttribute('kind');
  }
  public set kind(value: string) {
    this._kind = value;
  }
  public resetKind() {
    this._kind = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kindInput() {
    return this._kind;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // resource_version - computed: false, optional: true, required: false
  private _resourceVersion?: string; 
  public get resourceVersion() {
    return this.getStringAttribute('resource_version');
  }
  public set resourceVersion(value: string) {
    this._resourceVersion = value;
  }
  public resetResourceVersion() {
    this._resourceVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceVersionInput() {
    return this._resourceVersion;
  }

  // uid - computed: false, optional: true, required: false
  private _uid?: string; 
  public get uid() {
    return this.getStringAttribute('uid');
  }
  public set uid(value: string) {
    this._uid = value;
  }
  public resetUid() {
    this._uid = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get uidInput() {
    return this._uid;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsAddresses {
  /**
  * The Hostname of this endpoint
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#hostname DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#hostname}
  */
  readonly hostname?: string;
  /**
  * The IP of this endpoint. May not be loopback (127.0.0.0/8 or ::1), link-local (169.254.0.0/16 or fe80::/10), or link-local multicast (224.0.0.0/24 or ff02::/16).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#ip DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#ip}
  */
  readonly ip: string;
  /**
  * Optional: Node hosting this endpoint. This can be used to determine endpoints local to a node.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#node_name DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#node_name}
  */
  readonly nodeName?: string;
  /**
  * Reference to object providing the endpoint.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#target_ref DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#target_ref}
  */
  readonly targetRef?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsAddressesTargetRef;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsAddressesToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsAddresses | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    hostname: cdktf.stringToTerraform(struct!.hostname),
    ip: cdktf.stringToTerraform(struct!.ip),
    node_name: cdktf.stringToTerraform(struct!.nodeName),
    target_ref: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsAddressesTargetRefToTerraform(struct!.targetRef),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsAddressesToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsAddresses | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip: {
      value: cdktf.stringToHclTerraform(struct!.ip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    node_name: {
      value: cdktf.stringToHclTerraform(struct!.nodeName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    target_ref: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsAddressesTargetRefToHclTerraform(struct!.targetRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsAddressesTargetRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsAddressesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsAddresses | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._ip !== undefined) {
      hasAnyValues = true;
      internalValueResult.ip = this._ip;
    }
    if (this._nodeName !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeName = this._nodeName;
    }
    if (this._targetRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.targetRef = this._targetRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsAddresses | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._hostname = undefined;
      this._ip = undefined;
      this._nodeName = undefined;
      this._targetRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._hostname = value.hostname;
      this._ip = value.ip;
      this._nodeName = value.nodeName;
      this._targetRef.internalValue = value.targetRef;
    }
  }

  // hostname - computed: false, optional: true, required: false
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  public resetHostname() {
    this._hostname = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // ip - computed: false, optional: false, required: true
  private _ip?: string; 
  public get ip() {
    return this.getStringAttribute('ip');
  }
  public set ip(value: string) {
    this._ip = value;
  }
  // Temporarily expose input value. Use with caution.
  public get ipInput() {
    return this._ip;
  }

  // node_name - computed: false, optional: true, required: false
  private _nodeName?: string; 
  public get nodeName() {
    return this.getStringAttribute('node_name');
  }
  public set nodeName(value: string) {
    this._nodeName = value;
  }
  public resetNodeName() {
    this._nodeName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeNameInput() {
    return this._nodeName;
  }

  // target_ref - computed: false, optional: true, required: false
  private _targetRef = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsAddressesTargetRefOutputReference(this, "target_ref");
  public get targetRef() {
    return this._targetRef;
  }
  public putTargetRef(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsAddressesTargetRef) {
    this._targetRef.internalValue = value;
  }
  public resetTargetRef() {
    this._targetRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetRefInput() {
    return this._targetRef.internalValue;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsAddressesList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsAddresses[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsAddressesOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsAddressesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddressesTargetRef {
  /**
  * API version of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#api_version DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#api_version}
  */
  readonly apiVersion?: string;
  /**
  * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: 'spec.containers{name}' (where 'name' refers to the name of the container that triggered the event) or if no container name is specified 'spec.containers[2]' (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#field_path DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#field_path}
  */
  readonly fieldPath?: string;
  /**
  * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#kind DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#kind}
  */
  readonly kind?: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#name DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#namespace DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#namespace}
  */
  readonly namespace?: string;
  /**
  * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#resource_version DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#resource_version}
  */
  readonly resourceVersion?: string;
  /**
  * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#uid DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#uid}
  */
  readonly uid?: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddressesTargetRefToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddressesTargetRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    field_path: cdktf.stringToTerraform(struct!.fieldPath),
    kind: cdktf.stringToTerraform(struct!.kind),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    resource_version: cdktf.stringToTerraform(struct!.resourceVersion),
    uid: cdktf.stringToTerraform(struct!.uid),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddressesTargetRefToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddressesTargetRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    field_path: {
      value: cdktf.stringToHclTerraform(struct!.fieldPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kind: {
      value: cdktf.stringToHclTerraform(struct!.kind),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    resource_version: {
      value: cdktf.stringToHclTerraform(struct!.resourceVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    uid: {
      value: cdktf.stringToHclTerraform(struct!.uid),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddressesTargetRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddressesTargetRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._fieldPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.fieldPath = this._fieldPath;
    }
    if (this._kind !== undefined) {
      hasAnyValues = true;
      internalValueResult.kind = this._kind;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._resourceVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.resourceVersion = this._resourceVersion;
    }
    if (this._uid !== undefined) {
      hasAnyValues = true;
      internalValueResult.uid = this._uid;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddressesTargetRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiVersion = undefined;
      this._fieldPath = undefined;
      this._kind = undefined;
      this._name = undefined;
      this._namespace = undefined;
      this._resourceVersion = undefined;
      this._uid = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiVersion = value.apiVersion;
      this._fieldPath = value.fieldPath;
      this._kind = value.kind;
      this._name = value.name;
      this._namespace = value.namespace;
      this._resourceVersion = value.resourceVersion;
      this._uid = value.uid;
    }
  }

  // api_version - computed: false, optional: true, required: false
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  public resetApiVersion() {
    this._apiVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // field_path - computed: false, optional: true, required: false
  private _fieldPath?: string; 
  public get fieldPath() {
    return this.getStringAttribute('field_path');
  }
  public set fieldPath(value: string) {
    this._fieldPath = value;
  }
  public resetFieldPath() {
    this._fieldPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldPathInput() {
    return this._fieldPath;
  }

  // kind - computed: false, optional: true, required: false
  private _kind?: string; 
  public get kind() {
    return this.getStringAttribute('kind');
  }
  public set kind(value: string) {
    this._kind = value;
  }
  public resetKind() {
    this._kind = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kindInput() {
    return this._kind;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // resource_version - computed: false, optional: true, required: false
  private _resourceVersion?: string; 
  public get resourceVersion() {
    return this.getStringAttribute('resource_version');
  }
  public set resourceVersion(value: string) {
    this._resourceVersion = value;
  }
  public resetResourceVersion() {
    this._resourceVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceVersionInput() {
    return this._resourceVersion;
  }

  // uid - computed: false, optional: true, required: false
  private _uid?: string; 
  public get uid() {
    return this.getStringAttribute('uid');
  }
  public set uid(value: string) {
    this._uid = value;
  }
  public resetUid() {
    this._uid = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get uidInput() {
    return this._uid;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddresses {
  /**
  * The Hostname of this endpoint
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#hostname DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#hostname}
  */
  readonly hostname?: string;
  /**
  * The IP of this endpoint. May not be loopback (127.0.0.0/8 or ::1), link-local (169.254.0.0/16 or fe80::/10), or link-local multicast (224.0.0.0/24 or ff02::/16).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#ip DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#ip}
  */
  readonly ip: string;
  /**
  * Optional: Node hosting this endpoint. This can be used to determine endpoints local to a node.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#node_name DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#node_name}
  */
  readonly nodeName?: string;
  /**
  * Reference to object providing the endpoint.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#target_ref DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#target_ref}
  */
  readonly targetRef?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddressesTargetRef;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddressesToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddresses | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    hostname: cdktf.stringToTerraform(struct!.hostname),
    ip: cdktf.stringToTerraform(struct!.ip),
    node_name: cdktf.stringToTerraform(struct!.nodeName),
    target_ref: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddressesTargetRefToTerraform(struct!.targetRef),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddressesToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddresses | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip: {
      value: cdktf.stringToHclTerraform(struct!.ip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    node_name: {
      value: cdktf.stringToHclTerraform(struct!.nodeName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    target_ref: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddressesTargetRefToHclTerraform(struct!.targetRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddressesTargetRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddressesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddresses | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._ip !== undefined) {
      hasAnyValues = true;
      internalValueResult.ip = this._ip;
    }
    if (this._nodeName !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeName = this._nodeName;
    }
    if (this._targetRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.targetRef = this._targetRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddresses | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._hostname = undefined;
      this._ip = undefined;
      this._nodeName = undefined;
      this._targetRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._hostname = value.hostname;
      this._ip = value.ip;
      this._nodeName = value.nodeName;
      this._targetRef.internalValue = value.targetRef;
    }
  }

  // hostname - computed: false, optional: true, required: false
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  public resetHostname() {
    this._hostname = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // ip - computed: false, optional: false, required: true
  private _ip?: string; 
  public get ip() {
    return this.getStringAttribute('ip');
  }
  public set ip(value: string) {
    this._ip = value;
  }
  // Temporarily expose input value. Use with caution.
  public get ipInput() {
    return this._ip;
  }

  // node_name - computed: false, optional: true, required: false
  private _nodeName?: string; 
  public get nodeName() {
    return this.getStringAttribute('node_name');
  }
  public set nodeName(value: string) {
    this._nodeName = value;
  }
  public resetNodeName() {
    this._nodeName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeNameInput() {
    return this._nodeName;
  }

  // target_ref - computed: false, optional: true, required: false
  private _targetRef = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddressesTargetRefOutputReference(this, "target_ref");
  public get targetRef() {
    return this._targetRef;
  }
  public putTargetRef(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddressesTargetRef) {
    this._targetRef.internalValue = value;
  }
  public resetTargetRef() {
    this._targetRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetRefInput() {
    return this._targetRef.internalValue;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddressesList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddresses[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddressesOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddressesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsPorts {
  /**
  * The application protocol for this port. This is used as a hint for implementations to offer richer behavior for protocols that they understand. This field follows standard Kubernetes label syntax. Valid values are either: * Un-prefixed protocol names - reserved for IANA standard service names (as per RFC-6335 and https://www.iana.org/assignments/service-names). * Kubernetes-defined prefixed names: * 'kubernetes.io/h2c' - HTTP/2 prior knowledge over cleartext as described in https://www.rfc-editor.org/rfc/rfc9113.html#name-starting-http-2-with-prior- * 'kubernetes.io/ws' - WebSocket over cleartext as described in https://www.rfc-editor.org/rfc/rfc6455 * 'kubernetes.io/wss' - WebSocket over TLS as described in https://www.rfc-editor.org/rfc/rfc6455 * Other protocols should use implementation-defined prefixed names such as mycompany.com/my-custom-protocol.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#app_protocol DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#app_protocol}
  */
  readonly appProtocol?: string;
  /**
  * The name of this port. This must match the 'name' field in the corresponding ServicePort. Must be a DNS_LABEL. Optional only if one port is defined.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#name DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * The port number of the endpoint.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#port DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#port}
  */
  readonly port: number;
  /**
  * The IP protocol for this port. Must be UDP, TCP, or SCTP. Default is TCP.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#protocol DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#protocol}
  */
  readonly protocol?: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsPortsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsPorts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    app_protocol: cdktf.stringToTerraform(struct!.appProtocol),
    name: cdktf.stringToTerraform(struct!.name),
    port: cdktf.numberToTerraform(struct!.port),
    protocol: cdktf.stringToTerraform(struct!.protocol),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsPortsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsPorts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    app_protocol: {
      value: cdktf.stringToHclTerraform(struct!.appProtocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    protocol: {
      value: cdktf.stringToHclTerraform(struct!.protocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsPortsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsPorts | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._appProtocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.appProtocol = this._appProtocol;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._protocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocol = this._protocol;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsPorts | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._appProtocol = undefined;
      this._name = undefined;
      this._port = undefined;
      this._protocol = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._appProtocol = value.appProtocol;
      this._name = value.name;
      this._port = value.port;
      this._protocol = value.protocol;
    }
  }

  // app_protocol - computed: false, optional: true, required: false
  private _appProtocol?: string; 
  public get appProtocol() {
    return this.getStringAttribute('app_protocol');
  }
  public set appProtocol(value: string) {
    this._appProtocol = value;
  }
  public resetAppProtocol() {
    this._appProtocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appProtocolInput() {
    return this._appProtocol;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // protocol - computed: false, optional: true, required: false
  private _protocol?: string; 
  public get protocol() {
    return this.getStringAttribute('protocol');
  }
  public set protocol(value: string) {
    this._protocol = value;
  }
  public resetProtocol() {
    this._protocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolInput() {
    return this._protocol;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsPortsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsPorts[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsPortsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsPortsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsets {
  /**
  * IP addresses which offer the related ports that are marked as ready. These endpoints should be considered safe for load balancers and clients to utilize.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#addresses DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#addresses}
  */
  readonly addresses?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsAddresses[] | cdktf.IResolvable;
  /**
  * IP addresses which offer the related ports but are not currently marked as ready because they have not yet finished starting, have recently failed a readiness check, or have recently failed a liveness check.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#not_ready_addresses DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#not_ready_addresses}
  */
  readonly notReadyAddresses?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddresses[] | cdktf.IResolvable;
  /**
  * Port numbers available on the related IP addresses.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#ports DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#ports}
  */
  readonly ports?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsPorts[] | cdktf.IResolvable;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    addresses: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsAddressesToTerraform, false)(struct!.addresses),
    not_ready_addresses: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddressesToTerraform, false)(struct!.notReadyAddresses),
    ports: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsPortsToTerraform, false)(struct!.ports),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    addresses: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsAddressesToHclTerraform, false)(struct!.addresses),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsAddressesList",
    },
    not_ready_addresses: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddressesToHclTerraform, false)(struct!.notReadyAddresses),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddressesList",
    },
    ports: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsPortsToHclTerraform, false)(struct!.ports),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsPortsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsets | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addresses?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.addresses = this._addresses?.internalValue;
    }
    if (this._notReadyAddresses?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.notReadyAddresses = this._notReadyAddresses?.internalValue;
    }
    if (this._ports?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ports = this._ports?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsets | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addresses.internalValue = undefined;
      this._notReadyAddresses.internalValue = undefined;
      this._ports.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addresses.internalValue = value.addresses;
      this._notReadyAddresses.internalValue = value.notReadyAddresses;
      this._ports.internalValue = value.ports;
    }
  }

  // addresses - computed: false, optional: true, required: false
  private _addresses = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsAddressesList(this, "addresses", false);
  public get addresses() {
    return this._addresses;
  }
  public putAddresses(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsAddresses[] | cdktf.IResolvable) {
    this._addresses.internalValue = value;
  }
  public resetAddresses() {
    this._addresses.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressesInput() {
    return this._addresses.internalValue;
  }

  // not_ready_addresses - computed: false, optional: true, required: false
  private _notReadyAddresses = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddressesList(this, "not_ready_addresses", false);
  public get notReadyAddresses() {
    return this._notReadyAddresses;
  }
  public putNotReadyAddresses(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsNotReadyAddresses[] | cdktf.IResolvable) {
    this._notReadyAddresses.internalValue = value;
  }
  public resetNotReadyAddresses() {
    this._notReadyAddresses.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get notReadyAddressesInput() {
    return this._notReadyAddresses.internalValue;
  }

  // ports - computed: false, optional: true, required: false
  private _ports = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsPortsList(this, "ports", false);
  public get ports() {
    return this._ports;
  }
  public putPorts(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsPorts[] | cdktf.IResolvable) {
    this._ports.internalValue = value;
  }
  public resetPorts() {
    this._ports.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portsInput() {
    return this._ports.internalValue;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsets[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpoints {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#subsets DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#subsets}
  */
  readonly subsets?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsets[] | cdktf.IResolvable;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpoints | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    subsets: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsToTerraform, false)(struct!.subsets),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpoints | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    subsets: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsToHclTerraform, false)(struct!.subsets),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpoints | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._subsets?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.subsets = this._subsets?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpoints | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._subsets.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._subsets.internalValue = value.subsets;
    }
  }

  // subsets - computed: false, optional: true, required: false
  private _subsets = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsetsList(this, "subsets", false);
  public get subsets() {
    return this._subsets;
  }
  public putSubsets(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsSubsets[] | cdktf.IResolvable) {
    this._subsets.internalValue = value;
  }
  public resetSubsets() {
    this._subsets.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subsetsInput() {
    return this._subsets.internalValue;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentityExternalentityspecEndpoints {
  /**
  * IP associated with this endpoint.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#ip DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#ip}
  */
  readonly ip?: string;
  /**
  * Name identifies this endpoint. Could be the network interface name in case of VMs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#name DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#name}
  */
  readonly name?: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentityExternalentityspecEndpointsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentityExternalentityspecEndpoints | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ip: cdktf.stringToTerraform(struct!.ip),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentityExternalentityspecEndpointsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentityExternalentityspecEndpoints | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ip: {
      value: cdktf.stringToHclTerraform(struct!.ip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentityExternalentityspecEndpointsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentityExternalentityspecEndpoints | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ip !== undefined) {
      hasAnyValues = true;
      internalValueResult.ip = this._ip;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentityExternalentityspecEndpoints | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ip = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ip = value.ip;
      this._name = value.name;
    }
  }

  // ip - computed: false, optional: true, required: false
  private _ip?: string; 
  public get ip() {
    return this.getStringAttribute('ip');
  }
  public set ip(value: string) {
    this._ip = value;
  }
  public resetIp() {
    this._ip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipInput() {
    return this._ip;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentityExternalentityspecEndpointsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentityExternalentityspecEndpoints[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentityExternalentityspecEndpointsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentityExternalentityspecEndpointsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentityExternalentityspecPorts {
  /**
  * Name associated with the Port.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#name DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * The port on the given protocol.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#port DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#port}
  */
  readonly port?: number;
  /**
  * The protocol (TCP, UDP, or SCTP) which traffic must match. If not specified, this field defaults to TCP.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#protocol DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#protocol}
  */
  readonly protocol?: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentityExternalentityspecPortsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentityExternalentityspecPorts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    port: cdktf.numberToTerraform(struct!.port),
    protocol: cdktf.stringToTerraform(struct!.protocol),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentityExternalentityspecPortsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentityExternalentityspecPorts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    protocol: {
      value: cdktf.stringToHclTerraform(struct!.protocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentityExternalentityspecPortsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentityExternalentityspecPorts | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._protocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocol = this._protocol;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentityExternalentityspecPorts | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._port = undefined;
      this._protocol = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._port = value.port;
      this._protocol = value.protocol;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // protocol - computed: false, optional: true, required: false
  private _protocol?: string; 
  public get protocol() {
    return this.getStringAttribute('protocol');
  }
  public set protocol(value: string) {
    this._protocol = value;
  }
  public resetProtocol() {
    this._protocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolInput() {
    return this._protocol;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentityExternalentityspecPortsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentityExternalentityspecPorts[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentityExternalentityspecPortsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentityExternalentityspecPortsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentityExternalentityspec {
  /**
  * Endpoints is a list of external endpoints associated with this entity.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#endpoints DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#endpoints}
  */
  readonly endpoints?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentityExternalentityspecEndpoints[] | cdktf.IResolvable;
  /**
  * ExternalNode is the opaque identifier of the agent/controller responsible for additional processing or handling of this external entity.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#external_node DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#external_node}
  */
  readonly externalNode?: string;
  /**
  * Ports maintain the list of named ports.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#ports DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#ports}
  */
  readonly ports?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentityExternalentityspecPorts[] | cdktf.IResolvable;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentityExternalentityspecToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentityExternalentityspec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    endpoints: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentityExternalentityspecEndpointsToTerraform, false)(struct!.endpoints),
    external_node: cdktf.stringToTerraform(struct!.externalNode),
    ports: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentityExternalentityspecPortsToTerraform, false)(struct!.ports),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentityExternalentityspecToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentityExternalentityspec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    endpoints: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentityExternalentityspecEndpointsToHclTerraform, false)(struct!.endpoints),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentityExternalentityspecEndpointsList",
    },
    external_node: {
      value: cdktf.stringToHclTerraform(struct!.externalNode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ports: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentityExternalentityspecPortsToHclTerraform, false)(struct!.ports),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentityExternalentityspecPortsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentityExternalentityspecOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentityExternalentityspec | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._endpoints?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoints = this._endpoints?.internalValue;
    }
    if (this._externalNode !== undefined) {
      hasAnyValues = true;
      internalValueResult.externalNode = this._externalNode;
    }
    if (this._ports?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ports = this._ports?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentityExternalentityspec | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._endpoints.internalValue = undefined;
      this._externalNode = undefined;
      this._ports.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._endpoints.internalValue = value.endpoints;
      this._externalNode = value.externalNode;
      this._ports.internalValue = value.ports;
    }
  }

  // endpoints - computed: false, optional: true, required: false
  private _endpoints = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentityExternalentityspecEndpointsList(this, "endpoints", false);
  public get endpoints() {
    return this._endpoints;
  }
  public putEndpoints(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentityExternalentityspecEndpoints[] | cdktf.IResolvable) {
    this._endpoints.internalValue = value;
  }
  public resetEndpoints() {
    this._endpoints.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointsInput() {
    return this._endpoints.internalValue;
  }

  // external_node - computed: false, optional: true, required: false
  private _externalNode?: string; 
  public get externalNode() {
    return this.getStringAttribute('external_node');
  }
  public set externalNode(value: string) {
    this._externalNode = value;
  }
  public resetExternalNode() {
    this._externalNode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get externalNodeInput() {
    return this._externalNode;
  }

  // ports - computed: false, optional: true, required: false
  private _ports = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentityExternalentityspecPortsList(this, "ports", false);
  public get ports() {
    return this._ports;
  }
  public putPorts(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentityExternalentityspecPorts[] | cdktf.IResolvable) {
    this._ports.internalValue = value;
  }
  public resetPorts() {
    this._ports.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portsInput() {
    return this._ports.internalValue;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentity {
  /**
  * ExternalEntitySpec defines the desired state for ExternalEntity.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#externalentityspec DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#externalentityspec}
  */
  readonly externalentityspec?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentityExternalentityspec;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentityToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    externalentityspec: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentityExternalentityspecToTerraform(struct!.externalentityspec),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentityToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    externalentityspec: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentityExternalentityspecToHclTerraform(struct!.externalentityspec),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentityExternalentityspec",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._externalentityspec?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.externalentityspec = this._externalentityspec?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._externalentityspec.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._externalentityspec.internalValue = value.externalentityspec;
    }
  }

  // externalentityspec - computed: false, optional: true, required: false
  private _externalentityspec = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentityExternalentityspecOutputReference(this, "externalentityspec");
  public get externalentityspec() {
    return this._externalentityspec;
  }
  public putExternalentityspec(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentityExternalentityspec) {
    this._externalentityspec.internalValue = value;
  }
  public resetExternalentityspec() {
    this._externalentityspec.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get externalentityspecInput() {
    return this._externalentityspec.internalValue;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecLabelIdentity {
  /**
  * ID is the ID allocated for the label identity by the leader cluster.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#id DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: number;
  /**
  * Label is the normalized string of a label identity. The format of normalized label identity is 'ns:(?P<nslabels>(.)*)&pod:(?P<podlabels>(.)*)' E.g., 'ns:kubernetes.io/metadata.name=kube-system&pod:app=db'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#label DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#label}
  */
  readonly label?: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecLabelIdentityToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecLabelIdentity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    id: cdktf.numberToTerraform(struct!.id),
    label: cdktf.stringToTerraform(struct!.label),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecLabelIdentityToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecLabelIdentity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    id: {
      value: cdktf.numberToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecLabelIdentityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecLabelIdentity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecLabelIdentity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._id = undefined;
      this._label = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._id = value.id;
      this._label = value.label;
    }
  }

  // id - computed: false, optional: true, required: false
  private _id?: number; 
  public get id() {
    return this.getNumberAttribute('id');
  }
  public set id(value: number) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecRaw {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#data DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#data}
  */
  readonly data?: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecRawToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecRaw | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    data: cdktf.stringToTerraform(struct!.data),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecRawToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecRaw | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    data: {
      value: cdktf.stringToHclTerraform(struct!.data),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecRawOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecRaw | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._data !== undefined) {
      hasAnyValues = true;
      internalValueResult.data = this._data;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecRaw | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._data = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._data = value.data;
    }
  }

  // data - computed: false, optional: true, required: false
  private _data?: string; 
  public get data() {
    return this.getStringAttribute('data');
  }
  public set data(value: string) {
    this._data = value;
  }
  public resetData() {
    this._data = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dataInput() {
    return this._data;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpecPorts {
  /**
  * The application protocol for this port. This field follows standard Kubernetes label syntax. Un-prefixed names are reserved for IANA standard service names (as per RFC-6335 and http://www.iana.org/assignments/service-names). Non-standard protocols should use prefixed names such as mycompany.com/my-custom-protocol. Field can be enabled with ServiceAppProtocol feature gate.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#app_protocol DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#app_protocol}
  */
  readonly appProtocol?: string;
  /**
  * The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. When considering the endpoints for a Service, this must match the 'name' field in the EndpointPort. Optional if only one ServicePort is defined on this service.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#name DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * The port that will be exposed by this service.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#port DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#port}
  */
  readonly port: number;
  /**
  * The IP protocol for this port. Supports 'TCP', 'UDP', and 'SCTP'. Default is TCP.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#protocol DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#protocol}
  */
  readonly protocol?: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpecPortsToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpecPorts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    app_protocol: cdktf.stringToTerraform(struct!.appProtocol),
    name: cdktf.stringToTerraform(struct!.name),
    port: cdktf.numberToTerraform(struct!.port),
    protocol: cdktf.stringToTerraform(struct!.protocol),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpecPortsToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpecPorts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    app_protocol: {
      value: cdktf.stringToHclTerraform(struct!.appProtocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    protocol: {
      value: cdktf.stringToHclTerraform(struct!.protocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpecPortsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpecPorts | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._appProtocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.appProtocol = this._appProtocol;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._protocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocol = this._protocol;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpecPorts | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._appProtocol = undefined;
      this._name = undefined;
      this._port = undefined;
      this._protocol = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._appProtocol = value.appProtocol;
      this._name = value.name;
      this._port = value.port;
      this._protocol = value.protocol;
    }
  }

  // app_protocol - computed: false, optional: true, required: false
  private _appProtocol?: string; 
  public get appProtocol() {
    return this.getStringAttribute('app_protocol');
  }
  public set appProtocol(value: string) {
    this._appProtocol = value;
  }
  public resetAppProtocol() {
    this._appProtocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appProtocolInput() {
    return this._appProtocol;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // protocol - computed: false, optional: true, required: false
  private _protocol?: string; 
  public get protocol() {
    return this.getStringAttribute('protocol');
  }
  public set protocol(value: string) {
    this._protocol = value;
  }
  public resetProtocol() {
    this._protocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolInput() {
    return this._protocol;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpecPortsList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpecPorts[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpecPortsOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpecPortsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpecSessionAffinityConfigClientIp {
  /**
  * timeoutSeconds specifies the seconds of ClientIP type session sticky time. The value must be >0 && <=86400(for 1 day) if ServiceAffinity == 'ClientIP'. Default value is 10800(for 3 hours).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#timeout_seconds DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#timeout_seconds}
  */
  readonly timeoutSeconds?: number;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpecSessionAffinityConfigClientIpToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpecSessionAffinityConfigClientIp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    timeout_seconds: cdktf.numberToTerraform(struct!.timeoutSeconds),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpecSessionAffinityConfigClientIpToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpecSessionAffinityConfigClientIp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    timeout_seconds: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpecSessionAffinityConfigClientIpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpecSessionAffinityConfigClientIp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._timeoutSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSeconds = this._timeoutSeconds;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpecSessionAffinityConfigClientIp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._timeoutSeconds = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._timeoutSeconds = value.timeoutSeconds;
    }
  }

  // timeout_seconds - computed: false, optional: true, required: false
  private _timeoutSeconds?: number; 
  public get timeoutSeconds() {
    return this.getNumberAttribute('timeout_seconds');
  }
  public set timeoutSeconds(value: number) {
    this._timeoutSeconds = value;
  }
  public resetTimeoutSeconds() {
    this._timeoutSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecondsInput() {
    return this._timeoutSeconds;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpecSessionAffinityConfig {
  /**
  * clientIP contains the configurations of Client IP based session affinity.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#client_ip DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#client_ip}
  */
  readonly clientIp?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpecSessionAffinityConfigClientIp;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpecSessionAffinityConfigToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpecSessionAffinityConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    client_ip: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpecSessionAffinityConfigClientIpToTerraform(struct!.clientIp),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpecSessionAffinityConfigToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpecSessionAffinityConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    client_ip: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpecSessionAffinityConfigClientIpToHclTerraform(struct!.clientIp),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpecSessionAffinityConfigClientIp",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpecSessionAffinityConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpecSessionAffinityConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clientIp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientIp = this._clientIp?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpecSessionAffinityConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clientIp.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clientIp.internalValue = value.clientIp;
    }
  }

  // client_ip - computed: false, optional: true, required: false
  private _clientIp = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpecSessionAffinityConfigClientIpOutputReference(this, "client_ip");
  public get clientIp() {
    return this._clientIp;
  }
  public putClientIp(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpecSessionAffinityConfigClientIp) {
    this._clientIp.internalValue = value;
  }
  public resetClientIp() {
    this._clientIp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientIpInput() {
    return this._clientIp.internalValue;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpec {
  /**
  * ip will be used as the VIP for this service when type is ClusterSetIP.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#ips DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#ips}
  */
  readonly ips?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#ports DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#ports}
  */
  readonly ports: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpecPorts[] | cdktf.IResolvable;
  /**
  * Supports 'ClientIP' and 'None'. Used to maintain session affinity. Enable client IP based session affinity. Must be ClientIP or None. Defaults to None. Ignored when type is Headless More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#session_affinity DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#session_affinity}
  */
  readonly sessionAffinity?: string;
  /**
  * sessionAffinityConfig contains session affinity configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#session_affinity_config DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#session_affinity_config}
  */
  readonly sessionAffinityConfig?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpecSessionAffinityConfig;
  /**
  * type defines the type of this service. Must be ClusterSetIP or Headless.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#type DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#type}
  */
  readonly type: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpecToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ips: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.ips),
    ports: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpecPortsToTerraform, false)(struct!.ports),
    session_affinity: cdktf.stringToTerraform(struct!.sessionAffinity),
    session_affinity_config: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpecSessionAffinityConfigToTerraform(struct!.sessionAffinityConfig),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpecToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ips: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.ips),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    ports: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpecPortsToHclTerraform, false)(struct!.ports),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpecPortsList",
    },
    session_affinity: {
      value: cdktf.stringToHclTerraform(struct!.sessionAffinity),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    session_affinity_config: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpecSessionAffinityConfigToHclTerraform(struct!.sessionAffinityConfig),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpecSessionAffinityConfig",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpecOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpec | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ips !== undefined) {
      hasAnyValues = true;
      internalValueResult.ips = this._ips;
    }
    if (this._ports?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ports = this._ports?.internalValue;
    }
    if (this._sessionAffinity !== undefined) {
      hasAnyValues = true;
      internalValueResult.sessionAffinity = this._sessionAffinity;
    }
    if (this._sessionAffinityConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sessionAffinityConfig = this._sessionAffinityConfig?.internalValue;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpec | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ips = undefined;
      this._ports.internalValue = undefined;
      this._sessionAffinity = undefined;
      this._sessionAffinityConfig.internalValue = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ips = value.ips;
      this._ports.internalValue = value.ports;
      this._sessionAffinity = value.sessionAffinity;
      this._sessionAffinityConfig.internalValue = value.sessionAffinityConfig;
      this._type = value.type;
    }
  }

  // ips - computed: false, optional: true, required: false
  private _ips?: string[]; 
  public get ips() {
    return this.getListAttribute('ips');
  }
  public set ips(value: string[]) {
    this._ips = value;
  }
  public resetIps() {
    this._ips = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipsInput() {
    return this._ips;
  }

  // ports - computed: false, optional: false, required: true
  private _ports = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpecPortsList(this, "ports", false);
  public get ports() {
    return this._ports;
  }
  public putPorts(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpecPorts[] | cdktf.IResolvable) {
    this._ports.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portsInput() {
    return this._ports.internalValue;
  }

  // session_affinity - computed: false, optional: true, required: false
  private _sessionAffinity?: string; 
  public get sessionAffinity() {
    return this.getStringAttribute('session_affinity');
  }
  public set sessionAffinity(value: string) {
    this._sessionAffinity = value;
  }
  public resetSessionAffinity() {
    this._sessionAffinity = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sessionAffinityInput() {
    return this._sessionAffinity;
  }

  // session_affinity_config - computed: false, optional: true, required: false
  private _sessionAffinityConfig = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpecSessionAffinityConfigOutputReference(this, "session_affinity_config");
  public get sessionAffinityConfig() {
    return this._sessionAffinityConfig;
  }
  public putSessionAffinityConfig(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpecSessionAffinityConfig) {
    this._sessionAffinityConfig.internalValue = value;
  }
  public resetSessionAffinityConfig() {
    this._sessionAffinityConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sessionAffinityConfigInput() {
    return this._sessionAffinityConfig.internalValue;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportStatusClusters {
  /**
  * cluster is the name of the exporting cluster. Must be a valid RFC-1123 DNS label.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#cluster DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#cluster}
  */
  readonly cluster: string;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportStatusClustersToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportStatusClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cluster: cdktf.stringToTerraform(struct!.cluster),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportStatusClustersToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportStatusClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cluster: {
      value: cdktf.stringToHclTerraform(struct!.cluster),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportStatusClustersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportStatusClusters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cluster !== undefined) {
      hasAnyValues = true;
      internalValueResult.cluster = this._cluster;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportStatusClusters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cluster = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cluster = value.cluster;
    }
  }

  // cluster - computed: false, optional: false, required: true
  private _cluster?: string; 
  public get cluster() {
    return this.getStringAttribute('cluster');
  }
  public set cluster(value: string) {
    this._cluster = value;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterInput() {
    return this._cluster;
  }
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportStatusClustersList extends cdktf.ComplexList {
  public internalValue? : DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportStatusClusters[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportStatusClustersOutputReference {
    return new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportStatusClustersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportStatus {
  /**
  * clusters is the list of exporting clusters from which this service was derived.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#clusters DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#clusters}
  */
  readonly clusters?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportStatusClusters[] | cdktf.IResolvable;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportStatusToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportStatus | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    clusters: cdktf.listMapper(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportStatusClustersToTerraform, false)(struct!.clusters),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportStatusToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportStatus | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    clusters: {
      value: cdktf.listMapperHcl(dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportStatusClustersToHclTerraform, false)(struct!.clusters),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportStatusClustersList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportStatusOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportStatus | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clusters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusters = this._clusters?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportStatus | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clusters.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clusters.internalValue = value.clusters;
    }
  }

  // clusters - computed: false, optional: true, required: false
  private _clusters = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportStatusClustersList(this, "clusters", false);
  public get clusters() {
    return this._clusters;
  }
  public putClusters(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportStatusClusters[] | cdktf.IResolvable) {
    this._clusters.internalValue = value;
  }
  public resetClusters() {
    this._clusters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clustersInput() {
    return this._clusters.internalValue;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImport {
  /**
  * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#api_version DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#api_version}
  */
  readonly apiVersion?: string;
  /**
  * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#kind DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#kind}
  */
  readonly kind?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#metadata DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#metadata}
  */
  readonly metadata?: { [key: string]: string };
  /**
  * spec defines the behavior of a ServiceImport.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#spec DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#spec}
  */
  readonly spec?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpec;
  /**
  * status contains information about the exported services that form the multi-cluster service referenced by this ServiceImport.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#status DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#status}
  */
  readonly status?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportStatus;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImport | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    kind: cdktf.stringToTerraform(struct!.kind),
    metadata: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.metadata),
    spec: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpecToTerraform(struct!.spec),
    status: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportStatusToTerraform(struct!.status),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImport | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kind: {
      value: cdktf.stringToHclTerraform(struct!.kind),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metadata: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.metadata),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    spec: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpecToHclTerraform(struct!.spec),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpec",
    },
    status: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportStatusToHclTerraform(struct!.status),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportStatus",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImport | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._kind !== undefined) {
      hasAnyValues = true;
      internalValueResult.kind = this._kind;
    }
    if (this._metadata !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata;
    }
    if (this._spec?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.spec = this._spec?.internalValue;
    }
    if (this._status?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.status = this._status?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImport | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiVersion = undefined;
      this._kind = undefined;
      this._metadata = undefined;
      this._spec.internalValue = undefined;
      this._status.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiVersion = value.apiVersion;
      this._kind = value.kind;
      this._metadata = value.metadata;
      this._spec.internalValue = value.spec;
      this._status.internalValue = value.status;
    }
  }

  // api_version - computed: false, optional: true, required: false
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  public resetApiVersion() {
    this._apiVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // kind - computed: false, optional: true, required: false
  private _kind?: string; 
  public get kind() {
    return this.getStringAttribute('kind');
  }
  public set kind(value: string) {
    this._kind = value;
  }
  public resetKind() {
    this._kind = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kindInput() {
    return this._kind;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata?: { [key: string]: string }; 
  public get metadata() {
    return this.getStringMapAttribute('metadata');
  }
  public set metadata(value: { [key: string]: string }) {
    this._metadata = value;
  }
  public resetMetadata() {
    this._metadata = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata;
  }

  // spec - computed: false, optional: true, required: false
  private _spec = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpecOutputReference(this, "spec");
  public get spec() {
    return this._spec;
  }
  public putSpec(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportSpec) {
    this._spec.internalValue = value;
  }
  public resetSpec() {
    this._spec.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get specInput() {
    return this._spec.internalValue;
  }

  // status - computed: false, optional: true, required: false
  private _status = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportStatusOutputReference(this, "status");
  public get status() {
    return this._status;
  }
  public putStatus(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportStatus) {
    this._status.internalValue = value;
  }
  public resetStatus() {
    this._status.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get statusInput() {
    return this._status.internalValue;
  }
}
export interface DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpec {
  /**
  * ClusterIDs specifies the member clusters this resource to import to. When not specified, import to all member clusters.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#cluster_id DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#cluster_id}
  */
  readonly clusterId?: string[];
  /**
  * If imported resource is ClusterInfo.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#clusterinfo DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#clusterinfo}
  */
  readonly clusterinfo?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusterinfo;
  /**
  * If imported resource is AntreaClusterNetworkPolicy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#clusternetworkpolicy DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#clusternetworkpolicy}
  */
  readonly clusternetworkpolicy?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicy;
  /**
  * If imported resource is EndPoints.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#endpoints DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#endpoints}
  */
  readonly endpoints?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpoints;
  /**
  * If imported resource is ExternalEntity.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#externalentity DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#externalentity}
  */
  readonly externalentity?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentity;
  /**
  * Kind of imported resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#kind DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#kind}
  */
  readonly kind?: string;
  /**
  * If imported resource kind is LabelIdentity.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#label_identity DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#label_identity}
  */
  readonly labelIdentity?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecLabelIdentity;
  /**
  * Name of imported resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#name DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of imported resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#namespace DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#namespace}
  */
  readonly namespace?: string;
  /**
  * If imported resource kind is unknown.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#raw DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#raw}
  */
  readonly raw?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecRaw;
  /**
  * If imported resource is ServiceImport.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#service_import DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest#service_import}
  */
  readonly serviceImport?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImport;
}

export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecToTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cluster_id: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.clusterId),
    clusterinfo: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusterinfoToTerraform(struct!.clusterinfo),
    clusternetworkpolicy: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyToTerraform(struct!.clusternetworkpolicy),
    endpoints: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsToTerraform(struct!.endpoints),
    externalentity: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentityToTerraform(struct!.externalentity),
    kind: cdktf.stringToTerraform(struct!.kind),
    label_identity: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecLabelIdentityToTerraform(struct!.labelIdentity),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    raw: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecRawToTerraform(struct!.raw),
    service_import: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportToTerraform(struct!.serviceImport),
  }
}


export function dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecToHclTerraform(struct?: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cluster_id: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.clusterId),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    clusterinfo: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusterinfoToHclTerraform(struct!.clusterinfo),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusterinfo",
    },
    clusternetworkpolicy: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyToHclTerraform(struct!.clusternetworkpolicy),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicy",
    },
    endpoints: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsToHclTerraform(struct!.endpoints),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpoints",
    },
    externalentity: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentityToHclTerraform(struct!.externalentity),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentity",
    },
    kind: {
      value: cdktf.stringToHclTerraform(struct!.kind),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_identity: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecLabelIdentityToHclTerraform(struct!.labelIdentity),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecLabelIdentity",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    raw: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecRawToHclTerraform(struct!.raw),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecRaw",
    },
    service_import: {
      value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportToHclTerraform(struct!.serviceImport),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImport",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpec | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterId = this._clusterId;
    }
    if (this._clusterinfo?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterinfo = this._clusterinfo?.internalValue;
    }
    if (this._clusternetworkpolicy?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusternetworkpolicy = this._clusternetworkpolicy?.internalValue;
    }
    if (this._endpoints?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoints = this._endpoints?.internalValue;
    }
    if (this._externalentity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.externalentity = this._externalentity?.internalValue;
    }
    if (this._kind !== undefined) {
      hasAnyValues = true;
      internalValueResult.kind = this._kind;
    }
    if (this._labelIdentity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelIdentity = this._labelIdentity?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._raw?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.raw = this._raw?.internalValue;
    }
    if (this._serviceImport?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceImport = this._serviceImport?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpec | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clusterId = undefined;
      this._clusterinfo.internalValue = undefined;
      this._clusternetworkpolicy.internalValue = undefined;
      this._endpoints.internalValue = undefined;
      this._externalentity.internalValue = undefined;
      this._kind = undefined;
      this._labelIdentity.internalValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
      this._raw.internalValue = undefined;
      this._serviceImport.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clusterId = value.clusterId;
      this._clusterinfo.internalValue = value.clusterinfo;
      this._clusternetworkpolicy.internalValue = value.clusternetworkpolicy;
      this._endpoints.internalValue = value.endpoints;
      this._externalentity.internalValue = value.externalentity;
      this._kind = value.kind;
      this._labelIdentity.internalValue = value.labelIdentity;
      this._name = value.name;
      this._namespace = value.namespace;
      this._raw.internalValue = value.raw;
      this._serviceImport.internalValue = value.serviceImport;
    }
  }

  // cluster_id - computed: false, optional: true, required: false
  private _clusterId?: string[]; 
  public get clusterId() {
    return this.getListAttribute('cluster_id');
  }
  public set clusterId(value: string[]) {
    this._clusterId = value;
  }
  public resetClusterId() {
    this._clusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterIdInput() {
    return this._clusterId;
  }

  // clusterinfo - computed: false, optional: true, required: false
  private _clusterinfo = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusterinfoOutputReference(this, "clusterinfo");
  public get clusterinfo() {
    return this._clusterinfo;
  }
  public putClusterinfo(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusterinfo) {
    this._clusterinfo.internalValue = value;
  }
  public resetClusterinfo() {
    this._clusterinfo.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterinfoInput() {
    return this._clusterinfo.internalValue;
  }

  // clusternetworkpolicy - computed: false, optional: true, required: false
  private _clusternetworkpolicy = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicyOutputReference(this, "clusternetworkpolicy");
  public get clusternetworkpolicy() {
    return this._clusternetworkpolicy;
  }
  public putClusternetworkpolicy(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecClusternetworkpolicy) {
    this._clusternetworkpolicy.internalValue = value;
  }
  public resetClusternetworkpolicy() {
    this._clusternetworkpolicy.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusternetworkpolicyInput() {
    return this._clusternetworkpolicy.internalValue;
  }

  // endpoints - computed: false, optional: true, required: false
  private _endpoints = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpointsOutputReference(this, "endpoints");
  public get endpoints() {
    return this._endpoints;
  }
  public putEndpoints(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecEndpoints) {
    this._endpoints.internalValue = value;
  }
  public resetEndpoints() {
    this._endpoints.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointsInput() {
    return this._endpoints.internalValue;
  }

  // externalentity - computed: false, optional: true, required: false
  private _externalentity = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentityOutputReference(this, "externalentity");
  public get externalentity() {
    return this._externalentity;
  }
  public putExternalentity(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecExternalentity) {
    this._externalentity.internalValue = value;
  }
  public resetExternalentity() {
    this._externalentity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get externalentityInput() {
    return this._externalentity.internalValue;
  }

  // kind - computed: false, optional: true, required: false
  private _kind?: string; 
  public get kind() {
    return this.getStringAttribute('kind');
  }
  public set kind(value: string) {
    this._kind = value;
  }
  public resetKind() {
    this._kind = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kindInput() {
    return this._kind;
  }

  // label_identity - computed: false, optional: true, required: false
  private _labelIdentity = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecLabelIdentityOutputReference(this, "label_identity");
  public get labelIdentity() {
    return this._labelIdentity;
  }
  public putLabelIdentity(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecLabelIdentity) {
    this._labelIdentity.internalValue = value;
  }
  public resetLabelIdentity() {
    this._labelIdentity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelIdentityInput() {
    return this._labelIdentity.internalValue;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // raw - computed: false, optional: true, required: false
  private _raw = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecRawOutputReference(this, "raw");
  public get raw() {
    return this._raw;
  }
  public putRaw(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecRaw) {
    this._raw.internalValue = value;
  }
  public resetRaw() {
    this._raw.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rawInput() {
    return this._raw.internalValue;
  }

  // service_import - computed: false, optional: true, required: false
  private _serviceImport = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImportOutputReference(this, "service_import");
  public get serviceImport() {
    return this._serviceImport;
  }
  public putServiceImport(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecServiceImport) {
    this._serviceImport.internalValue = value;
  }
  public resetServiceImport() {
    this._serviceImport.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceImportInput() {
    return this._serviceImport.internalValue;
  }
}

/**
* Represents a {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest k8s_multicluster_crd_antrea_io_resource_import_v1alpha1_manifest}
*/
export class DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest extends cdktf.TerraformDataSource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType = "k8s_multicluster_crd_antrea_io_resource_import_v1alpha1_manifest";

  // ==============
  // STATIC Methods
  // ==============
  /**
  * Generates CDKTF code for importing a DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest resource upon running "cdktf plan <stack-name>"
  * @param scope The scope in which to define this construct
  * @param importToId The construct id used in the generated config for the DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest to import
  * @param importFromId The id of the existing DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest that should be imported. Refer to the {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest#import import section} in the documentation of this resource for the id to use
  * @param provider? Optional instance of the provider where the DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1Manifest to import is found
  */
  public static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider) {
        return new cdktf.ImportableResource(scope, importToId, { terraformResourceType: "k8s_multicluster_crd_antrea_io_resource_import_v1alpha1_manifest", importId: importFromId, provider });
      }

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/multicluster_crd_antrea_io_resource_import_v1alpha1_manifest k8s_multicluster_crd_antrea_io_resource_import_v1alpha1_manifest} Data Source
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestConfig
  */
  public constructor(scope: Construct, id: string, config: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestConfig) {
    super(scope, id, {
      terraformResourceType: 'k8s_multicluster_crd_antrea_io_resource_import_v1alpha1_manifest',
      terraformGeneratorMetadata: {
        providerName: 'k8s',
        providerVersion: '2025.10.20'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle,
      provisioners: config.provisioners,
      connection: config.connection,
      forEach: config.forEach
    });
    this._metadata.internalValue = config.metadata;
    this._spec.internalValue = config.spec;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // metadata - computed: false, optional: false, required: true
  private _metadata = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestMetadataOutputReference(this, "metadata");
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestMetadata) {
    this._metadata.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // spec - computed: false, optional: true, required: false
  private _spec = new DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecOutputReference(this, "spec");
  public get spec() {
    return this._spec;
  }
  public putSpec(value: DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpec) {
    this._spec.internalValue = value;
  }
  public resetSpec() {
    this._spec.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get specInput() {
    return this._spec.internalValue;
  }

  // yaml - computed: true, optional: false, required: false
  public get yaml() {
    return this.getStringAttribute('yaml');
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      metadata: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestMetadataToTerraform(this._metadata.internalValue),
      spec: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecToTerraform(this._spec.internalValue),
    };
  }

  protected synthesizeHclAttributes(): { [name: string]: any } {
    const attrs = {
      metadata: {
        value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestMetadataToHclTerraform(this._metadata.internalValue),
        isBlock: true,
        type: "struct",
        storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestMetadata",
      },
      spec: {
        value: dataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpecToHclTerraform(this._spec.internalValue),
        isBlock: true,
        type: "struct",
        storageClassType: "DataK8SMulticlusterCrdAntreaIoResourceImportV1Alpha1ManifestSpec",
      },
    };

    // remove undefined attributes
    return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined ))
  }
}
